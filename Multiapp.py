import zipfile
import json
import tkinter as tk
from tkinter import PhotoImage
from tkinter import filedialog, messagebox, ttk, Scrollbar
from tkinter.filedialog import askopenfilename, asksaveasfilename
import math
import pyperclip
import random
import psutil
import shutil
import os
import subprocess
import tkinter.messagebox as MB
import datetime
import platform
from tkinter.ttk import Progressbar, Scrollbar
import threading
import socket
from getmac import getmac
from tkinter.messagebox import showinfo
import socket,sys,threading,time
from tkinter import *
# Importuri standard
import argparse
import sys
import difflib
import mimetypes
import filecmp
import pandas as pd
import numpy as np
from tkinter import scrolledtext
from tkinter import filedialog as fd
from tkinter import messagebox as mb
import os.path
from aspose.words import Document
import aspose.words as aw
import platform
import dearpygui.dearpygui as dpg
from cpuinfo import get_cpu_info
import GPUtil
import psutil
import humanize
#from datetime import datetime
from multiprocessing import Process
from threading import Thread
import pyautogui
import threading
import cv2
import numpy as np

# Importuri pentru interfața grafică
try:
    from tkinter import *
    from tkinter.filedialog import askopenfilename, askdirectory
    from tkinter.simpledialog import askstring
    from tkinter.messagebox import showerror
    from tkinter import font
    from tkinter import ttk
    from tkinter.ttk import Treeview
except ImportError:    # Python 2 fallback
    from Tkinter import *
    from tkFileDialog import askopenfilename, askdirectory
    from tkSimpleDialog import askstring
    from tkMessageBox import showerror
    from tkFont import Font
    import ttk
    from ttk import Treeview
#from tkinter.ttk import *
def startup_services():
    #import tkinter as tk
    #import time
    #import random
    #import os

    def update_boot_messages():
        current_path = os.getcwd()
        messages = [
            f"{current_path}>Multiapp.exe\n",
            "Boot Manager starting...",
            "Configure enviroment... done.",
            "Starting Multiapp Services...",
            "REG-ED Version 7.0",
            "Virtual instance is testing RAM Memory... done.",
            "Loading Multiapp drivers...",
            "Checking file system...",
            "Initializing hardware...",
            "Scanning for disk errors... No errors found.",
            "Configuring network settings...",
            "Loading graphical interface...",
            "Applying system policies...",
            "Finalizing startup...",
            "Multiapp is now starting...\n\n",
            "Welcome to Multiapp Professional! \u00A9 2024 Tudor Marmureanu"
        ]
        
        for i, msg in enumerate(messages):
            boot_label.config(text=boot_label.cget("text") + "\n" + msg + "_")
            root_srv.update()
            time.sleep(random.uniform(0.2, 3.5))  # Simulează timpul de boot cu intervale aleatorii
            boot_label.config(text=boot_label.cget("text").rstrip("_"))
        
        progress_bar.pack_forget()  # Ascunde bara de progres la final
        root_srv.after(2000, root_srv.destroy)  # Închide fereastra după un scurt delay

    # Configurare fereastră principală
    root_srv = tk.Tk()
    root_srv.title("Multiapp 95 Professional Boot")
    root_srv.geometry("850x650")
    root_srv.configure(bg="black")
    root_srv.resizable(False, False)
    root_srv.overrideredirect(True)
    
    # Fă fereastra mereu deasupra altora
    root_srv.attributes("-topmost", True)
    
    # Obține dimensiunile ecranului
    screen_width = root_srv.winfo_screenwidth()
    screen_height = root_srv.winfo_screenheight()

    # Calculează poziția pentru a centra fereastra
    x_position = (screen_width - 850) // 2
    y_position = (screen_height - 650) // 2

    # Aplică poziția calculată
    root_srv.geometry(f"850x650+{x_position}+{y_position}")

    # Eticheta pentru mesaje
    boot_label = tk.Label(root_srv, text="", fg="white", bg="black", font=("Fixedsys",12), justify="left", anchor="nw")
    boot_label.pack(padx=20, pady=20, anchor="w")

    # Bara de progres ASCII
    progress_bar = tk.Label(root_srv, text="[                    ]", fg="white", bg="black", font=("Fixedsys",12))
    progress_bar.pack()

    # Start automat al bootării
    root_srv.after(1000, update_boot_messages)
    root_srv.mainloop()
    
startup_services()

#import tkinter as tk
#from tkinter import messagebox, filedialog
#import time
#import platform
#import psutil
#import os

def check_and_create_counter():
    # Verifică dacă fișierul counter.txt există
    if not os.path.exists('counter.txt'):
        # Dacă nu există, îl creăm și scriem 1 în el
        with open('counter.txt', 'w') as file:
            file.write('1')
        return True  # Funcția trebuie să ruleze
    else:
        # Dacă fișierul există și conține 1, nu mai rulăm funcția
        with open('counter.txt', 'r') as file:
            if file.read().strip() == '1':
                return False  # Nu mai rulăm funcția
        return True

def run_instance_checker():
    # Verifică dacă trebuie să ruleze funcția
    if not check_and_create_counter():
        #print("Funcția a fost deja rulată o dată. Nu se va mai executa.")
        return
    class Windows95Simulator:
        def __init__(self, root_inst):
            self.root_inst = root_inst
            self.root_inst.title("Virtual Instance Checker")
            self.root_inst.geometry("1024x768")
            self.root_inst.configure(bg='#008080')
            self.is_fullscreen = False  # Variabilă pentru a urmări starea fullscreen
            
            # Obținem dimensiunile ecranului
            screen_width = self.root_inst.winfo_screenwidth()
            screen_height = self.root_inst.winfo_screenheight()
            
            # Dimensiunile ferestrei
            window_width = 1024
            window_height = 768
            
            # Calculăm poziția pentru centrul ecranului
            position_top = int((screen_height / 2) - (window_height / 2))
            position_right = int((screen_width / 2) - (window_width / 2))
            
            # Setăm geometria ferestrei (dimensiuni și poziție)
            self.root_inst.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')
            
            # Background image (desktop wallpaper)
            self.desktop_bg = tk.Label(self.root_inst, bg='#008080', width=1024, height=768)
            self.desktop_bg.place(x=0, y=0)  # Plasare pe fundal
            
            # Taskbar
            self.taskbar = tk.Frame(self.root_inst, bg='gray', height=30)
            self.taskbar.pack(side='bottom', fill='x')
            
            # Start button
            self.start_button = tk.Button(self.taskbar, text='Start', width=10, height=2, bg='#8c8c8c', fg='white', font=("Fixedsys"), command=self.toggle_start_menu)
            self.start_button.pack(side='left')
            
            # Clock
            self.clock_label = tk.Label(self.taskbar, bg='gray', fg='white', font=("Fixedsys"))
            self.clock_label.pack(side='right', padx=10)
            self.update_clock()
            
            # Start menu
            self.start_menu = tk.Frame(self.root_inst, bg='lightgray', width=200, height=300)
            self.start_menu.place(x=0, y=728, anchor='sw')
            self.start_menu_visible = False
            
            # Meniu Start cu submeniuri
            self.apps_frame = tk.Frame(self.start_menu, bg='lightgray')
            self.apps_frame.pack(fill='both', expand=True)
            
            self.create_start_menu()
            
            self.start_menu.lower()
            
            # Taskbar running apps
            self.running_apps = {}
            
        def create_activation_window(self, window):
            import os
            from tkinter import messagebox
            window.title("Activation Wizard")  # Titlul ferestrei
            window.geometry("400x200")
            window.configure(bg="#c9c9c9")
            # Mesaj
            label = tk.Label(window, text="Enter your product key:", font=("Fixedsys"), bg="#c9c9c9")
            label.pack(pady=10)
            # Câmp de introducere a cheii
            product_key_entry = tk.Entry(window, font=("Fixedsys"), width=30, bd=5)
            product_key_entry.pack(pady=5)
            # Butonul de activare (inițial dezactivat)
            activate_button = tk.Button(
                window, text="Activate", font=("Fixedsys"), state=tk.DISABLED, bd=5, bg="#c9c9c9", 
                command=lambda: activate_product()
            )
            activate_button.pack(pady=5)
            # Butonul "Activate later" -> elimină aplicația din taskbar
            later_button = tk.Button(
                window, text="Activate later", font=("Fixedsys"), bd=5, bg="#c9c9c9", 
                command=lambda: self.close_app("Product Activation", window)
            )
            later_button.pack(pady=5)
            # Funcție pentru activare
            def activate_product():
                product_key = product_key_entry.get()
                valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
                FOLDER_NAME = "Serial"
                FILE_NAME = "product_key.lic95"
                
                if not os.path.exists(FOLDER_NAME):
                    try:
                        os.makedirs(FOLDER_NAME)
                    except:
                        pass
                        
                if product_key == valid_key:
                    file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                    # Verificăm dacă fișierul există deja
                    if not os.path.exists(file_path):
                        with open(file_path, "w") as file:
                            file.write(valid_key)
                    messagebox.showinfo("Activation Successful", "Product has been activated successfully.")
                    self.close_app("Product Activation", window)  # Închide corect aplicația
                else:
                    messagebox.showerror("Activation Failed", "Invalid product key. Please try again.")
                    
            # Funcție pentru validarea cheii în timp real
            def validate_key(event):
                if product_key_entry.get() == "R46BX-JHR2J-PG7ER-24QFG-MWKVR":
                    activate_button.config(state=tk.NORMAL)  # Activează butonul dacă cheia este corectă
                else:
                    activate_button.config(state=tk.DISABLED)  # Dezactivează butonul dacă cheia e greșită
            product_key_entry.bind("<KeyRelease>", validate_key)  # Verifică validitatea în timp real

        def activate_product(self, product_key, window):
            import os
            from tkinter import messagebox
            
            FOLDER_NAME = "Serial"
            FILE_NAME = "product_key.lic95"
            
            if not os.path.exists(FOLDER_NAME):
                try:
                    os.makedirs(FOLDER_NAME)
                except:
                    pass
                    
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
            
            # Verifică dacă fișierul există deja
            try:
                with open(file_path, "r") as file:
                    existing_key = file.read().strip()
                    if existing_key == valid_key:
                        messagebox.showinfo("Activation", "Product is already activated!")
                        window.destroy()
                        return
            except FileNotFoundError:
                pass  # Fișierul nu există, deci putem continua activarea
            
            # Salvează cheia de produs
            with open(file_path, "w") as file:
                file.write(valid_key)
            
            messagebox.showinfo("Activation", "Product activated successfully!")
            window.destroy()

        def shutdown(self):
            self.root_inst.destroy()  # Închide aplicația
        
        def create_start_menu(self):
            self.activation_button = tk.Button(self.apps_frame, text='Product Activation', font=("Fixedsys"), command=lambda: self.open_app("Product Activation"))
            self.activation_button.pack(fill='x')
            
            self.notepad_button = tk.Button(self.apps_frame, text='Notepad', font=("Fixedsys"), command=lambda: self.open_app("Notepad"))
            self.notepad_button.pack(fill='x')
            
            self.about_button = tk.Button(self.apps_frame, text='About Window', font=("Fixedsys"), command=lambda: self.open_app("About Window"))
            self.about_button.pack(fill='x')
            
            # Butonul Fullscreen în meniul Start
            self.fullscreen_button = tk.Button(self.apps_frame, text='Fullscreen', font=("Fixedsys"), command=self.toggle_fullscreen)
            self.fullscreen_button.pack(fill='x')
            
            # Buton de Shutdown
            self.shutdown_button = tk.Button(self.apps_frame, text='Shutdown', font=("Fixedsys"), command=self.shutdown)
            self.shutdown_button.pack(fill='x')
        
        def toggle_start_menu(self):
            if self.start_menu_visible:
                self.start_menu.lower()
            else:
                self.start_menu.lift()
            self.start_menu_visible = not self.start_menu_visible
        
        def open_app(self, app_name):
            if app_name in self.running_apps:
                return
            
            window = tk.Toplevel(self.root_inst)
            window.title(app_name)
            window.geometry("600x400")
            window.protocol("WM_DELETE_WINDOW", lambda: self.close_app(app_name, window))
            
            if app_name == "Notepad":
                self.create_notepad(window)
            elif app_name == "About Window":
                self.create_about_window(window)
                
            elif app_name == "Product Activation":
                self.create_activation_window(window)
            
            taskbar_button = tk.Button(self.taskbar, text=app_name, font=("Fixedsys"), command=lambda: self.toggle_app_visibility(app_name, window), bg='darkgray', fg='white', height=2)
            taskbar_button.pack(side='left')
            
            self.running_apps[app_name] = {'window': window, 'button': taskbar_button}
            
            self.start_menu.lower()
            self.start_menu_visible = False
        
        def close_app(self, app_name, window):
            window.destroy()
            self.running_apps[app_name]['button'].destroy()
            del self.running_apps[app_name]
        
        def toggle_app_visibility(self, app_name, window):
            if window.state() == "normal":
                window.withdraw()
            else:
                window.deiconify()
        
        def update_clock(self):
            current_time = time.strftime('%H:%M:%S')
            self.clock_label.config(text=current_time, font=("Fixedsys"))
            self.root_inst.after(1000, self.update_clock)
        
        def toggle_fullscreen(self):
            self.is_fullscreen = not self.is_fullscreen
            if self.is_fullscreen:
                self.root_inst.attributes('-fullscreen', True)
            else:
                self.root_inst.attributes('-fullscreen', False)
        
        def create_notepad(self, window):
            text_area = tk.Text(window, font=("Fixedsys"))
            text_area.pack(fill='both', expand=True)
            
            # Adăugăm un tag pentru culoarea gri
            text_area.tag_configure("placeholder", foreground="#c7c7c7")
            
            # Textul prestabilit care va apărea la început
            placeholder_text = "This instance helps you check if the system requirements of the computer running Multiapp Professional are compatible with the recommended minimum requirements. Click on the About Window button in the Start Menu to perform this check. To continue booting into Multiapp Professional, click on the Shutdown button in the Start Menu. For Multiapp to function, it must be activated using a product key. This can be done from the Product Activation section."
            text_area.insert(tk.END, placeholder_text)
            
            # Aplicăm tag-ul gri pe întregul text prestabilit
            text_area.tag_add("placeholder", "1.0", "end")
            
            # Funcția pentru a șterge textul prestabilit când utilizatorul începe să scrie
            def on_focus_in(event):
                if text_area.get("1.0", tk.END).strip() == placeholder_text:
                    text_area.delete("1.0", tk.END)
            
            # Funcția pentru a șterge textul prestabilit când utilizatorul pune cursorul
            def on_key_press(event):
                if text_area.get("1.0", tk.END).strip() == placeholder_text:
                    text_area.delete("1.0", tk.END)

            # Legăm evenimentele la funcțiile corespunzătoare
            text_area.bind("<FocusIn>", on_focus_in)  # Când fereastra primește focus
            text_area.bind("<KeyPress>", on_key_press)  # Când utilizatorul apasă o tastă
            
            # Adăugăm un meniu pentru a salva și deschide fișiere
            menu_bar = tk.Menu(window)
            file_menu = tk.Menu(menu_bar, tearoff=0)
            file_menu.add_command(label='Save', command=lambda: self.save_file(text_area))
            file_menu.add_command(label='Open', command=lambda: self.open_file(text_area))
            menu_bar.add_cascade(label='File', menu=file_menu)
            window.config(menu=menu_bar)
        
        def save_file(self, text_area):
            file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
            if file_path:
                with open(file_path, "w") as file:
                    file.write(text_area.get("1.0", tk.END))
        
        def open_file(self, text_area):
            file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
            if file_path:
                with open(file_path, "r") as file:
                    text_area.delete("1.0", tk.END)
                    text_area.insert("1.0", file.read())
        
        def create_about_window(self, window):
            sys_info = platform.uname()
            system_version = sys_info.system
            processor_info = platform.processor()
            
            # Specificațiile minime
            min_os = "Windows 10 (x64)"
            min_processor_speed = 1  # GHz
            min_ram = 4  # GB
            min_disk_space = 300  # MB
            
            # Obținem informațiile sistemului
            os_version = sys_info.release
            ram = psutil.virtual_memory().total / (1024 ** 3)  # RAM în GB
            processor_speed = float(processor_info.split()[2].split('GHz')[0])  # extragem valoarea GHz
            is_x64 = sys_info.machine in ["x86_64", "AMD64"]  # Verificăm dacă este sistem x64 (AMD64 sau x86_64)
            
            # Verificăm dacă sistemul îndeplinește cerințele minime
            meets_requirements = True
            requirements_message = "Meets minimum requirements"
            
            if system_version != "Windows" or not is_x64:
                meets_requirements = False
                requirements_message = "Does not meet minimum requirements: OS is not Windows x64."
            
            # Verificăm dacă versiunea este 10 sau mai mare
            major_version = int(os_version.split('.')[0])
            if major_version < 10:
                meets_requirements = False
                requirements_message = f"Does not meet minimum requirements: OS version is older than Windows 10 (Detected: Windows {major_version})."
            
            if processor_speed < min_processor_speed:
                meets_requirements = False
                requirements_message = "Does not meet minimum requirements: Processor speed is too low."
            
            # Verificăm RAM-ul
            if ram < min_ram:
                meets_requirements = False
                requirements_message = "Does not meet minimum requirements: RAM is too low."
            
            # Verificăm dacă există suficient spațiu pe disc
            if system_version == "Windows":
                disk_space = psutil.disk_usage('/').free / (1024 ** 2)  # spațiu liber în MB
                if disk_space < min_disk_space:
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: Insufficient disk space."
            
            window.configure(bg='#c9c9c9')
            
            # Creăm layout-ul pentru fereastra de 'About'
            frame = tk.Frame(window, bg='#c9c9c9')
            frame.pack(padx=10, pady=10)

            # Specificațiile minime
            min_specs = tk.Label(frame, text=f"Minimum Requirements:\nOS: {min_os}\nProcessor: {min_processor_speed} GHz\nRAM: {min_ram} GB\nDisk space: {min_disk_space} MB free", font=("Fixedsys", 12), bg='#c9c9c9')
            min_specs.grid(row=0, column=0, padx=10, pady=10, sticky='w')
            
            # Specificațiile curente
            current_specs = tk.Label(frame, text=f"Your System:\nOS: {system_version} {os_version} {sys_info.machine}\nProcessor: {processor_speed} GHz\nRAM: {ram:.2f} GB\nDisk space: {disk_space:.2f} MB free", font=("Fixedsys", 12), bg='#c9c9c9')
            current_specs.grid(row=0, column=1, padx=10, pady=10, sticky='w')
            
            # Mesajul de cerințe
            color = "green" if meets_requirements else "red"
            result_label = tk.Label(window, text=requirements_message, font=("Fixedsys", 14), fg=color, bg='#c9c9c9')
            result_label.pack(pady=10)

    if __name__ == '__main__':
        root_inst = tk.Tk()
        app = Windows95Simulator(root_inst)
        root_inst.mainloop()

run_instance_checker()

show_validation = True
adminT = False
c = None
#xx = None
#trmn = None
trmn = None
passfig = None
passfig1 = None
hardvar = None
screenvar = None
zipvar = None
compvar = None
pdfvar = None
replfindvar = None
testvarr = None
testvarr2 = None
pdfvwvar = None
netwvar = None
crpvar2 = None
aivar = None
notepadvar = None
paintvar = None
Adm1var = None
Adm2var = None
zippassvar = None
bkvar = None
rnvar = None
kbvar = None
passmngrr = None
pausevar = None
taskmngrvar = None
junkvar = None
cmvar = None
wbpvar = None
pingalivevar = None
launchervar = None
launchervar_admin = None
excelvar = None
readervar = None
hardmvar = None
fetchervar = None
shellvar = None
w95var = None
sqllvar = None
diagramvar = None
termadm = None
commandervar = None
calendarvar = None
allmonitorvar = None
eventvval = None
assemblyvar = None
kbbbvar = None
dev_mode = False  # Variabilă pentru modul dezvoltator

def on_closing():
    #pass
    messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

def on_enter_press(event):
    login()
    
def toggle_dev_mode():
    global dev_mode, combo_users
    dev_mode = not dev_mode
    status_label.config(text=f"Dev Mode: {'ACTIVE' if dev_mode else 'INACTIVE'}", 
                        fg="lime green" if dev_mode else "red")
    combo_users.config(state="readonly" if dev_mode else "disabled")

windowlogin = tk.Tk()
windowlogin.protocol("WM_DELETE_WINDOW", on_closing)
windowlogin.title("Login form")
windowlogin.geometry('600x500')
windowlogin.configure(bg='#333333')
windowlogin.resizable(False, False)
image_icon = PhotoImage(file = "img/coins2.png")
windowlogin.iconphoto(False, image_icon)

# Dicționar cu toate credențialele
credentials = {
    "AI Chatbot": {"username": "chatbot", "password": "aichatbot"},
    "Alert Monitor": {"username": "alert", "password": "monitor"},
    "Backup Manager": {"username": "backupmanager", "password": "backupmngr"},
    "Calendar": {"username": "calendar", "password": "calendar"},
    "Check Online Devices": {"username": "check", "password": "devices"},
    "Comparator": {"username": "comparator", "password": "comparator"},
    "Contact Manager": {"username": "contact", "password": "manager"},
    "Diagram Canvas": {"username": "diagram", "password": "canvas"},
    "Encrypting Files": {"username": "cryptoV2", "password": "securitate"},
    "Event Viewer": {"username": "eventviewer", "password": "eventviewer"},
    "Excel Lite": {"username": "excel", "password": "lite"},
    "Fetcher Repair": {"username": "fetcher", "password": "repair"},
    "Hardware Monitor Live Kit": {"username": "hardware", "password": "lite"},
    "IT - full acces for user": {"username": "it", "password": "copy"},
    "Junk File Manager": {"username": "junk", "password": "manager"},
    "Knowledge Base": {"username": "kbmanager", "password": "knowladgebase"},
    "Knowledge Base Retro": {"username": "kbretro", "password": "kbretro"},
    "Launcher": {"username": "launcher", "password": "launcher"},
    "Network Monitoring": {"username": "bandmonitoring", "password": "networking"},
    "Notepad": {"username": "notepad", "password": "notepad"},
    "Office Reader": {"username": "reader", "password": "office"},
    "Paint": {"username": "paint", "password": "paint"},
    "Password Generator": {"username": "passgen", "password": "passgen"},
    "Password Generator V2": {"username": "passgenV2", "password": "passgenV2"},
    "Password Manager": {"username": "password", "password": "manager"},
    "Pause Manager": {"username": "pausemanager", "password": "pauze"},
    "PDF Convertor to .docx": {"username": "convertorpdf", "password": "toword"},
    "PDF Tools": {"username": "pdftools", "password": "enjoyit"},
    "Python IDE": {"username": "ide", "password": "pycharm"},
    "Quiz Maker": {"username": "quizmaker", "password": "quizmaker"},
    "Quiz Test": {"username": "quiz", "password": "test"},
    "Rename Manager": {"username": "renamemanager", "password": "renamer"},
    "Screen Recorder": {"username": "screenrec", "password": "screenrec"},
    "Shell Integrator": {"username": "shell", "password": "integrator"},
    "SQL Editor": {"username": "sql", "password": "editor"},
    "System Resources": {"username": "system", "password": "realtime"},
    "Task Manager": {"username": "taskmanager", "password": "terminator"},
    "Terminal": {"username": "terminal", "password": "terminal"},
    "Text Replace & Find": {"username": "textreplace", "password": "textfind"},
    "Total Commander": {"username": "commander", "password": "total"},
    "User - copy files": {"username": "user", "password": "nopass"},
    "Whiteboard": {"username": "whiteboard", "password": "presentation"},
    "Zip Manager": {"username": "zipmanager", "password": "zipmngr"},
    "Zip Password Cracker": {"username": "zippass", "password": "wordsmith"}
}

def login():
    global show_validation
    global adminT
    global c
    #global xx
    global trmn
    global passfig
    global passfig1
    global hardvar
    global screenvar
    global zipvar
    global compvar
    global pdfvar
    global replfindvar
    global testvarr
    global testvarr2
    global pdfvwvar
    global netwvar
    global crpvar2
    global aivar
    global notepadvar
    global paintvar
    global Adm1var
    global Adm2var
    global zippassvar
    global bkvar
    global rnvar
    global kbvar
    global passmngrr
    global pausevar
    global taskmngrvar
    global junkvar
    global wbpvar
    global cmvar
    global pingalivevar
    global launchervar
    global launchervar_admin
    global excelvar
    global readervar
    global hardmvar
    global fetchervar
    global shellvar
    global w95var
    global sqllvar
    global diagramvar
    global termadm
    global commandervar
    global calendarvar
    global allmonitorvar
    global eventvval
    global assemblyvar
    global kbbbvar
    global dev_mode
    
    # Verificăm dacă este activarea modului dezvoltator
    if username_entry.get().lower() == "devcpp" and password_entry.get() == "":
        toggle_dev_mode()
        return

    username = "user"
    password = "nopass"
    usernameAdm = "tudor"
    passwordAdm = "fosfataza"
    usernameAdm1 = "ide"
    passwordAdm1 = "pycharm"
    usernameAdm2 = "tudor"
    passwordAdm2 = "fosfatazaaa"
    username_support = "it"
    password_support = "copy"
    usertrmn = "terminal"
    passtermn = "terminal"
    userpass = "passgen"
    passpass = "passgen"
    userpass1 = "passgenV2"
    passpass1 = "passgenV2"
    userhard = "system"
    passhard = "realtime"
    userscreenrec = "screenrec"
    passscreenrec = "screenrec"
    userzip = "zipmanager"
    passzip = "zipmngr"
    usercomp = "comparator"
    passcomp = "comparator"
    userpdf = "convertorpdf"
    passpdf = "toword"
    userreplfind = "textreplace"
    passreplfind = "textfind"
    testuser = "quizmaker"
    testpass = "quizmaker"
    testuser2 = "quiz"
    testpass2 = "test"
    pdfvwuser = "pdftools"
    pdfvwpass = "enjoyit"
    netwuser = "bandmonitoring"
    netwpass = "networking"
    crpuser2 = "cryptoV2"
    crppass2 = "securitate"
    aiuser = "chatbot"
    aipass = "aichatbot"
    notepaduser = "notepad"
    notepadpass = "notepad"
    paintuser = "paint"
    paintpass = "paint"
    usernamezp = "zippass"
    passwordzp = "wordsmith"
    userbk = "backupmanager"
    passbk = "backupmngr"
    userrn = "renamemanager"
    passrn = "renamer"
    kbuser = "kbmanager"
    kbpass = "knowladgebase"
    passmngrruser = "password"
    passmngrrpass = "manager"
    pauseuser = "pausemanager"
    pausepass = "pauze"
    taskmngruser = "taskmanager"
    taskmngrpass = "terminator"
    junkuser = "junk"
    junkpass = "manager"
    wbpuser = "whiteboard"
    wbppass = "presentation"
    cmuser = "contact"
    cmpass = "manager"
    pingaliveuser = "check"
    pingalivepass = "devices"
    launcheruser = "launcher"
    launcherpass = "launcher"
    launcheruseradmin = "tudor"
    launcherpassadmin = "adminlauncher"
    exceluser = "excel"
    excelpass = "lite"
    readeruser = "reader"
    readerpass = "office"
    hardmuser = "hardware"
    hardmpass = "lite"
    fetcheruser = "fetcher"
    fetcherpass = "repair"
    shelluser = "shell"
    shellpass = "integrator"
    w95user = "tudor"
    w95pass = "vnc"
    sqlluser = "sql"
    sqllpass = "editor"
    diagramuser = "diagram"
    diagrampass = "canvas"
    termadmuser = "tudor"
    termadmpass = "explorer"
    commanderuser = "commander"
    commanderpass = "total"
    calendaruser = "calendar"
    calendarpass = "calendar"
    allmonitoruser = "alert"
    allmonitorpass = "monitor"
    eventvuser = "eventviewer"
    eventvpass = "eventviewer"
    assemblyuser = "tudor"
    assemblypass = "assembly"
    kbbbuser = "kbretro"
    kbbbpass = "kbretro"

    if username_entry.get()==usernameAdm and password_entry.get()==passwordAdm:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = True
        adminT = True
        c = 3
        #xx = 2
        windowlogin.destroy()
        
    elif username_entry.get()==username and password_entry.get()==password:
        messagebox.showinfo(title="Login Success", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        show_validation = False
        adminT = False
        windowlogin.destroy()
    elif username_entry.get()==username_support and password_entry.get()==password_support:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        show_validation = True
        adminT = False
        #xx = 2
        windowlogin.destroy()
    elif username_entry.get()==usertrmn and password_entry.get()==passtermn:
        show_validation = False
        adminT = False
        trmn = 2
        windowlogin.destroy()
    elif username_entry.get()==userpass and password_entry.get()==passpass:
        show_validation = False
        adminT = False
        passfig = 4
        windowlogin.destroy()
    elif username_entry.get()==userpass1 and password_entry.get()==passpass1:
        show_validation = False
        adminT = False
        passfig1 = 5
        windowlogin.destroy()
    elif username_entry.get()==userhard and password_entry.get()==passhard:
        show_validation = False
        adminT = False
        hardvar = 6
        windowlogin.destroy()
    elif username_entry.get()==userscreenrec and password_entry.get()==passscreenrec:
        show_validation = False
        adminT = False
        screenvar = 7
        windowlogin.destroy()
    elif username_entry.get()==userzip and password_entry.get()==passzip:
        show_validation = False
        adminT = False
        zipvar = 8
        windowlogin.destroy()
    elif username_entry.get()==usercomp and password_entry.get()==passcomp:
        show_validation = False
        adminT = False
        compvar = 9
        windowlogin.destroy()
    elif username_entry.get()==userpdf and password_entry.get()==passpdf:
        show_validation = False
        adminT = False
        pdfvar = 10
        windowlogin.destroy()
    elif username_entry.get()==userreplfind and password_entry.get()==passreplfind:
        show_validation = False
        adminT = False
        replfindvar = 11
        windowlogin.destroy()
    elif username_entry.get()==testuser and password_entry.get()==testpass:
        show_validation = False
        adminT = False
        testvarr = 12
        windowlogin.destroy()
    elif username_entry.get()==testuser2 and password_entry.get()==testpass2:
        show_validation = False
        adminT = False
        testvarr2 = 122
        windowlogin.destroy()
    elif username_entry.get()==pdfvwuser and password_entry.get()==pdfvwpass:
        show_validation = False
        adminT = False
        pdfvwvar = 13
        windowlogin.destroy()
    elif username_entry.get()==netwuser and password_entry.get()==netwpass:
        show_validation = False
        adminT = False
        netwvar = 14
        windowlogin.destroy()
    elif username_entry.get()==crpuser2 and password_entry.get()==crppass2:
        show_validation = False
        adminT = False
        crpvar2 = 155
        windowlogin.destroy()
    elif username_entry.get()==aiuser and password_entry.get()==aipass:
        show_validation = False
        adminT = False
        aivar = 20
        windowlogin.destroy()
    elif username_entry.get()==notepaduser and password_entry.get()==notepadpass:
        show_validation = False
        adminT = False
        notepadvar = 21
        windowlogin.destroy()
    elif username_entry.get()==paintuser and password_entry.get()==paintpass:
        show_validation = False
        adminT = False
        paintvar = 22
        windowlogin.destroy()
    elif username_entry.get()==usernameAdm1 and password_entry.get()==passwordAdm1:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        # Definirea numele fisierului pentru salvarea cheii
        #FILE_NAME = "product_key.txt"
        # Definirea cheii de validare
        #KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Salvarea cheii în fisier text
        #with open(FILE_NAME, "w") as file:
            #file.write(KEY)
        show_validation = False
        adminT = False
        Adm1var = 30
        windowlogin.destroy()
    elif username_entry.get()==usernameAdm2 and password_entry.get()==passwordAdm2:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        Adm2var = 40
        windowlogin.destroy()
    elif username_entry.get()==usernamezp and password_entry.get()==passwordzp:
        show_validation = False
        adminT = False
        zippassvar = 60
        windowlogin.destroy()
    elif username_entry.get()==userbk and password_entry.get()==passbk:
        show_validation = False
        adminT = False
        bkvar = 700
        windowlogin.destroy()
    elif username_entry.get()==userrn and password_entry.get()==passrn:
        show_validation = False
        adminT = False
        rnvar = 710
        windowlogin.destroy()
    elif username_entry.get()==kbuser and password_entry.get()==kbpass:
        show_validation = False
        adminT = False
        kbvar = 1000
        windowlogin.destroy()
    elif username_entry.get()==passmngrruser and password_entry.get()==passmngrrpass:
        show_validation = False
        adminT = False
        passmngrr = 2000
        windowlogin.destroy()
    elif username_entry.get()==pauseuser and password_entry.get()==pausepass:
        show_validation = False
        adminT = False
        pausevar = 10000
        windowlogin.destroy()
    elif username_entry.get()==taskmngruser and password_entry.get()==taskmngrpass:
        show_validation = False
        adminT = False
        taskmngrvar = 1000000
        windowlogin.destroy()
    elif username_entry.get()==junkuser and password_entry.get()==junkpass:
        show_validation = False
        adminT = False
        junkvar = 77777
        windowlogin.destroy()
    elif username_entry.get()==wbpuser and password_entry.get()==wbppass:
        show_validation = False
        adminT = False
        wbpvar = 123456789
        windowlogin.destroy()
    elif username_entry.get()==cmuser and password_entry.get()==cmpass:
        show_validation = False
        adminT = False
        cmvar = 3333
        windowlogin.destroy()
    elif username_entry.get()==pingaliveuser and password_entry.get()==pingalivepass:
        show_validation = False
        adminT = False
        pingalivevar = 5566
        windowlogin.destroy()
    elif username_entry.get()==launcheruser and password_entry.get()==launcherpass:
        show_validation = False
        adminT = False
        launchervar = 1990
        windowlogin.destroy()
    elif username_entry.get()==launcheruseradmin and password_entry.get()==launcherpassadmin:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        launchervar_admin = 1991
        windowlogin.destroy()
    elif username_entry.get()==exceluser and password_entry.get()==excelpass:
        show_validation = False
        adminT = False
        excelvar = 1992
        windowlogin.destroy()
    elif username_entry.get()==readeruser and password_entry.get()==readerpass:
        show_validation = False
        adminT = False
        readervar = 1993
        windowlogin.destroy()
    elif username_entry.get()==hardmuser and password_entry.get()==hardmpass:
        show_validation = False
        adminT = False
        hardmvar = 1994
        windowlogin.destroy()
    elif username_entry.get()==fetcheruser and password_entry.get()==fetcherpass:
        show_validation = False
        adminT = False
        fetchervar = 1995
        windowlogin.destroy()
    elif username_entry.get()==shelluser and password_entry.get()==shellpass:
        show_validation = False
        adminT = False
        shellvar = 1996
        windowlogin.destroy()
    elif username_entry.get()==w95user and password_entry.get()==w95pass:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        w95var = 1997
        windowlogin.destroy()
    elif username_entry.get()==sqlluser and password_entry.get()==sqllpass:
        show_validation = False
        adminT = False
        sqllvar = 22222
        windowlogin.destroy()
    elif username_entry.get()==diagramuser and password_entry.get()==diagrampass:
        show_validation = False
        adminT = False
        diagramvar = 2345432
        windowlogin.destroy()
    elif username_entry.get()==termadmuser and password_entry.get()==termadmpass:
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        termadm = 6745
        windowlogin.destroy()
    elif username_entry.get()==commanderuser and password_entry.get()==commanderpass:
        show_validation = False
        adminT = False
        commandervar = 88888888
        windowlogin.destroy()
    elif username_entry.get()==calendaruser and password_entry.get()==calendarpass:
        show_validation = False
        adminT = False
        calendarvar = 999000
        windowlogin.destroy()
    elif username_entry.get()==allmonitoruser and password_entry.get()==allmonitorpass:
        show_validation = False
        adminT = False
        allmonitorvar = 999001
        windowlogin.destroy()
    elif username_entry.get()==eventvuser and password_entry.get()==eventvpass:
        show_validation = False
        adminT = False
        eventvval = 44445555
        windowlogin.destroy()
    elif username_entry.get()==assemblyuser and password_entry.get()==assemblypass:
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        assemblyvar = 333333333
        windowlogin.destroy()
    elif username_entry.get()==kbbbuser and password_entry.get()==kbbbpass:
        show_validation = False
        adminT = False
        kbbbvar = 5189
        windowlogin.destroy()
    #if (username_entry.get()!=usernameAdm and password_entry.get()!=passwordAdm) and (username_entry.get()!=username and password_entry.get()!=password):
    else:
        messagebox.showerror(title="Error", message="Invalid login.")

    # Verifica daca utilizatorul este autentificat ca "tudor"
    #if show_validation and username_entry.get() == "tudor":
        #adminT = True
    #else: 
        #adminT = False

# Funcția pentru completarea automată când se selectează o intrare din combobox
def on_combo_selected(event):
    selected = combo_users.get()
    if selected in credentials:
        username_entry.delete(0, tk.END)
        password_entry.delete(0, tk.END)
        username_entry.insert(0, credentials[selected]["username"])
        password_entry.insert(0, credentials[selected]["password"])
        
framelogin = tk.Frame(bg='gray20')

# Crearea combobox-ului pentru selecția utilizatorilor
combo_label = tk.Label(framelogin, text="Select user", bg='gray20', fg="lime green", font=("Fixedsys", 16, "bold"))
combo_users = ttk.Combobox(framelogin, font=("Fixedsys", 14), width=25, state="disabled")  # Initial disabled
combo_users['values'] = list(credentials.keys())
combo_users.bind("<<ComboboxSelected>>", on_combo_selected)

# Creating widgets
login_label = tk.Label(framelogin, text="Login", bg='gray20', fg="cyan", font=("Fixedsys", 30, "italic bold"))
#info_label = tk.Label(framelogin, text="This software was written in Python and C++ and precompiled into a single file.", bg="gray20", fg="yellow", font=("Fixedsys", 14, "italic"))
username_label = tk.Label(framelogin, text="Username", bg='gray20', fg="lime green", font=("Fixedsys", 16, "bold"))
username_entry = tk.Entry(framelogin, font=("Fixedsys", 16, "bold"), bg="gray40", fg="cyan", insertbackground="lime green")
password_entry = tk.Entry(framelogin, show="*", font=("Fixedsys", 16, "bold"), bg="gray40", fg="cyan", insertbackground="lime green")
password_label = tk.Label(framelogin, text="Password", bg='gray20', fg="lime green", font=("Fixedsys", 16, "bold"))
login_button = tk.Button(framelogin, text="Login", bg="black", fg="cyan", font=("Fixedsys", 16), command=login)

# Status label pentru a afișa starea modului dezvoltator
status_label = tk.Label(framelogin, text="Dev Mode: INACTIVE", bg='gray20', fg="red", font=("Fixedsys", 12, "bold"))

# Bind the <Return> key to the login function for both entry fields
username_entry.bind("<Return>", on_enter_press)
password_entry.bind("<Return>", on_enter_press)

# Placing widgets on the screen
login_label.grid(row=0, column=0, columnspan=2, sticky="news", pady=20)

#info_label.grid(row=1, column=0)

# Adăugăm combobox-ul înainte de câmpurile de login
combo_label.grid(row=1, column=0, pady=10)
combo_users.grid(row=1, column=1, pady=10, padx=10, sticky="w")

username_label.grid(row=2, column=0)
username_entry.grid(row=2, column=1, pady=20, padx=10)
password_label.grid(row=3, column=0)
password_entry.grid(row=3, column=1, pady=20, padx=10)
login_button.grid(row=4, column=0, columnspan=2, pady=30)

# Adăugăm statusbar-ul în partea de jos
status_label.grid(row=5, column=0, columnspan=2, pady=10)

framelogin.pack()

windowlogin.mainloop()



def main1():
    messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
    global adminT
    global c
    validation.destroy()  # Închide fereastra de validare
    class FileCopyApp:
        def __init__(self, root):
            self.root = root
            self.root.title("Copy App")
            self.root.geometry("400x400")
            self.root.config(bg="gray20")

            # Directorul destinație
            self.current_user = os.getenv('USERNAME')
            self.destination_path = rf'C:\KIT'

            # Verifică dacă calea de destinație există
            if not os.path.exists(self.destination_path):
                try:
                    # Creează calea de destinație dacă nu există
                    os.makedirs(self.destination_path)
                    print("Director successfully created:", self.destination_path)
                except OSError as e:
                    print("Error creating directory:", e)

            # Dicționarul cu programe și direcțiile lor sursă
            self.program_paths = {}
            
            # Deschide fișierul pentru citire
            with open("paths.txt", "r") as file:
                for line in file:
                    key, value = line.strip().split(":")
                    self.program_paths[key.strip()] = value.strip()

            # Frame-uri pentru fiecare jumătate a ferestrei
            self.left_frame = tk.Frame(root, bg="gray20")
            self.left_frame.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.BOTH, expand=True)

            self.right_frame = tk.Frame(root, bg="gray20")
            self.right_frame.pack(side=tk.RIGHT, padx=5, pady=5, fill=tk.Y)

            # Canvas pentru lista de programe cu scrollbar
            self.canvas = tk.Canvas(self.left_frame, bg="gray20", highlightthickness=0)
            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.scrollbar = ttk.Scrollbar(self.right_frame, orient="vertical", command=self.canvas.yview)
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.canvas.configure(yscrollcommand=self.scrollbar.set)
            self.canvas.bind('<Configure>', self.on_canvas_configure)

            self.program_frame = tk.Frame(self.canvas, bg="gray20")
            self.canvas.create_window((0, 0), window=self.program_frame, anchor='nw')

            # Funcție pentru actualizarea culorii textului în funcție de starea checkbox-ului
            def update_fg_color(*args):
                for program, var in self.program_vars.items():
                    if var.get() == 1:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="cyan")
                    else:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="white")

            # Checkbox-uri și progres bar-uri pentru programe
            self.program_vars = {}
            self.program_checkboxes = {}
            self.progress_bars = {}

            # Frame pentru butoanele de selecție a checkbox-urilor
            self.checkbox_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.checkbox_button_frame.pack(pady=10, padx=10)

            # Încarcă profilele și creează butoanele
            self.load_profiles_and_create_buttons()

            col_count = 2  # Numărul de coloane dorit
            row_count = -(-len(self.program_paths) // col_count)  # Calculul numărului de rânduri necesare
            program_index = 0  # Variabilă pentru a ține evidența indexului programului
         
            for i in range(row_count):
                for j in range(col_count):
                    if program_index >= len(self.program_paths):
                        break
                    program = list(self.program_paths.keys())[program_index]
                    var = tk.IntVar()
                    chk = tk.Checkbutton(self.program_frame, text=program, variable=var, bg="gray20", selectcolor="green", activebackground="pale green")
                    chk.grid(row=i, column=j*2, sticky="w")
                    self.program_vars[program] = var
                    self.program_checkboxes[program] = chk
                    chk.config(fg="white")
                    var.trace_add("write", update_fg_color)
         
                    # Creează progres bar-ul pentru fiecare program și îl pune sub checkbox
                    self.progress_bars[program] = ttk.Progressbar(self.program_frame, orient="horizontal", length=200, mode="determinate", style="custom.Horizontal.TProgressbar")
                    self.progress_bars[program].grid(row=i, column=j*2+1, sticky="ew", padx=10, pady=2)
         
                    program_index += 1
         
            # Stilizare progres bar personalizat
            self.style = ttk.Style()
            self.style.theme_use('default')
            self.style.configure("custom.Horizontal.TProgressbar", troughcolor='gray', background='green', borderwidth=0)

            # Frame pentru butonul de copiere
            self.copy_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.copy_button_frame.pack(pady=10, padx=10)

            # Plasează butonul de copiere direct în self.right_frame
            self.copy_button = tk.Button(self.right_frame, text="Copy Files", command=self.copy_files, bg="cyan", fg="black", bd=6)
            self.copy_button.pack(pady=10, padx=10)

            # Buton stergere campuri checkbox
            self.delete_button = tk.Button(self.right_frame, text="Delete checkboxes", command=self.delete_checkboxes, bg="red", fg="black", bd=6)
            self.delete_button.pack(pady=10, padx=10)

            self.bandmonitoring_button = tk.Button(self.right_frame, text="Network Console", command=self.band_network_monitoring, bg="gray40", fg="lime green", bd=5)
            self.bandmonitoring_button.pack(pady=5)
                
            # Butonul pentru a ieși din aplicație
            self.button_exit = tk.Button(self.checkbox_button_frame, text="EXIT", command=self.exit_application, bg="red", fg="white", bd=10)
            self.button_exit.pack(pady=20)

            self.last_received = 0
            self.last_sent = 0
            self.last_total = 0
            self.running = False

        def load_profiles_and_create_buttons(self):
            # Încarcă profilurile din JSON
            with open("profiles.json", "r") as f:
                self.profiles = json.load(f)

            # Creează butoanele pentru fiecare profil
            for profile_name in self.profiles:
                button = tk.Button(self.checkbox_button_frame, text=profile_name,
                                command=lambda p=profile_name: self.select_profile_checkboxes(p),
                                bg="gray40", fg="white", bd=1)
                button.pack(pady=5, padx=10)

        def select_profile_checkboxes(self, profile_name):
            # Resetează toate checkbox-urile
            for program in self.program_vars:
                self.program_vars[program].set(0)

            # Resetează barele de progres
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0

            # Resetează textul checkbox-urilor care se termină cu " (done)"
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                if current_text.endswith(" (done)"):
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)

            # Verifică dacă profilul există
            if profile_name in self.profiles:
                profile_checkboxes = self.profiles[profile_name]["checkboxes"]
                for program in profile_checkboxes:
                    if program in self.program_vars:
                        self.program_vars[program].set(1)
    ##############################################################################################################################################################    
                
         
        def exit_application(self):
            if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
                root.destroy()
         
    ###############################################################################
        def band_network_monitoring(self):
            def update_data():
                while self.running:
                    bytes_received = psutil.net_io_counters().bytes_recv
                    bytes_sent = psutil.net_io_counters().bytes_sent
                    bytes_total = bytes_received + bytes_sent
                        
                    new_received = bytes_received - self.last_received if hasattr(self, 'last_received') else 0
                    new_sent = bytes_sent - self.last_sent if hasattr(self, 'last_sent') else 0
                    new_total = bytes_total - self.last_total if hasattr(self, 'last_total') else 0
                  
                    mb_new_received = new_received / 1024 / 1024
                    mb_new_sent = new_sent / 1024 / 1024
                    mb_new_total = new_total / 1024 / 1024
                        
                    # Actualizează textul în text area cu noile date
                    text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                    text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                        
                    # Salvează datele în fișier
                    with open("network_data.txt", "a") as file:
                        file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        
                    print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                        
                    self.last_received = bytes_received
                    self.last_sent = bytes_sent
                    self.last_total = bytes_total
                        
                    time.sleep(1)

            def start():
                self.running = True
                # Șterge conținutul text area-ului la fiecare pornire
                text_area.delete(1.0, tk.END)
                # Crează un thread nou pentru actualizarea datelor
                data_thread = threading.Thread(target=update_data)
                data_thread.start()

            def stop():
                self.running = False

            # Crează fereastra
            monitorband = tk.Toplevel()
            monitorband.title("Network Console")
            monitorband.resizable(False, False)
            monitorband.config(bg="gray20")
            #image_icon44 = PhotoImage(file = "img/networklogo.png")
            #monitorband.iconphoto(False, image_icon44)

            # Creează un text area cu culoare de fundal și text personalizate
            text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
            text_area.pack(expand=True, fill=tk.BOTH)

            # Buton pentru pornirea monitorizării
            start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
            start_button.pack()

            # Buton pentru oprirea monitorizării
            stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
            stop_button.pack()

            # Inițializare variabile
            self.last_received = psutil.net_io_counters().bytes_recv
            self.last_sent = psutil.net_io_counters().bytes_sent
            self.last_total = self.last_received + self.last_sent
            self.running = False

            # Pornirea buclei principale a interfeței grafice
            #monitorband.mainloop()
    ###############################################################################
         
        def delete_checkboxes(self):
            for program in self.program_vars:
                self.program_vars[program].set(0)
            #self.program_vars[""].set(0)
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                # Verificăm dacă textul se termină cu " (done)"
                if current_text.endswith(" (done)"):
                    # Eliminăm ultimele 77 caractere din textul curent și actualizăm textul checkbox-ului
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)
         
        def on_canvas_configure(self, event):
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
         
        def copy_files(self):
            self.copy_button.config(state="disabled")  # Dezactivează butonul de copiere
            #self.select_Director_button.config(state="disabled")
            selected_programs = [program for program, var in self.program_vars.items() if var.get() == 1]
            if not selected_programs:
                messagebox.showwarning("No program selected", "Please select at least one program to copy the files.")
                self.copy_button.config(state="normal")  # Activează butonul de copiere
                #self.select_Director_button.config(state="normal")
                return
         
            # Funcție pentru a actualiza textul checkbox-urilor cu "done"
            def update_checkbox_text():
                for program in selected_programs:
                    checkbox = self.program_checkboxes[program]
                    checkbox.config(text=program + " (done)")
         
            # Funcție pentru a realiza copierea fișierelor într-un fir de execuție separat
            def copy_files_thread():
                try:
                    for program in selected_programs:
                        program_source = self.program_paths[program]
                        if os.path.exists(program_source):
                            # Crează un director pentru a stoca fișierele copiate
                            save_directory = os.path.join(self.destination_path, os.path.basename(program_source))
                            os.makedirs(save_directory, exist_ok=True)
                            if os.path.isdir(program_source):
                                # Dacă sursa este un director, copiază întregul director
                                total_files = sum(len(files) for _, _, files in os.walk(program_source))  # Calculăm numărul total de fișiere
                                files_copied = 0  # Inițializăm contorul pentru fișierele copiate
                                for root, dirs, files in os.walk(program_source):
                                    for dir in dirs:
                                        src = os.path.join(root, dir)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        os.makedirs(dest, exist_ok=True)
                                    for file in files:
                                        src = os.path.join(root, file)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        # Verificăm dacă fișierul de destinație există deja
                                        if not os.path.exists(dest):
                                            shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                        # Actualizăm progresul
                                        files_copied += 1
                                        progress_value = (files_copied / total_files) * 100
                                        self.progress_bars[program]["value"] = progress_value
                                        self.root.update_idletasks()  # Actualizează interfața grafică
         
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                            else:
                                # Dacă sursa este un fișier, copiază doar fișierul
                                total_files = 1  # Avem un singur fișier de copiat
                                files_copied = 0
                                file_name = os.path.basename(program_source)
                                src = program_source
                                dest = os.path.join(save_directory, file_name)
                                # Verificăm dacă fișierul de destinație există deja
                                if not os.path.exists(dest):
                                    shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                files_copied += 1
                                progress_value = (files_copied / total_files) * 100
                                self.progress_bars[program]["value"] = progress_value
                                self.root.update_idletasks()  # Actualizează interfața grafică
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                    # Afisăm mesajul de finalizare a copierii
                    self.root.after(0, self.show_copy_success)
        
                except Exception as ex:
                    # Afisăm mesaj de eroare dacă apare o excepție
                    self.root.after(0, lambda e=ex: self.show_copy_error(e))
        
                finally:
                    # Activează butonul de copiere după finalizarea copierii
                    self.root.after(0, self.enable_copy_button)
         
            # Pornim firul de execuție pentru copierea fișierelor
            threading.Thread(target=copy_files_thread).start()
         
         
        def show_copy_success(self):
            messagebox.showinfo("Copy completed", "The files have been successfully copied.")
         
        def show_copy_error(self, error_message):
            messagebox.showerror("Error copying", f"An error occurred while copying the files: {str(error_message)}")
         
        def enable_copy_button(self):
            self.copy_button.config(state="normal")
         
    def browse_folder():
        folder_path = filedialog.askdirectory()
        if folder_path:
            folder_path = folder_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("folder_paths.txt", "a") as file:
                file.write(folder_path + "\n")
         
    def browse_file():
        file_path = filedialog.askopenfilename()
        if file_path:
            file_path = file_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("file_paths.txt", "a") as file:
                file.write(file_path + "\n")
         
    def copy_file():
        with open("file_paths.txt", "r") as file:
            file_paths = file.readlines()
        for file_path in file_paths:
            file_path = file_path.strip()  # Eliminăm caracterele de nouă linie și spații suplimentare
            shutil.copy2(file_path, save_location.get())
         
    def copy_folder():
        with open("folder_paths.txt", "r") as file:
            folder_paths = file.readlines()
        for folder_path in folder_paths:
            folder_path = folder_path.strip()
            save_path = os.path.join(save_location.get(), os.path.basename(folder_path))
            try:
                shutil.copytree(folder_path, save_path)
            except PermissionError:
                messagebox.showerror("Error", "Access to the source folder is denied.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {str(e)}")
         
    def update_buttons_state():
        if save_location.get():
            button_copy_file.config(state="normal")
            button_copy_folder.config(state="normal")
        else:
            button_copy_file.config(state="disabled")
            button_copy_folder.config(state="disabled")
         
    def select_save_location():
        save_location.set(filedialog.askdirectory())
        update_buttons_state()
         
    def open_copy_window():
        global button_copy_file, button_copy_folder
        copy_window = tk.Toplevel(root)
        copy_window.title("Copy Files/Folders")
        copy_window.config(bg="gray20")  # Setare culoare fundal gri închis
        copy_window.resizable(False, False)
        #image_icon46 = PhotoImage(file = "img/downloadlogo.png")
        #copy_window.iconphoto(False, image_icon46)
         
        frame = tk.Frame(copy_window)
        frame.pack(padx=20, pady=20)
        
        button_copy_file = tk.Button(frame, text="Copy Files", command=copy_file, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_file.pack(padx=10, pady=5)
         
        button_copy_folder = tk.Button(frame, text="Copy Folders", command=copy_folder, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_folder.pack(padx=10, pady=5)
         
        button_select_location = tk.Button(frame, text="Select Save Location", command=select_save_location, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_select_location.pack(padx=10, pady=5)
         
        update_buttons_state()
         
        copy_window.mainloop()
         
    def open_file_explorer_window():
        file_explorer_window = tk.Toplevel(root)
        file_explorer_window.title("Browse in File Explorer")
        file_explorer_window.config(bg="gray20")  # Setare culoare fundal gri închis
        file_explorer_window.resizable(False, False)
        #image_icon47 = PhotoImage(file = "img/downloadlogo.png")
        #file_explorer_window.iconphoto(False, image_icon47)
         
        frame = tk.Frame(file_explorer_window, bg="gray20")  # Setare culoare fundal gri închis
        frame.pack(padx=20, pady=20)
         
        button_folder = tk.Button(frame, text="Select a Folder", command=browse_folder, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordura
        button_folder.pack(padx=10, pady=5)
         
        button_file = tk.Button(frame, text="Select a File", command=browse_file, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_file.pack(padx=10, pady=5)
         
        button_open_copy_window = tk.Button(frame, text="Open Copy Window", command=open_copy_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_open_copy_window.pack(padx=10, pady=5)
         
    def open_file_copy_app_window():
        file_copy_app_window = tk.Toplevel(root)
        file_copy_app_window.title("Copy App Defaults")
        file_copy_app_window.config(bg="gray20")  # Setare culoare fundal gri închis
        # Dezactivarea posibilității de redimensionare a ferestrei
        file_copy_app_window.resizable(False, False)
        #image_icon48 = PhotoImage(file = "img/downloadlogo.png")
        #file_copy_app_window.iconphoto(False, image_icon48)
        # Maximizarea ferestrei
        file_copy_app_window.state("zoomed")
        app = FileCopyApp(file_copy_app_window)
     
    def ExecuteIPandMAC():
        import re
        IPMAC = tk.Toplevel(root)
        IPMAC.config(bg='gray20')
        IPMAC.geometry('340x230')
        IPMAC.title("Get IP & MAC")
        IPMAC.resizable(False, False)
     
        def ip():
            hostname = socket.gethostname()
            ip_add = socket.gethostbyname(hostname)
            showinfo("IP Adress", f"IP Adress: {ip_add}")
            print("IP Adress: ", ip_add)
     
        def mac():
            mac_add = getmac.get_mac_address()
            showinfo("MAC Adress", f"MAC Adress: {mac_add}")
            print("MAC Adress: ", mac_add)
        
        def get_mac_address1(ip_address):
            try:
                # Run the arp command
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
                
                # Extract the ARP table
                arp_output = result.stdout
                
                # Search for the IP address in the ARP table
                match = re.search(rf'{ip_address}[\s]+([\w-]+)', arp_output)
                
                if match:
                    return match.group(1)
                else:
                    return None
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {str(e)}")
                return None

        def get_mac1():
            ip_address = ip_entry.get()
            mac_address = get_mac_address1(ip_address)
            if mac_address:
                result_label.config(text=f"The MAC address of {ip_address} is {mac_address}")
            else:
                result_label.config(text=f"MAC address for {ip_address} not found")

        def check_entry(event):
            if ip_entry.get() != "":
                find_button.config(state="normal")
            else:
                find_button.config(state="disabled")
     
        ip_button = tk.Button(IPMAC, text="Show IP Adress", bg="gray40", fg="lime green", font=('times new roman', 16, 'bold'), bd=3, command=ip)
        ip_button.pack()
     
        mac_button = tk.Button(IPMAC, text="Show MAC Adress", bg="gray40", fg="lime green", font=('times new roman', 16, 'bold'), bd=3, command=mac)
        mac_button.pack()
        
        # Create and pack widgets
        ip_label = tk.Label(IPMAC, text="Enter IP Address:", bg="gray20", fg="lime green", font=('times new roman', 16, 'bold'))
        ip_label.pack()

        ip_entry = tk.Entry(IPMAC, bg="gray20", fg="#ccff66", font=('times new roman', 16, 'bold'), insertbackground = "cyan")
        ip_entry.pack()
        ip_entry.bind("<KeyRelease>", check_entry)  # legăm funcția de verificare la evenimentul KeyRelease

        find_button = tk.Button(IPMAC, text="Find MAC Address", command=get_mac1, bg="black", fg="lime green", font=('times new roman', 16, 'bold'), bd=3, state="disabled")
        find_button.pack()

        result_label = tk.Label(IPMAC, text="", bg="gray20", fg="#ccff66", font=('times new roman', 10, 'bold'))
        result_label.pack()
     
     
     
    root = tk.Tk()
    root.title("Menu")
    root.geometry("300x810+10+10")
    root.config(bg="gray20")  # Setare culoare fundal gri închis
    #root.resizable(False, False)
    image_icon7 = PhotoImage(file = "img/appslogo.png")
    root.iconphoto(False, image_icon7)
     
    main_frame = tk.Frame(root, bg="gray20")  # Setare culoare fundal gri închis
    main_frame.pack(padx=20, pady=20)
     
    button_open_file_explorer = tk.Button(main_frame, text="Explorer Mode", command=open_file_explorer_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
    button_open_file_explorer.pack(padx=10, pady=5)
     
    button_open_file_copy_app = tk.Button(main_frame, text="Copy App", command=open_file_copy_app_window, bg="gray40", fg="white", bd=1)  # Schimbare scris negru
    button_open_file_copy_app.pack(padx=10, pady=5)
     
    button_network = tk.Button(main_frame, text="Get Ip & MAC", command=ExecuteIPandMAC, bg="gray40", fg="white", bd=1)  # Schimbare scris negru + gray40
    button_network.pack(padx=10, pady=5)
     
    # ==== Scanning Functions ====
    def scanPort(target, port):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(4)
            c = s.connect_ex((target, port))
            if c == 0:
                m = ' Port %d \t[open]' % (port,)
                log.append(m)
                ports.append(port)
                listbox.insert("end", str(m))
                updateResult()
            s.close()
        except OSError: 
            print('> Too many open sockets. Port ' + str(port))
        except:
            s.close()
            sys.exit()

    def updateResult():
        rtext = " [ " + str(len(ports)) + " / " + str(ip_f) + " ] ~ " + str(target)
        L27.configure(text = rtext)

    def startScan():
        global ports, log, target, ip_f
        clearScan()
        log = []
        ports = []
        ip_s = int(L24.get())
        ip_f = int(L25.get())
        log.append('> Port Scanner')
        log.append('='*14 + '\n')
        log.append(' Target:\t' + str(target))

        try:
            target = socket.gethostbyname(str(L22.get()))
            log.append(' IP Adr.:\t' + str(target))
            log.append(' Ports: \t[ ' + str(ip_s) + ' / ' + str(ip_f) + ' ]')
            log.append('\n')

            while ip_s <= ip_f:
                try:
                    scan = threading.Thread(target=scanPort, args=(target, ip_s))
                    scan.setDaemon(True)
                    scan.start()
                except: 
                    time.sleep(0.01)
                ip_s += 1
        except:
            m = '> Target ' + str(L22.get()) + ' not found.'
            log.append(m)
            listbox.insert(0, str(m))

    def saveScan():
        global log, target, ports, ip_f
        log[5] = " Result:\t[ " + str(len(ports)) + " / " + str(ip_f) + " ]\n"
        with open('portscan-'+str(target)+'.txt', mode='wt', encoding='utf-8') as myfile:
            myfile.write('\n'.join(log))

    def clearScan():
        listbox.delete(0, 'end')

    def PortScanner():
        '''
        global port_scan_window, listbox, L22, L24, L25, L27, log, ports, target, ip_f
        #port_scan_window = tk.Tk() # Define root window
        port_scan_window = tk.Toplevel(root)
        port_scan_window.title('Port Scanner')
        port_scan_window.geometry("400x600+20+20")
        port_scan_window.configure(bg="#222222")

        # ==== Colors ====
        m1c = '#00ee00'
        bgc = '#222222'
        dbg = '#000000'
        fgc = '#111111'

        #port_scan_window.tk_setPalette(background=bgc, foreground=m1c, activeBackground=fgc, activeForeground=bgc, highlightColor=m1c, highlightBackground=m1c)

        # ==== Labels ====
        L11 = tk.Label(port_scan_window, text="Port Scanner", font=("Helvetica", 16, 'underline'), bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L11.place(x=16, y=10)

        L21 = tk.Label(port_scan_window, text="Target: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L21.place(x=16, y=90)

        L22 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L22.place(x=180, y=90)
        L22.insert(0, "localhost")

        L23 = tk.Label(port_scan_window, text="Ports: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L23.place(x=16, y=158)

        L24 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L24.place(x=180, y=158, width=95)
        L24.insert(0, "1")

        L25 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L25.place(x=290, y=158, width=95)
        L25.insert(0, "1024")

        L26 = tk.Label(port_scan_window, text="Results: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L26.place(x=16, y=220)
        L27 = tk.Label(port_scan_window, text="[ ... ]", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L27.place(x=180, y=220)

        # ==== Ports list ====
        frame = tk.Frame(port_scan_window, bg="#222222")
        frame.place(x=16, y=275, width=370, height=215)
        listbox = tk.Listbox(frame, width=59, height=6, bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        listbox.place(x=0, y=0)
        listbox.bind('<<ListboxSelect>>')
        scrollbar = tk.Scrollbar(frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=listbox.yview)

        # ==== Buttons / Scans ====
        B11 = tk.Button(port_scan_window, text="Start Scan", command=startScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B11.place(x=16, y=500, width=170)
        B21 = tk.Button(port_scan_window, text="Save Result", command=saveScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B21.place(x=210, y=500, width=170)

        # Initialize variables
        log = []
        ports = []
        target = 'localhost'
        ip_f = 1024
        #port_scan_window.mainloop()
        '''
        global port_scan_window, listbox, L22, L24, L25, L27, log, ports, target, ip_f
        #port_scan_window = tk.Tk() # Define root window
        port_scan_window = tk.Toplevel(root)
        port_scan_window.title('Port Scanner')
        port_scan_window.geometry("400x600+20+20")
        port_scan_window.configure(bg="#222222")
        image_icon8 = PhotoImage(file = "img/networklogo.png")
        port_scan_window.iconphoto(False, image_icon8)

        # ==== Colors ====
        m1c = '#00ee00'
        bgc = '#222222'
        dbg = '#000000'
        fgc = '#111111'

        #port_scan_window.tk_setPalette(background=bgc, foreground=m1c, activeBackground=fgc, activeForeground=bgc, highlightColor=m1c, highlightBackground=m1c)

        # ==== Labels ====
        L11 = tk.Label(port_scan_window, text="Port Scanner", font=("Helvetica", 16, 'underline'), bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L11.place(x=16, y=10)

        L21 = tk.Label(port_scan_window, text="Target: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L21.place(x=16, y=90)

        L22 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L22.place(x=180, y=90)
        L22.insert(0, "localhost")

        L23 = tk.Label(port_scan_window, text="Ports: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L23.place(x=16, y=158)

        L24 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L24.place(x=180, y=158, width=95)
        L24.insert(0, "1")

        L25 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L25.place(x=290, y=158, width=95)
        L25.insert(0, "1024")

        L26 = tk.Label(port_scan_window, text="Results: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L26.place(x=16, y=220)
        L27 = tk.Label(port_scan_window, text="[ ... ]", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L27.place(x=180, y=220)

        # ==== Ports list ====
        frame = tk.Frame(port_scan_window, bg="#222222")
        frame.place(x=16, y=275, width=370, height=215)
        listbox = tk.Listbox(frame, width=59, height=6, bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        listbox.configure(highlightbackground=m1c)
        listbox.place(x=0, y=0)
        listbox.bind('<<ListboxSelect>>')
        scrollbar = tk.Scrollbar(frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=listbox.yview)

        # ==== Buttons / Scans ====
        B11 = tk.Button(port_scan_window, text="Start Scan", command=startScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B11.place(x=16, y=500, width=170)
        B21 = tk.Button(port_scan_window, text="Save Result", command=saveScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B21.place(x=210, y=500, width=170)

        # Initialize variables
        log = []
        ports = []
        target = 'localhost'
        ip_f = 1024
        #port_scan_window.mainloop()
     
    button_portscanner = tk.Button(main_frame, text="Port Scanner", command=PortScanner, bg="gray40", fg="white", bd=1) #black
    button_portscanner.pack(padx=10, pady=5)
    image_icon9 = None 
    def PingTool():
        #Globals
        window = tk.Tk();
        window.title("Port Pinger 1.0");
        #image_icon9 = PhotoImage(file = "img/networklogo.png")
        #window.iconphoto(False, image_icon9)
        window_Width = 1100;
        window_Height = 520;
        ScreenWidth = window.winfo_screenwidth();
        ScreenHeight = window.winfo_screenheight();
        Appear_in_the_Middle = '%dx%d+%d+%d' % (window_Width, window_Height, (ScreenWidth - window_Width) / 2, (ScreenHeight - window_Height) / 2);
        window.geometry(Appear_in_the_Middle);
        window.resizable(width=False, height=False);
        window.configure(bg='black'); 
        GUI = None; #pointer that will be used to reference GUI class for functions (instantiated later)
     
        #---Class--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        class PPPPP_GUI:
     
        #------Inline Functions------
              def Get_Current_Network(self): 
                  #Note: Code below works only for Windows and WLAN. Specify alt interface for other. For Linux call "ifconfig" or "iwconfig" respectively.
                  Client_Hostname = socket.gethostname(); 
                  IP_Settings = subprocess.run('ipconfig /all',stdout=subprocess.PIPE,text=True).stdout.lower();
                  scan=False;
                  IP_Address = "";
                  Default_Gateway = "";
                  Subnet_Mask = "";
                  DNS_Servers = "";
                  scan = "";
     
                  #Comment/uncomment line below to toggle WLAN and wired ethernet connection (till I find room on the GUi for a button)
                  for i in IP_Settings.split('\n'):
                      #if 'wireless' in i: scan=True;
                      if((i != None) and ("ethernet adapter ethernet:" in i)): scan=True;
                      #if((i != None) and ("ethernet adapter vmware network adapter vmnet8:" in i)): scan=True;
     
                      #Only get value 1st iternation. If value != null don't retrieve
                      if scan:
                         if 'ipv4 address' in i and IP_Address == "": 
                            IP_Address = i.split(':')[1].strip();
                            IP_Address = IP_Address.replace("(preferred)","");
                         if 'default gateway' in i and Default_Gateway == "": 
                            Default_Gateway = i.split(':')[1].strip();   
                         if 'subnet mask' in i and Subnet_Mask == "": 
                            Subnet_Mask = i.split(':')[1].strip(); 
                         if 'dns servers' in i and DNS_Servers == "": 
                            DNS_Servers = i.split(':')[1].strip();         
     
                  MESSAGE = "IP v4 ad: " +  IP_Address;
                  MESSAGE += "      Subnet: " + Subnet_Mask;
                  MESSAGE += "\nHostname: " + Client_Hostname;
                  MESSAGE += "           DNS: " + DNS_Servers;
                  MESSAGE += "\nGateway:  " + Default_Gateway;
                  self.TXT_Current_Network.insert("0.0", MESSAGE);
                  print("\n" + MESSAGE);          
     
        #----------------------------------------------------------------------------------------------------------------------           
     
              def refresh(self):
                  window.update();
                  window.after(1000,self.refresh);
     
        #----------------------------------------------------------------------------------------------------------------------       
     
              def Ping_Sweep_1(self):
                  self.TXT_Main_Output.delete("0.0", "end");
                  Net_IP = self.ENT_Network.get();
                  Start_Host = self.ENT_Start_Host.get();
                  End_Host = self.ENT_End_Host.get();
     
                  MESSAGE = "\n Initiating PING Sweep.\n";
                  MESSAGE += " Received from GUI:\n";
                  MESSAGE += "\n Network Address: " + Net_IP; 
                  MESSAGE +=  "\n Starting Host: " + Start_Host;
                  MESSAGE +=  "\n Ending Host: " + End_Host + "\n";
     
                  self.TXT_Main_Output.insert("0.0", MESSAGE);
                  print(MESSAGE);
     
                  The_Ping = "";
     
                  IP_PARTS = Net_IP.split('.');
                  NETWORK_IP = IP_PARTS[0] + '.' + IP_PARTS[1] + '.' + IP_PARTS[2] + '.';
     
                  Starting_Host = int(Start_Host);
                  Ending_Host = int(End_Host);
                  Ending_Host += 1;
     
                  OS = platform.system();
     
                  if(OS == "Windows"):
                     print("Windows OS detected.");
                     Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                     self.TXT_Main_Output.delete(1.0,"end");
                     self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + " Windows OS detected.");
                     The_Ping = "ping -n 1 ";
                  else:
                     print("Hopefully Linux OS detected.");
                     Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                     self.TXT_Main_Output.delete(1.0,"end");
                     self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + " Hopefully Linux OS detected.");
                     The_Ping = "ping -c 1 ";   
     
                  #Get starting time of scan
                  Time_Start = datetime.datetime.now();
                  MESSAGE = " Start time: " + str(Time_Start);  
                  MESSAGE += "\n Scanning ...\n";  
                  print(MESSAGE);
                  Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                  self.TXT_Main_Output.delete(1.0,"end");
                  self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
     
                  for IP in range(Starting_Host,Ending_Host):
                      ADDRESS = NETWORK_IP + str(IP);
                      MESSAGE = " Pinging " + ADDRESS; 
                      Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                      self.TXT_Main_Output.delete(1.0,"end");
                      self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                      self.TXT_Main_Output.see("end"); #autoscrolls TEXT object to bottom
                      print(MESSAGE);
                      The_Command = The_Ping + ADDRESS;
                      The_Response = os.popen(The_Command);
                      LIST = The_Response.readlines();
     
                      for LINE in LIST:
                          if(LINE.count("TTL")):
                             MESSAGE = "        " + ADDRESS + "---> Live!"; 
                             print(MESSAGE); 
                             Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                             self.TXT_Main_Output.delete(1.0,"end");
                             self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                             break;  
     
                  Time_End = datetime.datetime.now();
                  Total_Time = Time_End - Time_Start;
                  MESSAGE = "\nScan completed in: " + str(Total_Time);
                  print(MESSAGE);
                  Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                  self.TXT_Main_Output.delete(1.0,"end");
                  self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
     
        #----------------------------------------------------------------------------------------------------------------------
              def Threaded_Ping_Sweep_1(self):
                  self.refresh();
                  threading.Thread(target=self.Ping_Sweep_1).start();
     
        #---------------------------------------------------------------------------------------------------------------------- 
     
              def Port_Scan_1(self):
                  self.TXT_Main_Output.delete("0.0", "end");
                  The_Host = self.ENT_Host.get();
                  Start_Port = self.ENT_Start_Port.get();
                  End_Port = self.ENT_End_Port.get();
     
                  MESSAGE = "\n Initiating PORT Scan.\n";
                  MESSAGE += " Received from GUI:\n";
                  MESSAGE += "\n Host to scan: " + The_Host; 
                  MESSAGE +=  "\n Starting Port: " + Start_Port;
                  MESSAGE +=  "\n Ending Port: " + End_Port + "\n";
     
                  self.TXT_Main_Output.insert("0.0", MESSAGE);
                  print(MESSAGE);
     
                  # Check time when scan started
                  Time_Start = datetime.datetime.now();
     
                  Remote_Server = The_Host;
                  Remote_Server_IP = socket.gethostbyname(Remote_Server);
                  Port_Start = int(Start_Port);
                  Port_End = int(End_Port);
     
                  MESSAGE =  "\n Scanning remote host: " + Remote_Server_IP + "\n";
                  Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                  self.TXT_Main_Output.delete(1.0,"end");
                  self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                  print(MESSAGE);
     
                  try:
                      for port in range(Port_Start,Port_End): 
                          MESSAGE = " Scanning port: " + str(port);
                          Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                          self.TXT_Main_Output.delete(1.0,"end");
                          self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                          self.TXT_Main_Output.see("end"); #autoscrolls TEXT object to bottom
                          print(MESSAGE);  
                          sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
                          socket.setdefaulttimeout(.1);
                          result = sock.connect_ex((Remote_Server_IP, port));
                          if result == 0:
                             MESSAGE = "\n ********** Port " + str(port) + ":-->Open!";
                             Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                             self.TXT_Main_Output.delete(1.0,"end");
                             self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                             print(MESSAGE);
                          sock.close();
     
                  except KeyboardInterrupt:
                         MESSAGE = "\n You pressed Ctrl + C to terminate process.";
                         Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                         self.TXT_Main_Output.delete(1.0,"end");
                         self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                         print(MESSAGE);
                         self.sys.exit();
     
                  except socket.gaierror:
                         print("");
                         MESSAGE = "\n Hostname could not be resolved. Exiting ...";
                         Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                         self.TXT_Main_Output.delete(1.0,"end");
                         self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                         print(MESSAGE);                 
                         self.sys.exit();
     
                  except socket.error:
                         MESSAGE = "\n Couldn't connect to server. Exiting ...";
                         Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                         self.TXT_Main_Output.delete(1.0,"end");
                         self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                         print(MESSAGE);                 
                         self.sys.exit();
     
                  # Checking the time again
                  Time_Finish = datetime.datetime.now();
     
                  # Calculates the difference of time, to see how long it took to run the script
                  Time_Total =  Time_Finish - Time_Start;
     
                  # Printing the information to screen     
                  MESSAGE = "Scanning Completed in: " + str(Time_Total);
                  self.TXT_Main_Output.insert("1.0", MESSAGE);
                  print(MESSAGE);                     
        #---------------------------------------------------------------------------------------------------------------------- 
     
              def Threaded_Port_Scan_1(self):
                  self.refresh();
                  threading.Thread(target=self.Port_Scan_1).start();
     
        #---------------------------------------------------------------------------------------------------------------------- 
     
            #---Constructor----------------------------------------------------------------------------     
              def __init__(self, master=None):
     
                  self.RB_Ping_Or_Port_Var = tk.IntVar();
     
                  #Event handlers for File menu items
                  def File_Menu_NEW_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From FILE menu clicked NEW");
                  def File_Menu_CLOSE_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From FILE menu clicked CLOSE"); 
     
                  #Event handlers for View menu items
                  def View_Menu_ZOOMIN_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From VIEW menu clicked ZOOM IN");
                  def View_Menu_ZOOMOUT_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From VIEW menu clicked ZOOM OUT"); 
     
                  #Event handlers for Help menu items
                  def Help_Menu_Get_Network_Data_Handler():  BTN_Get_Current_Network_Settings();
                  def Help_Menu_HELP_Handler(): 
                      MESSAGE = "Welcome to the Port Pinger. This project is";
                      MESSAGE += "\na simple network scanning tool for initiating ping sweeps";
                      MESSAGE += "\nand port scans.\n"
                      MESSAGE += "\nMulti-threading is necessary for this project because the ";
                      MESSAGE += "\ntkinter GUI will lock and not refresh or respond when";
                      MESSAGE += "\nexternal functions that initiate long, time-consuming loops";
                      MESSAGE += "\nare called - that is UNLESS you place each external function";
                      MESSAGE += "\ncall in its own separate thread outside the GUI's mainloop";
                      MESSAGE += "\nthread used to display widgets and listen for event triggers.\n";
                      MESSAGE += "\nTo initiate a ping sweep, enter the parameters and click the";
                      MESSAGE += "\n\"INITIATE\" button for the selected Ping Sweep label frame.";
                      MESSAGE += "\nTo initiate a port scan, enter the parameters and click the";
                      MESSAGE += "\n\"INITIATE\" button for the selected Port Scan label frame.";
                      MESSAGE += "\nTo get the network environment for the current host, click the";
                      MESSAGE += "\n\"Get Host Network Data\" button.";
                      MB.showinfo(title='Help Menu', message=MESSAGE); 
     
                  def Help_Menu_ABOUT_Handler(): 
                      MESSAGE = "Port Pinger 1.0";
                      MB.showinfo(title='About Menu', message=MESSAGE);   
     
                  #Event Handlers for Buttons
                  def RB_Ping_Selection_Handler():
                      self.BTN_Init_Port['state'] = tk.DISABLED;
                      self.BTN_Init_Ping['state'] = tk.NORMAL;
                      self.ENT_Host['state'] = tk.DISABLED;
                      self.ENT_Start_Port['state'] = tk.DISABLED;
                      self.ENT_End_Port['state'] = tk.DISABLED;              
                      self.ENT_Network['state'] = tk.NORMAL;
                      self.ENT_Start_Host['state'] = tk.NORMAL;
                      self.ENT_End_Host['state'] = tk.NORMAL;                                      
     
                  def RB_Port_Selection_Handler():   
                      self.BTN_Init_Ping['state'] = tk.DISABLED;
                      self.BTN_Init_Port['state'] = tk.NORMAL; 
                      self.ENT_Network['state'] = tk.DISABLED;
                      self.ENT_Start_Host['state'] = tk.DISABLED;
                      self.ENT_End_Host['state'] = tk.DISABLED;
                      self.ENT_Host['state'] = tk.NORMAL;
                      self.ENT_Start_Port['state'] = tk.NORMAL;
                      self.ENT_End_Port['state'] = tk.NORMAL;
     
                  def BTN_Init_Ping_Handler():
                      self.Threaded_Ping_Sweep_1(); 
     
                  def BTN_Init_Port_Handler():
                      self.Threaded_Port_Scan_1();   
     
                  def BTN_Get_Current_Network_Settings():
                      #Note: Code below works only for Windows. For Linux call "ifconfig" or "iwconfig" respectively.
                      IP_Settings = subprocess.run('ipconfig /all',stdout=subprocess.PIPE,text=True).stdout.lower();
                      self.TXT_Main_Output.delete("0.0", "end");
                      self.TXT_Main_Output.insert("0.0", "\n IP Settings for Current Host:\n\n" + IP_Settings);                 
     
        #---A. Frame: Main Window -------------------------------------------------------------
                  self.FRM_Main_Window = tk.Frame(master);
                  self.FRM_Main_Window.configure(height=520, width=1100, borderwidth=3, relief="flat", background="gray20");
                  self.FRM_Main_Window.place(anchor="nw", height=520, width=1100, x=0, y=0);
     
                  self.LAB_Title = tk.Label(self.FRM_Main_Window);
                  self.LAB_Title.configure(background="gray20",foreground="cyan", font="{Barlow Condensed} 13 {}", text="Port Pinger");
                  self.LAB_Title.place(anchor="nw", height=25, width=240, x=870, y=2);  
     
                  self.BTN_Get_Host_Net_Data = tk.Button(self.FRM_Main_Window, command=BTN_Get_Current_Network_Settings);
                  self.BTN_Get_Host_Net_Data.configure(background="gray40",font="{Lucida Console} 10 {}",foreground="cyan",text="Get Host Network Data");
                  self.BTN_Get_Host_Net_Data.place(anchor="nw", height=25, width=363, x=395, y=3);          
     
        #---B. Create main Menu Bar------------------------------------------------------------   
                  self.master = master;
                  self.Main_Menu_Bar = tk.Menu(self.master);
                  self.master.config(menu = self.Main_Menu_Bar);
     
                  #File Menu
                  self.File_Menu = tk.Menu(self.Main_Menu_Bar, tearoff=0);
                  self.File_Menu.add_command(label="New", command=File_Menu_NEW_Handler);
                  self.File_Menu.add_command(label="Close", command=File_Menu_CLOSE_Handler);      
                  self.File_Menu.add_separator(); # Add separator line to menu
                  self.File_Menu.add_command(label="Exit", command=window.quit); #built-in method closes window
                  self.Main_Menu_Bar.add_cascade(label="File", menu=self.File_Menu); #adds menu File_Menu to Main_Menu_Bar             
     
                  #View Menu
                  self.View_Menu = tk.Menu(self.Main_Menu_Bar, tearoff=0);
                  self.View_Menu.add_command(label="Zoom In +", command=View_Menu_ZOOMIN_Handler);
                  self.View_Menu.add_command(label="Zoom Out -", command=View_Menu_ZOOMOUT_Handler);
                  self.Main_Menu_Bar.add_cascade(label="View", menu=self.View_Menu); #adds menu File_Menu to Main_Menu_Bar    
     
                  #Help Menu
                  self.Help_Menu = tk.Menu(self.Main_Menu_Bar, tearoff=0);
                  self.Help_Menu.add_command(label="Get Network Data", command=Help_Menu_Get_Network_Data_Handler);
                  self.Help_Menu.add_command(label="Help", command=Help_Menu_HELP_Handler);
                  self.Help_Menu.add_command(label="About", command=Help_Menu_ABOUT_Handler);
                  self.Main_Menu_Bar.add_cascade(label="Help", menu=self.Help_Menu); #adds menu File_Menu to Main_Menu_Bar                   
     
        #---C. Frame: Ping Sweeper -------------------------------------------------------------          
                  self.LFRM_Ping_Sweeper = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Ping_Sweeper.configure(height=200, width=377, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Ping Sweeper");
                  self.LFRM_Ping_Sweeper.place(anchor="nw", height=200, width=377, x=5, y=3); 
     
                  self.RB_Activate_Ping_Sweeper = tk.Radiobutton(self.LFRM_Ping_Sweeper, variable=self.RB_Ping_Or_Port_Var, value=1, command=RB_Ping_Selection_Handler);
                  self.RB_Activate_Ping_Sweeper.configure(height=25, width=190, background="gray20", foreground="cyan", font="{Arial} 12 {}", text="Activate Ping Sweeper");
                  self.RB_Activate_Ping_Sweeper.place(anchor="nw", height=25, width=190, x=18, y=10);            
     
                  self.LAB_Network = tk.Label(self.LFRM_Ping_Sweeper);
                  self.LAB_Network.configure(background="gray20", foreground="cyan", borderwidth=0, relief="flat", font="{Arial} 12 {}", anchor="nw", text="Network:");
                  self.LAB_Network.place(anchor="w", x=22, y=57);
     
                  self.LAB_Start_Host = tk.Label(self.LFRM_Ping_Sweeper);
                  self.LAB_Start_Host.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="Start Host:");
                  self.LAB_Start_Host.place(anchor="w", x=22, y=92);
     
                  self.LAB_End_Host = tk.Label(self.LFRM_Ping_Sweeper);
                  self.LAB_End_Host.configure(background="gray20", borderwidth=0, foreground="cyan",  relief="flat", font="{Arial} 12 {}", anchor="nw", text="End Host:");
                  self.LAB_End_Host.place(anchor="w", x=22, y=127);
     
                  self.ENT_Network = tk.Entry(self.LFRM_Ping_Sweeper);
                  self.ENT_Network.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Network.insert("0", "192.168.0.0");
                  self.ENT_Network.place(anchor="nw", height=25, width=232, x=105, y=45);
     
                  self.ENT_Start_Host = tk.Entry(self.LFRM_Ping_Sweeper);
                  self.ENT_Start_Host.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Start_Host.insert("0", "1");
                  self.ENT_Start_Host.place(anchor="nw", height=25, width=232, x=105, y=80);
     
                  self.ENT_End_Host = tk.Entry(self.LFRM_Ping_Sweeper);
                  self.ENT_End_Host.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_End_Host.insert("0", "254");
                  self.ENT_End_Host.place(anchor="nw", height=25, width=232, x=105, y=115);
     
                  self.BTN_Init_Ping = tk.Button(self.LFRM_Ping_Sweeper, command=BTN_Init_Ping_Handler);
                  self.BTN_Init_Ping.configure(background="gray40",font="{Lucida Console} 12 {}",foreground="cyan",text="INITIATE");
                  self.BTN_Init_Ping.place(anchor="nw", height=30, width=320, x=22, y=147);
     
     
        #---D. Frame: Port Scanner -------------------------------------------------------------            
                  self.LFRM_Port_Scanner = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Port_Scanner.configure(height=200, width=377, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Port Scanner");
                  self.LFRM_Port_Scanner.place(anchor="nw", height=200, width=377, x=5, y=310);       
     
                  self.RB_Activate_Port_Scanner = tk.Radiobutton(self.LFRM_Port_Scanner, variable=self.RB_Ping_Or_Port_Var, value=2, command=RB_Port_Selection_Handler);
                  self.RB_Activate_Port_Scanner.configure(height=25, width=190, background="gray20", foreground="cyan", font="{Arial} 12 {}", text="Activate Port Scanner");
                  self.RB_Activate_Port_Scanner.place(anchor="nw", height=25, width=190, x=18, y=10);
     
                  self.LAB_Host = tk.Label(self.LFRM_Port_Scanner);
                  self.LAB_Host.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="Host:");
                  self.LAB_Host.place(anchor="nw", x=20, y=45);
     
                  self.LAB_Start_Port = tk.Label(self.LFRM_Port_Scanner);
                  self.LAB_Start_Port.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="Start Port:");
                  self.LAB_Start_Port.place(anchor="nw", x=20, y=80);
     
                  self.LAB_End_Port = tk.Label(self.LFRM_Port_Scanner);
                  self.LAB_End_Port.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="End Port:" );
                  self.LAB_End_Port.place(anchor="nw", x=20, y=115);
     
                  self.ENT_Host = tk.Entry(self.LFRM_Port_Scanner);
                  self.ENT_Host.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Host.insert("0", "192.168.0.0");
                  self.ENT_Host.place(anchor="nw", height=25, width=232, x=105, y=45);
     
                  self.ENT_Start_Port = tk.Entry(self.LFRM_Port_Scanner);
                  self.ENT_Start_Port.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Start_Port.insert("0", "1");
                  self.ENT_Start_Port.place(anchor="nw", height=25, width=232, x=105, y=80)
     
                  self.ENT_End_Port = tk.Entry(self.LFRM_Port_Scanner);
                  self.ENT_End_Port.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_End_Port.insert("0", "65534");
                  self.ENT_End_Port.place(anchor="nw", height=25, width=232, x=105, y=115)
     
                  self.BTN_Init_Port = tk.Button(self.LFRM_Port_Scanner, command=BTN_Init_Port_Handler);
                  self.BTN_Init_Port.configure(background="gray40",font="{Lucida Console} 12 {}",foreground="cyan",text="INITIATE");
                  self.BTN_Init_Port.place(anchor="nw", height=30, width=320, x=22, y=147);
     
     
        #---E. Frame: Main Output -------------------------------------------------------------
                  self.LFRM_Main_Output = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Main_Output.configure(height=480, width=700, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Main Output");
                  self.LFRM_Main_Output.place(anchor="nw", height=480, width=700, x=390, y=30);
     
                  self.SB_Vert_TXT_Main_Output = tk.Scrollbar(self.LFRM_Main_Output, orient = tk.VERTICAL);
                  self.SB_Vert_TXT_Main_Output.pack(side=tk.RIGHT, fill=tk.Y);
     
                  self.TXT_Main_Output = tk.Text(self.LFRM_Main_Output, yscrollcommand=self.SB_Vert_TXT_Main_Output.set);
                  self.TXT_Main_Output.configure(height=457, width=678, background="#000000", foreground="lime green", borderwidth=3, relief="sunken", font="{Courier} 10 {}");
                  self.TXT_Main_Output.insert("0.0", "\n This is the MAIN OUTPUT panel.\n Ping sweep and port scan results will display here.");
                  self.TXT_Main_Output.place(anchor="nw", height=457, width=678, x=1, y=1);
     
                  self.SB_Vert_TXT_Main_Output.config(command=self.TXT_Main_Output.yview); #set scrollbar behavior
     
                  #Populate text object on starup with example text
                  self.TXT_Main_Output.insert(tk.END,"\n\n");
                  for Entry_Line_Item in range(255):
                      self.TXT_Main_Output.insert(tk.END, "Ping " + str(Entry_Line_Item) + "\n");   
     
        #---F. Frame: Current Network  -------------------------------------------------------------
                  self.LFRM_Current_Network = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Current_Network.configure(height=95, width=377, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Current Network");
                  self.LFRM_Current_Network.place(anchor="nw", height=95, width=377, x=5, y=210);  
     
                  self.TXT_Current_Network = tk.Text(self.LFRM_Current_Network);
                  self.TXT_Current_Network.configure(height=76, width=370, background="#000000", foreground="lime green", borderwidth=3, relief="sunken", font="{Courier} 9 {}");
                  self.TXT_Current_Network.place(anchor="nw", height=76, width=370, x=1, y=1);                                       
     
        #---G. Default Load Settings -------------------------------------------------------------
                  self.RB_Ping_Or_Port_Var.set(1); #set default radio button selection
                  RB_Ping_Selection_Handler();
                  self.Get_Current_Network();
     
        #---End Class----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     
        #-----Invocations-----
        GUI = PPPPP_GUI(window); #instantiate GUI class
     
        #---Launch Main Window---
        window.mainloop();
     
    button_ping = tk.Button(main_frame, text="Ping Tool", command=PingTool, bg="gray40", fg="white", bd=1) #black
    button_ping.pack(padx=10, pady=5)
     
    def Comparator():
        class DiffCode:
            SIMILAR = 0         # starts with '  '
            RIGHTONLY = 1       # starts with '+ '
            LEFTONLY = 2        # starts with '- '
            CHANGED = 3         # either three or four lines with the prefixes ('-', '+', '?'), ('-', '?', '+') or ('-', '?', '+', '?') respectively
     
        class DifflibParser:
            def __init__(self, text1, text2):
                self.__text1 = text1
                self.__text2 = text2
                self.__diff = list(difflib.ndiff(text1, text2))
                self.__currentLineno = 0
     
            def __iter__(self):
                return self
     
            def __next__(self):  # python3
                result = {}
                if self.__currentLineno >= len(self.__diff):
                    raise StopIteration
                currentLine = self.__diff[self.__currentLineno]
                code = currentLine[:2]
                line = currentLine[2:]
                result['line'] = line
                if code == '  ':
                    result['code'] = DiffCode.SIMILAR
                elif code == '- ':
                    incrementalChange = self.__tryGetIncrementalChange(self.__currentLineno)
                    if not incrementalChange:
                        result['code'] = DiffCode.LEFTONLY
                    else:
                        result['code'] = DiffCode.CHANGED
                        result['leftchanges'] = incrementalChange['left'] if 'left' in incrementalChange else None
                        result['rightchanges'] = incrementalChange['right'] if 'right' in incrementalChange else None
                        result['newline'] = incrementalChange['newline']
                        self.__currentLineno += incrementalChange['skiplines']
                elif code == '+ ':
                    result['code'] = DiffCode.RIGHTONLY
                self.__currentLineno += 1
                return result
     
            next = __next__  # for Python 2
     
            def __tryGetIncrementalChange(self, lineno):
                lineOne = self.__diff[lineno] if lineno < len(self.__diff) else None
                lineTwo = self.__diff[lineno + 1] if lineno + 1 < len(self.__diff) else None
                lineThree = self.__diff[lineno + 2] if lineno + 2 < len(self.__diff) else None
                lineFour = self.__diff[lineno + 3] if lineno + 3 < len(self.__diff) else None
     
                changes = {}
                # ('-', '?', '+', '?') case
                if lineOne and lineOne[:2] == '- ' and \
                   lineTwo and lineTwo[:2] == '? ' and \
                   lineThree and lineThree[:2] == '+ ' and \
                   lineFour and lineFour[:2] == '? ':
                    changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                    changes['right'] = [i for (i,c) in enumerate(lineFour[2:]) if c in ['+', '^']]
                    changes['newline'] = lineThree[2:]
                    changes['skiplines'] = 3
                    return changes
                # ('-', '+', '?')
                elif lineOne and lineOne[:2] == '- ' and \
                   lineTwo and lineTwo[:2] == '+ ' and \
                   lineThree and lineThree[:2] == '? ':
                    changes['right'] = [i for (i,c) in enumerate(lineThree[2:]) if c in ['+', '^']]
                    changes['left'] = []
                    changes['newline'] = lineTwo[2:]
                    changes['skiplines'] = 2
                    return changes
                # ('-', '?', '+')
                elif lineOne and lineOne[:2] == '- ' and \
                   lineTwo and lineTwo[:2] == '? ' and \
                   lineThree and lineThree[:2] == '+ ':
                    changes['right'] = []
                    changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                    changes['newline'] = lineThree[2:]
                    changes['skiplines'] = 2
                    return changes
                # no incremental change
                else:
                    return None
     
        class SearchTextDialog(Frame):
     
            def __init__(self, parent, textwidgets, searchButtonCallback):
                Frame.__init__(self, parent)
     
                self.parent = parent
                self.__searchCallback = searchButtonCallback
                self.__textwidgets = textwidgets
                self.__searchStr = None
                self.initUI()
     
            def initUI(self):
                self.searchTextFrame = Frame(self.parent)
     
                self.searchTextEntry = Entry(self)
                self.searchTextEntry.pack(fill=BOTH, expand=True, side=LEFT)
     
                self.__matchCaseVar = IntVar()
                self.__matchCaseVar.set(0)
                self.searchTextCheckbutton = Checkbutton(self, text='Match case', variable=self.__matchCaseVar, command=lambda *x: self.clearSearch())
                self.searchTextCheckbutton.pack(side=LEFT, padx=10)
     
                self.searchTextButton = Button(self, text='Find', command=self.nextResult)
                self.searchTextButton.pack(side=LEFT)
     
                self.searchTextEntry.bind('<Return>', self.nextResult)
                self.searchTextButton.bind('<Return>', self.nextResult)
                self.__curSearchResult = {'term': None, 'indices': ['0.0'] * len(self.__textwidgets)}
                self.__insession = False
     
            def getSearchTerm(self):
                return self.searchTextEntry.get()
     
            def focus(self):
                self.searchTextEntry.focus_set()
                self.searchTextEntry.select_range(0, END)
                self.__insession = True
     
            def nextResult(self, *args):
                if not self.__insession: return
     
                searchStr = self.searchTextEntry.get()
     
                if not self.__searchStr or self.__searchStr != searchStr:
                    self.__searchStr = searchStr
                    self.__curSearchResult = {'term': searchStr, 'indices': ['0.0'] * len(self.__textwidgets)}
     
                if searchStr in ['', None]: return
     
                countVar = StringVar()
                for i,t in enumerate(self.__textwidgets):
                    if self.__curSearchResult['indices'][i] == -1: continue
                    nextIdx = float(self.__curSearchResult['indices'][i]) + 1
                    pos = t.search(self.__searchStr, nextIdx, END, nocase=self.__matchCaseVar.get() == 0)
                    self.__curSearchResult['indices'][i] = pos if pos else -1
     
                self.__searchCallback(self.__curSearchResult)
     
            def clearSearch(self):
                self.__curSearchResult['indices'] = ['0.0'] * len(self.__textwidgets)
     
            def unfocus(self):
                self.clearSearch()
                self.__insession = False
     
        class MainWindowUI:
     
        # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |
        # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |                                     menu bar                                                  |
        # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |               |                                     search bar                                |
        # |               |          search entry                                                 | button|
        # |               +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |   treeview    |                                       |                                       |
        # |               |              text area 1              |               text area 2             |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |
     
            # Rows
            fileTreeRow = filePathLabelsRow = 0
            searchTextRow = 1
            uniScrollbarRow = lineNumbersRow = textAreasRow = 2
            horizontalScrollbarRow = 3
     
            # Columns
            fileTreeCol = 0
            fileTreeScrollbarCol = 1
            leftLineNumbersCol = leftFilePathLabelsCol = 2    # should span at least two columns
            leftTextAreaCol = leftHorizontalScrollbarCol = 3
            uniScrollbarCol = 4
            rightLineNumbersCol = rightFilePathLabelsCol = 5  # should span at least two columns
            rightTextAreaCol = rightHorizontalScrollbarCol = 6
     
            # Colors
            whiteColor = '#ffffff'
            redColor = '#ffc4c4'
            darkredColor = '#ff8282'
            grayColor = '#dddddd'
            lightGrayColor = '#eeeeee'
            greenColor = '#c9fcd6'
            darkgreenColor = '#50c96e'
            yellowColor = '#f0f58c'
            darkYellowColor = '#ffff00'
            purpleLight = '#F5EBFC'
     
            def __init__(self, window):
                self.main_window = window
                self.main_window.grid_rowconfigure(self.filePathLabelsRow, weight=0)
                self.main_window.grid_rowconfigure(self.searchTextRow, weight=0)
                self.main_window.grid_rowconfigure(self.textAreasRow, weight=1)
     
                self.main_window.grid_columnconfigure(self.fileTreeCol, weight=0)
                self.main_window.grid_columnconfigure(self.fileTreeScrollbarCol, weight=0)
                self.main_window.grid_columnconfigure(self.leftLineNumbersCol, weight=0)
                self.main_window.grid_columnconfigure(self.leftTextAreaCol, weight=1)
                self.main_window.grid_columnconfigure(self.uniScrollbarCol, weight=0)
                self.main_window.grid_columnconfigure(self.rightLineNumbersCol, weight=0)
                self.main_window.grid_columnconfigure(self.rightTextAreaCol, weight=1)
                self.menubar = Menu(self.main_window)
                self.menus = {}
                self.text_area_font = 'TkFixedFont'
     
            # Center window and set its size
            def center_window(self):
                sw = self.main_window.winfo_screenwidth()
                sh = self.main_window.winfo_screenheight()
     
                w = 0.7 * sw
                h = 0.7 * sh
     
                x = (sw - w)/2
                y = (sh - h)/2
                self.main_window.geometry('%dx%d+%d+%d' % (w, h, x, y))
                self.main_window.minsize(int(0.3 * sw), int(0.3 * sh))
     
            # Menu bar
            def add_menu(self, menuName, commandList):
                self.menus[menuName] = Menu(self.menubar,tearoff=0)
                for c in commandList:
                    if 'separator' in c: self.menus[menuName].add_separator()
                    else: self.menus[menuName].add_command(label=c['name'], command=c['command'], accelerator=c['accelerator'] if 'accelerator' in c else '')
                self.menubar.add_cascade(label=menuName, menu=self.menus[menuName])
                self.main_window.config(menu=self.menubar)
     
            # Labels
            def create_file_path_labels(self):
                self.leftFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
                self.leftFileLabel.grid(row=self.filePathLabelsRow, column=self.leftFilePathLabelsCol, columnspan=2)
                self.rightFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
                self.rightFileLabel.grid(row=self.filePathLabelsRow, column=self.rightFilePathLabelsCol, columnspan=2)
     
            # Search text entry
            def create_search_text_entry(self, searchButtonCallback):
                self.searchTextDialog = SearchTextDialog(self.main_window, [self.leftFileTextArea, self.rightFileTextArea], searchButtonCallback)
                self.searchTextDialog.grid(row=self.searchTextRow, column=self.leftFilePathLabelsCol, columnspan=5, sticky=EW)
     
                self.searchTextDialog.grid_remove()
     
            # File treeview
            def create_file_treeview(self):
                self.fileTreeView = Treeview(self.main_window)
                self.fileTreeYScrollbar = Scrollbar(self.main_window, orient='vertical', command=self.fileTreeView.yview)
                self.fileTreeXScrollbar = Scrollbar(self.main_window, orient='horizontal', command=self.fileTreeView.xview)
                self.fileTreeView.configure(yscroll=self.fileTreeYScrollbar.set, xscroll=self.fileTreeXScrollbar.set)
     
                self.fileTreeView.grid(row=self.fileTreeRow, column=self.fileTreeCol, sticky=NS, rowspan=3)
                self.fileTreeYScrollbar.grid(row=self.fileTreeRow, column=self.fileTreeScrollbarCol, sticky=NS, rowspan=3)
                self.fileTreeXScrollbar.grid(row=self.horizontalScrollbarRow, column=self.fileTreeCol, sticky=EW)
     
                self.fileTreeView.tag_configure('red', background=self.redColor)
                self.fileTreeView.tag_configure('green', background=self.greenColor)
                self.fileTreeView.tag_configure('yellow', background=self.yellowColor)
                self.fileTreeView.tag_configure('purpleLight', background=self.purpleLight)
     
                # hide it until needed
                self.fileTreeView.grid_remove()
                self.fileTreeYScrollbar.grid_remove()
                self.fileTreeXScrollbar.grid_remove()
     
            # Text areas
            def create_text_areas(self):
                self.leftFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
                self.leftFileTextArea.grid(row=self.textAreasRow, column=self.leftTextAreaCol, sticky=NSEW)
                self.leftFileTextArea.config(font=self.text_area_font)
                self.leftFileTextArea.config(wrap='none')
     
                self.rightFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
                self.rightFileTextArea.grid(row=self.textAreasRow, column=self.rightTextAreaCol, sticky=NSEW)
                self.rightFileTextArea.config(font=self.text_area_font)
                self.rightFileTextArea.config(wrap='none')
     
                # configuring highlight tags
                self.leftFileTextArea.tag_configure('red', background=self.redColor)
                self.leftFileTextArea.tag_configure('darkred', background=self.darkredColor)
                self.leftFileTextArea.tag_configure('gray', background=self.grayColor)
                self.leftFileTextArea.tag_configure('search', background=self.darkYellowColor)
                self.rightFileTextArea.tag_configure('green', background=self.greenColor)
                self.rightFileTextArea.tag_configure('darkgreen', background=self.darkgreenColor)
                self.rightFileTextArea.tag_configure('gray', background=self.grayColor)
                self.rightFileTextArea.tag_configure('search', background=self.darkYellowColor)
                self.rightFileTextArea.tag_configure('purpleLight', background=self.purpleLight)
     
                # disable the text areas
                self.leftFileTextArea.config(state=DISABLED)
                self.rightFileTextArea.config(state=DISABLED)
     
            # Line numbers
            def create_line_numbers(self):
                self.leftLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
                self.leftLinenumbers.grid(row=self.lineNumbersRow, column=self.leftLineNumbersCol, sticky=NS)
                self.leftLinenumbers.config(font=self.text_area_font)
                self.leftLinenumbers.tag_configure('line', justify='right')
     
                self.rightLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
                self.rightLinenumbers.grid(row=self.lineNumbersRow, column=self.rightLineNumbersCol, sticky=NS)
                self.rightLinenumbers.config(font=self.text_area_font)
                self.rightLinenumbers.tag_configure('line', justify='right')
     
                # disable the line numbers
                self.leftLinenumbers.config(state=DISABLED)
                self.rightLinenumbers.config(state=DISABLED)
     
            # Scroll bars
            def scrollBothY(self, action, position, type=None):
                self.leftFileTextArea.yview_moveto(position)
                self.rightFileTextArea.yview_moveto(position)
                self.leftLinenumbers.yview_moveto(position)
                self.rightLinenumbers.yview_moveto(position)
     
            def updateScrollY(self, first, last, type=None):
                self.leftFileTextArea.yview_moveto(first)
                self.rightFileTextArea.yview_moveto(first)
                self.leftLinenumbers.yview_moveto(first)
                self.rightLinenumbers.yview_moveto(first)
                self.uniScrollbar.set(first, last)
     
            def scrollBothX(self, action, position, type=None):
                self.leftFileTextArea.xview_moveto(position)
                self.rightFileTextArea.xview_moveto(position)
     
            def updateScrollX(self, first, last, type=None):
                self.leftFileTextArea.xview_moveto(first)
                self.rightFileTextArea.xview_moveto(first)
                self.leftHorizontalScrollbar.set(first, last)
                self.rightHorizontalScrollbar.set(first, last)
     
            def create_scroll_bars(self):
                self.uniScrollbar = Scrollbar(self.main_window)
                self.uniScrollbar.grid(row=self.uniScrollbarRow, column=self.uniScrollbarCol, sticky=NS)
                self.uniScrollbar.config(command=self.scrollBothY)
                self.leftFileTextArea.config(yscrollcommand=self.updateScrollY)
                self.rightFileTextArea.config(yscrollcommand=self.updateScrollY)
                self.leftLinenumbers.config(yscrollcommand=self.updateScrollY)
                self.rightLinenumbers.config(yscrollcommand=self.updateScrollY)
     
                self.leftHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
                self.leftHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.leftHorizontalScrollbarCol, sticky=EW)
                self.leftHorizontalScrollbar.config(command=self.scrollBothX)
                self.leftFileTextArea.config(xscrollcommand=self.updateScrollX)
     
                self.rightHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
                self.rightHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.rightHorizontalScrollbarCol, sticky=EW)
                self.rightHorizontalScrollbar.config(command=self.scrollBothX)
                self.rightFileTextArea.config(xscrollcommand=self.updateScrollX)
     
        class MainWindow:
            def start(self, leftpath = None, rightpath = None):
                self.main_window = Tk()
                self.main_window.title('Comparator')
                self.__main_window_ui = MainWindowUI(self.main_window)
                #self.image_icon10 = PhotoImage(file = "img/complogo.png")
                #self.main_window.iconphoto(False, self.image_icon10)
     
                self.leftFile = ''
                self.rightFile = ''
     
                self.__main_window_ui.center_window()
                self.__main_window_ui.create_file_path_labels()
                self.__main_window_ui.create_text_areas()
                self.__main_window_ui.create_search_text_entry(self.__findNext)
                self.__main_window_ui.create_line_numbers()
                self.__main_window_ui.create_scroll_bars()
                self.__main_window_ui.create_file_treeview()
                path_to_my_project = os.getcwd()
                self.__main_window_ui.add_menu('File', [
                    {'name': 'Compare Files', 'command': self.__browse_files},
                    {'name': 'Compare Directories', 'command': self.__browse_directories},
                    {'separator'},
                    {'name': 'Exit', 'command': self.__exit, 'accelerator': 'Alt+F4'}
                    ])
                self.__main_window_ui.add_menu('Edit', [
                    {'name': 'Find', 'command': self.__startFindText, 'accelerator': 'Ctrl+F'},
                    {'separator'},
                    {'name': 'Cut', 'command': self.__cut, 'accelerator': 'Ctrl+X'},
                    {'name': 'Copy', 'command': self.__copy, 'accelerator': 'Ctrl+C'},
                    {'name': 'Paste', 'command': self.__paste, 'accelerator': 'Ctrl+P'},
                    {'separator'},
                    {'name': 'Go To Line', 'command': self.__goToLine, 'accelerator': 'Ctrl+G'}
                    ])
                self.__main_window_ui.fileTreeView.bind('<<TreeviewSelect>>', lambda *x:self.treeViewItemSelected())
     
                if (leftpath and os.path.isdir(leftpath)) or (rightpath and os.path.isdir(rightpath)):
                    self.__load_directories(leftpath, rightpath)
                else:
                    self.leftFile = leftpath if leftpath else ''
                    self.rightFile = rightpath if rightpath else ''
                    self.filesChanged()
     
                self.__bind_key_shortcuts()
     
                self.main_window.mainloop()
     
            def __bind_key_shortcuts(self):
                self.main_window.bind('<Control-f>', lambda *x: self.__startFindText())
                self.main_window.bind('<Control-g>', lambda *x: self.__goToLine())
                self.main_window.bind('<Escape>', lambda *x: self.__endFindText())
                self.main_window.bind('<F3>', self.__main_window_ui.searchTextDialog.nextResult)
     
            def __browse_files(self):
                self.__load_file('left')
                self.__load_file('right')
                self.filesChanged()
                self.__main_window_ui.fileTreeView.grid_remove()
                self.__main_window_ui.fileTreeYScrollbar.grid_remove()
                self.__main_window_ui.fileTreeXScrollbar.grid_remove()
     
            # Load directories into the treeview
            def __browse_directories(self):
                leftDir = self.__load_directory('left')
                rightDir = self.__load_directory('right')
                self.__load_directories(leftDir, rightDir)
     
            def __load_directories(self, leftDir, rightDir):
                if leftDir and rightDir:
                    self.__main_window_ui.fileTreeView.grid()
                    self.__main_window_ui.fileTreeYScrollbar.grid()
                    self.__main_window_ui.fileTreeXScrollbar.grid()
                    self.__main_window_ui.fileTreeView.delete(*self.__main_window_ui.fileTreeView.get_children())
                    self.__browse_process_directory('', leftDir, rightDir)
     
            # Recursive method to fill the treevie with given directory hierarchy
            def __browse_process_directory(self, parent, leftPath, rightPath):
                if parent == '':
                    leftPath = leftPath.rstrip('/')
                    rightPath = rightPath.rstrip('/')
                    leftDirName = os.path.basename(leftPath)
                    rightDirName = os.path.basename(rightPath)
                    self.__main_window_ui.fileTreeView.heading('#0', text=leftDirName + ' / ' + rightDirName, anchor=W)
                leftListing = os.listdir(leftPath)
                rightListing = os.listdir(rightPath)
                mergedListing = list(set(leftListing) | set(rightListing))
                painted = FALSE
                for l in mergedListing:
                    newLeftPath = leftPath + '/' + l
                    newRightPath = rightPath + '/' + l
                    bindValue = (newLeftPath, newRightPath)
                    # Item in left dir only
                    if l in leftListing and l not in rightListing:
                        self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('red','simple'))
                        painted = TRUE
                    # Item in right dir only
                    elif l in rightListing and l not in leftListing:
                        self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('green','simple'))
                        painted = TRUE
                    # Item in both dirs
                    else:
                        # If one of the diffed items is a file and the other is a directory, show in yellow indicating a difference
                        if (not os.path.isdir(newLeftPath) and os.path.isdir(newRightPath)) or (os.path.isdir(newLeftPath) and not os.path.isdir(newRightPath)):
                            self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                            painted = TRUE
                        else:
                            # If both are directories, show in white and recurse on contents
                            if os.path.isdir(newLeftPath) and os.path.isdir(newRightPath):
                                oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, open=False)
                                painted = self.__browse_process_directory(oid, newLeftPath, newRightPath)
                                if painted:
                                    self.__main_window_ui.fileTreeView.item(oid, tags=('purpleLight', 'simple'))
                            else:
                                # Both are files. diff the two files to either show them in white or yellow
                                if (filecmp.cmp(newLeftPath, newRightPath)):
                                    oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('simple'))
                                else:
                                    oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                                    painted = TRUE
                return painted
     
            def __load_file(self, pos):
                fname = askopenfilename()
                if fname:
                    if pos == 'left':
                        self.leftFile = fname
                    else:
                        self.rightFile = fname
                    return fname
                else:
                    return None
     
            def __load_directory(self, pos):
                dirName = askdirectory()
                if dirName:
                    if pos == 'left':
                        self.__main_window_ui.leftFileLabel.config(text=dirName)
                    else:
                        self.__main_window_ui.rightFileLabel.config(text=dirName)
                    return dirName
                else:
                    return None
     
            # Callback for changing a file path
            def filesChanged(self):
                self.__main_window_ui.leftLinenumbers.grid_remove()
                self.__main_window_ui.rightLinenumbers.grid_remove()
     
                if not self.leftFile or not self.rightFile:
                    self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.grayColor)
                    self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.grayColor)
                    return
     
                if os.path.exists(self.leftFile):
                    self.__main_window_ui.leftFileLabel.config(text=self.leftFile)
                    self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.whiteColor)
                    self.__main_window_ui.leftLinenumbers.grid()
                else:
                    self.__main_window_ui.leftFileLabel.config(text='')
     
                if os.path.exists(self.rightFile):
                    self.__main_window_ui.rightFileLabel.config(text=self.rightFile)
                    self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.whiteColor)
                    self.__main_window_ui.rightLinenumbers.grid()
                else:
                    self.__main_window_ui.rightFileLabel.config(text='')
     
                self.diff_files_into_text_areas()
     
            def treeViewItemSelected(self):
                item_id = self.__main_window_ui.fileTreeView.focus()
                paths = self.__main_window_ui.fileTreeView.item(item_id)['values']
                if paths == None or len(paths) == 0:
                    return
                self.leftFile = paths[0]
                self.rightFile = paths[1]
                self.filesChanged()
     
            # Insert file contents into text areas and highlight differences
            def diff_files_into_text_areas(self):
                try:
                    leftFileContents = open(self.leftFile).read()
                except:
                    leftFileContents = ''
                try:
                    rightFileContents = open(self.rightFile).read()
                except:
                    rightFileContents = ''
     
                diff = DifflibParser(leftFileContents.splitlines(), rightFileContents.splitlines())
     
                # enable text area edits so we can clear and insert into them
                self.__main_window_ui.leftFileTextArea.config(state=NORMAL)
                self.__main_window_ui.rightFileTextArea.config(state=NORMAL)
                self.__main_window_ui.leftLinenumbers.config(state=NORMAL)
                self.__main_window_ui.rightLinenumbers.config(state=NORMAL)
     
                # clear all text areas
                self.__main_window_ui.leftFileTextArea.delete(1.0, END)
                self.__main_window_ui.rightFileTextArea.delete(1.0, END)
                self.__main_window_ui.leftLinenumbers.delete(1.0, END)
                self.__main_window_ui.rightLinenumbers.delete(1.0, END)
     
                leftlineno = rightlineno = 1
                for line in diff:
                    if line['code'] == DiffCode.SIMILAR:
                        self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n')
                        self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n')
                    elif line['code'] == DiffCode.RIGHTONLY:
                        self.__main_window_ui.leftFileTextArea.insert('end', '\n', 'gray')
                        self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n', 'green')
                    elif line['code'] == DiffCode.LEFTONLY:
                        self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n', 'red')
                        self.__main_window_ui.rightFileTextArea.insert('end', '\n', 'gray')
                    elif line['code'] == DiffCode.CHANGED:
                        for (i,c) in enumerate(line['line']):
                            self.__main_window_ui.leftFileTextArea.insert('end', c, 'darkred' if i in line['leftchanges'] else 'red')
                        for (i,c) in enumerate(line['newline']):
                            self.__main_window_ui.rightFileTextArea.insert('end', c, 'darkgreen' if i in line['rightchanges'] else 'green')
                        self.__main_window_ui.leftFileTextArea.insert('end', '\n')
                        self.__main_window_ui.rightFileTextArea.insert('end', '\n')
     
                    if line['code'] == DiffCode.LEFTONLY:
                        self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                        self.__main_window_ui.rightLinenumbers.insert('end', '\n', 'line')
                        leftlineno += 1
                    elif line['code'] == DiffCode.RIGHTONLY:
                        self.__main_window_ui.leftLinenumbers.insert('end', '\n', 'line')
                        self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                        rightlineno += 1
                    else:
                        self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                        self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                        leftlineno += 1
                        rightlineno += 1
     
                # calc width of line numbers texts and set it
                self.__main_window_ui.leftLinenumbers.config(width=len(str(leftlineno)))
                self.__main_window_ui.rightLinenumbers.config(width=len(str(rightlineno)))
     
                # disable text areas to prevent further editing
                self.__main_window_ui.leftFileTextArea.config(state=DISABLED)
                self.__main_window_ui.rightFileTextArea.config(state=DISABLED)
                self.__main_window_ui.leftLinenumbers.config(state=DISABLED)
                self.__main_window_ui.rightLinenumbers.config(state=DISABLED)
     
            def __cut(self):
                area = self.__getActiveTextArea()
                if area:
                    area.event_generate("<<Cut>>")
     
            def __copy(self):
                area = self.__getActiveTextArea()
                if area:
                    area.event_generate("<<Copy>>")
     
            def __paste(self):
                area = self.__getActiveTextArea()
                if area:
                    area.event_generate("<<Paste>>")
     
            def __getActiveTextArea(self):
                if self.main_window.focus_get() == self.__main_window_ui.leftFileTextArea:
                    return self.__main_window_ui.leftFileTextArea
                elif self.main_window.focus_get() == self.__main_window_ui.rightFileTextArea:
                    return self.__main_window_ui.rightFileTextArea
                else:
                    return None
     
            def __goToLine(self):
                line = askstring('Go to line', 'Enter line number:')
                if line:
                    try:
                        linenumber = int(line)
                        self.__main_window_ui.leftFileTextArea.see(float(linenumber) + 5)
                    except:
                        pass
     
            def __startFindText(self):
                self.__main_window_ui.searchTextDialog.grid()
                self.__main_window_ui.searchTextDialog.focus()
     
            def __endFindText(self):
                self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.searchTextDialog.unfocus()
                self.__main_window_ui.searchTextDialog.grid_remove()
     
            def __findNext(self, searchresult):
                term,leftpos,rightpos = searchresult['term'], searchresult['indices'][0], searchresult['indices'][1]
                if leftpos != -1:
                    self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
                    self.__main_window_ui.leftFileTextArea.tag_add('search', leftpos, '%s + %sc' % (leftpos, len(term)))
                    # scroll to position plus five lines for visibility
                    self.__main_window_ui.leftFileTextArea.see(float(leftpos) + 5)
                if rightpos != -1:
                    self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
                    self.__main_window_ui.rightFileTextArea.tag_add('search', rightpos, '%s + %sc' % (rightpos, len(term)))
                    # scroll to position plus five lines for visibility
                    self.__main_window_ui.rightFileTextArea.see(float(rightpos) + 5)
     
            def __exit(self):
                self.main_window.destroy()
     
        class FileIO:
            def load_file_to_text_area(self, fname, textArea):
                textArea.config(state=NORMAL)
                try:
                    text = open(fname).read()
                    textArea.delete(1.0, END) 
                    textArea.insert(1.0, text)
                except Exception as e:
                    showerror('Open Source File', 'Failed to read file\n"%s". Error: %s' % (fname, e))
                finally:
                    textArea.config(state=DISABLED)
     
        parser = argparse.ArgumentParser(description="pydiff - Tkinter GUI tool based on Python's difflib")
        parser.add_argument('-p', '--paths', metavar=('path1', 'path2'), nargs=2, help='Two paths to compare', required=False)
     
        args = parser.parse_args()
     
        leftpath = args.paths[0] if args.paths else None
        rightpath = args.paths[1] if args.paths else None
     
        main_window = MainWindow()
        main_window.start(leftpath, rightpath)
     
    button_pydiff = tk.Button(main_frame, text="Comparator", command=Comparator, bg="gray40", fg="white", bd=1) #black
    button_pydiff.pack(padx=10, pady=5)
     
     

    def ReplAndFind():
        # to create a window
        repl = Tk()
        repl.resizable(False, False)
        repl.title("Find & Replace")
        repl.config(bg="gray20")
        #image_icon11 = PhotoImage(file = "img/complogo.png")
        #repl.iconphoto(False, image_icon11)
        # root window is the parent window
        framrepl = Frame(repl, bg="gray20")

        # Creating Label, Entry Box, Button
        # and packing them adding label to
        # search box
        Label(framrepl, text='Find', bg="gray20", fg="lime green").pack(side=LEFT)

        # adding of single line text box
        edit = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        # positioning of text box
        edit.pack(side=LEFT, fill=BOTH, expand=1)
        # setting focus
        edit.focus_set()

        # adding of search button
        Find = Button(framrepl, text='Find', bg="gray40", fg="cyan", bd=5)
        Find.pack(side=LEFT)

        Label(framrepl, text="Replace With ", bg="gray20", fg="lime green", bd=1).pack(side=LEFT)

        edit2 = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        edit2.pack(side=LEFT, fill=BOTH, expand=1)
        edit2.focus_set()

        replace = Button(framrepl, text='FindNReplace', bg="gray40", fg="cyan", bd=5)
        replace.pack(side=LEFT)

        refresh = Button(framrepl, text='Refresh', bg="gray40", fg="cyan", bd=5)
        refresh.pack(side=LEFT)

        framrepl.pack(side=TOP)

        # text box in root window
        textrepl = Text(repl, width=120, height=40, bg="#999999")

        # text input area at index 1 in text window
        textrepl.insert('1.0', '''Type your text here''')
        textrepl.pack(side=BOTTOM)


        # function to search string in text
        def find(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()

            if (s):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)

                    if not idx: break
                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))
                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()


        def findNreplace(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()
            r = edit2.get()

            if (s and r):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)
                    print(idx)
                    if not idx: break

                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))

                    textrepl.delete(idx, lastidx)
                    textrepl.insert(idx, r)

                    lastidx = '% s+% dc' % (idx, len(r))

                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()

        def refresh_func():
            textrepl.tag_delete('found')

        # add commands to button
        Find.config(command=find)
        replace.config(command=findNreplace)
        refresh.config(command=refresh_func)
        # binding entry boxes ...
        edit.bind('<Return>',find)
        edit2.bind('<Return>',findNreplace)

        # mainloop function calls the endless
        # loop of the window, so the window will
        # wait for any user interaction till we
        # close it
        repl.mainloop()

    button_findrepl = tk.Button(main_frame, text="Find & Replace text", command=ReplAndFind, bg="gray40", fg="white", bd=1) #black
    button_findrepl.pack(padx=10, pady=5)

    def ScreenRec():
        from datetime import datetime
        class ScreenRecorderApp:
            def __init__(self, master):
                self.master = master
                self.master.title("Screen Recorder")
                #self.image_icon12 = PhotoImage(file = "img/reclogo.png")
                #self.root.iconphoto(False, image_icon12)

                self.recording = False

                # Butonul de start înregistrare
                self.record_button = tk.Button(master, text="Start Recording", command=self.toggle_recording, bg="gray40", fg="lime green", bd=7)
                self.record_button.pack(pady=10)

                # Butonul de oprire înregistrare
                self.stop_button = tk.Button(master, text="Stop Recording", command=self.stop_recording, bg="black", fg="red", bd=7, state=tk.DISABLED)
                self.stop_button.pack(pady=5)

                # Butonul de captură de ecran
                self.capture_button = tk.Button(master, text="Capture Screen", command=self.capture_screen, bg="gray40", fg="lime green", bd=7)
                self.capture_button.pack(pady=5)

            def start_recording(self):
                self.recording = True
                self.master.iconify()  # Minimizează fereastra Tkinter
                self.record_button.config(text="Recording...", bg="black", fg="white", state=tk.DISABLED)
                self.stop_button.config(bg="gray40", fg="red", state=tk.NORMAL)
                threading.Thread(target=self.record_screen).start()

            def stop_recording(self):
                self.recording = False
                self.master.deiconify()  # Restaurează fereastra Tkinter
                self.record_button.config(text="Start Recording", bg="gray40", fg="lime green", state=tk.NORMAL)
                self.stop_button.config(bg="black", fg="white", state=tk.DISABLED)

            def toggle_recording(self):
                if self.recording:
                    self.stop_recording()
                else:
                    self.start_recording()

            def record_screen(self):
                # Set up video writer
                width, height = pyautogui.size()
                fourcc = cv2.VideoWriter_fourcc(*'XVID')
                
                # Get current time
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                
                out = cv2.VideoWriter(f'screen_record_{current_time}.avi', fourcc, 20.0, (width, height))

                while self.recording:
                    # Capture screen
                    screenshot = pyautogui.screenshot()
                    frame = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                    out.write(frame)

                # Release video writer
                out.release()

            def capture_screen(self):
                self.master.iconify()  # Minimizează fereastra Tkinter
                
                # Capture screen
                screenshot = pyautogui.screenshot()
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                screenshot.save(f'screenshot_{current_time}.png')
                
                self.master.deiconify()  # Restaurează fereastra Tkinter

        scrrec = tk.Tk()
        app = ScreenRecorderApp(scrrec)
        scrrec.resizable(False, False)
        scrrec.config(bg="gray20")
        scrrec.geometry("150x150")
        scrrec.mainloop()

    scrrec_button = tk.Button(main_frame, text="Screen Events", command=ScreenRec, bg="gray40", fg="white", bd=1) #black
    scrrec_button.pack(padx=10, pady=5)

    def ZIPF():
        import os
        import subprocess
        import tkinter as tk
        from tkinter import filedialog, messagebox, ttk
        import zipfile
        from tkinter import simpledialog



        class Window:
            def __init__(self, master):
                self.file_sel = ""
                master.title("Create/Extract ZIP files")
                master.resizable(False, False)
                #image_icon13 = PhotoImage(file = "img/complogo.png")
                #master.iconphoto(False, image_icon13)
                self.frame1 = ttk.LabelFrame(master, height=100, width=400, text="Actions")
                self.frame1.pack(padx=10, pady=10)
                self.frame2 = ttk.LabelFrame(master, height=100, width=400, text="Information about zip file")
                self.frame2.pack(padx=10, pady=10)
                self.frame3 = ttk.LabelFrame(master, height=100, width=400, text="List of files and folders inside zip file")
                self.frame3.pack(padx=10, pady=10)

                self.button1 = ttk.Button(self.frame1, text="Browse zip file", command=self.button_file)
                self.button1.pack(side=tk.LEFT, padx=10, pady=10)

                self.button2 = ttk.Button(self.frame1, text="Unzip directory", command=self.change_dir)
                self.button2.pack(side=tk.LEFT, padx=10, pady=10)

                self.button3 = ttk.Button(self.frame1, text="Extract All", command=self.button_extract_all)
                self.button3.pack(side=tk.LEFT, padx=10, pady=10)

                self.button4 = ttk.Button(self.frame1, text="Extract Selection", command=self.button_extract_sel)
                self.button4.pack(side=tk.LEFT, padx=10, pady=10)
                
                self.button5 = ttk.Button(self.frame1, text="Create ZIP", command=self.button_create_zip)
                self.button5.pack(side=tk.LEFT, padx=10, pady=10)

                self.label_frame_2 = ttk.Label(self.frame2, text="Select a zip file", width=100)
                self.label_frame_2.pack(padx=10, pady=10)

                self.treeview = ttk.Treeview(self.frame3, show="tree", selectmode="extended")
                self.treeview.pack(padx=10, pady=10)
                self.treeview["column"] = ("one")
                self.treeview.column("one", width=400)
                self.treeview.bind("<<TreeviewSelect>>", self.callback)

                self.label1 = ttk.Label(master)
                self.label1.pack()
                
            def button_create_zip(self):
                dir_path = filedialog.askdirectory()
                if dir_path:
                    zip_file_path = filedialog.asksaveasfilename(defaultextension=".zip", filetypes=[("ZIP files", "*.zip")])
                    if zip_file_path:
                        with zipfile.ZipFile(zip_file_path, 'w') as z:
                            for root, _, files in os.walk(dir_path):
                                for file in files:
                                    file_path = os.path.join(root, file)
                                    rel_path = os.path.relpath(file_path, dir_path)
                                    z.write(file_path, rel_path)
                        messagebox.showinfo("Success", "ZIP archive created successfully.")



            def callback(self, event):
                self.button4.config(state="enabled")
                print(self.treeview.selection())

            def button_file(self):
                self.file_sel = self.find_file("file")
                if self.is_zip(self.file_sel):
                    zip1 = ZipData(self.file_sel)
                    self.update_label(1)
                    self.label_frame_2.config(text="You have selected the zip file " + self.file_sel + "\n" + str(zip1.len_zip()) + " items found in the zip file")
                    self.button3.config(state="enabled")
                    for elt in zip1.info():
                        elt_split = elt.split("/")
                        if "" in elt_split:
                            elt_split.remove("")
                        if len(elt_split) == 1:
                            parent = ""
                        else:
                            parent = "/".join(elt_split[:-1])

                        if not self.treeview.exists(parent):
                            self.treeview.insert("", "end", parent, text=elt_split[0])

                        self.treeview.insert(parent, "end", "/".join(elt_split), text=elt_split[-1])

            def button_extract_all(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_all()
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def button_extract_sel(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_sel(self.treeview.selection())
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def clean_window(self):
                self.update_label(2)
                self.label_frame_2.config(text="")
                for i in self.treeview.get_children():
                    self.treeview.delete(i)
                subprocess.Popen("explorer " + os.getcwd())

            @staticmethod
            def find_file(f_type):
                f_name = ""
                if f_type == "file":
                    file_name = filedialog.askopenfile()
                    if file_name:
                        f_name = file_name.name
                return f_name

            @staticmethod
            def is_zip(zip_path):
                if zip_path[-4:] != ".zip":
                    messagebox.showerror("Type file error", "You need to select a zip file")
                    return False
                else:
                    return True

            def change_dir(self):
                """ Change the current directory """
                dir_path = filedialog.askdirectory()
                if dir_path:
                    os.chdir(dir_path)
                    self.update_label(1)


            def update_label(self, val):
                if val == 1:
                    self.label1.config(text="The zip file will be extracted in the directory " + self.find_dir())
                if val == 2:
                    self.label1.config(text="Zip file successfully extracted")

            @staticmethod
            def find_dir():
                cwd = os.getcwd()
                return cwd


        class ZipData:
            def __init__(self, file):
                self.file = file

            def extract_all(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    z.extractall()

            def extract_sel(self, file_name):
                with zipfile.ZipFile(self.file, 'r') as z:
                    for f_name in file_name:
                        z.extract(f_name)

            def len_zip(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    nb_items = len(z.namelist())
                    return nb_items

            def info(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    return z.namelist()


        if __name__ == "__main__":
            ziproot = tk.Tk()
            win = Window(ziproot)
            ziproot.mainloop()

    button_zip = tk.Button(main_frame, text="Create/Extract ZIP", command=ZIPF, bg="gray40", fg="white", bd=1) #black
    button_zip.pack(padx=10, pady=5)
    '''
    def PassGen():
        def low():
            entrypass.delete(0, END)
            lengthpass = var1.get()
            passwordpass = ""
            
            if custom_check.get() == 1:  # If custom option is selected
                chars = custom_entry.get()  # Get custom characters
            else:
                if varpass.get() == 1:  # if strength selected is low
                    chars = "abcdefghijklmnopqrstuvwxyz"
                elif varpass.get() == 0:  # if strength selected is medium
                    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                elif varpass.get() == 3:  # if strength selected is strong
                    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !@#$%^&*()"
                else:
                    print("Please choose an option")

            for i in range(0, lengthpass):
                passwordpass = passwordpass + random.choice(chars)
            return passwordpass


        def save_to_file(passwordpass):
            with open("passwords.txt", "a") as file:
                file.write(passwordpass + "\n")

        def generate():
            password1 = low()
            entrypass.insert(10, password1)
            save_to_file(password1)


        def copy1():
            random_password = entrypass.get()
            pyperclip.copy(random_password)

        def enable_custom_entry():
            custom_entry.config(state=NORMAL if custom_check.get() == 1 else DISABLED)

        passroot = Tk()
        passroot.resizable(False, False)
        varpass = IntVar()
        var1 = IntVar()
        custom_check = IntVar()

        passroot.title("Random Password Generator")

        Random_password = Label(passroot, text="Password")
        Random_password.grid(row=0)
        entrypass = Entry(passroot)
        entrypass.grid(row=0, column=1)

        c_label = Label(passroot, text="Length")
        c_label.grid(row=1)

        copy_buttonpass = Button(passroot, text="Copy", command=copy1)
        copy_buttonpass.grid(row=0, column=2)
        generate_buttonpass = Button(passroot, text="Generate", command=generate)
        generate_buttonpass.grid(row=0, column=3)

        radio_low = Radiobutton(passroot, text="Low", variable=varpass, value=1, command=enable_custom_entry)
        radio_low.grid(row=1, column=2, sticky='E')
        radio_middle = Radiobutton(passroot, text="Medium", variable=varpass, value=0, command=enable_custom_entry)
        radio_middle.grid(row=1, column=3, sticky='E')
        radio_strong = Radiobutton(passroot, text="Strong", variable=varpass, value=3, command=enable_custom_entry)
        radio_strong.grid(row=1, column=4, sticky='E')

        custom_entry_label = Label(passroot, text="Custom Characters")
        custom_entry_label.grid(row=2)
        custom_entry = Entry(passroot, state=DISABLED)
        custom_entry.grid(row=2, column=1)

        custom_checkbutton = Checkbutton(passroot, text="Custom", variable=custom_check, command=enable_custom_entry)
        custom_checkbutton.grid(row=2, column=2)

        combopass = Combobox(passroot, textvariable=var1)
        combopass['values'] = (8, 9, 10, 11, 12, 13, 14, 15, 16,
                               17, 18, 19, 20, 21, 22, 23, 24, 25,
                               26, 27, 28, 29, 30, 31, 32, "Length")
        combopass.current(0)
        combopass.bind('<<ComboboxSelected>>')
        combopass.grid(column=1, row=1)

        passroot.mainloop()

    button_passgen = tk.Button(main_frame, text="Password Generator", command=PassGen, bg="gray40", fg="white", bd=1) #black
    button_passgen.pack(padx=10, pady=5)
    '''
     
    def open_excel_and_display_table():
        file_path = filedialog.askopenfilename(filetypes=[("Excel Files", "*.xlsx"), ("All Files", "*.*")])
        #file_path = "Fisa Dotari IT 2.0.xlsx"
        if file_path:
            try:
                wb = pd.ExcelFile(file_path)
                sheet_names = wb.sheet_names
     
                # Creating a new window for selecting the worksheet
                selection_window = tk.Toplevel(bg="gray20")
                selection_window.geometry("300x300")
                selection_window.title("Select the Worksheet")
                selection_window.resizable(False, False)
                #image_icon14 = PhotoImage(file = "img/complogo.png")
                #selection_window.iconphoto(False, image_icon14)
     
                # Configurăm stilul pentru combobox
                # Funcție pentru a suprima evidențierea elementului selectat
                def null_select(event):
                    sheet_option.selection_clear()

                # Configurăm stilul pentru combobox
                # Configurăm stilul pentru combobox
                style = ttk.Style()
                style.theme_create('custom_style',
                   parent='alt',
                   settings={'TCombobox':
                             {'configure':
                              {'selectforeground': 'white',
                               'selectbackground': '#1a2228',
                               'fieldforeground': 'white',
                               'fieldbackground': '#1a2228',
                               'background': '#1a2228'
                               }
                              }
                             }
                   )
                style.theme_use('custom_style')

                # Schimbăm culoarea fundalului și a chenarului combobox-ului
                style.configure('TCombobox', fieldbackground='#222222', background='#222222', foreground='#00ee00', arrowcolor='#00ee00', activeBackground="#222222")

                selection_window.option_add('*TCombobox*Listbox*Background', '#222222')
                selection_window.option_add('*TCombobox*Listbox*Foreground', '#00ee00')
                # Creăm combobox-ul
                sheet_option = ttk.Combobox(selection_window, values=sheet_names)

                # Suprimăm evidențierea elementului selectat
                sheet_option.bind("<<ComboboxSelected>>", null_select)

                # Afisăm combobox-ul
                sheet_option.pack(pady=10)
                # Creating a button to display the table
                display_button = tk.Button(selection_window, text="Arata tabelul", command=lambda: display_table(wb, sheet_option.get()), bg="gray40", fg="white", bd=1)
                display_button.pack(pady=5)
     
            except Exception as e:
                print("Error opening file:", e)
     
    def display_table(wb, sheet_name):
        # Reading data from the selected worksheet
        df = wb.parse(sheet_name)
     
        # Replace NaN values with empty strings
        df.replace(np.nan, '', inplace=True)
     
        # Creating a new window for displaying the table
        table_window = tk.Toplevel()
        table_window.title("Excel Table")
        table_window.configure(bg="gray20")
        #image_icon15 = PhotoImage(file = "img/complogo.png")
        #table_window.iconphoto(False, image_icon15)
     
        # Creating a canvas widget
        canvas = tk.Canvas(table_window)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
     
        # Creating a frame inside the canvas to hold the table content
        frame = tk.Frame(canvas)
        frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
     
        # Adding a scrollbar to the canvas
        scrollbar = tk.Scrollbar(table_window, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        canvas.configure(yscrollcommand=scrollbar.set)
     
        # Configure the canvas to update scrollregion when the frame size changes
        frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
     
        # Adding the frame to the canvas
        canvas.create_window((0, 0), window=frame, anchor="nw")
     
        # Creating a grid to simulate Excel-like cells
        for i in range(df.shape[0] + 1):  # Rows
            for j in range(df.shape[1] + 1):  # Columns
                if i == 0:
                    if j == 0:
                        label = tk.Label(frame, text="", width=10, height=2, borderwidth=1, relief="solid", bg="lightgray")
                    else:
                        label = tk.Label(frame, text=df.columns[j - 1], width=20, height=2, borderwidth=1, relief="solid", font=("Helvetica", 10, "bold"), bg="lightgray")
                else:
                    if j == 0:
                        label = tk.Label(frame, text=df.index[i - 1], width=10, height=2, borderwidth=1, relief="solid", font=("Helvetica", 10, "bold"))
                    else:
                        cell_text = str(df.iloc[i - 1, j - 1])
                        label_width = max(20, len(cell_text) + 2)  # Adjust width based on text length
                        entry = tk.Entry(frame, width=label_width, borderwidth=1, relief="solid")
                        entry.insert(0, cell_text)
                        entry.config(state="readonly")  # Make the entry readonly
                        entry.bind("<FocusIn>", lambda event, entry=entry: entry.config(state="normal"))  # Enable editing on focus
                        entry.bind("<FocusOut>", lambda event, entry=entry: entry.config(state="readonly"))  # Disable editing on focus out
                        entry.grid(row=i, column=j, sticky="nsew")
                label.grid(row=i, column=j, sticky="nsew")
     
        # Adjust column and row weights to make the cells expandable
        for i in range(df.shape[0] + 1):
            frame.grid_rowconfigure(i, weight=1)
        for j in range(df.shape[1] + 1):
            frame.grid_columnconfigure(j, weight=1)
     
        # Adding navigation buttons
        nav_frame = tk.Frame(table_window)
        nav_frame.config(bg="gray20")
        nav_frame.pack(side=tk.BOTTOM, pady=10)
     
        def navigate_left():
            canvas.xview_scroll(-1, "units")
     
        def navigate_right():
            canvas.xview_scroll(1, "units")
     
        left_button = tk.Button(nav_frame, text="← Left", bg="gray40", fg="white", command=navigate_left)
        left_button.pack(side=tk.LEFT, padx=5)

     
        right_button = tk.Button(nav_frame, text="Right →", bg="gray40", fg="white", command=navigate_right)
        right_button.pack(side=tk.LEFT, padx=5)
     
     
    # Creating a button to open the Excel file and display the table
    open_button = tk.Button(main_frame, text="Open the Equipment Sheet", command=open_excel_and_display_table, bg="gray40", fg="white", bd=1) #black
    open_button.pack(pady=5)

    def OpenNotepad():
        #from tkinter import *
        from tkinter.filedialog import asksaveasfile, askopenfile
        from tkinter.messagebox import showerror, askyesno
        from tkinter.scrolledtext import ScrolledText
        from tkinter.colorchooser import askcolor
        from tkinter.font import Font
        from tkinter.messagebox import showinfo
        from tkinter.simpledialog import askstring

        name = "Tudor Marmureanu"

        class File():
            def newFile(self):
                self.filename = "Untitled"
                self.text.delete(0.0, END)

            def saveFile(self):
                try:
                    t = self.text.get(0.0, END)
                    with open(self.filename, 'w') as f:
                        f.write(t)
                except Exception as e:
                    print(e)
                    self.saveAs()

            def saveAs(self):
                try:
                    f = asksaveasfile(mode='w', defaultextension='.txt')
                    t = self.text.get(0.0, END)
                    f.write(t.rstrip())
                    f.close()
                except Exception as e:
                    print(e)
                    showerror(title="Oops!", message="Unable to save file...")

            def openFile(self):
                try:
                    f = askopenfile(mode='r')
                    self.filename = f.name
                    t = f.read()
                    self.text.delete(0.0, END)
                    self.text.insert(0.0, t)
                except Exception as e:
                    print(e)

            def quit(self):
                if askyesno(title="Quit", message="Are you sure you want to quit?"):
                    self.rootnot.destroy()

            def __init__(self, text, rootnot):
                self.filename = None
                self.text = text
                self.rootnot = rootnot

        class Format():
            def __init__(self, text):
                self.text = text

            def changeBg(self):
                (triple, hexstr) = askcolor()
                if hexstr:
                    self.text.config(bg=hexstr)

            def changeFg(self):
                (triple, hexstr) = askcolor()
                if hexstr:
                    self.text.config(fg=hexstr)

            def bold(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "bold" in current_tags:
                        self.text.tag_remove("bold", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("bold", "sel.first", "sel.last")
                        bold_font = Font(self.text, self.text.cget("font"))
                        bold_font.configure(weight="bold")
                        self.text.tag_configure("bold", font=bold_font)
                except Exception as e:
                    print(e)

            def italic(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "italic" in current_tags:
                        self.text.tag_remove("italic", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("italic", "sel.first", "sel.last")
                        italic_font = Font(self.text, self.text.cget("font"))
                        italic_font.configure(slant="italic")
                        self.text.tag_configure("italic", font=italic_font)
                except Exception as e:
                    print(e)

            def underline(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "underline" in current_tags:
                        self.text.tag_remove("underline", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("underline", "sel.first", "sel.last")
                        underline_font = Font(self.text, self.text.cget("font"))
                        underline_font.configure(underline=1)
                        self.text.tag_configure("underline", font=underline_font)
                except Exception as e:
                    print(e)

            def overstrike(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "overstrike" in current_tags:
                        self.text.tag_remove("overstrike", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("overstrike", "sel.first", "sel.last")
                        overstrike_font = Font(self.text, self.text.cget("font"))
                        overstrike_font.configure(overstrike=1)
                        self.text.tag_configure("overstrike", font=overstrike_font)
                except Exception as e:
                    print(e)

        class Edit():
            def __init__(self, text, rootnot):
                self.clipboard = None
                self.text = text
                self.rightClick = Menu(rootnot)

            def popup(self, event):
                self.rightClick.post(event.x_rootnot, event.y_rootnot)

            def copy(self, *args):
                sel = self.text.selection_get()
                self.clipboard = sel

            def cut(self, *args):
                sel = self.text.selection_get()
                self.clipboard = sel
                self.text.delete(SEL_FIRST, SEL_LAST)

            def paste(self, *args):
                self.text.insert(INSERT, self.clipboard)

            def selectAll(self, *args):
                self.text.tag_add(SEL, "1.0", END)
                self.text.mark_set(0.0, END)
                self.text.see(INSERT)

            def undo(self, *args):
                self.text.edit_undo()

            def redo(self, *args):
                self.text.edit_redo()

            def find(self, *args):
                self.text.tag_remove('found', '1.0', END)
                target = askstring('Find', 'Search String:')

                if target:
                    idx = '1.0'
                    while 1:
                        idx = self.text.search(target, idx, nocase=1, stopindex=END)
                        if not idx: break
                        lastidx = '%s+%dc' % (idx, len(target))
                        self.text.tag_add('found', idx, lastidx)
                        idx = lastidx
                    self.text.tag_config('found', foreground='white', background='blue')

        class Help():
            def about(self):
                showinfo(title="About", message=f"This a simple text editor | Made by {name}")

        def mainnot(rootnot, text, menubar):
            objFile = File(text, rootnot)
            objFormat = Format(text)
            objEdit = Edit(text, rootnot)
            objHelp = Help()

            # File menu
            filemenu = Menu(menubar)
            filemenu.add_command(label="New", command=objFile.newFile)
            filemenu.add_command(label="Open", command=objFile.openFile)
            filemenu.add_command(label="Save", command=objFile.saveFile)
            filemenu.add_command(label="Save As...", command=objFile.saveAs)
            filemenu.add_separator()
            filemenu.add_command(label="Quit", command=objFile.quit)
            menubar.add_cascade(label="File", menu=filemenu)

            # Edit menu
            editmenu = Menu(menubar)
            editmenu.add_command(label="Copy", command=objEdit.copy)
            editmenu.add_command(label="Cut", command=objEdit.cut)
            editmenu.add_command(label="Paste", command=objEdit.paste)
            editmenu.add_command(label="Undo", command=objEdit.undo)
            editmenu.add_command(label="Redo", command=objEdit.redo)
            editmenu.add_command(label="Find", command=objEdit.find)
            editmenu.add_separator()
            editmenu.add_command(label="Select All", command=objEdit.selectAll)
            menubar.add_cascade(label="Edit", menu=editmenu)

            # Format menu
            formatMenu = Menu(menubar)
            formatMenu.add_command(label="Change Background", command=objFormat.changeBg)
            formatMenu.add_command(label="Change Font Color", command=objFormat.changeFg)
            formatMenu.add_command(label="Bold", command=objFormat.bold, accelerator="Ctrl+B")
            formatMenu.add_command(label="Italic", command=objFormat.italic, accelerator="Ctrl+I")
            formatMenu.add_command(label="Underline", command=objFormat.underline, accelerator="Ctrl+U")
            formatMenu.add_command(label="Overstrike", command=objFormat.overstrike, accelerator="Ctrl+T")
            menubar.add_cascade(label="Format", menu=formatMenu)
            
            # Help menu
            helpmenu = Menu(menubar)
            helpmenu.add_command(label="About", command=objHelp.about)
            menubar.add_cascade(label="Help", menu=helpmenu)

            rootnot.config(menu=menubar)

        rootnot = Tk()
        rootnot.title("Text Editor - Untitled")
        rootnot.geometry("400x400")

        text = ScrolledText(rootnot, state='normal', height=400, width=400, wrap='word', pady=2, padx=3, undo=True)
        text.pack(fill=Y, expand=1)
        text.focus_set()

        menubar = Menu(rootnot)

        mainnot(rootnot, text, menubar)
        rootnot.mainloop()

    open_notepad_button = tk.Button(main_frame, text="Text Editor", command=OpenNotepad, bg="gray40", fg="white", bd=1) #black
    open_notepad_button.pack(pady=5)
    
    def OpenPaint():
        from tkinter import filedialog, messagebox, colorchooser
        import PIL.ImageGrab as ImageGrab
        from PIL import Image, ImageDraw
        import PIL
        global color, image, draw  # adăugăm variabilele globale pentru imagine și obiectul draw
        color = 'black'
        Width = 600
        Height = 440

        rootpnt = Tk()

        def save():
            filename = filedialog.asksaveasfilename(initialfile="untitled.png", defaultextension=".png",
                                                    filetypes=[("PNG files", "*.png"), ("All files", "*.*")])
            if filename:
                image.save(filename)

        def change_color(c):
            global color
            color = c

        def pick_color():
            global color
            picked = colorchooser.askcolor()
            if picked[1]:
                color = picked[1]

        def drawing(event):
            x1, y1 = (event.x - 1), (event.y - 1)
            x2, y2 = (event.x + 1), (event.y + 1)
            canvas.create_oval((x1, y1, x2, y2), fill=color, outline=color, width=vertical.get())
            draw.ellipse([x1, y1, x2 + vertical.get(), y2 + vertical.get()], outline=color, fill=color)

        def on_closing():
            answer = messagebox.askyesnocancel("QUIT", "DO YOU WANT TO SAVE YOUR WORK?", parent=rootpnt)
            if answer is not None:
                if answer:
                    save()
                rootpnt.destroy()

        def new_canvas():
            canvas.delete('all')
            draw.rectangle([0, 0, Width, Height], fill='white')

        rootpnt.title("Paint")
        rootpnt.geometry('600x550')
        rootpnt.resizable(False, False)
        rootpnt.configure(bg='black')
        rootpnt.protocol("WM_DELETE_WINDOW", on_closing)

        frame = Frame(rootpnt, bg='white')
        color_frame = Frame(frame, bg='black', borderwidth=10)

        menu_bar = Menu(rootpnt)
        rootpnt.config(menu=menu_bar)
        submenu = Menu(menu_bar, tearoff=0)

        menu_bar.add_cascade(label='File', menu=submenu)
        submenu.add_command(label='New Canvas', command=new_canvas)
        submenu.add_command(label='Save', command=save)

        colors = ['black', 'grey', 'brown', 'orange', 'yellow', 'red', 'green', 'turquoise', 'indigo', 'purple', 'blue',
                  'white', 'lime', 'pink', 'gold', 'cyan']
        buttons = []

        for i, col in enumerate(colors):
            button = Button(color_frame, bg=col, width=1, command=lambda col=col: change_color(col))
            buttons.append(button)
            button.grid(row=i // 11, column=i % 11)

        vertical = Scale(frame, from_=1, to=25, label='Size')
        vertical.set(3)

        erase_but = Button(frame, text='Erase', command=lambda: change_color('white'))
        color_but = Button(frame, text='Color', command=pick_color)

        canvas = Canvas(rootpnt, bg='white', width=Width, height=Height)
        canvas.bind('<B1-Motion>', drawing)

        image = Image.new("RGB", (Width, Height), 'white')  # Inițializăm imaginea cu fundal alb
        draw = ImageDraw.Draw(image)

        frame.grid(row=0, column=0, sticky='nsew')
        color_frame.grid(row=0, column=0, padx=20)
        vertical.grid(row=0, column=1)
        erase_but.grid(row=0, column=2, padx=20)
        color_but.grid(row=0, column=3)

        canvas.grid(row=1, column=0)

        # Centralize Window
        rootpnt.update()
        window_width = rootpnt.winfo_width()
        window_height = rootpnt.winfo_height()
        screen_width = rootpnt.winfo_screenwidth()
        screen_height = rootpnt.winfo_screenheight()
        x = int((screen_width / 2) - (window_width / 2))
        y = int((screen_height / 2) - (window_height / 2))
        rootpnt.geometry(f"{window_width}x{window_height}+{x}+{y}")

        rootpnt.mainloop()
    
    open_paint_button = Button(main_frame, text="Whiteboard", command=OpenPaint, bg="gray40", fg="white", bd=1)
    open_paint_button.pack(pady=5)
     
    def PDFToWordConv():
        gpath = ""

        def openfile():
            tb.delete(0, END)
            global gpath
            filterex = [('PDF File', '*.pdf'), ('All Files', '*.*')]
            userfile = fd.askopenfile(title="Open PDF", filetypes=filterex)
            if userfile:
                tb.insert(0, userfile.name)
                gpath = userfile.name

        def convert_to_word():
            global gpath
            if gpath:
                pdf_document = aw.Document(gpath)
                pdf_document.save("pdf.docx")
                mb.showinfo("Succes", "The file has been converted to Word.")
            else:
                mb.showerror("Error", "No PDF file has been selected.")

        def convert_to_word_and_extract_images():
            global gpath
            if gpath:
                # Converting selected PDF file to Word DOCX format
                pdf_document = aw.Document(gpath)
                pdf_document.save("pdf.docx")

                # Opening the converted DOCX file
                doc = Document("pdf.docx")

                # Retrieving all shapes (images) from the DOCX file
                shapes = doc.get_child_nodes(aw.NodeType.SHAPE, True)
                imageIndex = 0

                # Folder path to save images
                folder_path = "imagini/"

                # Create the folder if it doesn't exist
                if not os.path.exists(folder_path):
                    os.makedirs(folder_path)

                # Looping through the shapes (images)
                for shape in shapes:
                    shape = shape.as_shape()
                    if shape.has_image:
                        # Setting the image file's name
                        imageFileName = f"{folder_path}Image.ExportImages.{imageIndex}_{aw.FileFormatUtil.image_type_to_extension(shape.image_data.image_type)}"

                        # Saving the image
                        shape.image_data.save(imageFileName)
                        imageIndex += 1

                mb.showinfo("Succes", "The file was converted to Word and the images were extracted.")
            else:
                mb.showerror("Error", "No PDF file has been selected.")

        W = Tk()
        W.title("PDF in Word Converter")
        #image_icon16 = PhotoImage(file = "img/complogo.png")
        #W.iconphoto(False, image_icon16)
        W.geometry("640x400")
        W.config(bg="gray20")
        W.resizable(FALSE, FALSE)
        lb = Label(W, text="Select PDF file", bg="gray40", fg="cyan", bd=1)
        lb.grid(row=1, column=0)
        tb = Entry(W, width=80)
        tb.grid(row=2, column=0)
        tb.focus()

        bt_browse = Button(W, text="Browse", bg="gray40", fg="cyan", width=15, bd=1, command=openfile)
        bt_browse.grid(row=2, column=1, ipady=3)

        bt_convert_to_word = Button(W, text="Convert in Word", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word)
        bt_convert_to_word.grid(row=3, column=0, columnspan=2, pady=5)

        bt_convert_with_images = Button(W, text="Convert in Word and extract images", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word_and_extract_images)
        bt_convert_with_images.grid(row=4, column=0, columnspan=2, pady=5)
        
    WP = tk.Button(main_frame, text="PDF to Word", command=PDFToWordConv, bg="gray40", fg="white", bd=1) #bg=black
    WP.pack(pady=5) 
    
    def pdftools():
            import tkinter as tk
            from tkinter import filedialog, messagebox
            import os
            import pikepdf
            from PIL import Image
            import fitz

            def get_file_path():
                file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
                return file_path

            def encrypt_decrypt():
                def process_pdf(action):
                    password = password_entry.get()
                    input_file = get_file_path()

                    if action == "Encrypt":
                        output_file = "encrypted_" + os.path.basename(input_file)
                        encryption = pikepdf.Encryption(owner=password, user=password, R=4)
                    else:  # Decrypt
                        output_file = "decrypted_" + os.path.basename(input_file)
                        try:
                            pdf = pikepdf.open(input_file, password=password)
                            pdf.save(output_file)
                            pdf.close()
                        except pikepdf._qpdf.PasswordError:
                            messagebox.showerror("Error", "Invalid password for decryption.")
                            return

                    with pikepdf.Pdf.open(input_file) as pdf:
                        pdf.save(output_file, encryption=encryption)

                    messagebox.showinfo("Success", f"PDF {action}ed successfully!")

                encrypt_decrypt_window = tk.Toplevel()
                encrypt_decrypt_window.title("Encrypt or Decrypt PDF")
                #image_icon17 = PhotoImage(file = "img/securelogo.png")
                #encrypt_decrypt_window.iconphoto(False, image_icon17)
                encrypt_decrypt_window.geometry("400x200")
                encrypt_decrypt_window.resizable(False, False)
                encrypt_decrypt_window.config(bg="gray20")

                label = tk.Label(encrypt_decrypt_window, text="Enter password:", bg="gray20", fg="cyan")
                label.pack()

                password_entry = tk.Entry(encrypt_decrypt_window, show="*")
                password_entry.pack()

                encrypt_button = tk.Button(encrypt_decrypt_window, text="Encrypt", command=lambda: process_pdf("Encrypt"), bg="gray40", fg="cyan")
                encrypt_button.pack()

                decrypt_button = tk.Button(encrypt_decrypt_window, text="Decrypt", command=lambda: process_pdf("Decrypt"), bg="gray40", fg="cyan")
                decrypt_button.pack()

            def rotate_pages():
                def process_rotation():
                    degrees = int(degrees_entry.get())
                    input_file = get_file_path()
                    output_file = "rotated_" + os.path.basename(input_file)

                    with pikepdf.Pdf.open(input_file) as pdf:
                        for page in pdf.pages:
                            page.Rotate = degrees
                        pdf.save(output_file)

                    messagebox.showinfo("Success", "PDF rotated successfully!")

                rotate_window = tk.Toplevel()
                rotate_window.title("Rotate Pages")
                rotate_window.geometry("400x200")
                rotate_window.config(bg="gray20")
                rotate_window.resizable(False, False)
                #image_icon18 = PhotoImage(file = "img/complogo.png")
                #rotate_window.iconphoto(False, image_icon18)

                label = tk.Label(rotate_window, text="Enter rotation degrees:", bg="gray20", fg="cyan")
                label.pack()

                degrees_entry = tk.Entry(rotate_window)
                degrees_entry.pack()

                rotate_button = tk.Button(rotate_window, text="Rotate", command=process_rotation, bg="gray40", fg="cyan")
                rotate_button.pack()


            def extract_images():
                def process_extraction():
                    input_file = get_file_path()
                    output_folder = filedialog.askdirectory()

                    # Deschide PDF-ul
                    pdf = fitz.open(input_file)

                    for page_num in range(len(pdf)):
                        page = pdf[page_num]
                        image_list = page.get_images(full=True)
                        
                        for image_index, img in enumerate(image_list):
                            # Extrage imaginea
                            xref = img[0]
                            base_image = pdf.extract_image(xref)
                            image_bytes = base_image["image"]

                            # Salvează imaginea
                            image_path = os.path.join(output_folder, f"page{page_num+1}_image{image_index}.png")
                            with open(image_path, "wb") as f:
                                f.write(image_bytes)

                            print("Image saved:", image_path)

                    pdf.close()
                    messagebox.showinfo("Success", "Images extracted successfully!")

                extract_images_window = tk.Toplevel()
                extract_images_window.title("Extract Images")
                extract_images_window.geometry("400x200")
                extract_images_window.resizable(False, False)
                extract_images_window.config(bg="gray20")
                #image_icon19 = PhotoImage(file = "img/complogo.png")
                #extract_images_window.iconphoto(False, image_icon19)

                extract_button = tk.Button(extract_images_window, text="Extract", command=process_extraction, bg="gray40", fg="cyan")
                extract_button.pack()

            def get_file_path():
                file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
                return file_path

            def separate_pages():
                def process_separation():
                    input_file = get_file_path()
                    output_folder = filedialog.askdirectory()

                    with pikepdf.Pdf.open(input_file) as pdf:
                        for page_num, page in enumerate(pdf.pages, start=1):
                            new_pdf = pikepdf.Pdf.new()
                            new_pdf.pages.append(page)
                            output_file = os.path.join(output_folder, f"page{page_num}.pdf")
                            new_pdf.save(output_file)

                    messagebox.showinfo("Success", "Pages separated successfully!")

                separate_pages_window = tk.Toplevel()
                separate_pages_window.title("Separate Pages")
                separate_pages_window.geometry("400x200")
                separate_pages_window.resizable(False, False)
                separate_pages_window.config(bg="gray20")
                #image_icon20 = PhotoImage(file = "img/complogo.png")
                #separate_pages_window.iconphoto(False, image_icon20)

                separate_button = tk.Button(separate_pages_window, text="Separate", command=process_separation, bg="gray40", fg="cyan")
                separate_button.pack()

            def delete_pages():
                def process_deletion():
                    input_file = get_file_path()
                    output_file = "deleted_" + os.path.basename(input_file)
                    pages_to_delete = list(map(int, pages_entry.get().split(',')))

                    with pikepdf.Pdf.open(input_file) as pdf:
                        for page_num in sorted(pages_to_delete, reverse=True):
                            del pdf.pages[page_num - 1]
                        pdf.save(output_file)

                    messagebox.showinfo("Success", "Pages deleted successfully!")

                delete_window = tk.Toplevel()
                delete_window.title("Delete Pages")
                delete_window.geometry("400x200")
                delete_window.resizable(False, False)
                delete_window.config(bg="gray20")
                #image_icon21 = PhotoImage(file = "img/complogo.png")
                #delete_window.iconphoto(False, image_icon21)

                label = tk.Label(delete_window, text="Enter page numbers to delete (separated by comma):", bg="gray20", fg="cyan")
                label.pack()

                pages_entry = tk.Entry(delete_window)
                pages_entry.pack()

                delete_button = tk.Button(delete_window, text="Delete", command=process_deletion, bg="gray40", fg="cyan")
                delete_button.pack()

            def mainpdf():
                rootpdff = tk.Tk()
                rootpdff.title("PDF Editing Tools")
                rootpdff.geometry("400x300")
                rootpdff.resizable(False, False)
                rootpdff.config(bg="gray20")
                #image_icon22 = PhotoImage(file = "img/complogo.png")
                #rootpdff.iconphoto(False, image_icon22)

                encrypt_decrypt_button = tk.Button(rootpdff, text="Encrypt or Decrypt PDF", command=encrypt_decrypt, bg="gray40", fg="cyan")
                encrypt_decrypt_button.pack(pady=5)

                rotate_pages_button = tk.Button(rootpdff, text="Rotate Pages", command=rotate_pages, bg="gray40", fg="cyan")
                rotate_pages_button.pack(pady=5)

                extract_images_button = tk.Button(rootpdff, text="Extract Images", command=extract_images, bg="gray40", fg="cyan")
                extract_images_button.pack(pady=5)

                separate_pages_button = tk.Button(rootpdff, text="Separate Pages", command=separate_pages, bg="gray40", fg="cyan")
                separate_pages_button.pack(pady=5)

                delete_pages_button = tk.Button(rootpdff, text="Delete Pages", command=delete_pages, bg="gray40", fg="cyan")
                delete_pages_button.pack(pady=5)

                rootpdff.mainloop()

            mainpdf()
    
    pdftools_button = tk.Button(main_frame, text="PDF Tools", command=pdftools, bg="gray40", fg="white", bd=1) #bg=black
    pdftools_button.pack(pady=5)  

    def BackupRestore():
        import shutil
        import os
        from datetime import datetime
        import tkinter as tk
        from tkinter import filedialog, messagebox

        def backup_files(source_dir, backup_dir):
            try:
                date_str = datetime.now().strftime('%Y%m%d_%H%M%S')
                backup_path = os.path.join(backup_dir, f'backup_{date_str}')
                shutil.copytree(source_dir, backup_path)
                messagebox.showinfo("Backup Completed", f'Backup completed: {backup_path}')
            except Exception as e:
                messagebox.showerror("Error", f'An error occurred: {e}')

        def select_source_directory():
            source_dir = filedialog.askdirectory()
            source_entry.delete(0, tk.END)
            source_entry.insert(0, source_dir)

        def select_backup_directory():
            backup_dir = filedialog.askdirectory()
            backup_entry.delete(0, tk.END)
            backup_entry.insert(0, backup_dir)

        def start_backup():
            source_dir = source_entry.get()
            backup_dir = backup_entry.get()
            if not source_dir or not backup_dir:
                messagebox.showwarning("Input Error", "Please select both source and backup directories.")
                return
            backup_files(source_dir, backup_dir)

        # Set up the main application window
        rootbkr = tk.Tk()
        rootbkr.title("Backup Utility")
        rootbkr.geometry("600x150")
        rootbkr.config(bg="gray20")
        rootbkr.resizable(False, False)

        # Configure the style of the labels and entries
        label_style = {'bg': 'gray20', 'fg': '#ccff66'}
        entry_style = {'bg': 'black', 'fg': '#ccff66', 'insertbackground': 'cyan'}

        # Source directory selection
        tk.Label(rootbkr, text="Source Directory:", **label_style).grid(row=0, column=0, padx=10, pady=5)
        source_entry = tk.Entry(rootbkr, width=50, **entry_style)
        source_entry.grid(row=0, column=1, padx=10, pady=5)
        tk.Button(rootbkr, text="Browse...", command=select_source_directory, bg="gray40", fg="#ccff66").grid(row=0, column=2, padx=10, pady=5)

        # Backup directory selection
        tk.Label(rootbkr, text="Backup Directory:", **label_style).grid(row=1, column=0, padx=10, pady=5)
        backup_entry = tk.Entry(rootbkr, width=50, **entry_style)
        backup_entry.grid(row=1, column=1, padx=10, pady=5)
        tk.Button(rootbkr, text="Browse...", command=select_backup_directory, bg="gray40", fg="#ccff66").grid(row=1, column=2, padx=10, pady=5)

        # Backup button
        tk.Button(rootbkr, text="Start Backup", command=start_backup, bg="gray40", fg="#ccff66").grid(row=2, column=0, columnspan=3, pady=20)

        # Run the application
        rootbkr.mainloop()

    
    bkr_button = tk.Button(main_frame, text="Backup Utility", command=BackupRestore, bg="gray40", fg="white", bd=1) #bg=black
    bkr_button.pack(pady=5)  
    
    def Renamer():
        import os
        import tkinter as tk
        from tkinter import filedialog, simpledialog, messagebox

        def rename_files(directory, selected_files, prefix, suffix):
            try:
                for file in selected_files:
                    file_path = os.path.join(directory, file)
                    if os.path.isfile(file_path):
                        base, ext = os.path.splitext(file)
                        new_name = base
                        if prefix:
                            new_name = f"{prefix}_{new_name}"
                        if suffix:
                            new_name = f"{new_name}_{suffix}"
                        new_name = f"{new_name}{ext}"
                        new_path = os.path.join(directory, new_name)
                        os.rename(file_path, new_path)
                messagebox.showinfo("Success", "Files have been renamed successfully.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")

        def select_directory():
            directory = filedialog.askdirectory()
            if directory:
                directory_entry.delete(0, tk.END)
                directory_entry.insert(0, directory)
                update_file_list(directory)

        def update_file_list(directory):
            files = os.listdir(directory)
            file_listbox.delete(0, tk.END)
            for file in files:
                file_listbox.insert(tk.END, file)

        def start_renaming():
            directory = directory_entry.get()
            if not directory:
                messagebox.showwarning("Input Error", "Please select a directory.")
                return
            
            selected_files = [file_listbox.get(i) for i in file_listbox.curselection()]
            if not selected_files:
                messagebox.showwarning("Input Error", "Please select at least one file.")
                return

            prefix = prefix_entry.get()
            suffix = suffix_entry.get()

            rename_files(directory, selected_files, prefix, suffix)
            update_file_list(directory)  # Refresh the file list after renaming

        # Set up the main application window
        rootrn = tk.Tk()
        rootrn.title("Batch File Renamer")
        rootrn.configure(bg='gray20')
        rootrn.resizable(False, False)

        # Directory selection
        tk.Label(rootrn, text="Directory:", bg='gray20', fg='#ccff66').grid(row=0, column=0, padx=10, pady=5)
        directory_entry = tk.Entry(rootrn, width=50, bg='black', fg='#ccff66', insertbackground='cyan')
        directory_entry.grid(row=0, column=1, padx=10, pady=5)
        tk.Button(rootrn, text="Browse...", command=select_directory, bg='gray40', fg='#ccff66').grid(row=0, column=2, padx=10, pady=5)

        # File list
        tk.Label(rootrn, text="Files:", bg='gray20', fg='#ccff66', font=('bold')).grid(row=1, column=0, padx=10, pady=5)
        file_listbox = tk.Listbox(rootrn, selectmode=tk.MULTIPLE, width=50, height=15, bg='black', fg='#ccff66', bd=25)
        file_listbox.grid(row=1, column=1, padx=10, pady=5, columnspan=2)

        # Prefix option
        tk.Label(rootrn, text="Prefix:", bg='gray20', fg='#ccff66').grid(row=2, column=0, padx=10, pady=5)
        prefix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
        prefix_entry.grid(row=2, column=1, padx=10, pady=5)

        # Suffix option
        tk.Label(rootrn, text="Suffix:", bg='gray20', fg='#ccff66').grid(row=3, column=0, padx=10, pady=5)
        suffix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
        suffix_entry.grid(row=3, column=1, padx=10, pady=5)

        # Rename button
        tk.Button(rootrn, text="Rename Files", command=start_renaming, bg='gray40', fg='#ccff66').grid(row=4, column=0, columnspan=3, pady=20)

        # Run the application
        rootrn.mainloop()


    rn_button = tk.Button(main_frame, text="Rename Utility", command=Renamer, bg="gray40", fg="white", bd=1) #bg=black
    rn_button.pack(pady=5) 
    
    def SystemInfoFunc():
        def get_service_tag():
            try:
                output = subprocess.check_output(["wmic", "bios", "get", "serialnumber"]).decode().strip().split("\n")
                # Service Tag-ul este în al doilea rând al rezultatului
                service_tag = output[1].strip()
                return service_tag
            except Exception as e:
                print("A apărut o Error:", e)
                return None

        def get_windows_license_key():
            try:#wmic path softwarelicensingservice get OA3xOriginalProductKey
                output = subprocess.check_output(["wmic", "path", "softwarelicensingservice", "get", "OA3xOriginalProductKey"]).decode().strip().split("\n")
                # Cheia de licență Windows este în ultima linie a rezultatului
                license_key = output[-1].split(":")[-1].strip()
                return license_key
            except Exception as e:
                print("A apărut o Error:", e)
                return None

        def save_to_file(filename, content):
            try:
                with open(filename, 'w') as file:
                    file.write(content)
                    print(f"The information has been saved to {filename}")
            except Exception as e:
                print(f"An error occurred while saving to {filename}: {e}")

        def save_to_file1(filename, content):
            try:
                with open(filename, 'w') as file:
                    for item in content:
                        file.write(item[2:-2] + '\n')  # Scriem fiecare element în fișier fără paranteze pătrate
                    print(f"The information has been saved to {filename}")
            except Exception as e:
                print(f"An error occurred while saving to {filename}: {e}")

        def display_info():
            system_info = get_system_info()
            text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
            text_area.delete(1.0, tk.END)
            for item in system_info:
                text_area.insert(tk.END, item[2:-2] + '\n')
            text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
            save_to_file1("SystemInfo.txt", system_info)

        def display_service_tag():
            service_tag = get_service_tag()
            if service_tag:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Service Tag: " + service_tag + '\n')
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
                save_to_file("ServiceTag.txt", service_tag)
            else:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Nu s-a putut obține Service Tag-ul.\n")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil

        def display_license_key():
            license_key = get_windows_license_key()
            if license_key:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Cheia de licență Windows: " + license_key + '\n')
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
                save_to_file("WindowsKey.txt", license_key)
            else:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Nu s-a putut obține cheia de licență Windows.\n")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil

        def display_battery():
            sfc_info = generate_battery_report()
            if sfc_info:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "powercfg /batteryreport /output \"C:\\battery_report.html\"\n")
                text_area.insert(tk.END, "Raport generat.")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
            else:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Nu s-a putut efectua comanda.\n")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil

        def get_system_info():
            info = subprocess.check_output(['systeminfo']).decode('utf-8').split('\n')
            formatted_info = []
            for item in info:
                formatted_info.append(str(item.split("\r")[:-1]))
            return formatted_info

        def shutdown():
            return subprocess.call("shutdown /s /t 1")

        def restart():
            return subprocess.call("shutdown /r /t 1")

        def logout():
            return subprocess.call("shutdown -l")

        def get_into_domain():
            os.startfile("sysdm.cpl")

        def run_appwiz():
            os.startfile("appwiz.cpl")

        def generate_battery_report():
            subprocess.call("powercfg /batteryreport /output \"C:\\battery_report.html\"")

        def open_power_plan_settings():
            try:
                subprocess.run(["control", "powercfg.cpl"])
            except Exception as e:
                print("Error:", e)

        def lusrmgr():
            os.startfile("lusrmgr.msc")

        def devmgmt():
            os.startfile("devmgmt.msc")

        infowindow = tk.Tk()
        infowindow.title("System Info")
        infowindow.config(bg="gray20")  # Setare culoare fundal gri închis
        infowindow.resizable(False, False)
        #image_icon23 = PhotoImage(file = "img/systemlogo.png")
        #infowindow.iconphoto(False, image_icon23)

        text_area = scrolledtext.ScrolledText(infowindow, wrap=tk.WORD, bg="black", fg="cyan", highlightbackground="gray40", highlightthickness=10, bd=20)  # Setarea culorii fundalului și a textului
        text_area.grid(row=0, column=1, rowspan=13, padx=10, pady=3, sticky="nsew")
        text_area.config(height=40)  # Modifică dimensiunile text_area

        buttons = [
            ("Display System info", display_info),
            ("Display Service Tag", display_service_tag),
            ("Display Windows license key", display_license_key),
            ("Introduction of PC in the domain", get_into_domain),
            ("Open the apps in Control Panel", run_appwiz),
            ("Generation of battery raport", display_battery),
            ("Edit Power Plan", open_power_plan_settings),
            ("Edit users and groups (lusrmgr)", lusrmgr),
            ("Device manager", devmgmt),
            ("Shutdown", shutdown),
            ("Restart", restart),
            ("Log out", logout),
            ("EXIT", infowindow.destroy)
        ]

        for i, (text, command) in enumerate(buttons):
            fg_color = "red" if text == "EXIT" else "cyan"  # Verificare dacă butonul este "EXIT"
            button = tk.Button(infowindow, text=text, command=command, bg="gray40", fg=fg_color, bd=6)
            button.grid(row=i, column=0, padx=5, pady=5, sticky="ew")

        # Configurarea configurării grilei pentru a redimensiona corect butoanele și zona de text
        infowindow.grid_rowconfigure(13, weight=1)
        infowindow.grid_columnconfigure(0, weight=1)
        infowindow.grid_columnconfigure(1, weight=3)

        '''
         infowindow = tk.Tk()
        infowindow.title("System Info")
        infowindow.config(bg="gray20")  # Setare culoare fundal gri închis

        text_area = scrolledtext.ScrolledText(infowindow, wrap=tk.WORD, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)  # Setarea culorii fundalului și a textului
        text_area.grid(row=0, column=1, rowspan=6, padx=10, pady=3, sticky="nsew")
        text_area.config(height=40)  # Modifică dimensiunile text_area

        info_button = tk.Button(infowindow, text="Afiseaza informatii", command=display_info, bg="gray40", fg="cyan", bd=6)
        info_button.grid(row=0, column=0, padx=5, pady=3, sticky="ew")

        service_tag_button = tk.Button(infowindow, text="Afiseaza Service Tag", command=display_service_tag, bg="gray40", fg="cyan", bd=6)
        service_tag_button.grid(row=1, column=0, padx=5, pady=3, sticky="ew")

        license_key_button = tk.Button(infowindow, text="Afiseaza Cheia de Licenta Windows", command=display_license_key, bg="gray40", fg="cyan", bd=6)
        license_key_button.grid(row=2, column=0, padx=5, pady=3, sticky="ew")

        into_domain = tk.Button(infowindow, text="Introducere PC in domeniu", command=get_into_domain, bg="gray40", fg="cyan", bd=6)
        into_domain.grid(row=3, column=0, padx=5, pady=3, sticky="ew")

        appwiz = tk.Button(infowindow, text="Deschide aplicatii Control Panel", command=run_appwiz, bg="gray40", fg="cyan", bd=6)
        appwiz.grid(row=4, column=0, padx=5, pady=3, sticky="ew")

        battery_report = tk.Button(infowindow, text="Generare raport baterie", command=display_battery, bg="gray40", fg="cyan", bd=6)
        battery_report.grid(row=5, column=0, padx=3, pady=1, sticky="ew")

        power_plan = tk.Button(infowindow, text="Edit Power Plan", command=open_power_plan_settings, bg="gray40", fg="cyan", bd=6)
        power_plan.grid(row=6, column=0, padx=5, pady=30, sticky="ew")

        lusrmgrBTN = tk.Button(infowindow, text="Editare useri si grupuri", command=lusrmgr, bg="gray40", fg="cyan", bd=6)
        lusrmgrBTN.grid(row=7, column=0, padx=5, pady=30, sticky="ew")

        devmgmtBTN = tk.Button(infowindow, text="Device manager", command=devmgmt, bg="gray40", fg="cyan", bd=6)
        devmgmtBTN.grid(row=8, column=0, padx=5, pady=30, sticky="ew")

        shutdown_button = tk.Button(infowindow, text="Shutdown", command=shutdown, bg="gray40", fg="red", bd=4)
        shutdown_button.grid(row=9, column=0, padx=5, pady=1, sticky="ew")

        restart_button = tk.Button(infowindow, text="Restart", command=restart, bg="gray40", fg="lime green", bd=4)
        restart_button.grid(row=10, column=0, padx=5, pady=1, sticky="ew")

        logout_button = tk.Button(infowindow, text="Log out", command=logout, bg="gray40", fg="yellow", bd=4)
        logout_button.grid(row=11, column=0, padx=5, pady=1, sticky="ew")

        exit_button = tk.Button(infowindow, text="EXIT", command=infowindow.destroy, bg="red", fg="black", bd=10)
        exit_button.grid(row=12, column=0, padx=5, pady=5, sticky="ew")

        # Configurarea configurării grilei pentru a redimensiona corect butoanele și zona de text
        infowindow.grid_rowconfigure(0, weight=1)
        infowindow.grid_rowconfigure(1, weight=1)
        infowindow.grid_rowconfigure(2, weight=1)
        infowindow.grid_rowconfigure(3, weight=1)
        infowindow.grid_rowconfigure(4, weight=1)
        infowindow.grid_rowconfigure(5, weight=1)
        infowindow.grid_rowconfigure(6, weight=1)
        infowindow.grid_rowconfigure(7, weight=1)
        infowindow.grid_rowconfigure(8, weight=1)
        infowindow.grid_rowconfigure(9, weight=1)
        infowindow.grid_rowconfigure(10, weight=1)
        infowindow.grid_rowconfigure(11, weight=1)
        infowindow.grid_rowconfigure(12, weight=1)
        infowindow.grid_columnconfigure(0, weight=1)
        infowindow.grid_columnconfigure(1, weight=3)
        '''

    SystemInfo_button = tk.Button(main_frame, text="System Info", command=SystemInfoFunc, bg="gray40", fg="white", bd=1)
    SystemInfo_button.pack(pady=5)

    '''
    def open_dearpygui():
        # Put your Dear PyGui code here
        AllInfo()

    def prevent_close():
        # Funcție apelată atunci când utilizatorul încearcă să închidă fereastra
        # Ignorăm acțiunea, astfel încât fereastra să rămână deschisă
        pass

    def AllInfo():
        # Check for AMD support and conditionally import pyadl
        from datetime import datetime
        AMD_SUPPORTED = False
        try:
            import pyadl
            _ = pyadl.ADLManager.getInstance().getDevices()
            AMD_SUPPORTED = True
        except ImportError:
            pass
        except Exception as amd_error:
            # Only print the AMD error if no NVIDIA GPUs are detected
            if not GPUtil.getGPUs():
                print(f"Unexpected error while checking for AMD support: {amd_error}")

        # Check for Windows and conditionally import winreg
        if platform.system() == 'Windows':
            import winreg
        else:
            winreg = None

        gci = get_cpu_info()
        WIN_WIDTH = 800
        WIN_HEIGHT = 400

        dpg.create_context()

        gpu_temp_texts = {}  # Store NVIDIA GPU temp text IDs
        amd_gpu_temp_texts = {}  # Store AMD GPU temp text IDs
        gpu_progress_bars = {}  # Store NVIDIA GPU progress bar IDs

        # Get CPU Total Utilization
        def get_cpu_util():
            """Get CPU Total Utilization"""

            while True:
                cpu_val = psutil.cpu_percent(interval=1, percpu=False)
                dpg.set_value(cpu_progress_bar, 1.0 / 100.0 * cpu_val)
                dpg.configure_item(cpu_progress_bar, overlay=f"{cpu_val}%")


        # entry
        with dpg.window(
                label=f"Computer Name: {platform.node()}",
                no_close=True,
                no_resize=True,
                no_move=True,
                width=WIN_WIDTH - 18,
                height=WIN_HEIGHT
        ) as main_window:
            with dpg.collapsing_header(label="Processor"):
                with dpg.group(horizontal=True):
                    dpg.add_text(f"{gci['brand_raw']} @", bullet=True)
                    dpg.add_text(f"{gci['hz_actual_friendly']}")
                with dpg.group(horizontal=True):
                    dpg.add_text("CPU Utilization(Total):", bullet=True)
                    threading.Thread(target=get_cpu_util, args=(), daemon=True).start()
                    cpu_progress_bar = dpg.add_progress_bar(default_value=0.0, overlay="0.0%", width=200)
                dpg.add_text(f"{gci['count']} Total Core/s", bullet=True)
                dpg.add_text(f"{gci['arch']} Architecture", bullet=True)
                with dpg.tree_node(label="Cache/s"):
                    try:
                        l1_i = humanize.naturalsize(gci['l1_instruction_cache_size'], gnu=True)
                        dpg.add_text(f"L1 Instruction Cache Size: {l1_i}")
                    except KeyError:
                        dpg.add_text("L1 Instruction Cache Size: Can't determine")

                    try:
                        l1_d = humanize.naturalsize(gci['l1_data_cache_size'], gnu=True)
                        dpg.add_text(f"L1 Data Cache Size: {l1_d}")
                    except KeyError:
                        dpg.add_text("L1 Data Cache Size: Can't determine")

                    try:
                        l2 = humanize.naturalsize(gci['l2_cache_size'], gnu=True)
                        dpg.add_text(f"L2 Cache Size: {l2}")
                    except KeyError:
                        dpg.add_text("L2 Cache Size: Can't determine")

                    try:
                        l3 = humanize.naturalsize(gci['l3_cache_size'], gnu=True)
                        dpg.add_text(f"L3 Cache Size: {l3}")
                    except KeyError:
                        dpg.add_text("L3 Cache Size: Can't determine")

                with dpg.tree_node(label="Flags"):
                    with dpg.table(
                        header_row=False,
                        resizable=True,
                        policy=dpg.mvTable_SizingStretchProp,
                        row_background=True,
                        borders_outerV=True,
                        borders_innerV=True,
                        borders_outerH=True,
                        borders_innerH=True,
                        delay_search=True
                    ):
                        COL = 11
                        FLAG = 0
                        flags = gci['flags']

                        for _ in range(COL):
                            dpg.add_table_column()

                        # https://github.com/hoffstadt/DearPyGui/discussions/1918#discussioncomment-3960795
                        rows = int(len(flags) / COL) + 1
                        for row in range(rows):
                            with dpg.table_row():
                                for col in range(COL):
                                    FLAG = row * COL + col
                                    if FLAG >= len(flags):
                                        dpg.add_text("---")
                                    else:
                                        dpg.add_text(f"{flags[FLAG]}")

            with dpg.collapsing_header(label="Graphics"):
                gpu_temp_placeholder = dpg.add_group(horizontal=False)
                gpu_list = []

                def handle_nvidia_gpus():
                    """handle NVIDIA GPUs"""
                    gpus = GPUtil.getGPUs()
                    for gpu in gpus:
                        if gpu.id not in gpu_temp_texts:
                            dpg.add_text(
                                f"Graphics Name: {gpu.name}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            with dpg.group(horizontal=True, parent=gpu_temp_placeholder):
                                dpg.add_text("GPU Utilization:", bullet=True)
                                gpu_progress_bar = dpg.add_progress_bar(
                                    default_value=0.0,
                                    overlay="0.0%",
                                    width=200
                                )
                                gpu_progress_bars[gpu.id] = gpu_progress_bar

                            gpu_temp_text_id = dpg.add_text(
                                f"Temperature: {gpu.temperature}°C",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            gpu_temp_texts[gpu.id] = gpu_temp_text_id
                        else:
                            dpg.set_value(
                                gpu_temp_texts[gpu.id],
                                f"Temperature: {gpu.temperature}°C"
                            )

                def handle_amd_gpus():
                    """handle AMD GPUs"""
                    if not AMD_SUPPORTED:
                        return

                    amd_manager = pyadl.ADLManager.getInstance()
                    devices = amd_manager.getDevices()
                    for device in devices:
                        temperature_data = device.getCurrentTemperature()
                        if temperature_data is not None:
                            if device.adapterName not in amd_gpu_temp_texts:
                                dpg.add_text(
                                f"AMD GPU {device.adapterName}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            amd_gpu_temp_text_id = dpg.add_text(
                                f"Temperature: {temperature_data}°C",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            amd_gpu_temp_texts[device.adapterName] = amd_gpu_temp_text_id
                        else:
                            dpg.set_value(
                                amd_gpu_temp_texts[device.adapterName],
                                f"Temperature: {temperature_data}°C"
                            )

                def update_gpu_temperature():
                    """Get GPU Temperature and Util Updates"""
                    while True:
                        try:
                            handle_nvidia_gpus()
                        except ImportError as import_error:
                            dpg.add_text(
                                f"Error importing GPUtil: {import_error}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                        except Exception as general_exception:
                            dpg.add_text(
                                f"Error fetching NVIDIA GPU information: {general_exception}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )

                        try:
                            handle_amd_gpus()
                        except Exception as general_exception:
                            dpg.add_text(
                                f"Error fetching AMD GPU temperature: {general_exception}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )

                        time.sleep(1)

                # Get GPU Utilization
                def get_gpu_util():
                    """Get GPU Utilization"""
                    while True:
                        try:
                            gpus = GPUtil.getGPUs()
                            for gpu in gpus:
                                gpu_val = gpu.load * 100
                                dpg.set_value(gpu_progress_bars[gpu.id], 1.0 / 100.0 * gpu_val)
                                dpg.configure_item(gpu_progress_bars[gpu.id], overlay=f"{gpu_val:.2f}%")
                        except (ImportError, Exception) as general_exception:
                            print(f"An error occurred: {general_exception}")
                        time.sleep(1)

            with dpg.collapsing_header(label="Memory"):
                mem = psutil.virtual_memory()
                mem_used = humanize.naturalsize(mem.used)
                mem_percent = mem.percent
                mem_avail = humanize.naturalsize(mem.available)
                mem_total = humanize.naturalsize(mem.total)
                dpg.add_text("MAIN MEMORY", color=(0, 255, 0))
                dpg.add_text(f"Used Memory: {mem_used}({mem_percent}%)", bullet=True)
                dpg.add_text(f"Available Memory: {mem_avail}", bullet=True)
                dpg.add_text(f"Total Memory: {mem_total}", bullet=True)

                swap = psutil.swap_memory()
                swap_used = humanize.naturalsize(swap.used)
                swap_percent = swap.percent
                swap_free = humanize.naturalsize(swap.free)
                swap_total = humanize.naturalsize(swap.total)
                dpg.add_text("SWAP MEMORY", color=(0, 255, 0))
                dpg.add_text(f"Used Swap Memory: {swap_used}({swap_percent}%)", bullet=True)
                dpg.add_text(f"Free Swap Memory: {swap_free}", bullet=True)
                dpg.add_text(f"Total Swap Memory: {swap_total}", bullet=True)

            with dpg.collapsing_header(label="Disk"):
                with dpg.table(
                    resizable=True,
                    policy=dpg.mvTable_SizingStretchProp,
                    borders_outerV=True,
                    borders_innerV=True,
                    borders_outerH=True,
                    borders_innerH=True,
                    delay_search=True
                ):
                    dpg.add_table_column(label="Device")
                    dpg.add_table_column(label="Mount point")
                    dpg.add_table_column(label="File System type")
                    dpg.add_table_column(label="Used")
                    dpg.add_table_column(label="Free")
                    dpg.add_table_column(label="Total")

                    prts = psutil.disk_partitions()
                    for prt in prts:
                        with dpg.table_row():
                            for row in range(8):
                                dpg.add_text(f"{prt.device}", color=(0, 255, 0))
                                dpg.add_text(f"{prt.mountpoint}")
                                dpg.add_text(f"{prt.fstype}")
                                try:
                                    usage = psutil.disk_usage(prt.mountpoint)
                                except PermissionError:
                                    dpg.add_text("Can't determine")
                                    continue
                                dpg.add_text(f"{humanize.naturalsize(usage.used)}({usage.percent}%)")
                                dpg.add_text(f"{humanize.naturalsize(usage.free)}")
                                dpg.add_text(f"{humanize.naturalsize(usage.total)}")

            with dpg.collapsing_header(label="Network"):
                addr_list = psutil.net_if_addrs()
                for name, addresses in addr_list.items():
                    with dpg.group(horizontal=True):
                        dpg.add_text("Interface Name: ")
                        dpg.add_text(f"{name}", color=(0, 255, 0))
                    for address in addresses:
                        if address.family == socket.AF_INET:
                            dpg.add_text(f"IP Address: {address.address}", bullet=True)
                            dpg.add_text(f"Subnet Mask: {address.netmask}", bullet=True)
                        if address.family == psutil.AF_LINK:
                            dpg.add_text(f"MAC Address: {address.address}", bullet=True)

            with dpg.collapsing_header(label="Operating System"):
                if platform.system() == 'Windows':
                    try:
                        BRAND = subprocess.check_output('wmic csproduct get vendor', shell=True)
                        BRAND = BRAND.decode('utf-8').strip().split('\n')[1]
                        MODEL = subprocess.check_output('wmic csproduct get name', shell=True)
                        MODEL = MODEL.decode('utf-8').strip().split('\n')[1]

                        dpg.add_text(f"Brand: {BRAND}", bullet=True)
                        dpg.add_text(f"Model: {MODEL}", bullet=True)
                    except subprocess.CalledProcessError:
                        dpg.add_text("Brand: Can't determine", bullet=True)
                        dpg.add_text("Model: Can't determine", bullet=True)

                elif platform.system() == 'Linux':
                    try:
                        BRAND = subprocess.check_output('dmidecode -s system-manufacturer', shell=True)
                        BRAND = BRAND.decode('utf-8').strip()
                        MODEL = subprocess.check_output('dmidecode -s system-product-name', shell=True)
                        MODEL = MODEL.decode('utf-8').strip()

                        dpg.add_text(f"Brand: {BRAND}", bullet=True)
                        dpg.add_text(f"Model: {MODEL}", bullet=True)
                    except subprocess.CalledProcessError:
                        dpg.add_text("Brand: Can't determine", bullet=True)
                        dpg.add_text("Model: Can't determine", bullet=True)

                uname = platform.uname()
                dpg.add_text(f"System: {uname.system}", bullet=True)
                if uname.system == "Windows":
                    if int(uname.version[5:]) > 22000:
                        dpg.add_text("Version: 11", bullet=True)
                dpg.add_text(f"Machine: {uname.machine}", bullet=True)

                timestamp = psutil.boot_time()
                bt = datetime.fromtimestamp(timestamp)
                boot = bt.strftime("%m/%d/%Y %I:%M:%S %p")
                dpg.add_text(f"Last boot timestamp: {boot}", bullet=True)

                if platform.system() == "Windows":
                    with dpg.tree_node(label="BIOS"):
                        bios = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\DESCRIPTION\System\BIOS")
                        vendor = winreg.QueryValueEx(bios, "BIOSVendor")
                        version = winreg.QueryValueEx(bios, "BIOSVersion")

                        dpg.add_text(f"Vendor: {vendor[0]}", bullet=True)
                        dpg.add_text(f"Version: {version[0]}", bullet=True)

        threading.Thread(target=update_gpu_temperature, daemon=True).start()
        threading.Thread(target=get_gpu_util, daemon=True).start()

        dpg.create_viewport(
            title="Real Time System Info",
            #on_close=prevent_close,
            #small_icon="res/icon.ico",
            #large_icon="res/icon.ico",
            disable_close=True,
            resizable=False,
            max_width=WIN_WIDTH,
            max_height=WIN_HEIGHT
        )
        dpg.setup_dearpygui()
        dpg.set_primary_window(main_window, True)
        dpg.show_viewport()
        dpg.start_dearpygui()
        dpg.destroy_context()


    def run_dearpygui_in_thread():
        thread = Thread(target=open_dearpygui)
        thread.start()

    AllInfo_button = tk.Button(main_frame, text="Real Time System Info", command=run_dearpygui_in_thread, bg="gray40", fg="cyan", bd=1)
    AllInfo_button.pack(pady=5)
    '''
    
    '''
    def BandNetworkMonitoring():
        def update_data():
            global last_received, last_sent, last_total, running
            
            while running:
                bytes_received = psutil.net_io_counters().bytes_recv
                bytes_sent = psutil.net_io_counters().bytes_sent
                bytes_total = bytes_received + bytes_sent
                
                new_received = bytes_received - last_received if 'last_received' in globals() else 0
                new_sent = bytes_sent - last_sent if 'last_sent' in globals() else 0
                new_total = bytes_total - last_total if 'last_total' in globals() else 0
                
                mb_new_received = new_received / 1024 / 1024
                mb_new_sent = new_sent / 1024 / 1024
                mb_new_total = new_total / 1024 / 1024
                
                # Actualizează textul în text area cu noile date
                text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                
                # Salvează datele în fișier
                with open("network_data.txt", "a") as file:
                    file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                
                print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                
                last_received = bytes_received
                last_sent = bytes_sent
                last_total = bytes_total
                
                time.sleep(1)

        def start():
            global running
            running = True
            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Crează un thread nou pentru actualizarea datelor
            data_thread = threading.Thread(target=update_data)
            data_thread.start()

        def stop():
            global running
            running = False

        # Inițializare variabile
        last_received = psutil.net_io_counters().bytes_recv
        last_sent = psutil.net_io_counters().bytes_sent
        last_total = last_received + last_sent
        running = False
        
        # Crează fereastra
        monitorband = tk.Tk()
        monitorband.title("Network Console")
        monitorband.resizable(False, False)
        monitorband.config(bg="gray20")

        # Creează un text area cu culoare de fundal și text personalizate
        text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
        text_area.pack(expand=True, fill=tk.BOTH)

        # Buton pentru pornirea monitorizării
        start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
        start_button.pack()

        # Buton pentru oprirea monitorizării
        stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
        stop_button.pack()

        # Pornirea buclei principale a interfeței grafice
        monitorband.mainloop()
    '''


    def BandNetworkMonitoring():
        import tkinter as tkj
        from psutil import net_io_counters
        REFRESH_DELAY = 1500  # Intervalul de actualizare pentru monitorizarea lățimii de bandă a rețelei în milisecunde

        class mnbd:
            def __init__(self):
                self.last_upload = 0
                self.last_download = 0
                self.upload_speed = 0
                self.down_speed = 0

                self.windowbd = tk.Tk()
                self.windowbd.title("Network Bandwidth Monitor")
                self.windowbd.geometry("400x400")
                self.windowbd.resizable(False, False)
                self.windowbd.config(bg="gray20")
                #self.image_icon24 = PhotoImage(file = "img/networklogo.png")
                #self.windowbd.iconphoto(False, self.image_icon24)

                # Crearea etichetelor
                self.label_total_upload_header = tkj.Label(self.windowbd, text="Total Upload:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_total_upload_header.pack()
                self.label_total_upload = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_total_upload.pack()

                self.label_total_download_header = tkj.Label(self.windowbd, text="Total Download:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_total_download_header.pack()
                self.label_total_download = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_total_download.pack()

                self.label_total_usage_header = tkj.Label(self.windowbd, text="Total Usage:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_total_usage_header.pack()
                self.label_total_usage = tkj.Label(self.windowbd, text="Calculating...\n", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_total_usage.pack()

                self.label_upload_header = tkj.Label(self.windowbd, text="Upload:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_upload_header.pack()
                self.label_upload = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_upload.pack()

                self.label_download_header = tkj.Label(self.windowbd, text="Download:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_download_header.pack()
                self.label_download = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_download.pack()

                self.attribution = tkj.Label(self.windowbd, text="\n~ Tudor Marmureanu ~", font="Quicksand 11 italic", bg="gray20", fg="#ccff66")
                self.attribution.pack()

            def size(self, B):
                KB = float(1024)
                MB = float(KB ** 2)
                GB = float(KB ** 3)
                TB = float(KB ** 4)

                B = float(B)
                if B < KB:
                    return f"{B} Bytes"
                elif KB <= B < MB:
                    return f"{B/KB:.2f} KB"
                elif MB <= B < GB:
                    return f"{B/MB:.2f} MB"
                elif GB <= B < TB:
                    return f"{B/GB:.2f} GB"
                elif TB <= B:
                    return f"{B/TB:.2f} TB"

            def update(self):
                counter = net_io_counters()

                upload = counter.bytes_sent
                download = counter.bytes_recv
                total = upload + download

                if self.last_upload > 0:
                    if upload < self.last_upload:
                        self.upload_speed = 0
                    else:
                        self.upload_speed = upload - self.last_upload

                if self.last_download > 0:
                    if download < self.last_download:
                        self.down_speed = 0
                    else:
                        self.down_speed = download - self.last_download

                self.last_upload = upload
                self.last_download = download
                
                self.label_total_upload["text"] = f"{self.size(upload)} ({upload} Bytes)"
                self.label_total_download["text"] = f"{self.size(download)} ({download} Bytes)"
                self.label_total_usage["text"] = f"{self.size(total)}\n"
                
                self.label_upload["text"] = self.size(self.upload_speed)
                self.label_download["text"] = self.size(self.down_speed)
                
                self.windowbd.after(REFRESH_DELAY, self.update)

            def start_monitoring(self):
                self.windowbd.after(REFRESH_DELAY, self.update)
                #self.windowbd.mainloop()
        monitorb = mnbd()
        monitorb.start_monitoring()
        def update_data():
            global last_received, last_sent, last_total, running
            
            while running:
                bytes_received = psutil.net_io_counters().bytes_recv
                bytes_sent = psutil.net_io_counters().bytes_sent
                bytes_total = bytes_received + bytes_sent
                
                new_received = bytes_received - last_received if 'last_received' in globals() else 0
                new_sent = bytes_sent - last_sent if 'last_sent' in globals() else 0
                new_total = bytes_total - last_total if 'last_total' in globals() else 0
                
                mb_new_received = new_received / 1024 / 1024
                mb_new_sent = new_sent / 1024 / 1024
                mb_new_total = new_total / 1024 / 1024
                
                # Actualizează textul în text area cu noile date
                text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                
                # Salvează datele în fișier
                with open("network_data.txt", "a") as file:
                    file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                
                print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                
                last_received = bytes_received
                last_sent = bytes_sent
                last_total = bytes_total
                
                time.sleep(1)

        def start():
            global running
            running = True
            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Crează un thread nou pentru actualizarea datelor
            data_thread = threading.Thread(target=update_data)
            data_thread.start()

        def stop():
            global running
            running = False

        def wifi_info():
            # Oprește executia butonului de Start
            stop()

            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Rulează comanda pentru a afișa rețelele Wi-Fi disponibile și parolele asociate lor
            '''
            try:
                output = subprocess.check_output(['netsh', 'wlan', 'show', 'all']).decode('utf-8')
                text_area.insert(tk.END, output)
            except subprocess.CalledProcessError as e:
                text_area.insert(tk.END, "Error: " + e.output.decode('utf-8'))
            '''
            try:
                output = subprocess.check_output(['netsh', 'wlan', 'show', 'all']).decode('utf-8')
                # Inserează output-ul în text_area
                text_area.insert(tk.END, output)
                # Salvează output-ul în fișierul wifi_info.txt
                with open('more_network_info.txt', 'w') as file:
                    file.write(output)
                print("Informațiile despre rețelele Wi-Fi au fost salvate în fișierul more_network_info.txt.")
            except subprocess.CalledProcessError as e:
                text_area.insert(tk.END, "Error: " + e.output.decode('utf-8'))
                print("Error: " + e.output.decode('utf-8'))

        def clear_wifi_passwords():
            # Oprește executia butonului de Start
            stop()
            
            # Șterge tot din text area
            text_area.delete(1.0, tk.END)

            # Șterge conținutul text area-ului la fiecare pornire######################
            text_area.delete(1.0, tk.END)
            # Rulează comanda pentru a afișa rețelele Wi-Fi și parolele asociate lor
            try:
                output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8')
                text_area.insert(tk.END, output)
            except subprocess.CalledProcessError as e:
                text_area.insert(tk.END, "Error: " + e.output.decode('utf-8'))########################
            
            # Salvează parolele Wi-Fi în fișierul Wifi_Passwords.txt
            with open("Wifi_Passwords.txt", "w") as file:
                data = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
                profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]
                for i in profiles:
                    results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', i, 'key=clear']).decode('utf-8').split('\n')
                    results = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
                    try:
                        file.write("{:<30}|  {:<}\n".format(i, results[0]))
                        text_area.insert(tk.END, "{:<30}|  {:<}\n".format(i, results[0]))
                    except IndexError:
                        file.write("{:<30}|  {:<}\n".format(i, ""))
                        text_area.insert(tk.END, "{:<30}|  {:<}\n".format(i, ""))
                    except:
                        file.write("Password Not Found\n")
                        text_area.insert(tk.END, "Password Not Found\n")

        def show_devices_on_network():
            stop()
            text_area.delete(1.0, tk.END)
            try:
                output_arp = subprocess.check_output(['arp', '-a']).decode('utf-8')  # modificare aici
                text_area.insert(tk.END, "Active devices on the network:\n" + output_arp + "\n\n\n")
            except subprocess.CalledProcessError as e_arp:
                text_area.insert(tk.END, "Error: " + str(e))  # modificare aici

            try:
                output_netstat = subprocess.check_output(['netstat', '-an']).decode('utf-8')
                text_area.insert(tk.END, "Network connections and open ports:\n" + output_netstat)
            except subprocess.CalledProcessError as e_netstat:
                text_area.insert(tk.END, "Error: " + str(e))  # modificare aici

            with open('devices_on_network.txt', 'w') as f:  # Deschide fișierul pentru scriere ('w' - write mode)
                f.write("Active devices on the network:\n" + output_arp + "\n\n\n" if 'output_arp' in locals() else "")
                f.write("Network connections and open ports:\n" + output_netstat if 'output_netstat' in locals() else "")

        def show_net_connections_for_device():
            try:
                subprocess.run(["control", "netconnections"])
            except Exception as e:
                print("Error:", e)

        # Inițializare variabile
        last_received = psutil.net_io_counters().bytes_recv
        last_sent = psutil.net_io_counters().bytes_sent
        last_total = last_received + last_sent
        running = False
        
        # Crează fereastra
        monitorband = tk.Tk()
        monitorband.title("Network Console")
        monitorband.resizable(False, False)
        monitorband.config(bg="gray20")
        #image_icon25 = PhotoImage(file = "img/networklogo.png")
        #monitorband.iconphoto(False, image_icon25)

        # Creează un text area cu culoare de fundal și text personalizate
        text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
        text_area.pack(expand=True, fill=tk.BOTH)

        # Buton pentru pornirea monitorizării
        start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
        start_button.pack()

        # Buton pentru oprirea monitorizării
        stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
        stop_button.pack()
        
        # Buton pentru afișarea parolelor WiFi
        wifi_passwords_button = tk.Button(monitorband, text="Wi-Fi Passwords", command=clear_wifi_passwords, bg="gray40", bd=10, fg="orange")
        wifi_passwords_button.pack()

        # Buton pentru afisarea informatiilor wifi
        more_info_button = tk.Button(monitorband, text="More Info", command=wifi_info, bg="gray40", bd=10, fg="lime green")
        more_info_button.pack()

        # Buton pentru a afisa dispozitivele conectate la retea
        dev_netw = tk.Button(monitorband, text="Who is on my network", command=show_devices_on_network, bg="gray40", fg="lime green", bd=10)
        dev_netw.pack()

        # Buton pentru a afisa dispozitivele conectate la retea
        net_cp = tk.Button(monitorband, text="Show connections", command=show_net_connections_for_device, bg="gray40", fg="lime green", bd=10)
        net_cp.pack()

        # Buton pentru EXIT
        EXIT_BTN = tk.Button(monitorband, text="EXIT", command=monitorband.destroy, bg="gray40", fg="red", bd=10)
        EXIT_BTN.pack()

        # Pornirea buclei principale a interfeței grafice
        monitorband.mainloop()
        
    bandmonitoring_button = tk.Button(main_frame, text="Network Console", command=BandNetworkMonitoring, bg="gray40", fg="lime green", bd=5)
    bandmonitoring_button.pack(pady=1)

    def AIChatbot():
        import tkinter as tk
        from tkinter import scrolledtext
        import re
        import subprocess
        import os

        class ChatInterface:
            def __init__(self, masterr):
                self.masterr = masterr
                masterr.title("AI Chatbot")
                
                # Setarea culorilor pentru fereastra principala
                masterr.configure(bg="gray20")
                
                self.chat_history = scrolledtext.ScrolledText(masterr, wrap=tk.WORD, bg="black", fg="#ccff66")
                self.chat_history.pack(expand=True, fill=tk.BOTH)
                
                self.text = """Daca nu poti copia, atunci verifica ca maparile sa fie facute si sa ai acces la ele si ca locatiile din fisierul tau txt sa corespunda locatiilor reale din PC si, astfel, copierea se realizeaza instant.
                Copierea se realizeaza mai eficient decat daca ai face manual tot procesul, deoarece locatiile sunt deja precompilate, deci este o maniera mai eficienta cu 20%.
                Daca bara de copiere nu este verde niciodata, atunci locatiile din fisierul tau txt nu corespund sau cuvantul inainte de : este modificat.
                Daca nu se copiaza nimic, atunci verifica maparile si asigura-te ca locatiile corespund cu fisierul txt.
                Acest tool sau program te ajuta sa faci si operatiuni diverse in reteaua ta, inclusiv sa scanezi porturile, sa vezi ce dispozitive se afla in retea sau in VLAN, sa executi diverse comenzi in retea, sa verifici proprietatile hardware ale sistemului tau in timp real, contine si functii care manipuleaza fisierele pdf si multe altele.
                Altceva ar mai fi ca poate sa compare 2 fisiere sau foldere, sa caute o secventa de text si sa o inlocuiasca, genereaza parole in diverse combinatii, ba chiar poate deschide un nou Terminal personalizat si sa cripteze fisiere.
                Licenta are scopul de a limita accesul neautorizat la fel cum este si in cazul conturilor create, adica fiecare cont are un rol predefinit.
                Contul dev nu poate fi accesat decat de Tudor Marmureanu, deoarece nimeni nu are acces full la tot ce contine tocmai din cauza ca se poate da peste cap tot sistemul sau se pot produce pagube in retea.
                Conturile deja predefinite inglobeaza celelalte functionalitati care nu se regasesc in contul it, in principal pentru ca nu au legatura cu procesul de copy.
                Sunt mai multe conturi si functionalitati, insa Tudor Marmureanu nu mi-a dat acces sa dezvalui toata informatia.
                Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale.
                Atat timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii.
                """
                
                self.input_field_label = tk.Label(masterr, text="Ask a question:", bg="gray20", fg="cyan")
                self.input_field_label.pack()

                # Crearea câmpului de intrare cu culori
                self.input_field = tk.Entry(masterr, bg="gray40", fg="#ccff66", insertbackground="cyan")
                self.input_field.pack(expand=True, fill=tk.X)

                self.input_field.bind("<Return>", self.process_input)
                
            def process_input(self, event):
                input_text = self.input_field.get()
                self.input_field.delete(0, tk.END)
                response = self.get_response(input_text)
                self.display_response(input_text, response)
                
            def get_response(self, question):
                if question.lower() == "deschide-mi servicetagul" or question.lower() == "deschide-mi servicetag-ul" or question.lower() == "deschide servicetag-ul" or question.lower() == "deschide-mi servicetag" or question.lower() == "afiseaza-mi servicetag" or question.lower() == "afiseaza-mi servicetagul" or question.lower() == "deschide servicetagul" or question.lower() == "deschide servicetag" or question.lower() == "afiseaza servicetag" or question.lower() == "afiseaza servicetagul" or question.lower() == "afiseaza servicetag-ul" or question.lower() == "afiseaza-mi servicetag-ul":
                    try:
                        output = subprocess.check_output(["wmic", "bios", "get", "serialnumber"]).decode().strip().split("\n")
                        # Service Tag-ul este în al doilea rând al rezultatului
                        service_tag = output[1].strip()
                        try:
                            with open("ServiceTag.txt", 'w') as file:
                                file.write(service_tag)  # Scriem Service Tag-ul în fișier
                            print("The information has been saved to ServiceTag.txt")
                        except Exception as e:
                            print(f"An error occurred while saving to ServiceTag.txt: {e}")
                        return service_tag
                    except Exception as e:
                        print("A apărut o Error:", e)
                        return None
                elif question.lower() == "deschide-mi licenta" or question.lower() == "deschide-mi cheia de licenta" or question.lower() == "afiseaza-mi licenta" or question.lower() == "afiseaza-mi cheia de licenta" or question.lower() == "deschide licenta" or question.lower() == "deschide cheia de licenta" or question.lower() == "afiseaza licenta" or question.lower() == "afiseaza cheia de licenta":
                    try:
                        output = subprocess.check_output(["wmic", "path", "softwarelicensingservice", "get", "OA3xOriginalProductKey"]).decode().strip().split("\n")
                        # Cheia de licență Windows este în ultima linie a rezultatului
                        license_key = output[-1].split(":")[-1].strip()
                        try:
                            with open("WindowsKey.txt", 'w') as file:
                                file.write(license_key)  # Scriem Service Tag-ul în fișier
                            print("The information has been saved to WindowsKey.txt")
                        except Exception as e:
                            print(f"An error occurred while saving to WindowsKey.txt: {e}")
                        return license_key
                    except Exception as e:
                        print("A apărut o Error:", e)
                        return None
                elif question.lower() == "lusrmgr.msc" or question.lower() == "lusrmgr":
                    os.startfile("lusrmgr.msc")
                elif question.lower() == "devmgmt.msc" or question.lower() == "devmgmt" or question.lower() == "device manager":
                    os.startfile("devmgmt.msc")
                elif question.lower() == "edit power plan" or question.lower() == "power plan" or question.lower() == "battery" or question.lower() == "battery plan" or question.lower() == "batery" or question.lower() == "batery plan":
                    try:
                        subprocess.run(["control", "powercfg.cpl"])
                    except Exception as e:
                        print("Error:", e)
                elif question.lower() == "control panel apps" or question.lower() == "control panel" or question.lower() == "appwiz.cpl" or question.lower() == "appwiz" or question.lower() == "apwiz" or question.lower() == "apwiz.cpl":
                    os.startfile("appwiz.cpl")
                elif question.lower() == "sysdm" or question.lower() == "sysdm.cpl" or question.lower() == "windows domain" or question.lower() == "domain" or question.lower() == "domeniu" or question.lower() == "windows domeniu" or question.lower() == "domeniu windows":
                    os.startfile("sysdm.cpl")
                elif question.lower() == "shutdown" or question.lower() == "shutdown pc" or question.lower() == "inchide pc" or question.lower() == "inchide acest pc" or question.lower() == "inchide" or question.lower() == "shutdown laptop" or question.lower() == "inchide laptop" or question.lower() == "inchide acest laptop":
                    subprocess.call("shutdown /s /t 1")
                elif question.lower() == "restart" or question.lower() == "restart pc" or question.lower() == "restarteaza pc" or question.lower() == "restarteaza" or question.lower() == "restart laptop" or question.lower() == "restarteaza laptop" or question.lower() == "restarteaza acest pc" or question.lower() == "restarteaza acest laptop":
                    subprocess.call("shutdown /r /t 1")
                elif question.lower() == "logout" or question.lower() == "logout pc" or question.lower() == "log out" or question.lower() == "logout laptop" or question.lower() == "log out pc" or question.lower() == "log out laptop":
                    subprocess.call("shutdown -l")
                elif question.lower() == "system info" or question.lower() == "system information" or question.lower() == "display system info" or question.lower() == "afiseaza informatiile sistemului" or question.lower() == "afiseaza informatiile pc-ului" or question.lower() == "afiseaza informatiile pcului" or question.lower() == "afiseaza informatiile laptopului" or question.lower() == "afiseaza informatiile" or question.lower() == "afiseaza-mi informatiile sistemului" or question.lower() == "afiseaza-mi informatiile pc-ului" or question.lower() == "afiseaza-mi informatiile pcului" or question.lower() == "afiseaza-mi informatiile laptopului" or question.lower() == "afiseaza-mi informatiile":
                    try:
                        info = subprocess.check_output(['systeminfo']).decode('utf-8').split('\n')
                        formatted_info = [item.rstrip() for item in info]
                        try:
                            with open("SystemInfo.txt", 'w') as file:
                                file.write('\n'.join(formatted_info))
                            print("The information has been saved to SystemInfo.txt")
                        except Exception as e:
                            print(f"An error occurred while saving to SystemInfo.txt: {e}")
                        self.chat_history.insert(tk.END, "AI: System info:\n")
                        for item in formatted_info:
                            self.chat_history.insert(tk.END, "AI: " + item + "\n")
                        self.chat_history.insert(tk.END, "\n")
                        self.text_area.insert(tk.END, "System info:\n")
                        for item in formatted_info:
                            self.text_area.insert(tk.END, item + "\n")
                        self.text_area.insert(tk.END, "\n")
                        return formatted_info
                    except Exception as e:
                        print("A apărut o Error:", e)
                        return []

                elif question.lower() == "afiseaza device-urile conectate la retea" or question.lower() == "afiseaza device-urile conectate la reteaua mea" or question.lower() == "afiseaza deviceurile conectate la retea" or question.lower() == "afiseaza deviceurile conectate la reteaua mea" or question.lower() == "afiseaza-mi device-urile conectate la retea" or question.lower() == "afiseaza-mi device-urile conectate la reteaua mea" or question.lower() == "afiseaza-mi deviceurile conectate la retea" or question.lower() == "afiseaza-mi deviceurile conectate la reteaua mea" or question.lower() == "show devices on network" or question.lower() == "arata device-urile conectate la retea" or question.lower() == "arata device-urile conectate la reteaua mea" or question.lower() == "arata deviceurile conectate la retea" or question.lower() == "arata deviceurile conectate la reteaua mea" or question.lower() == "arata-mi device-urile conectate la retea" or question.lower() == "arata-mi device-urile conectate la reteaua mea" or question.lower() == "arata-mi deviceurile conectate la retea" or question.lower() == "arata-mi deviceurile conectate la reteaua mea":
                    output_arp = subprocess.check_output(['arp', '-a']).decode('utf-8')
                    output_netstat = subprocess.check_output(['netstat', '-an']).decode('utf-8')
                    self.chat_history.insert(tk.END, "AI: Active devices on the network:\n" + output_arp + "\n\n")
                    self.chat_history.insert(tk.END, "AI: Network connections and open ports:\n" + output_netstat + "\n\n")
                    with open('devices_on_network.txt', 'w') as f:
                        f.write("Active devices on the network:\n" + output_arp + "\n\n")
                        f.write("Network connections and open ports:\n" + output_netstat)
                    self.text_area.insert(tk.END, "Active devices on the network:\n" + output_arp + "\n\n")
                    self.text_area.insert(tk.END, "Network connections and open ports:\n" + output_netstat + "\n\n")
                elif question.lower() == "afiseaza toate parolele wi-fi" or question.lower() == "afiseaza toate parolele wifi" or question.lower() == "afiseaza parolele wi-fi" or question.lower() == "afiseaza parolele wifi" or question.lower() == "afiseaza-mi toate parolele wi-fi" or question.lower() == "afiseaza-mi toate parolele wifi" or question.lower() == "afiseaza-mi parolele wi-fi" or question.lower() == "afiseaza-mi parolele wifi" or question.lower() == "arata toate parolele wi-fi" or question.lower() == "arata toate parolele wifi" or question.lower() == "arata parolele wi-fi" or question.lower() == "arata parolele wifi" or question.lower() == "arata-mi toate parolele wi-fi" or question.lower() == "arata-mi toate parolele wifi" or question.lower() == "arata-mi parolele wi-fi" or question.lower() == "arata-mi parolele wifi" or question.lower() == "show wifi passwords" or question.lower() == "afiseaza parolele wifi" or question.lower() == "show wifi pass" or question.lower() == "show wifi paswords" or question.lower() == "show wifi pas" or question.lower() == "show wi-fi passwords" or question.lower() == "afiseaza parolele wifi" or question.lower() == "show wi-fi pass" or question.lower() == "show wi-fi paswords" or question.lower() == "show wi-fi pas" or question.lower() == "vreau sa imi afisezi parolele wifi" or question.lower() == "vreau sa imi afisezi parolele wi-fi":
                    try:
                        output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8')
                        self.chat_history.insert(tk.END, "AI: " + output + "\n")
                    except subprocess.CalledProcessError as e:
                        error_msg = "Error: " + e.output.decode('utf-8')
                        self.chat_history.insert(tk.END, "AI: " + error_msg + "\n")

                    with open("Wifi_Passwords.txt", "w") as file:
                        data = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
                        profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]
                        for i in profiles:
                            results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', i, 'key=clear']).decode('utf-8').split('\n')
                            results = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
                            try:
                                file.write("{:<30}|  {:<}\n".format(i, results[0]))
                                self.chat_history.insert(tk.END, "AI: " + "{:<30}|  {:<}\n".format(i, results[0]) + "\n")
                            except IndexError:
                                file.write("{:<30}|  {:<}\n".format(i, ""))
                                self.chat_history.insert(tk.END, "AI: " + "{:<30}|  {:<}\n".format(i, "") + "\n")
                            except Exception as ex:
                                file.write("Password Not Found\n")
                                self.chat_history.insert(tk.END, "AI: Password Not Found\n" + "\n")
                
                elif question.lower() == "cine esti" or question.lower() == "ce esti" or question.lower() == "cine esti tu" or question.lower() == "ce esti tu" or question.lower() == "cine esti?" or question.lower() == "ce esti?" or question.lower() == "cine esti tu?" or question.lower() == "ce esti tu?":
                    response = "Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale. Atata timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii."
                    self.chat_history.insert(tk.END, "AI: " + response + "\n")
                else:
                    # Verificăm dacă întrebarea conține semnul întrebării '?'
                    if '?' in question:
                        # Eliminăm semnul întrebării din întrebare
                        question = question.replace('?', '')
                    unique_sentences = set()
                    # Lista cuvintelor cheie de omis
                    skip_words = {"scanezi", "priveste", "cu", "privire", "la", "voastre", "noastre", "mele", "tale", "ale", "voi", "un", "exista", "locatiilor", "locatii", "locatiile", "dns", "DNS", "VLAN", "vlan", "vad", "vezi", "vazut", "azi", "cat", "deci", "asadar", "cazul", "caz", "contrar", "alte", "altele", "altor", "construit", "daca", "parca", "prin", "intermediul", "ajutor", "ajutorul", "ajutoare", "baza", "bazez", "bazezi", "bazam", "bazati", "puternic", "slab", "dar", "doar", "numai", "intrucat", "incat", "soare", "frig", "furtuna", "ninge", "ploua", "stele", "sunt", "au", "am", "rol", "faci", "fac", "facem", "faceti", "faceau", "faceati", "faceam", "aveam", "aveai", "aveati", "aveti", "avem", "o", "situatie", "situatii", "niciodata", "aia", "acum", "acea", "aceea", "fisiere", "fisierele", "fisierelor", "fisier", "fisierul", "directorul", "director", "directoare", "directoarele", "arhiva", "zip", "ZIP", "arhive", "arhivele", "arhivelor", "cont", "conturi", "conturile", "conturilor", "fa", "-", "mi", "ti", "l", "le", "lor", "lui", "meu", "noastra", "voastra", "ei", "ea", "eu", "tu", "am", "ai", "voua", "va", "v", "i", "ai", "ti", "voi", "noua", "mie", "mi", "as", "m", "ar", "ne", "va", "place", "placea", "placut", "copi", "copii", "instant", "astfel", "altfel", "legatura", "au", "cu", "cu copierea", "inglobeaza", "principal", "in", "procesul", "de", "deja", "nicicand", "niciunde", "nici", "faca", "candva", "cand", "de", "ce", "face", "acest", "acestui", "acestora", "putea", "unde", "cum", "care", "este", "e", "sa", "fisiere", "chiar", "daca", "in", "timp", "real", "realmente", "si", "multe", "mult", "alt", "alte", "altele", "peste", "produce", "contine", "contin", "cauza", "cap", "tot", "toti", "toate", "poate", "are", "poti", "as", "merge", "functioneaza", "pentru", "ca", "deoarece", "daca", "tocmai", "din", "cauza", "la", "avea", "avem", "aveai", "ai", "fi", "a", "fost", "eram", "era", "musai", "trebuie", "trebuia", "trebuit", "mai", "imi", "ne", "ii", "cheie", "cheia", "chei", "merge", "mergea", "mers", "o", "poate", "realiza", "nu", "pot", "poti", "nimic", "se", "putea", "prea", "?"}
                    # Filtrăm cuvintele din întrebare eliminând cuvintele cheie
                    words_in_question = set(word for word in re.split(r'\W+', question.lower()) if word not in skip_words)
                    for sentence in self.text.split('.'):
                        # Verificăm dacă orice cuvânt din întrebare filtrată se regăsește în propoziția curentă
                        if any(word in re.split(r'\W+', sentence.lower()) for word in words_in_question):
                            unique_sentences.add(sentence.strip())
                    response = '\n'.join(unique_sentences) if unique_sentences else "Imi pare rau, dar nu am fost antrenat sa raspund la aceasta cerere. Voi primi actualizari constante."
                    return response

                
            def display_response(self, input_text, response):
                self.chat_history.insert(tk.END, "You: " + input_text + "\n")
                self.chat_history.insert(tk.END, "AI: " + response + "\n\n")
                
        rootai = tk.Tk()
        chat_interface = ChatInterface(rootai)
        #image_icon120 = PhotoImage(file = "img/ailogo.png")
        #rootai.iconphoto(False, image_icon120)
        rootai.mainloop()

    AI_button = tk.Button(main_frame, text="AI Chatbot", command=AIChatbot, bg="gray40", fg="#ccff66", bd=5)
    AI_button.pack(pady=5)

    def ReadMe():
        # Funcția pentru închiderea ferestrei
        def inchide_fereastra():
            readme.destroy()
        
        # Crearea ferestrei principale
        readme = tk.Toplevel()
        readme.title("Working procedure (Copy App)")
        readme.geometry("700x350")
        readme.config(bg="gray20")  # Setare culoare fundal gri închis
        #image_icon50 = PhotoImage(file = "img/complogo.png")
        #readme.iconphoto(False, image_icon50)
        
        # Crearea obiectului Text și inserarea textului
        text = scrolledtext.ScrolledText(readme, wrap="word", height=10, width=40)
        text.insert(tk.END, "To avoid potential errors, it is recommended to run the program as the corresponding domain user. Additionally, there must be a network location mapping, and you should have access to that location, of course. You need to manually configure the paths.txt and profiles.json files (according to the example).\n")
        text.configure(state="disabled")  # Textul nu poate fi editat
        text.pack(expand=True, fill="both", padx=10, pady=10)
        
        # Butonul pentru închiderea ferestrei
        buton_inchide = tk.Button(readme, text="Close", command=inchide_fereastra, bg="gray40", fg="white", bd=10)
        buton_inchide.pack(pady=5)


        # Funcția pentru închiderea ferestrei
        def inchide_fereastra1():
            readme1.destroy()
     
        # Crearea ferestrei principale
        readme1 = tk.Toplevel()
        readme1.title("About the application (licensed version)")
        readme1.geometry("700x350")
        readme1.config(bg="gray20")  # Setare culoare fundal gri închis
        image_icon27 = PhotoImage(file = "img/complogo.png")
        readme1.iconphoto(False, image_icon27)
     
        # Crearea obiectului Text și inserarea textului
        text1 = scrolledtext.ScrolledText(readme1, wrap="word", height=10, width=40)
        text1.insert(tk.END, "- Explorer Mode: Allow manual exploration of the paths and record them in the corresponding .txt files, and enable copying them to the manually selected location (this process occurs automatically after the copy buttons are pressed).\n")
        text1.insert(tk.END, "- Get MAC & IP: Display the MAC address and the IP address of the computer.\n")
        text1.insert(tk.END, "- Port Scanner: Scan the ports of a device on the network either through its IP address or hostname.\n")
        text1.insert(tk.END, "- Ping Tool: Send a ping command to all devices within the given range and display all available ports. Also, show the network data of your computer.\n")
        text1.insert(tk.END, "- Comparator: Compare 2 files to see the differences, as well as 2 folders, and display all differences.\n")
        text1.insert(tk.END, "- Find & Replace: Search for a character sequence in a text and replace the text sequence with the string entered in the respective field.\n")
        text1.insert(tk.END, "- Open the Equipment Sheet: The Excel file can be opened using the application interface, and any sheet from that file can be accessed.\n")
        text1.insert(tk.END, "- Text Editor: Advanced Notepad.\n")
        text1.insert(tk.END, "- Whiteboard: Mini Paint tool.\n")
        text1.insert(tk.END, "- PDF to Word: Convert a .pdf file to .docx, and the images from its content can be saved in a folder named Imagini.\n")
        text1.insert(tk.END, "- PDF Tools: Various tools for manipulating a PDF.")
        text1.insert(tk.END, "- Backup Utility: Perform a backup of data that is sensitive or might undergo major changes; the user should consider why it is important to create a backup.\n")
        text1.insert(tk.END, "- Rename Utility: Rename certain files in a selected folder.\n")
        text1.insert(tk.END, "- System Info: Display information about your computer, such as the service tag and Windows license key, in a special console. Additionally, you can perform operations such as shutdown, restart, and logout, along with many other commands from the Command Prompt.\n")
        text1.insert(tk.END, "- Network Console: Display confidential information such as real-time data traffic to view, for example, how quickly data is being copied from the current network (in the Copy application), information about stored Wi-Fi network passwords, and details regarding drivers, internet or Wi-Fi connections, routers, or devices that were registered on the computer when a hotspot was created, along with many other details.\n")
        text1.insert(tk.END, "- Dev Console: It is a console where you can debug this program and more; you can edit a multitude of functionalities of this program and create or implement nearly any functionality much faster than writing classic code. Therefore, access is restricted regardless of whether the user has a product key or not.\n")
        text1.configure(state="disabled")  # Textul nu poate fi editat
        text1.pack(expand=True, fill="both", padx=10, pady=10)
     
        # Butonul pentru închiderea ferestrei
        buton_inchide1 = tk.Button(readme1, text="Close", command=inchide_fereastra1, bg="gray40", fg="white", bd=10)
        buton_inchide1.pack(pady=5)
     
     
    readme_button = tk.Button(main_frame, text="Read me first", command=ReadMe, bg="gray40", fg="cyan", bd=5)
    readme_button.pack(pady=7)


    def DebuggingConsoleFunc():
        IDE = Tk()
        IDE.title("Dev Console")
        IDE.geometry("1280x720+10+10")
        IDE.configure(bg="gray20")
        IDE.resizable(False, False)
        #image_icon28 = PhotoImage(file = "img/devlogo.png")
        #IDE.iconphoto(False, image_icon28)

        label = Label(IDE, bg="gray20")
        label.place(x=180, y=0)

        file_path = ''

        def set_file_path(path):
            nonlocal file_path
            file_path = path

        def open_file():
            nonlocal file_path
            path = askopenfilename(filetypes=[('Python Files)', '*.py')])
            if path:
                with open(path, 'r') as file:
                    code = file.read()
                    code_input.delete('1.0', END)
                    code_input.insert('1.0', code)
                    file_path = path

                file_name = os.path.basename(path)
                label.config(text=file_name)
                label.config(bg="#ccff66")

        def save():
            nonlocal file_path
            if file_path == '':
                path = asksaveasfilename(filetypes=[('Python Files)', '*.py')])
            else:
                path = file_path

            if path:
                with open(path, 'w') as file:
                    code = code_input.get('1.0', END)
                    file.write(code)
                    set_file_path(path)

                file_name = os.path.basename(path)
                label.config(text=file_name)
                label.config(bg="#ccff66")

        def run():
            nonlocal file_path
            if file_path == '':
                messagebox.showerror("Dev Console Request Window", "Please save your code before running.")
                return

            def run_process():
                command = f'python {file_path}'
                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
                output, error = process.communicate()
                code_output.delete('1.0', END)
                code_output.insert('1.0', output.decode())
                code_output.insert('1.0', error.decode())

                path = file_path
                file_name = os.path.basename(path)
                label.config(text=file_name)
                label.config(bg="#ccff66")

            threading.Thread(target=run_process).start()

        def on_closing():
            if messagebox.askyesnocancel("Dev Console Request Window", "Do you want to save your work before exiting?"):
                save()
            IDE.destroy()

        def open_whiteboard():
            whiteboard = Toplevel(IDE)
            whiteboard.title("Whiteboard")
            whiteboard.geometry("800x600+700+100")
            whiteboard.resizable(False, False)
            #image_icon29 = PhotoImage(file = "img/complogo.png")
            #whiteboard.iconphoto(False, image_icon29)

            canvas = Canvas(whiteboard, bg="white")
            canvas.place(x=0, y=0, width=800, height=600)

            def draw(event):
                x, y = event.x, event.y
                canvas.create_line(x, y, x + 1, y + 1)

            canvas.bind("<B1-Motion>", draw)

        def open_text_editor():
            text_editor = Toplevel(IDE)
            text_editor.title("Text Editor")
            text_editor.geometry("500x500+18+50")
            #image_icon30 = PhotoImage(file = "img/complogo.png")
            #text_editor.iconphoto(False, image_icon30)

            text_area = Text(text_editor)
            text_area.pack(fill='both', expand=True)

            save_button = Button(text_editor, text="Save", background="lightgreen", activebackground="#ccff66",
                                 command=lambda: save_file_TE(text_area))
            save_button.pack(side='right')

        def save_file_TE(text_area):
            file = filedialog.asksaveasfile(mode = 'w', defaultextension = ".txt")
            if file is None:
                return
            text = text_area.get("1.0", "end-1c")
            file.write(text)
            file.close()

        def on_closing1():
            if messagebox.askokcancel("Warning Window", "Do you want to quit?"):
                IDE.destroy()

        def highlight_line(event):
            code_input.tag_remove("active_line", 1.0, "end")
            code_input.tag_add("active_line", "insert linestart", "insert lineend+1c")
            code_input.tag_config("active_line", background="#262626")

        def update_line_numbers(event):
            txt = event.widget
            txt.update_idletasks()
            lineno = txt.index("@0,0").split(".")[0]
            lineend = txt.index("end-1c")
            lines = int(lineend.split(".")[0]) - int(lineno)
            line_number_bar.config(state="normal")
            line_number_bar.delete("1.0", "end")
            line_number_bar.insert("end", "\n".join(str(i) for i in range(1, lines + 1)))
            line_number_bar.config(state="disabled")

        def NEW():
            nonlocal file_path
            code_input.delete('1.0', END)
            code_output.delete('1.0', END)
            file_path = ''
            label.config(text="")
            label.config(bg="gray20")

        def calculator():
            calcroot = Tk()
            calcroot.title("Scientific Calculator")
            calcroot.configure(background = 'white')
            calcroot.resizable(width=False, height=False)
            calcroot.geometry("480x568+450+90")
            #image_icon31 = PhotoImage(file = "img/calculatorlogo.png")
            #calcroot.iconphoto(False, image_icon31)
            calc = Frame(calcroot)
            calc.grid()

            class Calc():
                def __init__(self):
                    self.total=0
                    self.current=''
                    self.input_value=True
                    self.check_sum=False
                    self.op=''
                    self.result=False

                def numberEnter(self, num):
                    self.result=False
                    firstnum=txtDisplay.get()
                    secondnum=str(num)
                    if self.input_value:
                        self.current = secondnum
                        self.input_value=False
                    else:
                        if secondnum == '.':
                            if secondnum in firstnum:
                                return
                        self.current = firstnum+secondnum
                    self.display(self.current)

                def sum_of_total(self):
                    self.result=True
                    self.current=float(self.current)
                    if self.check_sum==True:
                        self.valid_function()
                    else:
                        self.total=float(txtDisplay.get())

                def display(self, value):
                    txtDisplay.delete(0, END)
                    txtDisplay.insert(0, value)

                def valid_function(self):
                    if self.op == "add":
                        self.total += self.current
                    if self.op == "sub":
                        self.total -= self.current
                    if self.op == "multi":
                        self.total *= self.current
                    if self.op == "divide":
                        self.total /= self.current
                    if self.op == "mod":
                        self.total %= self.current
                    self.input_value=True
                    self.check_sum=False
                    self.display(self.total)

                def operation(self, op):
                    self.current = float(self.current)
                    if self.check_sum:
                        self.valid_function()
                    elif not self.result:
                        self.total=self.current
                        self.input_value=True
                    self.check_sum=True
                    self.op=op
                    self.result=False

                def Clear_Entry(self):
                    self.result = False
                    self.current = "0"
                    self.display(0)
                    self.input_value=True

                def All_Clear_Entry(self):
                    self.Clear_Entry()
                    self.total=0

                def pi(self):
                    self.result = False
                    self.current = math.pi
                    self.display(self.current)

                def tau(self):
                    self.result = False
                    self.current = math.tau
                    self.display(self.current)

                def e(self):
                    self.result = False
                    self.current = math.e
                    self.display(self.current)

                def mathPM(self):
                    self.result = False
                    self.current = -(float(txtDisplay.get()))
                    self.display(self.current)

                def squared(self):
                    self.result = False
                    self.current = math.sqrt(float(txtDisplay.get()))
                    self.display(self.current)

                def cos(self):
                    self.result = False
                    self.current = math.cos(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def cosh(self):
                    self.result = False
                    self.current = math.cosh(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def tan(self):
                    self.result = False
                    self.current = math.tan(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def tanh(self):
                    self.result = False
                    self.current = math.tanh(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def sin(self):
                    self.result = False
                    self.current = math.sin(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def sinh(self):
                    self.result = False
                    self.current = math.sinh(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def log(self):
                    self.result = False
                    self.current = math.log(float(txtDisplay.get()))
                    self.display(self.current)

                def exp(self):
                    self.result = False
                    self.current = math.exp(float(txtDisplay.get()))
                    self.display(self.current)

                def acosh(self):
                    self.result = False
                    self.current = math.acosh(float(txtDisplay.get()))
                    self.display(self.current)

                def asinh(self):
                    self.result = False
                    self.current = math.asinh(float(txtDisplay.get()))
                    self.display(self.current)

                def expm1(self):
                    self.result = False
                    self.current = math.expm1(float(txtDisplay.get()))
                    self.display(self.current)

                def lgamma(self):
                    self.result = False
                    self.current = math.lgamma(float(txtDisplay.get()))
                    self.display(self.current)

                def degrees(self):
                    self.result = False
                    self.current = math.degrees(float(txtDisplay.get()))
                    self.display(self.current)

                def log2(self):
                    self.result = False
                    self.current = math.log2(float(txtDisplay.get()))
                    self.display(self.current)

                def log10(self):
                    self.result = False
                    self.current = math.log10(float(txtDisplay.get()))
                    self.display(self.current)

                def log1p(self):
                    self.result = False
                    self.current = math.log1p(float(txtDisplay.get()))
                    self.display(self.current)

            added_value = Calc()

            txtDisplay = Entry(calc, font=('Helvetica',20,'bold'),
                            bg='black',fg='white',
                            bd=30,width=28,justify=RIGHT)
            txtDisplay.grid(row=0,column=0, columnspan=4, pady=1)
            txtDisplay.insert(0,"0")

            numberpad = "789456123"
            i=0
            btn = []
            for j in range(2,5):
                for k in range(3):
                    btn.append(Button(calc, width=6, height=2,
                                    bg='black',fg='white',
                                    font=('Helvetica',20,'bold'),
                                    bd=4,text=numberpad[i]))
                    btn[i].grid(row=j, column= k, pady = 1)
                    btn[i]["command"]=lambda x=numberpad[i]:added_value.numberEnter(x)
                    i+=1
                
            btnClear = Button(calc, text=chr(67),width=6,
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold')
                            ,bd=4, command=added_value.Clear_Entry
                            ).grid(row=1, column= 0, pady = 1)

            btnAllClear = Button(calc, text=chr(67)+chr(69),
                                width=6, height=2,
                                bg='powder blue', 
                                font=('Helvetica',20,'bold'),
                                bd=4,
                                command=added_value.All_Clear_Entry
                                ).grid(row=1, column= 1, pady = 1)

            btnsq = Button(calc, text="\u221A",width=6, height=2,
                        bg='powder blue', font=('Helvetica',
                                                20,'bold'),
                        bd=4,command=added_value.squared
                        ).grid(row=1, column= 2, pady = 1)

            btnAdd = Button(calc, text="+",width=6, height=2,
                            bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("add")
                            ).grid(row=1, column= 3, pady = 1)

            btnSub = Button(calc, text="-",width=6,
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("sub")
                            ).grid(row=2, column= 3, pady = 1)

            btnMul = Button(calc, text="x",width=6, 
                            height=2,bg='powder blue', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("multi")
                            ).grid(row=3, column= 3, pady = 1)

            btnDiv = Button(calc, text="/",width=6, 
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("divide")
                            ).grid(row=4, column= 3, pady = 1)

            btnZero = Button(calc, text="0",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.numberEnter(0)
                            ).grid(row=5, column= 0, pady = 1)

            btnDot = Button(calc, text=".",width=6,
                            height=2,bg='powder blue', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.numberEnter(".")
                            ).grid(row=5, column= 1, pady = 1)
            btnPM = Button(calc, text=chr(177),width=6, 
                        height=2,bg='powder blue', font=('Helvetica',20,'bold'),
                        bd=4,command=added_value.mathPM
                        ).grid(row=5, column= 2, pady = 1)

            btnEquals = Button(calc, text="=",width=6,
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.sum_of_total
                            ).grid(row=5, column= 3, pady = 1)
            # ROW 1 :
            btnPi = Button(calc, text="pi",width=6,
                        height=2,bg='black',fg='white', 
                        font=('Helvetica',20,'bold'),
                        bd=4,command=added_value.pi
                        ).grid(row=1, column= 4, pady = 1)

            btnCos = Button(calc, text="Cos",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.cos
                        ).grid(row=1, column= 5, pady = 1)

            btntan = Button(calc, text="tan",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.tan
                        ).grid(row=1, column= 6, pady = 1)

            btnsin = Button(calc, text="sin",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.sin
                        ).grid(row=1, column= 7, pady = 1)

            # ROW 2 :
            btn2Pi = Button(calc, text="2pi",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.tau
                        ).grid(row=2, column= 4, pady = 1)

            btnCosh = Button(calc, text="Cosh",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.cosh
                            ).grid(row=2, column= 5, pady = 1)

            btntanh = Button(calc, text="tanh",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.tanh
                            ).grid(row=2, column= 6, pady = 1)

            btnsinh = Button(calc, text="sinh",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.sinh
                            ).grid(row=2, column= 7, pady = 1)

            # ROW 3 :
            btnlog = Button(calc, text="log",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log
                        ).grid(row=3, column= 4, pady = 1)

            btnExp = Button(calc, text="exp",width=6, height=2,
                            bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.exp
                        ).grid(row=3, column= 5, pady = 1)

            btnMod = Button(calc, text="Mod",width=6,
                            height=2,bg='black',fg='white', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("mod")
                            ).grid(row=3, column= 6, pady = 1)

            btnE = Button(calc, text="e",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.e
                        ).grid(row=3, column= 7, pady = 1)

            # ROW 4 :
            btnlog10 = Button(calc, text="log10",width=6, 
                            height=2,bg='black',fg='white', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log10
                            ).grid(row=4, column= 4, pady = 1)

            btncos = Button(calc, text="log1p",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log1p
                            ).grid(row=4, column= 5, pady = 1)

            btnexpm1 = Button(calc, text="expm1",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd = 4,command=added_value.expm1
                            ).grid(row=4, column= 6, pady = 1)

            btngamma = Button(calc, text="gamma",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.lgamma
                            ).grid(row=4, column= 7, pady = 1)
            # ROW 5 :
            btnlog2 = Button(calc, text="log2",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log2
                            ).grid(row=5, column= 4, pady = 1)

            btndeg = Button(calc, text="deg",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.degrees
                        ).grid(row=5, column= 5, pady = 1)

            btnacosh = Button(calc, text="acosh",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.acosh
                            ).grid(row=5, column= 6, pady = 1)

            btnasinh = Button(calc, text="asinh",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.asinh
                            ).grid(row=5, column= 7, pady = 1)

            lblDisplay = Label(calc, text = "Scientific Calculator",
                            font=('Helvetica',30,'bold'),
                            bg='black',fg='white',justify=CENTER)

            lblDisplay.grid(row=0, column= 4,columnspan=4)

            def iExit():
                iExit = tkinter.messagebox.askyesno("Scientific Calculator",
                                                    "Do you want to exit ?")
                if iExit>0:
                    calcroot.destroy()
                    return

            def Scientific():
                calcroot.resizable(width=False, height=False)
                calcroot.geometry("944x568+0+0")


            def Standard():
                calcroot.resizable(width=False, height=False)
                calcroot.geometry("480x568+0+0")

            menubar = Menu(calc)

            # ManuBar 1 :
            filemenu = Menu(menubar, tearoff = 0)
            menubar.add_cascade(label = 'File', menu = filemenu)
            filemenu.add_command(label = "Standard", command = Standard)
            filemenu.add_command(label = "Scientific", command = Scientific)
            filemenu.add_separator()
            filemenu.add_command(label = "Exit", command = iExit)

            # ManuBar 2 :
            editmenu = Menu(menubar, tearoff = 0)
            menubar.add_cascade(label = 'Edit', menu = editmenu)
            editmenu.add_command(label = "Cut")
            editmenu.add_command(label = "Copy")
            editmenu.add_separator()
            editmenu.add_command(label = "Paste")

            calcroot.config(menu=menubar)

            calcroot.mainloop()


        code_input = Text(IDE, bg="black", fg="lime green", wrap="word", insertbackground="white")
        code_input.place(x=180, y=20, width=680, height=720)

        code_output = Text(IDE, font="consolas 15", bg="gray20", fg="#ccff66", insertbackground="white")
        code_output.place(x=860, y=0, width=420, height=720)

        Button(IDE, bd=5, bg="gray40", fg="cyan", text="Open File", command=open_file).place(x=30, y=30)
        Button(IDE, bd=5, bg="gray40", fg="orange", text="Save", command=save).place(x=30, y=70)
        Button(IDE, bd=5, bg="gray40", fg="lime green", text="Run", command=run).place(x=30, y=110)
        Button(IDE, bd=5, bg="gray40", fg="cyan", text="Calculator", command=calculator).place(x=30, y=320)
        Button(IDE, bd=5, bg="gray40", fg="red", text="EXIT", command=on_closing).place(x=30, y=380)
        Button(IDE, bd=5, bg="gray40", fg="white", text="Whiteboard", command=open_whiteboard).place(x=30, y=210)
        Button(IDE, bd=5, bg="gray40", fg="white", text="Text Editor", command=open_text_editor).place(x=30, y=170)
        Button(IDE, bd=5, bg="gray40", fg="lime green", text="NEW", command=NEW).place(x=30, y=270)

        IDE.protocol("WM_DELETE_WINDOW", on_closing1)

        code_input.bind("<Motion>", highlight_line)
        code_input.bind("<Key>", highlight_line)

        scrollbar = Scrollbar(IDE, command=code_input.yview)
        scrollbar.pack(side="left", fill="y")
        code_input.config(yscrollcommand=scrollbar.set)

        line_number_bar = Text(IDE, width=10000, bg="#595959", state="disabled", fg="#ccff66")
        line_number_bar.pack(side="left", fill="y")
        line_number_bar.place(x=147, y=20, width=30, height=720)

        code_input.bind("<Any-KeyRelease>", update_line_numbers)
        code_input.bind("<Button-1>", update_line_numbers)

        IDE.mainloop()

    def activate_debugging_button():
        if adminT != False and c == 3:
            Debugging_button.config(state="normal")

    Debugging_button = tk.Button(main_frame, text="Dev Console", command=DebuggingConsoleFunc, bg="black", fg="#ff8080", bd=5, state="disabled")
    Debugging_button.pack(pady=20)
    adminT = Debugging_button

    
    save_location = tk.StringVar()

    if adminT != False:
        activate_debugging_button()
     
    root.mainloop()
############################################################################################################################################
def main2():
    messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
    validation.destroy()  # Închide fereastra de validare
    class FileCopyApp:
        def __init__(self, root):
            self.root = root
            self.root.title("Copy App")
            self.root.geometry("400x400")
            self.root.config(bg="gray20")

            # Directorul destinație
            self.current_user = os.getenv('USERNAME')
            self.destination_path = rf'C:\KIT'

            # Verifică dacă calea de destinație există
            if not os.path.exists(self.destination_path):
                try:
                    # Creează calea de destinație dacă nu există
                    os.makedirs(self.destination_path)
                    print("Director successfully created:", self.destination_path)
                except OSError as e:
                    print("Error creating directory:", e)

            # Dicționarul cu programe și direcțiile lor sursă
            self.program_paths = {}
            
            # Deschide fișierul pentru citire
            with open("paths.txt", "r") as file:
                for line in file:
                    key, value = line.strip().split(":")
                    self.program_paths[key.strip()] = value.strip()

            # Frame-uri pentru fiecare jumătate a ferestrei
            self.left_frame = tk.Frame(root, bg="gray20")
            self.left_frame.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.BOTH, expand=True)

            self.right_frame = tk.Frame(root, bg="gray20")
            self.right_frame.pack(side=tk.RIGHT, padx=5, pady=5, fill=tk.Y)

            # Canvas pentru lista de programe cu scrollbar
            self.canvas = tk.Canvas(self.left_frame, bg="gray20", highlightthickness=0)
            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.scrollbar = ttk.Scrollbar(self.right_frame, orient="vertical", command=self.canvas.yview)
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.canvas.configure(yscrollcommand=self.scrollbar.set)
            self.canvas.bind('<Configure>', self.on_canvas_configure)

            self.program_frame = tk.Frame(self.canvas, bg="gray20")
            self.canvas.create_window((0, 0), window=self.program_frame, anchor='nw')

            # Funcție pentru actualizarea culorii textului în funcție de starea checkbox-ului
            def update_fg_color(*args):
                for program, var in self.program_vars.items():
                    if var.get() == 1:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="cyan")
                    else:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="white")

            # Checkbox-uri și progres bar-uri pentru programe
            self.program_vars = {}
            self.program_checkboxes = {}
            self.progress_bars = {}

            # Frame pentru butoanele de selecție a checkbox-urilor
            self.checkbox_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.checkbox_button_frame.pack(pady=10, padx=10)

            # Încarcă profilele și creează butoanele
            self.load_profiles_and_create_buttons()

            col_count = 2  # Numărul de coloane dorit
            row_count = -(-len(self.program_paths) // col_count)  # Calculul numărului de rânduri necesare
            program_index = 0  # Variabilă pentru a ține evidența indexului programului
         
            for i in range(row_count):
                for j in range(col_count):
                    if program_index >= len(self.program_paths):
                        break
                    program = list(self.program_paths.keys())[program_index]
                    var = tk.IntVar()
                    chk = tk.Checkbutton(self.program_frame, text=program, variable=var, bg="gray20", selectcolor="green", activebackground="pale green")
                    chk.grid(row=i, column=j*2, sticky="w")
                    self.program_vars[program] = var
                    self.program_checkboxes[program] = chk
                    chk.config(fg="white")
                    var.trace_add("write", update_fg_color)
         
                    # Creează progres bar-ul pentru fiecare program și îl pune sub checkbox
                    self.progress_bars[program] = ttk.Progressbar(self.program_frame, orient="horizontal", length=200, mode="determinate", style="custom.Horizontal.TProgressbar")
                    self.progress_bars[program].grid(row=i, column=j*2+1, sticky="ew", padx=10, pady=2)
         
                    program_index += 1
         
            # Stilizare progres bar personalizat
            self.style = ttk.Style()
            self.style.theme_use('default')
            self.style.configure("custom.Horizontal.TProgressbar", troughcolor='gray', background='green', borderwidth=0)

            # Frame pentru butonul de copiere
            self.copy_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.copy_button_frame.pack(pady=10, padx=10)

            # Plasează butonul de copiere direct în self.right_frame
            self.copy_button = tk.Button(self.right_frame, text="Copy Files", command=self.copy_files, bg="cyan", fg="black", bd=6)
            self.copy_button.pack(pady=10, padx=10)

            # Buton stergere campuri checkbox
            self.delete_button = tk.Button(self.right_frame, text="Delete checkboxes", command=self.delete_checkboxes, bg="red", fg="black", bd=6)
            self.delete_button.pack(pady=10, padx=10)

            self.bandmonitoring_button = tk.Button(self.right_frame, text="Network Console", command=self.band_network_monitoring, bg="gray40", fg="lime green", bd=5)
            self.bandmonitoring_button.pack(pady=5)
                
            # Butonul pentru a ieși din aplicație
            self.button_exit = tk.Button(self.checkbox_button_frame, text="EXIT", command=self.exit_application, bg="red", fg="white", bd=10)
            self.button_exit.pack(pady=20)

            self.last_received = 0
            self.last_sent = 0
            self.last_total = 0
            self.running = False

        def load_profiles_and_create_buttons(self):
            # Încarcă profilurile din JSON
            with open("profiles.json", "r") as f:
                self.profiles = json.load(f)

            # Creează butoanele pentru fiecare profil
            for profile_name in self.profiles:
                button = tk.Button(self.checkbox_button_frame, text=profile_name,
                                command=lambda p=profile_name: self.select_profile_checkboxes(p),
                                bg="gray40", fg="white", bd=1)
                button.pack(pady=5, padx=10)

        def select_profile_checkboxes(self, profile_name):
            # Resetează toate checkbox-urile
            for program in self.program_vars:
                self.program_vars[program].set(0)

            # Resetează barele de progres
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0

            # Resetează textul checkbox-urilor care se termină cu " (done)"
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                if current_text.endswith(" (done)"):
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)

            # Verifică dacă profilul există
            if profile_name in self.profiles:
                profile_checkboxes = self.profiles[profile_name]["checkboxes"]
                for program in profile_checkboxes:
                    if program in self.program_vars:
                        self.program_vars[program].set(1)
    ##############################################################################################################################################################    
                
         
        def exit_application(self):
            if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
                root.destroy()
         
    ###############################################################################
        def band_network_monitoring(self):
            def update_data():
                while self.running:
                    bytes_received = psutil.net_io_counters().bytes_recv
                    bytes_sent = psutil.net_io_counters().bytes_sent
                    bytes_total = bytes_received + bytes_sent
                        
                    new_received = bytes_received - self.last_received if hasattr(self, 'last_received') else 0
                    new_sent = bytes_sent - self.last_sent if hasattr(self, 'last_sent') else 0
                    new_total = bytes_total - self.last_total if hasattr(self, 'last_total') else 0
                  
                    mb_new_received = new_received / 1024 / 1024
                    mb_new_sent = new_sent / 1024 / 1024
                    mb_new_total = new_total / 1024 / 1024
                        
                    # Actualizează textul în text area cu noile date
                    text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                    text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                        
                    # Salvează datele în fișier
                    with open("network_data.txt", "a") as file:
                        file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        
                    print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                        
                    self.last_received = bytes_received
                    self.last_sent = bytes_sent
                    self.last_total = bytes_total
                        
                    time.sleep(1)

            def start():
                self.running = True
                # Șterge conținutul text area-ului la fiecare pornire
                text_area.delete(1.0, tk.END)
                # Crează un thread nou pentru actualizarea datelor
                data_thread = threading.Thread(target=update_data)
                data_thread.start()

            def stop():
                self.running = False

            # Crează fereastra
            monitorband = tk.Toplevel()
            monitorband.title("Network Console")
            monitorband.resizable(False, False)
            monitorband.config(bg="gray20")
            #image_icon44 = PhotoImage(file = "img/networklogo.png")
            #monitorband.iconphoto(False, image_icon44)

            # Creează un text area cu culoare de fundal și text personalizate
            text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
            text_area.pack(expand=True, fill=tk.BOTH)

            # Buton pentru pornirea monitorizării
            start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
            start_button.pack()

            # Buton pentru oprirea monitorizării
            stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
            stop_button.pack()

            # Inițializare variabile
            self.last_received = psutil.net_io_counters().bytes_recv
            self.last_sent = psutil.net_io_counters().bytes_sent
            self.last_total = self.last_received + self.last_sent
            self.running = False

            # Pornirea buclei principale a interfeței grafice
            #monitorband.mainloop()
    ###############################################################################
         
        def delete_checkboxes(self):
            for program in self.program_vars:
                self.program_vars[program].set(0)
            #self.program_vars[""].set(0)
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                # Verificăm dacă textul se termină cu " (done)"
                if current_text.endswith(" (done)"):
                    # Eliminăm ultimele 77 caractere din textul curent și actualizăm textul checkbox-ului
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)
         
        def on_canvas_configure(self, event):
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
         
        def copy_files(self):
            self.copy_button.config(state="disabled")  # Dezactivează butonul de copiere
            #self.select_Director_button.config(state="disabled")
            selected_programs = [program for program, var in self.program_vars.items() if var.get() == 1]
            if not selected_programs:
                messagebox.showwarning("No program selected", "Please select at least one program to copy the files.")
                self.copy_button.config(state="normal")  # Activează butonul de copiere
                #self.select_Director_button.config(state="normal")
                return
         
            # Funcție pentru a actualiza textul checkbox-urilor cu "done"
            def update_checkbox_text():
                for program in selected_programs:
                    checkbox = self.program_checkboxes[program]
                    checkbox.config(text=program + " (done)")
         
            # Funcție pentru a realiza copierea fișierelor într-un fir de execuție separat
            def copy_files_thread():
                try:
                    for program in selected_programs:
                        program_source = self.program_paths[program]
                        if os.path.exists(program_source):
                            # Crează un director pentru a stoca fișierele copiate
                            save_directory = os.path.join(self.destination_path, os.path.basename(program_source))
                            os.makedirs(save_directory, exist_ok=True)
                            if os.path.isdir(program_source):
                                # Dacă sursa este un director, copiază întregul director
                                total_files = sum(len(files) for _, _, files in os.walk(program_source))  # Calculăm numărul total de fișiere
                                files_copied = 0  # Inițializăm contorul pentru fișierele copiate
                                for root, dirs, files in os.walk(program_source):
                                    for dir in dirs:
                                        src = os.path.join(root, dir)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        os.makedirs(dest, exist_ok=True)
                                    for file in files:
                                        src = os.path.join(root, file)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        # Verificăm dacă fișierul de destinație există deja
                                        if not os.path.exists(dest):
                                            shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                        # Actualizăm progresul
                                        files_copied += 1
                                        progress_value = (files_copied / total_files) * 100
                                        self.progress_bars[program]["value"] = progress_value
                                        self.root.update_idletasks()  # Actualizează interfața grafică
         
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                            else:
                                # Dacă sursa este un fișier, copiază doar fișierul
                                total_files = 1  # Avem un singur fișier de copiat
                                files_copied = 0
                                file_name = os.path.basename(program_source)
                                src = program_source
                                dest = os.path.join(save_directory, file_name)
                                # Verificăm dacă fișierul de destinație există deja
                                if not os.path.exists(dest):
                                    shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                files_copied += 1
                                progress_value = (files_copied / total_files) * 100
                                self.progress_bars[program]["value"] = progress_value
                                self.root.update_idletasks()  # Actualizează interfața grafică
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                    # Afisăm mesajul de finalizare a copierii
                    self.root.after(0, self.show_copy_success)
        
                except Exception as ex:
                    # Afisăm mesaj de eroare dacă apare o excepție
                    self.root.after(0, lambda e=ex: self.show_copy_error(e))
        
                finally:
                    # Activează butonul de copiere după finalizarea copierii
                    self.root.after(0, self.enable_copy_button)
         
            # Pornim firul de execuție pentru copierea fișierelor
            threading.Thread(target=copy_files_thread).start()
         
         
        def show_copy_success(self):
            messagebox.showinfo("Copy completed", "The files have been successfully copied.")
         
        def show_copy_error(self, error_message):
            messagebox.showerror("Error copying", f"An error occurred while copying the files: {str(error_message)}")
         
        def enable_copy_button(self):
            self.copy_button.config(state="normal")
         
    def browse_folder():
        folder_path = filedialog.askdirectory()
        if folder_path:
            folder_path = folder_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("folder_paths.txt", "a") as file:
                file.write(folder_path + "\n")
         
    def browse_file():
        file_path = filedialog.askopenfilename()
        if file_path:
            file_path = file_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("file_paths.txt", "a") as file:
                file.write(file_path + "\n")
         
    def copy_file():
        with open("file_paths.txt", "r") as file:
            file_paths = file.readlines()
        for file_path in file_paths:
            file_path = file_path.strip()  # Eliminăm caracterele de nouă linie și spații suplimentare
            shutil.copy2(file_path, save_location.get())
         
    def copy_folder():
        with open("folder_paths.txt", "r") as file:
            folder_paths = file.readlines()
        for folder_path in folder_paths:
            folder_path = folder_path.strip()
            save_path = os.path.join(save_location.get(), os.path.basename(folder_path))
            try:
                shutil.copytree(folder_path, save_path)
            except PermissionError:
                messagebox.showerror("Error", "Access to the source folder is denied.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {str(e)}")
         
    def update_buttons_state():
        if save_location.get():
            button_copy_file.config(state="normal")
            button_copy_folder.config(state="normal")
        else:
            button_copy_file.config(state="disabled")
            button_copy_folder.config(state="disabled")
         
    def select_save_location():
        save_location.set(filedialog.askdirectory())
        update_buttons_state()
         
    def open_copy_window():
        global button_copy_file, button_copy_folder
        copy_window = tk.Toplevel(root)
        copy_window.title("Copy Files/Folders")
        copy_window.config(bg="gray20")  # Setare culoare fundal gri închis
        copy_window.resizable(False, False)
        #image_icon46 = PhotoImage(file = "img/downloadlogo.png")
        #copy_window.iconphoto(False, image_icon46)
         
        frame = tk.Frame(copy_window)
        frame.pack(padx=20, pady=20)
        
        button_copy_file = tk.Button(frame, text="Copy Files", command=copy_file, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_file.pack(padx=10, pady=5)
         
        button_copy_folder = tk.Button(frame, text="Copy Folders", command=copy_folder, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_folder.pack(padx=10, pady=5)
         
        button_select_location = tk.Button(frame, text="Select Save Location", command=select_save_location, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_select_location.pack(padx=10, pady=5)
         
        update_buttons_state()
         
        copy_window.mainloop()
         
    def open_file_explorer_window():
        file_explorer_window = tk.Toplevel(root)
        file_explorer_window.title("Browse in File Explorer")
        file_explorer_window.config(bg="gray20")  # Setare culoare fundal gri închis
        file_explorer_window.resizable(False, False)
        #image_icon47 = PhotoImage(file = "img/downloadlogo.png")
        #file_explorer_window.iconphoto(False, image_icon47)
         
        frame = tk.Frame(file_explorer_window, bg="gray20")  # Setare culoare fundal gri închis
        frame.pack(padx=20, pady=20)
         
        button_folder = tk.Button(frame, text="Select a Folder", command=browse_folder, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordura
        button_folder.pack(padx=10, pady=5)
         
        button_file = tk.Button(frame, text="Select a File", command=browse_file, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_file.pack(padx=10, pady=5)
         
        button_open_copy_window = tk.Button(frame, text="Open Copy Window", command=open_copy_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_open_copy_window.pack(padx=10, pady=5)
         
    def open_file_copy_app_window():
        file_copy_app_window = tk.Toplevel(root)
        file_copy_app_window.title("Copy App Defaults")
        file_copy_app_window.config(bg="gray20")  # Setare culoare fundal gri închis
        # Dezactivarea posibilității de redimensionare a ferestrei
        file_copy_app_window.resizable(False, False)
        #image_icon48 = PhotoImage(file = "img/downloadlogo.png")
        #file_copy_app_window.iconphoto(False, image_icon48)
        # Maximizarea ferestrei
        file_copy_app_window.state("zoomed")
        app = FileCopyApp(file_copy_app_window)
     
    def ExecuteIPandMAC():
        pass
     
    root = tk.Tk()
    root.title("Menu")
    root.geometry("300x790+10+10")
    root.config(bg="gray20")  # Setare culoare fundal gri închis
    root.resizable(False, False)
    image_icon39 = PhotoImage(file = "img/appslogo.png")
    root.iconphoto(False, image_icon39)
     
    main_frame = tk.Frame(root, bg="gray20")  # Setare culoare fundal gri închis
    main_frame.pack(padx=20, pady=20)
     
    button_open_file_explorer = tk.Button(main_frame, text="Explorer Mode", command=open_file_explorer_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
    button_open_file_explorer.pack(padx=10, pady=5)
     
    button_open_file_copy_app = tk.Button(main_frame, text="Copy App", command=open_file_copy_app_window, bg="gray40", fg="white", bd=1)  # Schimbare scris negru
    button_open_file_copy_app.pack(padx=10, pady=5)
     
    button_network = tk.Button(main_frame, text="Get Ip & MAC", command=ExecuteIPandMAC, bg="black", fg="white", bd=1, state="disabled")  # Schimbare scris negru + gray40
    button_network.pack(padx=10, pady=5)
     
    # ==== Scanning Functions ====
    def PortScanner():
        pass
     
    button_portscanner = tk.Button(main_frame, text="Port Scanner", command=PortScanner, bg="black", fg="white", bd=1, state="disabled")
    button_portscanner.pack(padx=10, pady=5)
     
    def PingTool():
        pass
     
    button_ping = tk.Button(main_frame, text="Ping Tool", command=PingTool, bg="black", fg="white", bd=1, state="disabled") #gray40
    button_ping.pack(padx=10, pady=5)
     
    def Comparator():
        pass
     
    button_pydiff = tk.Button(main_frame, text="Comparator", command=Comparator, bg="black", fg="white", bd=1, state="disabled") #gray40
    button_pydiff.pack(padx=10, pady=5)
     
    def ReplAndFind():
        pass

    button_findrepl = tk.Button(main_frame, text="Find & Replace text", command=ReplAndFind, bg="black", fg="white", bd=1, state="disabled") #black
    button_findrepl.pack(padx=10, pady=5) 

    def ScreenRec():
        pass

    scrrec_button = tk.Button(main_frame, text="Screen Events", command=ScreenRec, bg="black", fg="white", bd=1, state="disabled") #black
    scrrec_button.pack(padx=10, pady=5)

    def ZIPF():
        pass

    button_zip = tk.Button(main_frame, text="Create/Extract ZIP", command=ZIPF, bg="black", fg="white", bd=1, state="disabled") #black
    button_zip.pack(padx=10, pady=5)
     
    def open_excel_and_display_table():
        pass
     
    def display_table(wb, sheet_name):
        pass
     
     
    # Creating a button to open the Excel file and display the table
    open_button = tk.Button(main_frame, text="Open the Equipment Sheet", command=open_excel_and_display_table, bg="black", fg="white", bd=1, state="disabled") #gray40
    open_button.pack(pady=5)
     
    def OpenNotepad():
        pass

    open_notepad_button = tk.Button(main_frame, text="Text Editor", command=OpenNotepad, bg="black", fg="white", bd=1, state="disabled") #gray40
    open_notepad_button.pack(pady=5)
    
    def OpenPaint():
        pass
    
    open_paint_button = Button(main_frame, text="Whiteboard", command=OpenPaint, bg="black", fg="white", bd=1, state="disabled") #gray40
    open_paint_button.pack(pady=5)    
    
    def PDFToWordConv():
        pass
        
    WP = tk.Button(main_frame, text="PDF to Word", command=PDFToWordConv, bg="black", fg="white", bd=1, state="disabled") #bg=gray40
    WP.pack(pady=5)

    def pdftools():
        pass

    pdftools_button = tk.Button(main_frame, text="PDF Tools", command=pdftools, bg="Black", fg="white", bd=1, state="disabled") #bg=black
    pdftools_button.pack(pady=5) 

    def BackupRestore():
        pass
    
    bkr_button = tk.Button(main_frame, text="Backup Utility", command=BackupRestore, bg="black", fg="white", bd=1, state="disabled") #bg=gray40
    bkr_button.pack(pady=5)  
    
    def Renamer():
        pass

    rn_button = tk.Button(main_frame, text="Rename Utility", command=Renamer, bg="black", fg="white", bd=1, state="disabled") #bg=gray40
    rn_button.pack(pady=5) 

    def SystemInfoFunc():
        pass

    SystemInfo_button = tk.Button(main_frame, text="System Info", command=SystemInfoFunc, bg="black", fg="white", bd=1, state="disabled")
    SystemInfo_button.pack(pady=5)

    '''
    def run_dearpygui_in_thread():
        pass

    AllInfo_button = tk.Button(main_frame, text="Real Time System Info", command=run_dearpygui_in_thread, bg="black", fg="white", bd=1, state="disabled") #gray40
    AllInfo_button.pack(pady=5)
    '''

    def BandNetworkMonitoring():
        def update_data():
            global last_received, last_sent, last_total, running
            
            while running:
                bytes_received = psutil.net_io_counters().bytes_recv
                bytes_sent = psutil.net_io_counters().bytes_sent
                bytes_total = bytes_received + bytes_sent
                
                new_received = bytes_received - last_received if 'last_received' in globals() else 0
                new_sent = bytes_sent - last_sent if 'last_sent' in globals() else 0
                new_total = bytes_total - last_total if 'last_total' in globals() else 0
                
                mb_new_received = new_received / 1024 / 1024
                mb_new_sent = new_sent / 1024 / 1024
                mb_new_total = new_total / 1024 / 1024
                
                # Actualizează textul în text area cu noile date
                text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                
                # Salvează datele în fișier
                with open("network_data.txt", "a") as file:
                    file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                
                print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                
                last_received = bytes_received
                last_sent = bytes_sent
                last_total = bytes_total
                
                time.sleep(1)

        def start():
            global running
            running = True
            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Crează un thread nou pentru actualizarea datelor
            data_thread = threading.Thread(target=update_data)
            data_thread.start()

        def stop():
            global running
            running = False

        # Inițializare variabile
        last_received = psutil.net_io_counters().bytes_recv
        last_sent = psutil.net_io_counters().bytes_sent
        last_total = last_received + last_sent
        running = False
        
        # Crează fereastra
        monitorband = tk.Tk()
        monitorband.title("Network Console")
        monitorband.resizable(False, False)
        monitorband.config(bg="gray20")
        image_icon40 = PhotoImage(file = "img/networklogo.png")
        monitorband.iconphoto(False, image_icon40)

        # Creează un text area cu culoare de fundal și text personalizate
        text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
        text_area.pack(expand=True, fill=tk.BOTH)

        # Buton pentru pornirea monitorizării
        start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
        start_button.pack()

        # Buton pentru oprirea monitorizării
        stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
        stop_button.pack()

        # Pornirea buclei principale a interfeței grafice
        monitorband.mainloop()
        
    bandmonitoring_button = tk.Button(main_frame, text="Network Console", command=BandNetworkMonitoring, bg="black", fg="white", bd=1, state="disabled") #gray40
    bandmonitoring_button.pack(pady=1)

    def AIChatbot():
        pass

    AI_button = tk.Button(main_frame, text="AI Chatbot", command=AIChatbot, bg="black", fg="white", bd=1, state="disabled")
    AI_button.pack(pady=5)

    def ReadMe():
        # Funcția pentru închiderea ferestrei
        def inchide_fereastra():
            readme.destroy()
     
        # Crearea ferestrei principale
        readme = tk.Toplevel()
        readme.title("Working procedure (Copy App)")
        readme.geometry("700x350")
        readme.config(bg="gray20")  # Setare culoare fundal gri închis
        #image_icon50 = PhotoImage(file = "img/complogo.png")
        #readme.iconphoto(False, image_icon50)
        
        # Crearea obiectului Text și inserarea textului
        text = scrolledtext.ScrolledText(readme, wrap="word", height=10, width=40)
        text.insert(tk.END, "To avoid potential errors, it is recommended to run the program as the corresponding domain user. Additionally, there must be a network location mapping, and you should have access to that location, of course. You need to manually configure the paths.txt and profiles.json files (according to the example).\n")
        text.configure(state="disabled")  # Textul nu poate fi editat
        text.pack(expand=True, fill="both", padx=10, pady=10)
     
     
    readme_button = tk.Button(main_frame, text="Read me first", command=ReadMe, bg="gray40", fg="cyan", bd=5)
    readme_button.pack(pady=7)

    def DebuggingConsoleFunc():
        pass

    Debugging_button = tk.Button(main_frame, text="Dev Console", command=ReadMe, bg="black", fg="#ff8080", bd=5, state="disabled")
    Debugging_button.pack(pady=7)
     
    save_location = tk.StringVar()
     
    root.mainloop()


'''
# Definirea cheii de validare
KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"

def validate_key(event=None):
    # Funcția pentru validarea cheii
    if text_box.get("1.0", "end-1c").strip() == KEY:
        validate_button.config(state=tk.NORMAL)
        no_key_button.config(state=tk.DISABLED)
    else:
        validate_button.config(state=tk.DISABLED)
        no_key_button.config(state=tk.NORMAL)

# Crearea ferestrei principale pentru validare
validation = tk.Tk()
validation.title("Product key validation")
validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
validation.config(bg="gray20")

# Crearea obiectului Text editabil
text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
text_box.config(bd=4)
text_box.pack(pady=10)
text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

# Crearea butonului "I don't have a product key"
no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=main2)
no_key_button.pack(pady=5)

# Crearea butonului "Validate key"
validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=main1, state=tk.DISABLED)
validate_button.pack(pady=5)

# Rularea buclei principale
validation.mainloop()
'''

if show_validation == True:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass


    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon42 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon42)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=main2)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=main1, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

elif trmn != 2 and passfig != 4 and passfig1 != 5 and hardvar != 6 and screenvar != 7 and zipvar != 8 and compvar != 9 and pdfvar != 10 and replfindvar != 11 and testvarr != 12 and testvarr2 != 122 and pdfvwvar != 13 and netwvar != 14 and crpvar2 != 155 and aivar != 20 and notepadvar != 21 and paintvar != 22 and Adm1var != 30 and  Adm2var != 40 and zippassvar != 60 and bkvar != 700 and rnvar != 710 and kbvar != 1000 and passmngrr != 2000 and pausevar != 10000 and taskmngrvar != 1000000 and show_validation == False and junkvar != 77777 and wbpvar != 123456789 and cmvar != 3333 and pingalivevar != 5566 and launchervar != 1990 and launchervar_admin != 1991 and excelvar != 1992 and readervar != 1993 and hardmvar != 1994 and fetchervar != 1995 and shellvar != 1996 and w95var != 1997 and sqllvar != 22222 and diagramvar != 2345432 and termadm != 6745 and commandervar != 88888888 and calendarvar != 999000 and allmonitorvar != 999001 and eventvval != 44445555 and assemblyvar != 333333333 and kbbbvar != 5189:
    def main3():
        class FileCopyApp:
            def __init__(self, root):
                self.root = root
                self.root.title("Copy App")
                self.root.geometry("400x400")
                self.root.config(bg="gray20")

                # Directorul destinație
                self.current_user = os.getenv('USERNAME')
                self.destination_path = rf'C:\KIT'

                # Verifică dacă calea de destinație există
                if not os.path.exists(self.destination_path):
                    try:
                        # Creează calea de destinație dacă nu există
                        os.makedirs(self.destination_path)
                        print("Director successfully created:", self.destination_path)
                    except OSError as e:
                        print("Error creating directory:", e)

                # Dicționarul cu programe și direcțiile lor sursă
                self.program_paths = {}

                # Deschide fișierul pentru citire
                with open("paths.txt", "r") as file:
                    for line in file:
                        key, value = line.strip().split(":")
                        self.program_paths[key.strip()] = value.strip()

                # Frame-uri pentru fiecare jumătate a ferestrei
                self.left_frame = tk.Frame(root, bg="gray20")
                self.left_frame.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.BOTH, expand=True)

                self.right_frame = tk.Frame(root, bg="gray20")
                self.right_frame.pack(side=tk.RIGHT, padx=5, pady=5, fill=tk.Y)

                # Canvas pentru lista de programe cu scrollbar
                self.canvas = tk.Canvas(self.left_frame, bg="gray20", highlightthickness=0)
                self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

                self.scrollbar = ttk.Scrollbar(self.right_frame, orient="vertical", command=self.canvas.yview)
                self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

                self.canvas.configure(yscrollcommand=self.scrollbar.set)
                self.canvas.bind('<Configure>', self.on_canvas_configure)

                self.program_frame = tk.Frame(self.canvas, bg="gray20")
                self.canvas.create_window((0, 0), window=self.program_frame, anchor='nw')

                # Funcție pentru actualizarea culorii textului în funcție de starea checkbox-ului
                def update_fg_color(*args):
                    for program, var in self.program_vars.items():
                        if var.get() == 1:
                            chk = self.program_checkboxes[program]
                            chk.config(fg="cyan")
                        else:
                            chk = self.program_checkboxes[program]
                            chk.config(fg="white")

                # Checkbox-uri și progres bar-uri pentru programe
                self.program_vars = {}
                self.program_checkboxes = {}
                self.progress_bars = {}

                # Frame pentru butoanele de selecție a checkbox-urilor
                self.checkbox_button_frame = tk.Frame(self.right_frame, bg="gray20")
                self.checkbox_button_frame.pack(pady=10, padx=10)

                # Încarcă profilele și creează butoanele
                self.load_profiles_and_create_buttons()

                col_count = 2  # Numărul de coloane dorit
                row_count = -(-len(self.program_paths) // col_count)  # Calculul numărului de rânduri necesare
                program_index = 0  # Variabilă pentru a ține evidența indexului programului
         
                for i in range(row_count):
                    for j in range(col_count):
                        if program_index >= len(self.program_paths):
                            break
                        program = list(self.program_paths.keys())[program_index]
                        var = tk.IntVar()
                        chk = tk.Checkbutton(self.program_frame, text=program, variable=var, bg="gray20", selectcolor="green", activebackground="pale green")
                        chk.grid(row=i, column=j*2, sticky="w")
                        self.program_vars[program] = var
                        self.program_checkboxes[program] = chk
                        chk.config(fg="white")
                        var.trace_add("write", update_fg_color)
         
                        # Creează progres bar-ul pentru fiecare program și îl pune sub checkbox
                        self.progress_bars[program] = ttk.Progressbar(self.program_frame, orient="horizontal", length=200, mode="determinate", style="custom.Horizontal.TProgressbar")
                        self.progress_bars[program].grid(row=i, column=j*2+1, sticky="ew", padx=10, pady=2)
         
                        program_index += 1
         
                # Stilizare progres bar personalizat
                self.style = ttk.Style()
                self.style.theme_use('default')
                self.style.configure("custom.Horizontal.TProgressbar", troughcolor='gray', background='green', borderwidth=0)

                # Frame pentru butonul de copiere
                self.copy_button_frame = tk.Frame(self.right_frame, bg="gray20")
                self.copy_button_frame.pack(pady=10, padx=10)

                # Plasează butonul de copiere direct în self.right_frame
                self.copy_button = tk.Button(self.right_frame, text="Copy Files", command=self.copy_files, bg="cyan", fg="black", bd=6)
                self.copy_button.pack(pady=10, padx=10)

                # Buton stergere campuri checkbox
                self.delete_button = tk.Button(self.right_frame, text="Delete checkboxes", command=self.delete_checkboxes, bg="red", fg="black", bd=6)
                self.delete_button.pack(pady=10, padx=10)

                self.bandmonitoring_button = tk.Button(self.right_frame, text="Network Console", command=self.band_network_monitoring, bg="gray40", fg="lime green", bd=5)
                self.bandmonitoring_button.pack(pady=5)
                
                # Butonul pentru a ieși din aplicație
                self.button_exit = tk.Button(self.checkbox_button_frame, text="EXIT", command=self.exit_application, bg="red", fg="white", bd=10)
                self.button_exit.pack(pady=20)

                self.last_received = 0
                self.last_sent = 0
                self.last_total = 0
                self.running = False

            def load_profiles_and_create_buttons(self):
                # Încarcă profilurile din JSON
                with open("profiles.json", "r") as f:
                    self.profiles = json.load(f)

                # Creează butoanele pentru fiecare profil
                for profile_name in self.profiles:
                    button = tk.Button(self.checkbox_button_frame, text=profile_name,
                                    command=lambda p=profile_name: self.select_profile_checkboxes(p),
                                    bg="gray40", fg="white", bd=1)
                    button.pack(pady=5, padx=10)

            def select_profile_checkboxes(self, profile_name):
                # Resetează toate checkbox-urile
                for program in self.program_vars:
                    self.program_vars[program].set(0)

                # Resetează barele de progres
                for progress_bar in self.progress_bars.values():
                    progress_bar["value"] = 0

                # Resetează textul checkbox-urilor care se termină cu " (done)"
                for program in self.program_checkboxes:
                    current_text = self.program_checkboxes[program].cget("text")
                    if current_text.endswith(" (done)"):
                        updated_text = current_text[:-7]
                        self.program_checkboxes[program].config(text=updated_text)

                # Verifică dacă profilul există
                if profile_name in self.profiles:
                    profile_checkboxes = self.profiles[profile_name]["checkboxes"]
                    for program in profile_checkboxes:
                        if program in self.program_vars:
                            self.program_vars[program].set(1)
        ##############################################################################################################################################################    
                
         
            def exit_application(self):
                if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
                    root.destroy()
         
        ###############################################################################
            def band_network_monitoring(self):
                def update_data():
                    while self.running:
                        bytes_received = psutil.net_io_counters().bytes_recv
                        bytes_sent = psutil.net_io_counters().bytes_sent
                        bytes_total = bytes_received + bytes_sent
                        
                        new_received = bytes_received - self.last_received if hasattr(self, 'last_received') else 0
                        new_sent = bytes_sent - self.last_sent if hasattr(self, 'last_sent') else 0
                        new_total = bytes_total - self.last_total if hasattr(self, 'last_total') else 0
                        
                        mb_new_received = new_received / 1024 / 1024
                        mb_new_sent = new_sent / 1024 / 1024
                        mb_new_total = new_total / 1024 / 1024
                        
                        # Actualizează textul în text area cu noile date
                        text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                        
                        # Salvează datele în fișier
                        with open("network_data.txt", "a") as file:
                            file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        
                        print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                        
                        self.last_received = bytes_received
                        self.last_sent = bytes_sent
                        self.last_total = bytes_total
                        
                        time.sleep(1)

                def start():
                    self.running = True
                    # Șterge conținutul text area-ului la fiecare pornire
                    text_area.delete(1.0, tk.END)
                    # Crează un thread nou pentru actualizarea datelor
                    data_thread = threading.Thread(target=update_data)
                    data_thread.start()

                def stop():
                    self.running = False

                # Crează fereastra
                monitorband = tk.Toplevel()
                monitorband.title("Network Console")
                monitorband.resizable(False, False)
                monitorband.config(bg="gray20")
                #image_icon44 = PhotoImage(file = "img/networklogo.png")
                #monitorband.iconphoto(False, image_icon44)

                # Creează un text area cu culoare de fundal și text personalizate
                text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
                text_area.pack(expand=True, fill=tk.BOTH)

                # Buton pentru pornirea monitorizării
                start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
                start_button.pack()

                # Buton pentru oprirea monitorizării
                stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
                stop_button.pack()

                # Inițializare variabile
                self.last_received = psutil.net_io_counters().bytes_recv
                self.last_sent = psutil.net_io_counters().bytes_sent
                self.last_total = self.last_received + self.last_sent
                self.running = False

                # Pornirea buclei principale a interfeței grafice
                #monitorband.mainloop()
        ###############################################################################
         
            def delete_checkboxes(self):
                for program in self.program_vars:
                    self.program_vars[program].set(0)
                #self.program_vars[""].set(0)
                for progress_bar in self.progress_bars.values():
                    progress_bar["value"] = 0
                for program in self.program_checkboxes:
                    current_text = self.program_checkboxes[program].cget("text")
                    # Verificăm dacă textul se termină cu " (done)"
                    if current_text.endswith(" (done)"):
                        # Eliminăm ultimele 77 caractere din textul curent și actualizăm textul checkbox-ului
                        updated_text = current_text[:-7]
                        self.program_checkboxes[program].config(text=updated_text)
         
            def on_canvas_configure(self, event):
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))
         
            def copy_files(self):
                self.copy_button.config(state="disabled")  # Dezactivează butonul de copiere
                #self.select_Director_button.config(state="disabled")
                selected_programs = [program for program, var in self.program_vars.items() if var.get() == 1]
                if not selected_programs:
                    messagebox.showwarning("No program selected", "Please select at least one program to copy the files.")
                    self.copy_button.config(state="normal")  # Activează butonul de copiere
                    #self.select_Director_button.config(state="normal")
                    return
         
                # Funcție pentru a actualiza textul checkbox-urilor cu "done"
                def update_checkbox_text():
                    for program in selected_programs:
                        checkbox = self.program_checkboxes[program]
                        checkbox.config(text=program + " (done)")
         
                # Funcție pentru a realiza copierea fișierelor într-un fir de execuție separat
                def copy_files_thread():
                    try:
                        for program in selected_programs:
                            program_source = self.program_paths[program]
                            if os.path.exists(program_source):
                                # Crează un director pentru a stoca fișierele copiate
                                save_directory = os.path.join(self.destination_path, os.path.basename(program_source))
                                os.makedirs(save_directory, exist_ok=True)
                                if os.path.isdir(program_source):
                                    # Dacă sursa este un director, copiază întregul director
                                    total_files = sum(len(files) for _, _, files in os.walk(program_source))  # Calculăm numărul total de fișiere
                                    files_copied = 0  # Inițializăm contorul pentru fișierele copiate
                                    for root, dirs, files in os.walk(program_source):
                                        for dir in dirs:
                                            src = os.path.join(root, dir)
                                            dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                            os.makedirs(dest, exist_ok=True)
                                        for file in files:
                                            src = os.path.join(root, file)
                                            dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                            # Verificăm dacă fișierul de destinație există deja
                                            if not os.path.exists(dest):
                                                shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                            # Actualizăm progresul
                                            files_copied += 1
                                            progress_value = (files_copied / total_files) * 100
                                            self.progress_bars[program]["value"] = progress_value
                                            self.root.update_idletasks()  # Actualizează interfața grafică
         
                                    # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                    self.program_checkboxes[program].config(text=program + " (done)")
         
                                else:
                                    # Dacă sursa este un fișier, copiază doar fișierul
                                    total_files = 1  # Avem un singur fișier de copiat
                                    files_copied = 0
                                    file_name = os.path.basename(program_source)
                                    src = program_source
                                    dest = os.path.join(save_directory, file_name)
                                    # Verificăm dacă fișierul de destinație există deja
                                    if not os.path.exists(dest):
                                        shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                    files_copied += 1
                                    progress_value = (files_copied / total_files) * 100
                                    self.progress_bars[program]["value"] = progress_value
                                    self.root.update_idletasks()  # Actualizează interfața grafică
                                    # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                    self.program_checkboxes[program].config(text=program + " (done)")
         
                        # Afisăm mesajul de finalizare a copierii
                        self.root.after(0, self.show_copy_success)
         
                    except Exception as ex:
                        # Afisăm mesaj de eroare dacă apare o excepție
                        self.root.after(0, lambda e=ex: self.show_copy_error(e))
         
                    finally:
                        # Activează butonul de copiere după finalizarea copierii
                        self.root.after(0, self.enable_copy_button)
         
                # Pornim firul de execuție pentru copierea fișierelor
                threading.Thread(target=copy_files_thread).start()
         
         
            def show_copy_success(self):
                messagebox.showinfo("Copy completed", "The files have been successfully copied.")
         
            def show_copy_error(self, error_message):
                messagebox.showerror("Error copying", f"An error occurred while copying the files: {str(error_message)}")
         
            def enable_copy_button(self):
                self.copy_button.config(state="normal")
         
        def browse_folder():
            folder_path = filedialog.askdirectory()
            if folder_path:
                folder_path = folder_path.replace("/", "\\")  # înlocuim '/' cu '\'
                with open("folder_paths.txt", "a") as file:
                    file.write(folder_path + "\n")
         
        def browse_file():
            file_path = filedialog.askopenfilename()
            if file_path:
                file_path = file_path.replace("/", "\\")  # înlocuim '/' cu '\'
                with open("file_paths.txt", "a") as file:
                    file.write(file_path + "\n")
         
        def copy_file():
            with open("file_paths.txt", "r") as file:
                file_paths = file.readlines()
            for file_path in file_paths:
                file_path = file_path.strip()  # Eliminăm caracterele de nouă linie și spații suplimentare
                shutil.copy2(file_path, save_location.get())
         
        def copy_folder():
            with open("folder_paths.txt", "r") as file:
                folder_paths = file.readlines()
            for folder_path in folder_paths:
                folder_path = folder_path.strip()
                save_path = os.path.join(save_location.get(), os.path.basename(folder_path))
                try:
                    shutil.copytree(folder_path, save_path)
                except PermissionError:
                    messagebox.showerror("Error", "Access to the source folder is denied.")
                except Exception as e:
                    messagebox.showerror("Error", f"An error occurred: {str(e)}")
         
        def update_buttons_state():
            if save_location.get():
                button_copy_file.config(state="normal")
                button_copy_folder.config(state="normal")
            else:
                button_copy_file.config(state="disabled")
                button_copy_folder.config(state="disabled")
         
        def select_save_location():
            save_location.set(filedialog.askdirectory())
            update_buttons_state()
         
        def open_copy_window():
            global button_copy_file, button_copy_folder
            copy_window = tk.Toplevel(root)
            copy_window.title("Copy Files/Folders")
            copy_window.config(bg="gray20")  # Setare culoare fundal gri închis
            copy_window.resizable(False, False)
            #image_icon46 = PhotoImage(file = "img/downloadlogo.png")
            #copy_window.iconphoto(False, image_icon46)
         
            frame = tk.Frame(copy_window)
            frame.pack(padx=20, pady=20)
         
            button_copy_file = tk.Button(frame, text="Copy Files", command=copy_file, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_copy_file.pack(padx=10, pady=5)
         
            button_copy_folder = tk.Button(frame, text="Copy Folders", command=copy_folder, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_copy_folder.pack(padx=10, pady=5)
         
            button_select_location = tk.Button(frame, text="Select Save Location", command=select_save_location, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_select_location.pack(padx=10, pady=5)
         
            update_buttons_state()
         
            copy_window.mainloop()
         
        def open_file_explorer_window():
            file_explorer_window = tk.Toplevel(root)
            file_explorer_window.title("Browse in File Explorer")
            file_explorer_window.config(bg="gray20")  # Setare culoare fundal gri închis
            file_explorer_window.resizable(False, False)
            #image_icon47 = PhotoImage(file = "img/downloadlogo.png")
            #file_explorer_window.iconphoto(False, image_icon47)
         
            frame = tk.Frame(file_explorer_window, bg="gray20")  # Setare culoare fundal gri închis
            frame.pack(padx=20, pady=20)
         
            button_folder = tk.Button(frame, text="Select a Folder", command=browse_folder, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordura
            button_folder.pack(padx=10, pady=5)
         
            button_file = tk.Button(frame, text="Select a File", command=browse_file, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_file.pack(padx=10, pady=5)
         
            button_open_copy_window = tk.Button(frame, text="Open Copy Window", command=open_copy_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_open_copy_window.pack(padx=10, pady=5)
         
        def open_file_copy_app_window():
            file_copy_app_window = tk.Toplevel(root)
            file_copy_app_window.title("Copy App Defaults")
            file_copy_app_window.config(bg="gray20")  # Setare culoare fundal gri închis
            # Dezactivarea posibilității de redimensionare a ferestrei
            file_copy_app_window.resizable(False, False)
            #image_icon48 = PhotoImage(file = "img/downloadlogo.png")
            #file_copy_app_window.iconphoto(False, image_icon48)
            # Maximizarea ferestrei
            file_copy_app_window.state("zoomed")
            app = FileCopyApp(file_copy_app_window)
         
        root = tk.Tk()
        root.title("Menu")
        root.geometry("200x200")
        root.config(bg="gray20")  # Setare culoare fundal gri închis
        root.resizable(False, False)
        #image_icon49 = PhotoImage(file = "img/appslogo.png")
        #root.iconphoto(False, image_icon49)
         
        main_frame = tk.Frame(root, bg="gray20")  # Setare culoare fundal gri închis
        main_frame.pack(padx=20, pady=20)
        
        button_open_file_explorer = tk.Button(main_frame, text="Explorer Mode", command=open_file_explorer_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_open_file_explorer.pack(padx=10, pady=5)
         
        button_open_file_copy_app = tk.Button(main_frame, text="Copy App", command=open_file_copy_app_window, bg="gray40", fg="white", bd=1)  # Schimbare scris negru
        button_open_file_copy_app.pack(padx=10, pady=5)
        
        def ReadMe():
            # Funcția pentru închiderea ferestrei
            def inchide_fereastra():
                readme.destroy()
         
            # Crearea ferestrei principale
            readme = tk.Toplevel()
            readme.title("Working procedure (Copy App)")
            readme.geometry("700x350")
            readme.config(bg="gray20")  # Setare culoare fundal gri închis
            #image_icon50 = PhotoImage(file = "img/complogo.png")
            #readme.iconphoto(False, image_icon50)
            
            # Crearea obiectului Text și inserarea textului
            text = scrolledtext.ScrolledText(readme, wrap="word", height=10, width=40)
            text.insert(tk.END, "To avoid potential errors, it is recommended to run the program as the corresponding domain user. Additionally, there must be a network location mapping, and you should have access to that location, of course. You need to manually configure the paths.txt and profiles.json files (according to the example).\n")
            text.configure(state="disabled")  # Textul nu poate fi editat
            text.pack(expand=True, fill="both", padx=10, pady=10)
         
            # Butonul pentru închiderea ferestrei
            buton_inchide = tk.Button(readme, text="Close", command=inchide_fereastra, bg="gray40", fg="white", bd=10)
            buton_inchide.pack(pady=5)
         
         
        readme_button = tk.Button(main_frame, text="Read me first", command=ReadMe, bg="gray40", fg="cyan", bd=5)
        readme_button.pack(pady=20)
         
        save_location = tk.StringVar()
         
        root.mainloop()
    main3()

if trmn == 2:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon52 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon52)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()


    from tkinter import font
    from tkinter.font import Font
    from tkinter import colorchooser
    import tkinter.messagebox

    import trace
    import traceback
    import threading
    import subprocess
    import os
    import sys
    import json
    from abc import ABC, abstractmethod
    import platform
    import webbrowser

    sys.path.append("..")

    class Interpreter():

        MAPPINGS = {
            "sh"        : "/bin/sh",
            "bash"      : "/bin/bash",
            "windows"   : None
        }

        BACKENDS = {}

        _ICONS = {}

        DEFAULT_SHELL = ""

        @staticmethod
        def add_interpreter(name, backend, icon=None, set_default=False):
            """ Add new interpreter """

            assert(not name in Interpreter.MAPPINGS.keys())
            assert(not name in Interpreter.BACKENDS.keys())

            Interpreter.MAPPINGS[name] = None
            Interpreter.BACKENDS[name] = backend

            if set_default:
                Interpreter.DEFAULT_SHELL = name

            Interpreter._ICONS[name] = icon

        @staticmethod
        def init_backends():
            """ Initialise interpreter backends """

            Interpreter.BACKENDS.clear()

            for name, path in Interpreter.MAPPINGS.items():
                Interpreter.BACKENDS[name] = InterpreterShell(path)

            # Set default interpreter based on operating system
            if (os.name == 'nt'):
                Interpreter.DEFAULT_SHELL = "windows"
            else:
               Interpreter.DEFAULT_SHELL = "bash"

            Interpreter._ICONS.clear()

            Interpreter._ICONS["sh"]        = PhotoImage(file=get_absolute_path(__file__, "img/linux.png"))
            Interpreter._ICONS["bash"]      = PhotoImage(file=get_absolute_path(__file__, "img/linux.png"))
            Interpreter._ICONS["windows"]   = PhotoImage(file=get_absolute_path(__file__, "img/windows.png"))

        @staticmethod
        def get_backends():
            """ Return Interpreter backends """

            return Interpreter.BACKENDS

        @staticmethod
        def get_interpreter(name):
            """ Get interpreter instance by name """

            assert(name in Interpreter.BACKENDS.keys())
            return Interpreter.BACKENDS[name]

        @staticmethod
        def get_default_shell():
            """ Get default shell based on operating system """

            return Interpreter.DEFAULT_SHELL

        @staticmethod
        def get_icon(name):
            # assert (name in Interpreter._ICONS.keys())

            if name in Interpreter._ICONS.keys():
                return Interpreter._ICONS[name]
            else:
                return Interpreter._ICONS["bash"]

    class ExitDiaglogBox():

        def __init__(self, master, icon):

            self.master = master
            self.master.protocol("WM_DELETE_WINDOW", self._diaglog_box)
            self.iconMaster = icon
            self.iconWarn = tk.PhotoImage(file=get_absolute_path(__file__, "img/warn.png"))

        def _diaglog_box(self):

            self.top = tk.Toplevel()
            self.top.iconphoto(False, self.iconMaster)
            self.top.title("Close this terminal?")
            self.top.resizable(False, False)

            width = 320
            height = 130

            # Set dialog box geometry
            self.top.geometry("{}x{}".format(width, height))

            # Get master current position
            root_x = self.master.winfo_x()
            root_y = self.master.winfo_y()

            # Get master width and height
            root_width = self.master.winfo_width()
            root_height = self.master.winfo_height()

            # Work out the new center coordinate
            x = root_x + (root_width/2) - (width/2)
            y = root_y + (root_height/2) - (height/2)

            # Position dialog box to center
            self.top.geometry("+%d+%d" % (x, y))

            # Make top a subwindow on root window
            self.top.transient(self.master)

            # Stop user interacting with other windows
            self.top.grab_set()

            self.top.focus_set()

            ########################################################################
            ## Create dialog box
            ########################################################################

            self.frameWrap = tk.Frame(self.top, bg=TkTermConfig.CONFIG["bg"])
            self.frameWrap.pack(fill=BOTH, expand=True)

            frameBody = tk.Frame(self.frameWrap, bg=TkTermConfig.CONFIG["bg"])
            frameBody.pack(side=TOP, ipadx=20, ipady=20)

            frameButton = tk.Frame(self.frameWrap, bg=TkTermConfig.CONFIG["bg"], bd=0)
            frameButton.pack(side=BOTTOM, fill=X)

            buttonOptions = {
                "relief"                : FLAT,
                "bd"                    : 0,
                "height"                : 2,
                "highlightthickness"    : 0,
                "font"                  : ("Helvetica", 8)
            }

            buttonCancel = tk.Button(frameButton, text="Cancel", bg=TkTermConfig.CONFIG["bg"], fg="white", **buttonOptions , command=self._cancel)
            buttonCancel.pack(side=LEFT, pady=0, padx=0, fill=X, expand=True)

            buttonExit = tk.Button(frameButton, text="Exit Terminal", bg="orange", **buttonOptions , command=self._exit)
            buttonExit.pack(side=LEFT, pady=0, padx=0, fill=X, expand=True)

            # Fixes for Windows
            if os.name == "nt":
                buttonCancel.bind("<Enter>", lambda e: buttonCancel.config(fg="black", bg="#ececec"))
                buttonCancel.bind("<Leave>", lambda e: buttonCancel.config(fg="white", bg=TkTermConfig.CONFIG["bg"]))

                buttonExit.bind("<Enter>", lambda e: buttonExit.config(fg="black", bg="#ececec"))
                buttonExit.bind("<Leave>", lambda e: buttonExit.config(fg="black", bg="orange"))
            else:
                buttonCancel["activebackground"] = "#ececec"
                buttonCancel["activeforeground"] = "black"

                buttonExit["activebackground"] = "#ececec"
                buttonExit["activeforeground"] = "black"

            # self.warningIcon = tk.PhotoImage(file=WARNING_ICON_PATH)
            icon = tk.Label(frameBody, image=self.iconWarn, bg=TkTermConfig.CONFIG["bg"])
            icon.pack(side=LEFT, padx=10)

            label = tk.Label(frameBody, text="Are you sure you want to exit the terminal\nand close all tabs?", bg=TkTermConfig.CONFIG["bg"], fg="white", font=("Helvetica", 8))
            label.pack(side=LEFT, padx=10)

            # Wait until top closes before return to root
            self.master.wait_window(self.top)

        def _exit(self):
            self.master.destroy()

        def _cancel(self):
            self.top.destroy()

    class TkTermConfig():

        # Default config
        DEFAULT_CONFIG = {
            "fg"                : "#00A79D",
            "bg"                : "#282C34",
            "insertbackground"  : "white",
            "error"             : "red",
            "output"            : "#E6E6E6",
            "basename"          : "#0080ff",
            "cursorshape"       : "bar",
            "selectbackground"  : "#464E5E",
            "fontfamily"        : "Cascadia Code SemiLight",
            "fontsize"          : 9
        }

        # Curernt config
        CONFIG = {}

        # Configuration filename
        CONFIG_FILE = os.path.abspath(os.path.join(os.path.dirname(__file__), "Term_settings.json"))

        @staticmethod
        def get_default(key=None):
            if key:
                assert(key in TkTermConfig.DEFAULT_CONFIG.keys())
                return TkTermConfig.DEFAULT_CONFIG[key]

            return TkTermConfig.DEFAULT_CONFIG.copy()

        @staticmethod
        def set_default(config):
            TkTermConfig.DEFAULT_CONFIG = config.copy()

        @staticmethod
        def get_config(key=None):
            if key:
                assert(key in TkTermConfig.CONFIG)
                return TkTermConfig.CONFIG[key]

            return TkTermConfig.CONFIG.copy()

        @staticmethod
        def set_config(config):
            TkTermConfig.CONFIG = config

        @staticmethod
        def set_config_key(key, value):
            assert(key in TkTermConfig.CONFIG.keys())
            TkTermConfig.CONFIG[key] = value

        @staticmethod
        def get_config_file():
            return TkTermConfig.CONFIG_FILE

    def get_last_line(widget):
        """ Get the position of the last line from Text Widget"""

        pos = widget.index("end linestart")
        pos = float(pos) - 1
        return pos

    def get_absolute_path(root, *args):
        """ Get absolute path given a root """

        return os.path.join(os.path.dirname(os.path.abspath(root)), *args)

    class Tooltip(object):
        '''
        create a tooltip for a given widget
        '''
        def __init__(self, widget, text='widget info', manual=False, delay=False):
            self.widget = widget
            self.text = text
            self.delay = delay

            self.tw = None

            self.manual = manual

            if not manual:
                self.widget.bind("<Enter>", self.enter)
                self.widget.bind("<Leave>", self.close)

        def enter(self, event=None):
            # if self.delay:
            #     self.widget.winfo_toplevel().after(600, self.create)
            # else:
            #     self.create()
            # else:
            #     self.close()

            self.create()

        def create(self):
            x = y = 0
            x, y, cx, cy = self.widget.bbox("insert")

            if self.manual:
                x += self.widget.winfo_rootx() - 1
                y += self.widget.winfo_rooty() + 20
            else:
                x += self.widget.winfo_rootx() + 25
                y += self.widget.winfo_rooty() + 30

            # creates a toplevel window
            self.tw = tk.Toplevel(self.widget)
            # Leaves only the label and removes the app window
            self.tw.wm_overrideredirect(True)
            self.tw.wm_geometry("+%d+%d" % (x, y))
            label = tk.Label(self.tw, text=self.text, justify='left',
                           relief='solid', borderwidth=1, wraplength=150,
                           font=("Helvetica", "7", "normal"))

            label.pack(ipadx=1)

        def close(self, *args):

            if self.tw:
                self.tw.destroy()
                self.tw = None


    class InterpreterInterface(ABC):

        def __init__(self, *kwargs):
            # super().__init__()

            self.stdout = None
            self.stderr = None
            self.exit_code = None

        @abstractmethod
        def execute(self, command):
            pass

        @abstractmethod
        def terminate(self, processThread):
            pass
    # Add to system path
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))

    __version__ = "1.0.2"

    class InterpreterShell(InterpreterInterface):

        def __init__(self, interpreter_path=None):
            super().__init__()

            self.history = []

            self.process_options = {
                "shell"                 : True,
                "stdout"                : subprocess.PIPE,
                "stderr"                : subprocess.PIPE,
                "universal_newlines"    : True
            }

            # Ignore utf-8 decode error which sometimes happens on early terminating
            if os.name != "nt":
                self.process_options["errors"] = "ignore"

            if interpreter_path:
                self.process_options['executable'] = interpreter_path

        def execute(self, command):
            return subprocess.Popen(command, cwd=os.getcwd(), **self.process_options)

        def terminate(self, processThread):

            stdout = ""
            stderr = ""

            if (os.name == 'nt'):
                process = subprocess.Popen(
                    "TASKKILL /F /PID {} /T".format(processThread.pid),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    universal_newlines=True
                )

                for line in process.stdout:
                    stdout += line
                for line in process.stderr:
                    stderr += line

            else:

                try:
                    os.system("pkill -TERM -P %s" % processThread.pid)
                    os.system("kill -2 {}".format(processThread.pid))
                    os.system("kill -9 {}".format(processThread.pid))
                except:
                    pass

            processThread.wait()

            return (stdout, stderr)

        def get_return_code(self, process):
            return process.poll()

        def get_prompt(self):
            return os.getcwd() + ">> "

        def get_history(self):
            return self.history

        def __repr__(self):
            return "<InterpreterShell object: {}>".format(self.process_options['executable'])

    class KThread(threading.Thread):
      """
      A subclass of threading.Thread, with a kill() method.
      """

      def __init__(self, *args, **keywords):
        threading.Thread.__init__(self, *args, **keywords)
        self.killed = False

      def start(self):
        """Start the thread."""
        self.__run_backup = self.run
        self.run = self.__run      # Force the Thread to install our trace.
        threading.Thread.start(self)

      def __run(self):
        """Hacked run function, which installs the trace."""
        sys.settrace(self.globaltrace)
        self.__run_backup()
        self.run = self.__run_backup

      def globaltrace(self, frame, why, arg):
        if why == 'call':
          return self.localtrace
        else:
          return None

      def localtrace(self, frame, why, arg):
        if self.killed:
          if why == 'line':
            raise SystemExit()
        return self.localtrace

      def kill(self):
        self.killed = True

    '''
    from src.TerminalTab import TerminalTab
    from src.Interpreter import Interpreter
    from src.ExitDiaglogBox import ExitDiaglogBox
    from src.Utils import get_absolute_path
    from src.Config import TkTermConfig
    '''

    class Terminal(tk.Frame):
        """ Terminal widget """

        def __init__(self, parent, text=None, *args, **kwargs):

            super().__init__(parent, *args, **kwargs)

            self.splashText = text

            # Initialised all interpreter backends
            Interpreter.init_backends()

            ########################################################################
            # Load setting profile
            ########################################################################
            self.TerminalConfig = TkTermConfig.get_default()

            if "Cascadia Code SemiLight" in font.families():
                self.TerminalConfig["fontfamily"] = "Cascadia Code SemiLight"
            else:
                self.TerminalConfig["fontfamily"] = "Consolas"

            TkTermConfig.set_default(self.TerminalConfig)

            # Load settings from file
            if os.path.isfile(TkTermConfig.CONFIG_FILE):
                with open(TkTermConfig.CONFIG_FILE, "r") as f:
                    try:
                        data = json.load(f)

                        for k in data.keys():
                            if k in self.TerminalConfig.keys():
                                self.TerminalConfig[k] = data[k]
                    except:
                        pass

            TkTermConfig.set_config(self.TerminalConfig)

            ########################################################################
            # Create terminal tabs using notebook
            ########################################################################
            self.notebook = TerminalTab(self, self.splashText)
            self.notebook.pack(expand=True, fill=BOTH)

        def add_interpreter(self, *args, **kwargs):
            """ Add a new interpreter and optionally set as default """

            Interpreter.add_interpreter(*args, **kwargs)

        def run_command(self, cmd):
            """ Run command on current terminal tab """

            # Get the selected tab
            tab_id = self.notebook.select()

            # Get the associated terminal widget
            terminal = self.notebook.nametowidget(tab_id)
            terminal.run_command(cmd)

        def on_resize(self, event):
            """Auto scroll to bottom when resize event happens"""

            first_visible_line = self.TerminalScreen.index("@0,0")

            if self.scrollbar.get()[1] >= 1:
                self.TerminalScreen.see(END)
            # elif float(first_visible_line) >  1.0:
            #     self.TerminalScreen.see(float(first_visible_line)-1)

            # self.statusText.set(self.TerminalScreen.winfo_height())

    class TerminalTab(ttk.Notebook):

        def __init__(self, parent, splashText):

            ttk.Notebook.__init__(self, parent)

            self.parent = parent
            self.splashText = splashText

            ########################################################################
            # Bind keys
            ########################################################################
            self.bind("<B1-Motion>", self._reorder_tab)
            self.bind("<ButtonRelease-2>", lambda e: self._close_tab(event=e))
            self.bind("<<NotebookTabChanged>>", self._tab_clicked)
            self.bind('<Double-Button-1>', self._tab_rename)

            ########################################################################
            # Add default tabs
            # This will automatically create a tab and an add tab button
            ########################################################################
            self.iconPlus = PhotoImage(file=get_absolute_path(__file__, "img/plus.png"))
            self.add(tk.Frame(self.parent), image=self.iconPlus)

            # Set color profile for notebook
            self.init_style()

            ########################################################################
            # Create menu button
            ########################################################################
            self.frameNav = tk.Frame(self.parent)
            self.frameNav.place(rely=0, relx=1.0, x=-10, y=17, anchor="e")

            self.iconHamburger  = PhotoImage(file=get_absolute_path(__file__, "img/hamburger.png"))
            self.iconSearch     = PhotoImage(file=get_absolute_path(__file__, "img/search.png"))
            self.iconNewTab     = PhotoImage(file=get_absolute_path(__file__, "img/new_tab.png"))
            self.iconNextTab    = PhotoImage(file=get_absolute_path(__file__, "img/next_tab.png"))
            self.iconPrevTab    = PhotoImage(file=get_absolute_path(__file__, "img/prev_tab.png"))
            self.iconCloseTab   = PhotoImage(file=get_absolute_path(__file__, "img/close_tab.png"))

            self.renameCloseButton  = PhotoImage(file=get_absolute_path(__file__, "img/close.png"))
            self.iconApp            = PhotoImage(file=get_absolute_path(__file__, "img/app_icon.png"))

            self.buttonTabList = tk.Button(
                self.frameNav,
                # text="\u2630",
                image=self.iconHamburger,
                width=30,
                height=25,
                bd=0,
                relief=FLAT,
                highlightbackground="#414755",
                bg="#414755",
                fg="#9da5b4",
                activebackground="#495162",
                activeforeground="#9da5b4"
            )

            self.buttonTabList.pack()

            self.buttonTabList.bind("<ButtonRelease-1>", self._tab_menu)

            if os.name == "nt":
                self.buttonTabList.bind("<Enter>", lambda e: e.widget.config(bg="#495162"))
                self.buttonTabList.bind("<Leave>", self._tab_menu_on_leave)

        def init_style(self):
            """ Style the notebook """

            s = ttk.Style()
            s.theme_use('default')
            s.configure('Terminal.TNotebook',
                background="#414755",
                bd=0,
                borderwidth=0,
                padding=[0,0,0,0],
                tabmargins=[7, 7, 50, 0],
                # tabposition='wn'
            )

            s.configure('Terminal.TNotebook.Tab',
                borderwidth=0,
                padding=[10,5],
                # width=15,
                height=1,
                background="#495162",
                foreground="#9da5b4",
                font=('Helvetica','8'),
                focuscolor=TkTermConfig.get_config("bg")
            )

            s.map("Terminal.TNotebook.Tab",
                background=[("selected", TkTermConfig.get_config("bg")), ("active", TkTermConfig.get_config("bg"))],
                foreground=[("selected", "white"), ("active", "white")],
                font=[("selected", ('Helvetica 8 bold'))],
                # expand=[("selected", [0, 3])]
            )

            self.configure(style="Terminal.TNotebook")

        def set_color_style(self):
            """ Set color style for all terminal tabs and notebook """

            for tab in self.tabs()[:-1]:
                terminal = self.nametowidget(tab)

                terminal.set_color_style()

            self.init_style()

        def _tab_menu_on_leave(self, event):
            """ Set effect when mouse cursor leave menu button """

            if event.widget["state"] == "normal":
                event.widget.config(bg="#414755")

        def _tab_menu(self, event):
            """ Create menu for menu button """

            self.tabListMenu = Menu(self,
                tearoff=0,
                bg="white",
                bd=1,
                activebackground="#2c313a",
                activeforeground="white",
                selectcolor="red",
                activeborderwidth=1,
                relief=GROOVE,
                font="Helvetica 10"
            )

            # Add list of currently opened tabs to menu
            for tab in self.tabs()[:-1]:

                self.tabListMenu.add_command(
                    label="   " + self.tab(tab, option="text"),
                    image=self.tab(tab, option="image"),
                    compound=LEFT,
                    command= lambda temp=tab: self.select(temp)
                )

            self.tabListMenu.add_separator()

            self.tabListMenu.add_command(
                label="   Search",
                accelerator="Ctrl+F",
                image=self.iconSearch, compound=LEFT,
                command=lambda : self.nametowidget(self.select()).event_generate("<Control-f>")
            )

            self.tabListMenu.add_command(
                label="   New tab",
                accelerator="Ctrl+T",
                command=self._insert_new_tab,
                image=self.iconNewTab, compound=LEFT
            )

            # Number of opened tabs (minus add tab button)
            num_tabs = len(self.tabs()) - 1

            if num_tabs == 1:
                state = "disabled"
            else:
                state = "normal"

            self.tabListMenu.add_command(
                label="   Go to next tab",
                accelerator="Ctrl+Tab",
                command=lambda: self._cycle_through_tabs(True),
                image=self.iconNextTab, compound=LEFT,
                state=state
            )

            self.tabListMenu.add_command(
                label="   Go to prev tab",
                accelerator="Shift+Tab",
                command=lambda: self._cycle_through_tabs(False),
                image=self.iconPrevTab, compound=LEFT,
                state=state
            )

            self.tabListMenu.add_command(
                label="   Close this tab",
                accelerator="Middle-click" + "{}".format("" if os.name == "nt" else "  "),
                image=self.iconCloseTab, compound=LEFT,
                command=lambda : self._close_tab(index=self.index(self.select())),
                state=state
            )

            self.tabListMenu.add_separator()

            self.tabListMenu.add_command(label="About Everything Console ...", command=self._about_page)

            self.tabListMenu.bind("<FocusOut>", lambda e: (
                e.widget.destroy(),
                event.widget.config(bg="#414755")
            ))

            ########################################################################
            # Create popup event
            ########################################################################

            try:
                event.widget.config(fg="#9da5b4", bg="#495162")
                self.tabListMenu.tk_popup(event.widget.winfo_rootx(), event.widget.winfo_rooty()+30)
                # self.tabListMenu.focus_set()
            finally:
                self.tabListMenu.grab_release()

                if os.name == "nt":
                    event.widget.config(bg="#414755")

        def _tab_clicked(self, *event):
            """ Monitor tab change event """

            # Fake the last tab as insert new tab
            if self.select() == self.tabs()[-1]:
                self._insert_new_tab()

        def _insert_new_tab(self):
            """ Insert new tab event """

            terminal = TerminalWidget(self.parent)

            if self.splashText:
                terminal.update_shell(print_basename=False)
                terminal.stdout.write(self.splashText)

            terminal.update_shell()

            # Attach search bar to terminal
            terminal.searchBar = SearchBar(terminal)

            # Attach right click context menu
            terminal.contextMenu = RightClickContextMenu(self, terminal)

            # Insert new tab before the add button
            index = len(self.tabs()) - 1
            self.insert(index, terminal, text=f"Terminal {len(self.tabs())}", image=terminal.icon, compound=LEFT)
            self.select(index)

            # Bind event for each terminal instance
            tab_id = self.select()
            terminal.bind("<<eventUpdateShell>>",   lambda e : self._update_icon(tab_id))
            terminal.bind("<<eventNewTab>>",        lambda e : self._insert_new_tab())
            terminal.bind("<<eventCycleNextTab>>",  lambda e : self._cycle_through_tabs(traverse_next=True))
            terminal.bind("<<eventCyclePrevTab>>",  lambda e : self._cycle_through_tabs(traverse_next=False))

        def _cycle_through_tabs(self, traverse_next=True):
            """ Cycle through opened tabs """

            # Number of opened tabs (minus add tab button)
            num_tabs = len(self.tabs()) - 1

            # Get current tab id and its index
            tab_id = self.select()
            index = self.index(tab_id)

            # Work out new tab index
            if traverse_next:
                if (index >= num_tabs - 1): index = 0
                else:                       index += 1
            else:
                if index == 0:              index = num_tabs - 1
                else:                       index -= 1

            # Select new tab
            self.select(index)

            # Set focus on the terminal
            new_tab_id = self.select()
            terminal = self.nametowidget(new_tab_id)
            terminal.TerminalScreen.focus_set()

        def _update_icon(self, tab_id):
            """ Update icon on tab """

            terminal = self.nametowidget(tab_id)
            self.tab(tab_id, image=terminal.icon)

        def _reorder_tab(self, event):
            """ Drag to reorder tab """

            try:
                index = self.index(f"@{event.x},{event.y}")

                if index >= len(self.tabs()) - 1:
                    return

                self.insert(index, child=self.select())

            except tk.TclError:
                pass

        def _close_tab(self, index=None, event=None):
            """ Close tab event """

            try:

                if event:
                    index = self.index(f"@{event.x},{event.y}")

                # Do nothing if it is the last tab (add tab button)
                if index >= len(self.tabs()) - 1:
                    return

                # Do nothing if there are 2 tabs left
                if len(self.tabs()) == 2:
                    return

                # When closing the last tab, immediately switch to the tab before
                if index == len(self.tabs()) - 2:
                    self.select(len(self.tabs()) - 3)

                terminal = self.nametowidget(self.tabs()[index])

                # TODO: Error on closing tabs if there are processes running
                # If process still running just kill it
                terminal.terminate()

                del terminal.searchBar
                del terminal.contextMenu

                for child in terminal.winfo_children():
                    child.destroy()

                terminal.destroy()

                # self.event_generate("<<NotebookTabClosed>>")

            except Exception:
                pass

        def _tab_rename(self, event):
            """ Rename a tab """

            def _accept_change(event):
                """ Accept a change """

                self.tab(tab_id, text=field.get())
                _focus_out()

            def _focus_out(*event):
                """ On focus out destroy all created widgets """

                buttonClose.destroy()
                entry.destroy()
                frameInner.destroy()
                frame.destroy()

                terminal.TerminalScreen.focus_set()

            def _on_enter(event):
                event.widget["bg"] = INNER_BG
                event.widget["activebackground"] = INNER_BG

            def _on_leave(event):
                event.widget["bg"] = OUTER_BG

            try:

                # Define colors
                OUTER_BG = "#212224"
                INNER_BG = "#414755"

                # Get the selected tab
                index = self.index(f"@{event.x},{event.y}")
                self.select(index)
                tab_id = self.select()

                # Get the associated terminal widget
                terminal = self.nametowidget(tab_id)

                # Create a popup frame attached to terminal
                frame = tk.Frame(terminal, bg=OUTER_BG)
                frame.place(rely=0, x=event.x, y=13, anchor="w")

                frameInner = tk.Frame(frame, bg=OUTER_BG)
                frameInner.pack(expand=True, fill=BOTH, padx=5, pady=5)

                field = StringVar()

                entry = tk.Entry(
                    frameInner,
                    textvariable=field,
                    bd=0,
                    width=10,
                    bg=INNER_BG,
                    fg="white",
                    insertbackground="white",
                    borderwidth=0,
                    font="Helvetica 9"
                )

                entry.pack(side=LEFT, expand=True, fill=BOTH)

                buttonClose = tk.Button(
                    frameInner,
                    image=self.renameCloseButton,
                    bg=OUTER_BG,
                    relief=FLAT,
                    bd=0,
                    height=15,
                    highlightbackground=OUTER_BG,
                    command=_focus_out
                )

                buttonClose.pack(side=LEFT, padx=(5, 0))

                # Get the tab label
                field.set(self.tab(tab_id, option="text"))

                # Set focus to Entry box and select all text by default
                entry.focus()
                entry.select_range(0, END)

                # Bind keys
                entry.bind("<Return>", _accept_change)
                entry.bind("<FocusOut>", _focus_out)
                entry.bind("<Escape>", _focus_out)

                buttonClose.bind("<Enter>", _on_enter)
                buttonClose.bind("<Leave>", _on_leave)

            except tk.TclError:
                pass

        def _about_page(self):
            """ About page """

            def _focus_out(*event):
                """ On focus out destroy all created widgets """

                background.destroy()
                #button1.destroy()
                button2.destroy()
                frameButton.destroy()
                labelAbout.destroy()
                labelIcon.destroy()
                frameInner.destroy()
                frame.destroy()

                tab_id = self.select()
                terminal = self.nametowidget(tab_id)
                terminal.TerminalScreen.focus_set()

            # Define colors
            OUTER_BG = "#9da5b4"
            INNER_BG = "#414755"

            # Get screen dimension
            root_width = self.parent.winfo_width()
            root_height = self.parent.winfo_height()

            # Fill background to cover whole screen
            background = tk.Label(self.parent, bg=OUTER_BG, width=root_width, height=root_height)
            background.place(x=0, y=0)

            # Create a popup frame
            frame = tk.Frame(self.parent, bg=INNER_BG)
            frame.place(relx=0.5, rely=0.5, anchor="center")

            # Inner frame
            frameInner = tk.Frame(frame, bg=INNER_BG)
            frameInner.pack(expand=True, fill=BOTH, padx=20, pady=20)

            about_text = f"""
    Terminal Emulator.
    Version: {__version__}

    Created by Tudor Marmureanu

    """

            labelIcon = tk.Label(frameInner, image=self.iconApp, bg=INNER_BG)
            labelIcon.pack(side=TOP)

            labelAbout = tk.Label(frameInner, text=about_text, bg=INNER_BG, fg="white")
            labelAbout.pack(side=TOP)

            # Area for buttons
            frameButton = tk.Frame(frameInner, bg=INNER_BG)
            frameButton.pack(side=TOP)

            #button1 = ttk.Button(frameButton, text="Visit github", takefocus=0, command=lambda : webbrowser.open("https://github.com/dhanoosu/TkTerm"))
            #button1.pack(side=LEFT, expand=True, padx=5, ipadx=10)

            button2 = ttk.Button(frameButton, text="OK", takefocus=0, command=_focus_out)
            button2.pack(side=LEFT, expand=True, padx=5)

            # Bind keys
            frame.bind("<FocusOut>", _focus_out)
            background.bind("<ButtonRelease-1>", _focus_out)

    class TerminalWidget(tk.Frame):

        SHELL_MAPPINGS = Interpreter.MAPPINGS

        def __init__(self, parent, **kwargs):
            tk.Frame.__init__(self, parent, **kwargs)

            self.parent = parent

            self.basename = ""
            self.commandIndex = -1
            self.commandHistory = []

            # get the root after
            self.after = self.winfo_toplevel().after

            self.currentInterpreter = None

            self.TerminalColors = TkTermConfig.get_config()

            self.caretHandling = False
            self.pendingKeys = ""

            self.icon = None

            ########################################################################
            ## Terminal screen
            ########################################################################
            self.frameTerminal = tk.Frame(self, borderwidth=0, relief=FLAT, bg=self.TerminalColors["bg"])

            self.TerminalScreen = tk.Text(
                self.frameTerminal,
                bg=self.TerminalColors["bg"],
                fg=self.TerminalColors["fg"],
                insertbackground="white",
                highlightthickness=0,
                borderwidth=0,
                insertwidth=1,
                undo=False
            )

            self.stdout = Redirect(self, stream="stdout")
            self.stderr = Redirect(self, stream="stderr")

            self.frameScrollbar = Frame(self.frameTerminal, borderwidth=0, width=14, bg=self.TerminalColors["bg"])
            # tell frame not to let its children control its size
            self.frameScrollbar.pack_propagate(0)

            self.scrollbar = ttk.Scrollbar(self.frameScrollbar, style="Terminal.Vertical.TScrollbar", orient="vertical")
            self.scrollbar.pack(anchor=E, side=RIGHT, fill=Y, expand=True, padx=(0,3))

            self.TerminalScreen['yscrollcommand'] = self.scrollbar.set
            self.scrollbar['command'] = self.TerminalScreen.yview

            self.scrollTimer = 0
            self.frameScrollbar.bind("<Enter>", self.on_scrollbar_enter)
            self.frameScrollbar.bind("<Leave>", self.on_scrollbar_leave)

            # Initially map as leave event
            self.frameScrollbar.bind("<Map>", self.on_scrollbar_leave)

            # Flag to indicate if user enters scrollbar area
            self.isScrollbarEnterEvent = False

            ########################################################################
            ## Status bar
            ########################################################################
            self.frameStatusBar = ttk.Frame(self, style="Status.TFrame")

            self.returnCodeLabel = Label(self.frameStatusBar, text="RC: 0", fg="white", bg="green", font=("Helvetica", 8), anchor=W, width=8)
            self.returnCodeLabel.pack(side=LEFT)

            self.statusText = StringVar()
            self.statusText.set("Status: IDLE")
            self.statusLabel = Label(self.frameStatusBar, textvariable=self.statusText, font=("Helvetica", 8), relief=FLAT)
            self.statusLabel.pack(side=LEFT)

            ########################################################################
            ## Style configure for ttk widgets
            ########################################################################
            style_combobox = {
                "relief"                : FLAT,
                "borderwidth"           : 0,
                "highlightthickness"    : 0
            }

            self.style = ttk.Style(self)
            self.style.theme_use('default')
            self.style.configure("Shell.TCombobox", **style_combobox)
            self.style.configure("Terminal.Vertical.TScrollbar",
                background="#3A3E48",
                borderwidth=0,
                relief=FLAT
            )

            self.style.configure("Status.TFrame", background="#21252B", borderwidth=0, relief=FLAT)

            # following are style option for the drop down combobox listbox
            self.option_add('*TCombobox*Listbox*Background', '#21252B')
            self.option_add('*TCombobox*Listbox*Foreground', "#9DA5B4")
            self.option_add('*TCombobox*Listbox.font', ("Helvetica", 8))

            self.shellComboBox = ttk.Combobox(self.frameStatusBar, style="Shell.TCombobox", state="readonly", width=8, font=("Helvetica", 8))
            self.shellComboBox.pack(side=RIGHT, padx=0)
            self.shellComboBox['values'] = list(Interpreter.MAPPINGS.keys())

            # Set default shell
            self.shellComboBox.set(Interpreter.DEFAULT_SHELL)

            self.shellComboBox.bind("<<ComboboxSelected>>", self.update_shell)
            # self.shellComboBox.bind("<Button-1>", self.do_leftClick)
            self.shellComboBox.bind("<Escape>", self.do_leftClickRelease, add="+")


            ########################################################################
            ## Set style colours
            ########################################################################
            self.set_color_style()

            ########################################################################
            ## Packing
            ########################################################################

            # Need to pack these last otherwise a glitch happens
            # where scrollbar disappear when window resized
            self.frameStatusBar.pack(side=BOTTOM, fill=X)
            self.frameTerminal.pack(side=TOP, fill=BOTH, expand=True)
            self.frameScrollbar.pack(side=RIGHT, fill=Y)
            self.TerminalScreen.pack(side=LEFT, fill=BOTH, expand=True, padx=(4,0), pady=(4,0))

            ########################################################################
            ## Key bindings
            ########################################################################
            self.TerminalScreen.bind('<MouseWheel>', self.rollWheel)
            self.frameScrollbar.bind('<MouseWheel>', self.rollWheel)
            self.scrollbar.bind('<MouseWheel>', self.rollWheel)

            self.TerminalScreen.bind('<Control-c>', self.do_cancel)
            self.TerminalScreen.bind("<Control-t>", lambda e: self.event_generate("<<eventNewTab>>") or "break")
            self.TerminalScreen.bind('<Control-Tab>', lambda e: self.event_generate("<<eventCycleNextTab>>") or "break")

            # Windows or Mac
            if (platform.system() == "Windows") or (platform.system() == "Darwin"):
                self.TerminalScreen.bind('<Shift-Tab>', lambda e: self.event_generate("<<eventCyclePrevTab>>") or "break")
            else:
                self.TerminalScreen.bind('<ISO_Left_Tab>', lambda e: self.event_generate("<<eventCyclePrevTab>>") or "break")

            self.bind_keys()

            # Bind all other key press
            self.TerminalScreen.bind("<KeyPress>", self.do_keyPress)

            self.insertionIndex = self.TerminalScreen.index("end")
            self.count = 0

            self.terminalThread = None
            self.processTerminated = False

            # Caret handling and multiline commands
            self.multilineCommand = ""

            # Automatically set focus to Terminal screen when initialised
            self.TerminalScreen.focus_set()

        def terminate(self):
            """ Terminate this terminal instance """

            if (self.terminalThread is not None) and (self.terminalThread.is_alive()):
                self.TerminalScreen.event_generate("<Control-c>")
                self.stdout = sys.stdout
                self.stderr = sys.stderr

                self.check_process_terminate()

        def check_process_terminate(self):

            if (self.terminalThread is not None) and (self.terminalThread.is_alive()):
                self.after(100, self.check_process_terminate)


        def reset(self):

            # Caret handling and multiline commands
            self.multilineCommand = ""
            self.caretHandling = False

        def set_color_style(self):
            """
            Set coloring style for widgets
            """

            TerminalColors = TkTermConfig.get_config()

            self.TerminalScreen["bg"]               = TerminalColors["bg"]
            self.TerminalScreen["fg"]               = TerminalColors["fg"]
            self.TerminalScreen["selectbackground"] = TerminalColors["selectbackground"]

            self.frameTerminal["bg"] = TerminalColors["bg"]
            self.frameScrollbar["bg"] = TerminalColors["bg"]

            ########################################################################
            ## Font
            ########################################################################

            terminalFont = Font(family=TerminalColors["fontfamily"], size=TerminalColors["fontsize"])
            self.TerminalScreen["font"] = terminalFont

            boldFont = Font(font=terminalFont)
            boldFont.configure(weight="bold")

            self.TerminalScreen.tag_config("basename", foreground=TerminalColors["basename"], font=boldFont)
            self.TerminalScreen.tag_config("error", foreground=TerminalColors["error"])
            self.TerminalScreen.tag_config("output", foreground=TerminalColors["output"])

            ########################################################################
            ## Scrollbar
            ########################################################################

            self.style.configure("Terminal.Vertical.TScrollbar", troughcolor=TerminalColors["bg"])
            self.style.configure("Terminal.Vertical.TScrollbar", arrowcolor=TerminalColors["bg"])

            self.style.map('Terminal.Vertical.TScrollbar',
                background=[
                    ('pressed', "#9DA5B4"),
                    ('disabled', TerminalColors["bg"])
                ],
                arrowcolor=[
                    ('disabled', TerminalColors["bg"]),
                    ('active', TerminalColors["bg"])
                ]
            )

            ########################################################################
            ## Shell selection combobox
            ########################################################################

            self.style.map('Shell.TCombobox', background=[('hover', "#2F333D")])
            self.style.map('Shell.TCombobox', fieldbackground=[('hover', "#2F333D")])
            self.style.map('Shell.TCombobox', arrowcolor=[('readonly', '#9DA5B4')])

            self.style.configure("Shell.TCombobox", fieldbackground="#21252B") # current field background
            self.style.configure("Shell.TCombobox", background="#21252B") # arrow box background
            self.style.configure("Shell.TCombobox", foreground="#9DA5B4") # current field foreground

            ########################################################################
            ## Status bar
            ########################################################################

            self.statusLabel["bg"] = "#21252B"
            self.statusLabel["fg"] = "#9DA5B4"

            # Use i-beam cursor
            if TerminalColors["cursorshape"] == "bar":
                self.TerminalScreen['blockcursor'] = False
                self.TerminalScreen['insertwidth'] = 1

            # Use block cursor
            elif TerminalColors["cursorshape"] == "block":
                self.TerminalScreen['blockcursor'] = True
                self.TerminalScreen['insertwidth'] = 0


        def on_scrollbar_enter(self, event):
            """
            On focus on scrollbar increase width of scrollbar
            """

            self.isScrollbarEnterEvent = True

            # self.style.configure("Terminal.Vertical.TScrollbar",
            #     width=10,
            #     arrowsize=10
            # )

            self._scrollbar_animation()

        def on_scrollbar_leave(self, eventL):
            """
            On focus off from scrollbar decrease width of scrollbar
            """

            self.isScrollbarEnterEvent = False

            # self.style.configure("Terminal.Vertical.TScrollbar",
            #     width=5,

            #     # hack to make arrow invisible
            #     arrowsize=-10
            # )

            self._scrollbar_animation()

        def _scrollbar_animation(self):

            if self.isScrollbarEnterEvent:
                self.scrollTimer += 3

                if self.scrollTimer <= 12:
                    self.after(100, self._scrollbar_animation)
                else:
                    self.style.configure("Terminal.Vertical.TScrollbar", arrowsize=10)
                    self.style.map('Terminal.Vertical.TScrollbar',
                        background=[('active', "#9DA5B4"), ('pressed', "#9DA5B4"), ('disabled', TkTermConfig.CONFIG["bg"])]
                    )
                    self.style.configure("Terminal.Vertical.TScrollbar", background="#9DA5B4")

            else:
                self.scrollTimer -= 1

                if self.scrollTimer >= 0:
                    self.after(100, self._scrollbar_animation)
                else:
                    self.style.configure("Terminal.Vertical.TScrollbar", arrowsize=-10)
                    self.style.configure("Terminal.Vertical.TScrollbar", width=5)
                    self.style.map('Terminal.Vertical.TScrollbar',
                        background=[('active', "#3A3E48"), ('disabled', TkTermConfig.CONFIG["bg"])]
                    )
                    self.style.configure("Terminal.Vertical.TScrollbar", background="#3A3E48")

        def bind_keys(self):
            self.TerminalScreen.bind("<FocusOut>",          self.focus_out)

            self.TerminalScreen.bind("<Return>",            self.do_keyReturn)
            self.TerminalScreen.bind("<Up>",                self.do_keyUpArrow)
            self.TerminalScreen.bind("<Down>",              self.do_keyDownArrow)
            self.TerminalScreen.bind("<BackSpace>",         self.do_keyBackspace)
            self.TerminalScreen.bind("<Delete>",            lambda event: "")
            self.TerminalScreen.bind("<End>",               lambda event: "")
            self.TerminalScreen.bind("<Left>",              self.do_keyLeftArrow)
            self.TerminalScreen.bind("<Right>",             lambda event: "")
            self.TerminalScreen.bind("<Button-1>",          self.do_leftClick)
            self.TerminalScreen.bind("<ButtonRelease-1>",   self.do_leftClickRelease)
            self.TerminalScreen.bind("<ButtonRelease-2>",   self.do_middleClickRelease)
            self.TerminalScreen.bind("<Tab>",               self.do_keyTab)
            self.TerminalScreen.bind("<Home>",              self.do_keyHome)
            self.TerminalScreen.unbind("<B1-Motion>")

        def unbind_keys(self):
            self.TerminalScreen.bind("<Return>",            lambda event: "break")
            self.TerminalScreen.bind("<Up>",                lambda event: "break")
            self.TerminalScreen.bind("<Down>",              lambda event: "break")
            self.TerminalScreen.bind("<BackSpace>",         lambda event: "break")
            self.TerminalScreen.bind("<Delete>",            lambda event: "break")
            self.TerminalScreen.bind("<End>",               lambda event: "break")
            self.TerminalScreen.bind("<Left>",              lambda event: "break")
            self.TerminalScreen.bind("<Right>",             lambda event: "break")
            self.TerminalScreen.bind("<Button-1>",          lambda event: "break")
            self.TerminalScreen.bind("<ButtonRelease-1>",   lambda event: "break")
            self.TerminalScreen.bind("<ButtonRelease-2>",   lambda event: "break")
            self.TerminalScreen.bind("<Tab>",               lambda event: "break")
            self.TerminalScreen.bind("<Home>",              lambda event: "break")
            self.TerminalScreen.bind("<B1-Motion>",         lambda event: "break")

        def rollWheel(self, event):
            direction = 0
            if event.num == 5 or event.delta == -120:
                direction = 3
            if event.num == 4 or event.delta == 120:
                direction = -3
            self.TerminalScreen.yview_scroll(direction, UNITS)

            return "break"

        def focus_out(self, event):
            """When out of focus, store the last insertion index """

            self.insertionIndex = self.TerminalScreen.index("insert")

        def do_keyPress(self, event):

            import string

            # The obvious information
            c = event.keysym
            s = event.state

            # Manual way to get the modifiers
            ctrl  = (s & 0x4) != 0
            alt   = (s & 0x8) != 0 or (s & 0x80) != 0
            shift = (s & 0x1) != 0

            if ctrl:
                return "break"


            char = event.char

            if self.terminalThread:
                self.pendingKeys += char
            elif char in list(string.printable):
                self.pendingKeys = ""
                self.TerminalScreen.insert("insert", char)
                self.TerminalScreen.see(END)

            return "break"

        def update_shell(self, print_basename=True, *args):

            # Update current interpreter
            self.currentInterpreter = Interpreter.get_interpreter(self.shellComboBox.get())
            self.shellComboBox.selection_clear()
            self.TerminalScreen.focus()

            # Update icon
            self.icon = Interpreter.get_icon(self.shellComboBox.get())

            # Generate event
            self.event_generate("<<eventUpdateShell>>")

            if print_basename:
                # When new shell is selected from the list we want to add new line
                # and print basename in case the prompt changes
                self.insert_new_line()
                self.print_basename()

        def do_cancel(self, *args):

            import signal

            # Kill current running process if there is any
            if (self.terminalThread is not None) and (self.terminalThread.is_alive()):

                # Signals TerminalPrint to immediately stops any printout
                self.processTerminated = True

                self.stdout.write("^C")

                (stdout, stderr) = self.currentInterpreter.terminate(self.terminalThread.process)

                self.stdout.write(stdout, end='')
                self.stderr.write(stderr, end='')

            else:

                # Clear multiline commands
                if self.multilineCommand != "":
                    self.multilineCommand = ""

                if self.caretHandling:
                    # Always clear caret handle
                    self.caretHandling = False

                # Clear commands
                self.insert_new_line()
                self.print_basename()

        class TerminalPrint(KThread):

            def __init__(self, top, cmd):

                KThread.__init__(self)
                # super().__init__(parent, *args, **kwargs)

                self.daemon = True
                self.cmd = cmd
                self.returnCode = 0

                self.process = None

                # Attach outer class instance
                self.top = top

            def run(self):

                # Modify shell executable based on selected shell combobox variable
                shellSelected = self.top.shellComboBox.get()

                # Set current interpreter based on shell selected
                # self.top.currentInterpreter = Interpreter.get_interpreter(shellSelected)

                if self.cmd != "":

                    try:

                        # with subprocess.Popen(self.cmd, **process_options) as self.process:
                        with self.top.currentInterpreter.execute(self.cmd) as self.process:

                            # if hasattr(self.process, "stdout") and hasattr(self.process, "stderr"):
                            for line in self.process.stdout:

                                # if self.top.processTerminated:
                                #     break

                                self.top.stdout.write(line, end='')

                            for line in self.process.stderr:
                                self.top.stderr.write(line, end='')


                        self.returnCode = self.top.currentInterpreter.get_return_code(self.process)

                    except Exception:
                        self.top.stderr.write(traceback.format_exc())
                        self.returnCode = -1

                # Always print basename on a newline
                insert_pos = self.top.TerminalScreen.index("insert")
                if insert_pos.split('.')[1] != '0':
                    self.top.insert_new_line()

                self.top.print_basename()
                self.top.processTerminated = False

        def clear_screen(self):
            """ Clear screen and print basename """

            self.TerminalScreen.delete("1.0", END)
            self.print_basename()

        def print_basename(self):
            """ Print basename on Terminal """

            self.stdout.write(self.get_basename(), end='')
            self.stdout.write(self.pendingKeys, end='')

            self.pendingKeys = ""

        def get_basename(self):
            """ Get full basename comtaining newline characters """

            if self.caretHandling:
                return "> "
            else:
                return self.currentInterpreter.get_prompt()

        def get_last_basename(self):
            """ Get the basename after the last newline character """

            basename = self.get_basename()

            if "\n" in basename:
                return basename.split("\n")[-1]

            return basename


        def do_keyHome(self, *args):
            """ Press HOME to return to the start position of command """

            pos = self.get_pos_after_basename()

            self.TerminalScreen.mark_set("insert", pos)
            return "break"

        def get_pos_after_basename(self):
            """ Return starting position of the command """

            pos = get_last_line(self.TerminalScreen)
            pos_integral = str(pos).split('.')[0]
            offset = '.' + str(len(self.get_last_basename()))
            new_pos = pos_integral + offset

            return new_pos

        def get_cmd(self):
            """ Return command after the basename """

            pos = self.get_pos_after_basename()
            return self.TerminalScreen.get(pos, "end-1c")

        def delete_cmd(self):
            """ Delete command after basename """

            pos = self.get_pos_after_basename()
            self.TerminalScreen.delete(pos, END)

        def do_keyTab(self, *args):
            """ Tab completion """

            # Windows uses backward slash
            # Unix uses forward slash
            slash = os.sep

            raw_cmd = self.get_cmd()
            cmd = raw_cmd

            # Always focus on the last command
            # E.g., "cd folder" : only focus on the last command "folder"
            # Get the last space-separated command
            if cmd == "":
                last_cmd = ""
            elif cmd[-1] == " ":
                last_cmd = ""
            else:
                last_cmd = cmd.split()[-1]

            # Create a pattern to be match with glob
            match_pattern = last_cmd+'*'

            import glob

            cd_children = sorted(glob.glob(match_pattern))
            cd_children = [f+slash if os.path.isdir(f) else f for f in cd_children]

            import re
            import fnmatch

            # glob on Windows are case insensitive - below is a hack to match case-sensitive path
            match = re.compile(fnmatch.translate(match_pattern)).match
            cd_children = [pth for pth in cd_children if match(pth)]

            common_path = os.path.commonprefix(cd_children)

            return_cmd = raw_cmd

            # If common prefix path is not found this is our final command
            # Concatenate with the previous "last command"
            if common_path != "":
                self.delete_cmd()
                return_cmd += common_path[len(last_cmd):]

                self.stdout.write(return_cmd, end='')

            # Also print the files and folders that matched the pattern only if
            # the results have more than one entry
            if len(cd_children) > 1:
                self.insert_new_line()
                self.stdout.write('\n'.join(cd_children))

                self.print_basename()
                self.stdout.write(return_cmd, end='')

            return "break"

        def do_leftClickRelease(self, *args):

            # Unhide cursor
            self.TerminalScreen["insertwidth"] = 1
            self.TerminalScreen["insertbackground"] = "white"

            self.TerminalScreen.focus_set()
            self.TerminalScreen.mark_set("insert", self.insertionIndex)

        def do_middleClickRelease(self, *args):

            try:
                selected = self.TerminalScreen.selection_get()
            except Exception as e:
                selected = ""

            current_pos = self.TerminalScreen.index(INSERT)
            self.TerminalScreen.insert(current_pos, selected)

            return "break"

        def do_leftClick(self, *args):

            # Hide cursor
            self.TerminalScreen["insertwidth"] = 0
            self.TerminalScreen["insertbackground"] = self.TerminalColors["selectbackground"]

            self.insertionIndex = self.TerminalScreen.index("insert")
            # self.TerminalScreen.mark_set("insert", self.insertionIndex)
            # return "break"
            pass

        def do_keyReturn(self, *args):
            """ On pressing Return, execute the command """

            # Caret character differs on Windows and Unix
            if os.name == "nt":
                CARET = "^"
            else:
                CARET = "\\"

            cmd = self.get_cmd()
            cmd = cmd.strip()

            # Empty command - pass
            if cmd == "":
                self.insert_new_line()
                self.print_basename()
                pass

            # Multiline command
            elif cmd.endswith(CARET):

                # Add to command history
                if cmd in self.commandHistory:
                    self.commandHistory.pop(self.commandIndex)

                self.commandIndex = -1
                self.commandHistory.insert(0, cmd)

                # Construct multiline command
                self.multilineCommand += cmd.rstrip(CARET)

                # Set caret handling
                if not self.caretHandling:
                    self.caretHandling = True

                self.insert_new_line()
                self.print_basename()

            # Valid command
            else:

                # Add to command history
                if cmd in self.commandHistory:
                    self.commandHistory.pop(self.commandIndex)

                self.commandIndex = -1
                self.commandHistory.insert(0, cmd)

                # Merge all multiline command and disable caret handling
                if self.multilineCommand != "":
                    cmd = self.multilineCommand + cmd
                    self.multilineCommand = ""

                    self.caretHandling = False

                if cmd == "clear" or cmd == "reset":
                    self.clear_screen()

                elif "cd" in cmd.split()[0]:
                    path = ' '.join(cmd.split()[1:])
                    path = os.path.expanduser(path)

                    if os.path.isdir(path):
                        os.chdir(path)

                        # Insert new line
                        self.insert_new_line()
                        self.set_returnCode(0)
                    else:
                        self.insert_new_line()
                        self.stderr.write("cd: no such file or directory: {}".format(path))
                        self.set_returnCode(1)

                    self.print_basename()
                else:
                    self.insert_new_line()

                    self.terminalThread = self.TerminalPrint(self, cmd)
                    self.terminalThread.start()

                    self.count = 0
                    self.unbind_keys()
                    self.monitor(self.terminalThread)


            return 'break'

        def do_keyBackspace(self, *args):
            """ Delete a character until the basename """

            index = self.TerminalScreen.index("insert-1c")

            if int(str(index).split('.')[1]) >= len(self.get_last_basename()):
                self.TerminalScreen.delete(index)

            return "break"

        def do_keyLeftArrow(self, *args):
            """ Moves cursor to the left until it reaches the basename """

            index = self.TerminalScreen.index("insert-1c")

            if int(str(index).split('.')[1]) < len(self.get_last_basename()):
                return "break"

        def do_keyUpArrow(self, *args):
            """ Press UP arrow to get previous command in history """

            if self.commandIndex < len(self.commandHistory) - 1:
                self.commandIndex += 1

                self.delete_cmd()

                cmd = self.commandHistory[self.commandIndex]
                self.stdout.write(cmd, end='')

            return 'break'

        def do_keyDownArrow(self, *args):
            """ Press Down arrow to get the next command in history """

            if self.commandIndex >= 1:
                self.commandIndex -= 1

                self.delete_cmd()

                cmd = self.commandHistory[self.commandIndex]
                self.stdout.write(cmd, end='')

            elif self.commandIndex == 0:
                self.commandIndex = -1

                self.delete_cmd()

            return 'break'

        def insert_new_line(self):
            """ Insert a newline in Terminal """
            self.TerminalScreen.insert(END, "\n")
            self.TerminalScreen.mark_set("insert", END)

        def monitor(self, progress_thread):
            """ Monitor running process and update RC and Status on status bar """

            seq1 = ["⢿", "⣻", "⣽", "⣾", "⣷", "⣯", "⣟", "⡿"]
            seq2 = ["∙∙∙∙∙∙∙", "●∙∙∙∙∙∙", "∙●∙∙∙∙∙", "∙∙●∙∙∙∙", "∙∙∙●∙∙∙", "∙∙∙∙●∙∙", "∙∙∙∙∙●∙", "∙∙∙∙∙∙●"]

            if progress_thread.is_alive():

                string = "{} Status: Working {}".format(seq1[self.count], seq2[self.count])
                self.count = (self.count + 1) % 8
                self.statusText.set(string)

                self.after(100, lambda: self.monitor(progress_thread))

            else:
                self.set_returnCode(progress_thread.returnCode)
                self.statusText.set("Status: IDLE")
                self.terminalThread = None

                self.bind_keys()

        def set_returnCode(self, rc):
            """ Set return code on status bar """

            if(rc != 0):
                self.returnCodeLabel.configure(bg="red")
            else:
                self.returnCodeLabel.configure(bg="green")

            self.returnCodeLabel['text'] = "RC: {}".format(rc)

        def run_command(self, cmd):
            """ Print and execute command on terminal """

            while self.terminalThread: pass

            self.stdout.write(cmd, end='')
            self.do_keyReturn()

    class SearchBar():

        def __init__(self, parent):
            self.TerminalScreen = parent.TerminalScreen
            self.frameTerminal = parent.frameTerminal
            self._init()

        def _init(self):

            ## Bind keys
            self.TerminalScreen.bind('<Control-f>', self.open_searchbar)
            self.TerminalScreen.bind('<Escape>', self.close_searchbar)

            self.foundList = []
            self._reset()

            self.click_close    = PhotoImage(file=get_absolute_path(__file__, 'img/close.png'))
            self.click_next     = PhotoImage(file=get_absolute_path(__file__, 'img/next.png'))
            self.click_prev     = PhotoImage(file=get_absolute_path(__file__, 'img/prev.png'))
            self.click_regex    = PhotoImage(file=get_absolute_path(__file__, 'img/regex.png'))
            self.click_case     = PhotoImage(file=get_absolute_path(__file__, 'img/case.png'))


        def _reset(self):
            """ Reset attributes """

            self.searchIsOpen = False
            self.searchCaseSensitive = False
            self.searchRegex = False

            self.foundList.clear()
            self.currentSearchIndex = 0
            self.searchFoundCount = 0
            self.frameSearchBar = None
            self.searchRegexTooltip = None

        def open_searchbar(self, event):

            self.search_config = {
                "bd"        : 0,
                "fg"        : "white",
                "bg"        : "#21252B",
                "relief"    : FLAT,
                "font"      : ("Helvetica", 8)
            }

            if not self.searchIsOpen:

                ## Create searchbar frame
                self.frameSearchBar = tk.Frame(self.frameTerminal, width=20, height=50, borderwidth=0, bg="#21252B", relief=FLAT)

                self.searchFieldText = StringVar()

                self.searchField = Entry(
                    self.frameSearchBar,
                    textvariable = self.searchFieldText,
                    fg="#b2b2b3",
                    bg="#1d1f23",
                    insertbackground="white",
                    relief=FLAT,
                    highlightbackground="#1d1f23",
                    font=("Helvetica", 8)
                )

                self.searchField.pack(side=LEFT, padx=(5,0), pady=(5))

                # Bind keys
                self.searchField.bind("<Return>",       lambda event: self.do_search_next_or_prev(isNext=True))
                self.searchField.bind("<Shift-Return>", lambda event: self.do_search_next_or_prev(isNext=False))
                self.searchField.bind('<Escape>',       self.close_searchbar)

                self.searchFieldText.trace("w", self.do_search)

                self.searchResultText = StringVar()
                self.searchResultText.set("No results")

                def toggle_searchRegex():
                    self.searchRegex = not self.searchRegex

                    bg = "red" if self.searchRegex else "#1d1f23"
                    self.searchRegexButton.configure(bg=bg)

                    self.do_search()

                def toggle_searchCaseSensitive():
                    self.searchCaseSensitive = not self.searchCaseSensitive

                    bg = "red" if self.searchCaseSensitive else "#1d1f23"
                    self.searchCaseButton.configure(bg=bg)

                    self.do_search()

                self.searchCaseButton = Button(self.frameSearchBar, cursor="hand2", image=self.click_case, bg="#1d1f23", relief=FLAT, bd=0, highlightbackground="#1d1f23", command=toggle_searchCaseSensitive)
                self.searchCaseButton.pack(side=LEFT, fill=Y, pady=5)
                Tooltip(self.searchCaseButton, text="Match Case", delay=1)

                self.searchRegexButton = Button(self.frameSearchBar, cursor="hand2", image=self.click_regex, bg="#1d1f23", relief=FLAT, bd=0, highlightbackground="#1d1f23", command=toggle_searchRegex)
                self.searchRegexButton.pack(side=LEFT, fill=Y, pady=5)
                Tooltip(self.searchRegexButton, text="Use Regular Expression", delay=1)

                self.searchResult   = Label(self.frameSearchBar, textvariable=self.searchResultText, width=8, anchor=W, **self.search_config)
                self.searchResult.pack(side=LEFT, padx=(5), fill=Y)

                self.searchPrev     = Button(self.frameSearchBar, cursor="hand2", image=self.click_prev, width=30, highlightbackground= "#21252B", command= lambda: self.do_search_next_or_prev(False), **self.search_config)
                self.searchPrev.pack(side=LEFT, padx=(2), fill=Y)
                Tooltip(self.searchPrev, text="Previous Match (Shift+Enter)", delay=1)

                self.searchNext     = Button(self.frameSearchBar, cursor="hand2", image=self.click_next, width=30, highlightbackground= "#21252B", command= lambda: self.do_search_next_or_prev(True), **self.search_config)
                self.searchNext.pack(side=LEFT, padx=(2), fill=Y)
                Tooltip(self.searchNext, text="Next Match (Enter)", delay=1)

                self.searchClose = Button(
                    self.frameSearchBar,
                    cursor="hand2",
                    image=self.click_close,
                    highlightbackground="#21252B",
                    width=30,
                    command=self.close_searchbar,
                    **self.search_config
                )

                self.searchClose.pack(side=LEFT, padx=(2), fill=Y)

                ## Create extra binding event on top of what Tooltip had (add="+")
                self.searchPrev.bind("<Enter>", self.on_enter, add="+")
                self.searchPrev.bind("<Leave>", self.on_leave, add="+")

                self.searchNext.bind("<Enter>", self.on_enter, add="+")
                self.searchNext.bind("<Leave>", self.on_leave, add="+")

                self.searchClose.bind("<Enter>", self.on_enter, add="+")
                self.searchClose.bind("<Leave>", self.on_leave, add="+")

                self.frameSearchBar.place(rely=0, relx=1.0, x=-14, y=14, anchor="e")
                self.searchField.focus_set()
                self.searchIsOpen = True

            ## Destroy searchbar frame
            else:
                self.close_searchbar()

        def on_enter(self, e):
            e.widget["bg"] = "black"

            # Set activebackground
            e.widget["activebackground"] = "black"

        def on_leave(self, e):
            e.widget["bg"] = self.search_config["bg"]

        def close_searchbar(self, *args):

            if self.frameSearchBar:

                for child in self.frameSearchBar.winfo_children():
                    child.destroy()

                self.frameSearchBar.destroy()

                self._reset()

                self.TerminalScreen.tag_remove("found", "1.0", END)
                self.TerminalScreen.tag_remove("found_selected", "1.0", END)

                self.TerminalScreen.focus_set()

            self.frameSearchBar = None

        def do_search(self, *args):

            value = self.searchFieldText.get()

            self.TerminalScreen.tag_remove("found", "1.0", END)
            self.TerminalScreen.tag_remove("found_selected", "1.0", END)
            self.searchResultText.set("No results")

            self.foundList.clear()

            if not self.searchRegexTooltip:
                self.searchRegexTooltip = Tooltip(self.searchField, "", manual=True)
            else:
                self.searchRegexTooltip.close()

            self.searchField.configure(bg = "#1d1f23")

            if value:

                idx = "1.0"
                self.searchFoundCount = 0
                self.currentSearchIndex = 0

                while True:

                    try:
                        idx = self.TerminalScreen.search(value, idx, nocase=(not self.searchCaseSensitive), stopindex=END, regexp=self.searchRegex)
                        self.searchField.configure(bg = "#1d1f23")
                    except Exception as err:
                        # self.searchField.configure(borderwidth= 2)
                        self.searchField.configure(bg = "red")
                        self.searchRegexTooltip.text = err
                        self.searchRegexTooltip.create()
                        break

                    if not idx:
                        self.searchResult['fg'] = "#f4875b" if self.searchFoundCount == 0 else "#b2b2b3"
                        break

                    lastidx = "{}+{}c".format(idx, len(value))

                    self.foundList.append((idx, lastidx))

                    self.TerminalScreen.tag_add("found", idx, lastidx)
                    idx = lastidx

                    self.TerminalScreen.tag_config("found", background="green")
                    self.searchFoundCount += 1


                if self.foundList:
                    self.searchResultText.set("{} of {}".format(1, self.searchFoundCount))
                    self.TerminalScreen.tag_add("found_selected", self.foundList[0][0], self.foundList[0][1])
                    self.TerminalScreen.see(self.foundList[0][0])

                self.TerminalScreen.tag_config("found_selected", background="orange")

        def do_search_next_or_prev(self, isNext):

            self.TerminalScreen.tag_remove("found_selected", "1.0", END)

            if self.foundList:

                if isNext:
                    self.currentSearchIndex = (self.currentSearchIndex + 1) % self.searchFoundCount
                else:
                    self.currentSearchIndex = (self.currentSearchIndex - 1) % self.searchFoundCount

                self.searchResultText.set("{} of {}".format(self.currentSearchIndex + 1, self.searchFoundCount))
                self.TerminalScreen.tag_add("found_selected", self.foundList[self.currentSearchIndex][0], self.foundList[self.currentSearchIndex][1])


                self.TerminalScreen.see(self.foundList[self.currentSearchIndex][0])

    class RightClickContextMenu:

        def __init__(self, top_level, terminal):

            self.top = top_level
            self.terminal = terminal

            self.bind_menu()

            self.setting_win_top = False

        def bind_menu(self):
            self.menu = tk.Menu(self.terminal,
                tearoff=0,
                bg="#1D1F23",
                # bg="white",
                fg="white",
                # borderwidth=0,
                bd=1,
                relief=FLAT,
                activebackground="#2c313a",
                activeforeground="white",
                selectcolor="red",
                activeborderwidth=0,
            )

            self.menu.add_command(label ="Copy", accelerator=" "*10, command=self._copyClipboard)
            self.menu.add_command(label ="Paste", command=self._pasteClipboard)
            self.menu.add_command(label ="Reload", command=self._reloadScreen)
            self.menu.add_separator()
            self.menu.add_command(label="Settings...", command=self._showSettings)

            self.terminal.TerminalScreen.bind("<ButtonRelease-3>", self._popup)
            self.menu.bind('<FocusOut>', self.on_focusout_popup)

        def on_focusout_popup(self, event=None):
            self.menu.unpost()

        def _popup(self, event):

            try:
                # self.menu.tk_popup(event.x_root+1, event.y_root+1)
                self.menu.post(event.x_root+1, event.y_root+1)
                self.menu.focus_set()
            finally:
                self.menu.grab_release()

        def _copyClipboard(self):

            try:
                selected = self.terminal.TerminalScreen.selection_get()
            except Exception as e:
                selected = ""

            self.top.parent.clipboard_clear()
            self.top.parent.clipboard_append(selected)

        def _pasteClipboard(self):
            data = self.top.parent.clipboard_get()

            current_pos = self.terminal.TerminalScreen.index(INSERT)
            self.terminal.TerminalScreen.insert(current_pos, data)

        def _reloadScreen(self):
            self.terminal.clear_screen()

        def _showSettings(self):

            def _init():

                fieldTexts["background"].set(TkTermConfig.get_config("bg"))
                fieldTexts["foreground"].set(TkTermConfig.get_config("fg"))
                fieldTexts["basename"].set(TkTermConfig.get_config("basename"))
                fieldTexts["error"].set(TkTermConfig.get_config("error"))
                fieldTexts["output"].set(TkTermConfig.get_config("output"))
                fieldTexts["selectbackground"].set(TkTermConfig.get_config("selectbackground"))

                mappings = dict(zip(cursorShapeMappings.values(), cursorShapeMappings.keys()))
                cursorCombobox.set(mappings[TkTermConfig.get_config("cursorshape")])

                fontFamilyCombobox.set(TkTermConfig.get_config("fontfamily"))
                fontSizeFieldText.set(TkTermConfig.get_config("fontsize"))

            def _do_restoreDefault():

                # self.top.TerminalColors = self.top.DefaultTerminalColors.copy()
                TkTermConfig.set_config(TkTermConfig.get_default())
                _init()

            def _init_sample():

                sampleTerminal["state"] = "normal"

                try:

                    isError = False

                    sample_font = Font(family=fontFamilyCombobox.get(), size=int(fontSizeFieldText.get()))

                    sampleTerminal["bg"] = fieldTexts["background"].get()
                    sampleTerminal["selectbackground"] = fieldTexts["selectbackground"].get()
                    sampleTerminal["font"] = sample_font

                    sampleTerminal.delete("1.0", END)

                    boldFont = Font(font=sample_font)
                    boldFont.configure(weight="bold")

                    sampleTerminal.insert(END, "basename>>")
                    sampleTerminal.tag_add("basename", get_last_line(sampleTerminal), sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("basename", foreground=fieldTexts["basename"].get(), font=boldFont)

                    sampleTerminal.insert(END, " ")

                    start_pos = sampleTerminal.index("insert")

                    sampleTerminal.insert(END, "command")
                    sampleTerminal.tag_add("command", start_pos, sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("command", foreground=fieldTexts["foreground"].get())

                    sampleTerminal.insert(END, "\n")

                    start_pos = sampleTerminal.index("insert")

                    output_text = """\
    This is a sample output message from a given command
    Second line ...
    Third line ...
    ^C
    """
                    sampleTerminal.insert(END, output_text)
                    sampleTerminal.tag_add("output", start_pos, sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("output", foreground=fieldTexts["output"].get())


                    start_pos = sampleTerminal.index("insert")

                    error_text = "Terminate.\nAn error has occurred"
                    sampleTerminal.insert(END, error_text)
                    sampleTerminal.tag_add("error", start_pos, sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("error", foreground=fieldTexts["error"].get())

                except:
                    isError = True

                sampleTerminal["state"] = "disabled"


            def _populate_color_fields(name, row, color="white"):

                label = tk.Label(frameSettings, text=name)

                field = StringVar()
                field.set(color)

                entry = tk.Entry(frameSettings, textvariable=field, relief=FLAT)
                button = tk.Button(frameSettings, width=2, height=1, relief=FLAT, cursor="hand2", command= lambda: _choose_color(field))

                field.trace("w", lambda *args: _update_color(button, field))

                label.grid(sticky="W", padx=(0,10), row=row, column=0)
                entry.grid(sticky="W", row=row, column=1)
                button.grid(sticky="W", padx=10, row=row, column=2)

                fieldTexts[name] = field

            def _update_color(entry, field):
                try:
                    entry["text"] = ""
                    entry["bg"] = field.get()
                    entry["activebackground"] = field.get()
                except:
                    entry["text"] = "Err"
                    entry["bg"] = "white"
                    entry["fg"] = "red"

                _init_sample()

            def _choose_color(field):

                try:
                    result = colorchooser.askcolor(title="Color Chooser", parent=self.setting_win_top, initialcolor=field.get())
                except:
                    result = colorchooser.askcolor(title="Color Chooser", parent=self.setting_win_top)

                field.set(result[1])

                _init_sample()

            def _do_ok():

                result = _do_apply()

                if result:
                    self.setting_win_top.destroy()
                else:
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()

            def _do_apply():

                try:
                    TkTermConfig.CONFIG["bg"]               = fieldTexts["background"].get()
                    TkTermConfig.CONFIG["fg"]               = fieldTexts["foreground"].get()
                    TkTermConfig.CONFIG["cursorshape"]      = cursorShapeMappings[cursorCombobox.get()]
                    TkTermConfig.CONFIG["fontfamily"]       = fontFamilyCombobox.get()
                    TkTermConfig.CONFIG["fontsize"]         = fontSizeFieldText.get()
                    TkTermConfig.CONFIG["output"]           = fieldTexts["output"].get()
                    TkTermConfig.CONFIG["error"]            = fieldTexts["error"].get()
                    TkTermConfig.CONFIG["basename"]         = fieldTexts["basename"].get()
                    TkTermConfig.CONFIG["selectbackground"] = fieldTexts["selectbackground"].get()

                    self.top.set_color_style()

                except:
                    tkinter.messagebox.showerror(title="Invalid input", message="Found invalid input. Please check your settings")
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()
                    return False

                return True

            def _update_cursorShapeSelected(*args):
                cursorCombobox.selection_clear()

                _init_sample()

            def _do_saveConfig():

                result = _do_apply()

                if result:
                    with open(TkTermConfig.CONFIG_FILE, "w") as f:
                        f.write(json.dumps(TkTermConfig.get_config(), indent = 4))

                        tkinter.messagebox.showinfo(title="Configuration saved", message="Successfully saved configuration to file.\n{}".format(f.name))

                else:
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()

            def _update_FontFamilySelected(*args):

                fontFamilyCombobox.selection_clear()
                _init_sample()

            def _change_font_size(mode):

                assert(mode in ["decrease", "increase"])

                if mode == "decrease":
                    fontSizeFieldText.set(int(fontSizeFieldText.get()) - 1)
                elif mode == "increase":
                    fontSizeFieldText.set(int(fontSizeFieldText.get()) + 1)

            #
            # If popup window existed, bring it up
            #
            if self.setting_win_top:
                try:
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()
                    return
                except:
                    pass

            #
            # Create new popup window
            #
            self.setting_win_top = Toplevel(self.top.winfo_toplevel())
            self.setting_win_top.geometry("750x500")
            self.setting_win_top.resizable(False, False)

            self.setting_win_top.title("Settings")
            self.setting_win_top.focus_set()

            ########################################################################
            # Notebook
            ########################################################################

            tabControl = ttk.Notebook(self.setting_win_top)

            tab1 = tk.Frame(tabControl)
            tab1.pack(expand=True, fill=BOTH)

            ########################################################################
            # Tabs
            ########################################################################

            tabControl.pack(expand=True, fill=BOTH)
            tabControl.add(tab1, text ='Appearance')

            ########################################################################
            # Frames
            ########################################################################

            frameWrap = tk.Frame(tab1)
            frameWrap.pack(expand=True, fill=BOTH, padx=10, pady=10)

            frameTop = tk.Frame(frameWrap)
            frameTop.pack(expand=True, fill=X)

            frameSettings = tk.Frame(frameTop)
            frameSettings.pack(side=LEFT)

            frameSample = tk.Frame(frameTop, height=300, width=500)
            frameSample.pack_propagate(False)
            frameSample.pack(side=LEFT, padx=(10, 0))

            frameBottom = tk.Frame(tab1, relief=RAISED, bd=1, height=5)
            frameBottom.pack(side=BOTTOM, fill=X, ipadx=10, ipady=10)

            ########################################################################
            # Sample terminal
            ########################################################################

            sampleTerminal = tk.Text(frameSample)
            sampleTerminal.pack(expand=True, fill=BOTH)

            ########################################################################
            #
            ########################################################################

            fieldTexts = {}
            isError = False

            label_terminal = tk.Label(frameSettings, text="Terminal", font="Helvetica 16 bold")
            label_cursor = tk.Label(frameSettings, text="Cursor", font="Helvetica 16 bold")
            label_font = tk.Label(frameSettings, text="Font", font="Helvetica 16 bold")

            label_cusor_shape = tk.Label(frameSettings, text="Cursor shape")

            label_font_size = tk.Label(frameSettings, text="Font size")
            label_font_family = tk.Label(frameSettings, text="Font family")

            cursorShapeMappings = {
                "Bar ( | )" : "bar",
                "Block ( █ )" : "block"
            }


            fontSizeFieldText = IntVar()

            frameFontSize = tk.Frame(frameSettings)
            buttonFontSizeMinus = tk.Button(frameFontSize, text=" - ", relief=GROOVE, command= lambda:_change_font_size(mode="decrease")).pack(side=LEFT)
            entry_font_size = tk.Entry(frameFontSize, textvariable=fontSizeFieldText, relief=FLAT, justify=CENTER, width=5).pack(side=LEFT, ipady=3)
            buttonFontSizePlus = tk.Button(frameFontSize, text=" + ", relief=GROOVE, command= lambda:_change_font_size(mode="increase")).pack(side=LEFT)

            label_terminal.grid(sticky="W", ipady=10, row=2)

            _populate_color_fields(name="background", row=3)
            _populate_color_fields(name="foreground", row=4)
            _populate_color_fields(name="selectbackground", row=5)
            _populate_color_fields(name="basename", row=6)
            _populate_color_fields(name="output", row=7)
            _populate_color_fields(name="error", row=8)

            label_cursor.grid(sticky="W", ipady=10, row=9)
            label_cusor_shape.grid(sticky="W", row=10, column=0)

            cursorCombobox = ttk.Combobox(frameSettings, state="readonly", width=15, font=("Helvetica", 8))
            cursorCombobox['values'] = list(cursorShapeMappings.keys())
            cursorCombobox.bind("<<ComboboxSelected>>", _update_cursorShapeSelected)
            cursorCombobox.grid(sticky="W", ipady=3, row=10, column=1)

            label_font.grid(sticky="W", ipady=10, row=11)
            label_font_size.grid(sticky="W", row=12, column=0)
            frameFontSize.grid(sticky="W", row=12, column=1)

            label_font_family.grid(sticky="W", row=13, column=0)

            fontFamilyCombobox = ttk.Combobox(frameSettings, state="readonly", width=25)
            fontFamilyCombobox["values"] = list(font.families())
            fontFamilyCombobox.bind("<<ComboboxSelected>>", _update_FontFamilySelected)
            fontFamilyCombobox.grid(sticky="W", ipady=3, row=13, column=1)

            ttk.Button(frameBottom, style="Settings.TButton", text="Restore default", command=_do_restoreDefault).pack(side=LEFT, expand=True)

            ttk.Button(frameBottom, style="Settings.TButton", text="OK", command=_do_ok).pack(side=LEFT)
            ttk.Button(frameBottom, style="Settings.TButton", text="Apply", command=_do_apply).pack(side=LEFT)

            ttk.Button(frameBottom, style="Settings.TButton", text="Save config", command=_do_saveConfig).pack(side=LEFT, expand=True)

            s = ttk.Style()
            s.map('Settings.TButton',
                background=[('disabled','#d9d9d9'), ('active','#ececec')],
                foreground=[('disabled','#a3a3a3')])


            fontSizeFieldText.trace("w", lambda *args: _init_sample())


            _init()
            _init_sample()

    class Redirect():
        """ Redirect stdout and stderr to be written to Text widget """

        def __init__(self, widget, autoscroll=True, stream="stdout"):
            self.app = widget
            self.TerminalScreen = widget.TerminalScreen
            self.autoscroll = autoscroll
            self.stream = stream

        def write(self, text, end="\n"):

            text = text + end

            # Keep line limit for Terminal to 5000 lines
            limit_diff = int(get_last_line(self.TerminalScreen)) - 5000
            for i in range(limit_diff):
                self.TerminalScreen.delete("1.0", "2.0")

            # Work out if the current line is a command or output
            start_pos = get_last_line(self.TerminalScreen)
            line = self.TerminalScreen.get(start_pos, END)
            isCmd = True if line.startswith(self.app.get_last_basename()) else False

            self.TerminalScreen.insert("end", text)

            if self.autoscroll:
                self.TerminalScreen.see("end")

            ########################################################################
            ## Adding color tags
            ########################################################################

            # Error output
            # would have added a newline, so start_pos needs -1
            if self.stream == "stderr":
                start_pos = get_last_line(self.TerminalScreen) - 1
                end_pos = self.TerminalScreen.index("insert")
                self.TerminalScreen.tag_add("error", start_pos, end_pos)

                # Clear caret handling on invalid commands
                if self.app.caretHandling:
                    self.app.caretHandling = False

            # Normal output
            else:
                # Basename
                if text.startswith(self.app.get_basename()):

                    # Handle custom basename that contains newlines characters
                    last_line_pos = get_last_line(self.TerminalScreen)

                    # Start position needs to minus the number of newline characters found
                    start_pos = last_line_pos - text.count("\n")
                    end_pos = str(last_line_pos).split('.')[0] + '.' + str(len(self.app.get_last_basename()))

                    if self.app.caretHandling:
                        self.TerminalScreen.tag_add("command", start_pos, end_pos)
                    else:
                        self.TerminalScreen.tag_add("basename", start_pos, end_pos)

                # Normal output - could be command or its output
                # needs start_pos - 1
                elif not isCmd:
                    # start_pos = get_last_line(self.TerminalScreen) - 1
                    end_pos = self.TerminalScreen.index("insert")
                    self.TerminalScreen.tag_add("output", start_pos, end_pos)

            # Gives slightly smoother print out and reduces CPU stress
            # time.sleep(0.0001)




    def main():
        """ Main function """

        rootterm = tk.Tk()
        rootterm.title("Terminal Emulator")
        rootterm.geometry("700x400")

        terminal = Terminal(rootterm)
        terminal.pack(expand=True, fill=BOTH)

        icon = PhotoImage(file=get_absolute_path(__file__, "img/icon.png"))
        rootterm.iconphoto(False, icon)

        ExitDiaglogBox(rootterm, icon)
        rootterm.mainloop()

    if __name__ == "__main__":
        main()

if passfig == 4:
    import random
    import pyperclip
    from tkinter import *
    from tkinter.ttk import *

    def low():
        entrypass.delete(0, END)
        lengthpass = var1.get()
        passwordpass = ""
        
        if custom_check.get() == 1:  # If custom option is selected
            chars = custom_entry.get()  # Get custom characters
        else:
            if varpass.get() == 1:  # if strength selected is low
                chars = "abcdefghijklmnopqrstuvwxyz"
            elif varpass.get() == 0:  # if strength selected is medium
                chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
            elif varpass.get() == 3:  # if strength selected is strong
                chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !@#$%^&*()"
            else:
                print("Please choose an option")

        for i in range(0, lengthpass):
            passwordpass = passwordpass + random.choice(chars)
        return passwordpass


    def save_to_file(passwordpass):
        with open("passwords.txt", "a") as file:
            file.write(passwordpass + "\n")

    def generate():
        password1 = low()
        entrypass.insert(10, password1)
        save_to_file(password1)


    def copy1():
        random_password = entrypass.get()
        pyperclip.copy(random_password)

    def enable_custom_entry():
        custom_entry.config(state=NORMAL if custom_check.get() == 1 else DISABLED)

    passroot = Tk()
    passroot.resizable(False, False)
    varpass = IntVar()
    var1 = IntVar()
    custom_check = IntVar()

    passroot.title("Random Password Generator")
    image_icon53 = PhotoImage(file = "img/passlogo.png")
    passroot.iconphoto(False, image_icon53)

    Random_password = Label(passroot, text="Password")
    Random_password.grid(row=0)
    entrypass = Entry(passroot)
    entrypass.grid(row=0, column=1)

    c_label = Label(passroot, text="Length")
    c_label.grid(row=1)

    copy_buttonpass = Button(passroot, text="Copy", command=copy1)
    copy_buttonpass.grid(row=0, column=2)
    generate_buttonpass = Button(passroot, text="Generate", command=generate)
    generate_buttonpass.grid(row=0, column=3)

    radio_low = Radiobutton(passroot, text="Low", variable=varpass, value=1, command=enable_custom_entry)
    radio_low.grid(row=1, column=2, sticky='E')
    radio_middle = Radiobutton(passroot, text="Medium", variable=varpass, value=0, command=enable_custom_entry)
    radio_middle.grid(row=1, column=3, sticky='E')
    radio_strong = Radiobutton(passroot, text="Strong", variable=varpass, value=3, command=enable_custom_entry)
    radio_strong.grid(row=1, column=4, sticky='E')

    custom_entry_label = Label(passroot, text="Custom Characters")
    custom_entry_label.grid(row=2)
    custom_entry = Entry(passroot, state=DISABLED)
    custom_entry.grid(row=2, column=1)

    custom_checkbutton = Checkbutton(passroot, text="Custom", variable=custom_check, command=enable_custom_entry)
    custom_checkbutton.grid(row=2, column=2)

    combopass = Combobox(passroot, textvariable=var1)
    combopass['values'] = (8, 9, 10, 11, 12, 13, 14, 15, 16,
                           17, 18, 19, 20, 21, 22, 23, 24, 25,
                           26, 27, 28, 29, 30, 31, 32, "Length")
    combopass.current(0)
    combopass.bind('<<ComboboxSelected>>')
    combopass.grid(column=1, row=1)

    passroot.mainloop()

if passfig1 == 5:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon54 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon54)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()


    import tkinter as tk
    from tkinter import ttk
    import random
    import string
    from PIL import Image, ImageTk
    import tkinter.messagebox
    import json

    class Settings:
        def __init__(self, filename="settings.json"):
            self.filename = filename
            self.defaults = {
                "password_length": 12,
                "include_uppercase": False,
                "include_numbers": False,
                "include_special_chars": False
            }
            self.load_settings()

        def load_settings(self):
            try:
                with open(self.filename, "r") as file:
                    self.settings = json.load(file)
            except FileNotFoundError:
                self.settings = self.defaults

        def save_settings(self):
            with open(self.filename, "w") as file:
                json.dump(self.settings, file)

        def get_setting(self, key):
            return self.settings.get(key, self.defaults.get(key))

        def set_setting(self, key, value):
            self.settings[key] = value

    class PasswordGeneratorApp:
        def __init__(self, rootpassgen):
            self.rootpassgen = rootpassgen
            self.rootpassgen.title("Password Generator")
            self.rootpassgen.geometry("750x620") 
            self.rootpassgen.resizable(False, False) 
            self.image_icon55 = PhotoImage(file = "img/passlogo.png")
            self.rootpassgen.iconphoto(False, self.image_icon55)

            self.settings = Settings()
            self.settings.load_settings()
            
            self.settings_button = ttk.Button(self.rootpassgen, text="Settings", command=self.open_settings)
            self.settings_button.pack(anchor="ne", padx=10, pady=10)

            self.main_frame = ttk.Frame(rootpassgen)
            self.main_frame.pack(pady=10)

            self.options_frame = ttk.Frame(self.main_frame)
            self.options_frame.pack(side=tk.LEFT)

            self.length_label = ttk.Label(self.options_frame, text="Password Length:")
            self.length_label.pack(pady=10)

            self.length_var = tk.IntVar(value=12)
            self.length_scale = ttk.Scale(self.options_frame, from_=6, to=50, variable=self.length_var, orient=tk.HORIZONTAL, length=200, command=self.update_length_label)
            self.length_scale.pack()

            self.length_display = ttk.Label(self.options_frame, text="Length: 12")
            self.length_display.pack(pady=10)

            self.uppercase_var = tk.IntVar(value=0)
            self.uppercase_check = ttk.Checkbutton(self.options_frame, text="Include Uppercase Letters", variable=self.uppercase_var)
            self.uppercase_check.pack(pady=5)

            self.numbers_var = tk.IntVar(value=0)
            self.numbers_check = ttk.Checkbutton(self.options_frame, text="Include Numbers", variable=self.numbers_var)
            self.numbers_check.pack(pady=5)

            self.special_chars_var = tk.IntVar(value=0)
            self.special_chars_check = ttk.Checkbutton(self.options_frame, text="Include Special Characters", variable=self.special_chars_var)
            self.special_chars_check.pack(pady=10)

            self.generate_button = ttk.Button(self.options_frame, text="Generate Password", command=self.generate_password)
            self.generate_button.pack(pady=15)

            self.password_frame = ttk.Frame(self.options_frame)
            self.password_frame.pack(pady=10)

            self.password_entry = ttk.Entry(self.password_frame, width=30, font=("Arial", 12), state='readonly')
            self.password_entry.pack(side=tk.LEFT)

            self.copy_button = ttk.Button(self.password_frame, text="Copy", command=self.copy_password)
            self.copy_button.pack(side=tk.LEFT)

            self.complexity_label = ttk.Label(self.options_frame, text="Complexity:")
            self.complexity_label.pack()
            self.complexity_display = ttk.Label(self.options_frame, text="", font=("Arial", 12))
            self.complexity_display.pack()

            self.black_bar = ttk.Separator(self.main_frame, orient=tk.VERTICAL)
            self.black_bar.pack(side=tk.LEFT, fill=tk.Y, padx=20)

            self.history_frame = ttk.Frame(self.main_frame)
            self.history_frame.pack(side=tk.LEFT)

            self.history_label = ttk.Label(self.history_frame, text="Password History:")
            self.history_label.pack()

            self.history_scrollbar = ttk.Scrollbar(self.history_frame)
            self.history_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.history_listbox = tk.Listbox(self.history_frame, width=30, yscrollcommand=self.history_scrollbar.set)
            self.history_listbox.pack(pady=5)

            self.history_scrollbar.config(command=self.history_listbox.yview)

            self.copy_history_button = ttk.Button(self.history_frame, text="Copy", command=self.copy_selected_password)
            self.copy_history_button.pack(pady=5)

            self.delete_selected_button = ttk.Button(self.history_frame, text="Delete Selected", command=self.delete_selected_history)
            self.delete_selected_button.pack(pady=5)

            self.delete_full_button = ttk.Button(self.history_frame, text="Delete Full History", command=self.delete_full_history)
            self.delete_full_button.pack(pady=5)

            self.load_password_history()

            self.apply_settings()

        def generate_password(self):
            length = self.length_var.get()
            uppercase = bool(self.uppercase_var.get())
            numbers = bool(self.numbers_var.get())
            special_chars = bool(self.special_chars_var.get())

            selected_characters = [string.ascii_lowercase]

            if uppercase:
                selected_characters.append(string.ascii_uppercase)
            if numbers:
                selected_characters.append(string.digits)
            if special_chars:
                selected_characters.append(string.punctuation)

            random.shuffle(selected_characters)

            password = ''.join(random.choice(chars) for chars in selected_characters for _ in range(length // len(selected_characters)))
            password += ''.join(random.choice(chars) for chars in selected_characters[:length % len(selected_characters)])

            password_list = list(password)
            random.shuffle(password_list)
            password = ''.join(password_list)

            self.password_entry.configure(state='normal')
            self.password_entry.delete(0, tk.END)
            self.password_entry.insert(0, password)
            self.password_entry.configure(state='readonly')

            complexity = self.check_complexity(password)
            self.update_complexity_display(complexity)

            if password not in self.history_listbox.get(0, tk.END):
                self.add_password_to_history(password)

        def check_complexity(self, password):
            complexity = 0

            if any(c in string.ascii_uppercase for c in password):
                complexity += 1
            if any(c in string.digits for c in password):
                complexity += 1
            if any(c in string.punctuation for c in password):
                complexity += 1

            if len(password) >= 14 and complexity >= 3 or len(password) >= 15 and complexity >= 2 or len(password) >= 16 and complexity >= 1 or len(password) >= 20:
                return "Complex"
            elif len(password) >= 10 and complexity >= 3 or len(password) >= 11 and complexity >= 2 or len(password) >= 12 and complexity >= 1 or len(password) >= 15:
                return "Medium"
            else:
                return "Weak"

        def update_complexity_display(self, complexity):
            if complexity == "Complex":
                self.complexity_display.configure(text=complexity, foreground="green")
            elif complexity == "Medium":
                self.complexity_display.configure(text=complexity, foreground="orange")
            else:
                self.complexity_display.configure(text=complexity, foreground="red")

        def update_length_label(self, event=None):
            length = self.length_var.get()
            self.length_display.configure(text=f"Length: {length}")

        def copy_password(self):
            password = self.password_entry.get()
            if password:
                self.rootpassgen.clipboard_clear()
                self.rootpassgen.clipboard_append(password)
                self.rootpassgen.update()
                tkinter.messagebox.showinfo("Password Copied", "Password copied to clipboard!")

        def copy_selected_password(self):
            selected_index = self.history_listbox.curselection()
            if selected_index:
                selected_password = self.history_listbox.get(selected_index)
                self.rootpassgen.clipboard_clear()
                self.rootpassgen.clipboard_append(selected_password)
                self.rootpassgen.update()
                tkinter.messagebox.showinfo("Password Copied", "Password copied to clipboard!")

        def load_password_history(self):
            try:
                with open("password_history.txt", "r") as file:
                    passwords = file.readlines()
                    for password in passwords:
                        password = password.strip()
                        if password not in self.history_listbox.get(0, tk.END):
                            self.add_password_to_history(password)
            except FileNotFoundError:
                pass

        def add_password_to_history(self, password):
            self.history_listbox.insert(tk.END, password)
            self.history_listbox.yview(tk.END)

            with open("password_history.txt", "a") as file:
                file.write(password + "\n")

        def delete_selected_history(self):
            selected_indices = self.history_listbox.curselection()
            if selected_indices:
                for index in reversed(selected_indices):
                    self.history_listbox.delete(index)
                self.save_password_history()

        def delete_full_history(self):
            self.history_listbox.delete(0, tk.END)
            self.save_password_history()

        def save_password_history(self):
            with open("password_history.txt", "w") as file:
                for password in self.history_listbox.get(0, tk.END):
                    file.write(password + "\n")

        def apply_settings(self):
            self.length_var.set(self.settings.get_setting("password_length"))
            self.uppercase_var.set(self.settings.get_setting("include_uppercase"))
            self.numbers_var.set(self.settings.get_setting("include_numbers"))
            self.special_chars_var.set(self.settings.get_setting("include_special_chars"))
            self.update_length_label()

            # New objects for custom characters and enabling/disabling text entry
            self.custom_chars_var = tk.StringVar(value="")
            self.custom_chars_entry = ttk.Entry(self.options_frame, textvariable=self.custom_chars_var)
            self.custom_chars_entry.pack(pady=10)

            self.custom_chars_checkbox_var = tk.BooleanVar(value=False)
            self.custom_chars_checkbox = ttk.Checkbutton(self.options_frame, text="Use Custom Characters", variable=self.custom_chars_checkbox_var, command=self.toggle_custom_characters)
            self.custom_chars_checkbox.pack(pady=5)

        def toggle_custom_characters(self):
            if self.custom_chars_checkbox_var.get():
                self.custom_chars_entry.config(state="normal")
                self.uppercase_check.config(state="disabled")
                self.numbers_check.config(state="disabled")
                self.special_chars_check.config(state="disabled")
            else:
                self.custom_chars_entry.config(state="disabled")
                self.uppercase_check.config(state="normal")
                self.numbers_check.config(state="normal")
                self.special_chars_check.config(state="normal")

        def generate_password(self):
            if self.custom_chars_checkbox_var.get():
                custom_chars = self.custom_chars_var.get()
                password = ''.join(random.choice(custom_chars) for _ in range(self.length_var.get()))
            else:
                length = self.length_var.get()
                uppercase = bool(self.uppercase_var.get())
                numbers = bool(self.numbers_var.get())
                special_chars = bool(self.special_chars_var.get())

                selected_characters = [string.ascii_lowercase]

                if uppercase:
                    selected_characters.append(string.ascii_uppercase)
                if numbers:
                    selected_characters.append(string.digits)
                if special_chars:
                    selected_characters.append(string.punctuation)

                random.shuffle(selected_characters)

                password = ''.join(random.choice(chars) for chars in selected_characters for _ in range(length // len(selected_characters)))
                password += ''.join(random.choice(chars) for chars in selected_characters[:length % len(selected_characters)])

                password_list = list(password)
                random.shuffle(password_list)
                password = ''.join(password_list)

            self.password_entry.configure(state='normal')
            self.password_entry.delete(0, tk.END)
            self.password_entry.insert(0, password)
            self.password_entry.configure(state='readonly')

            complexity = self.check_complexity(password)
            self.update_complexity_display(complexity)

            if password not in self.history_listbox.get(0, tk.END):
                self.add_password_to_history(password)

        # Function to load settings on the main window
        def load_settings(self):
            self.length_var.set(self.settings.get_setting("password_length"))
            self.uppercase_var.set(self.settings.get_setting("include_uppercase"))
            self.numbers_var.set(self.settings.get_setting("include_numbers"))
            self.special_chars_var.set(self.settings.get_setting("include_special_chars"))

            # Reconfigure the main window based on the new settings
            self.update_length_label()

        # Function to save the settings to file and update the main window
        def save_settings_and_update_main_window(self):
            # Update the settings object with the new settings from the settings window
            self.settings.set_setting("password_length", self.password_length_var.get())
            self.settings.set_setting("include_uppercase", self.include_uppercase_var.get())
            self.settings.set_setting("include_numbers", self.include_numbers_var.get())
            self.settings.set_setting("include_special_chars", self.include_special_chars_var.get())

            # Save the settings to file
            self.settings.save_settings()

            # Apply the new settings to the main window
            self.load_settings()

            # Message box to confirm settings have been saved
            tkinter.messagebox.showinfo("Settings Saved", "Your settings have been saved!")
        
        # Function to open the settings window
        def open_settings(self):
            settings_window = tk.Toplevel(self.rootpassgen)
            settings_window.title("Settings")
            settings_window.resizable(False, False)
            image_icon57 = PhotoImage(file = "img/settingslogo.png")
            settings_window.iconphoto(False, image_icon57)

            # Set the application icon for the settings window
            #settings_window.iconbitmap("Logo_Tool.ico")

            # Load settings from the main window
            self.load_settings()

            self.password_length_label = ttk.Label(settings_window, text="Default Password Length:")
            self.password_length_label.pack(pady=5)

            self.password_length_var = tk.IntVar(value=self.settings.get_setting("password_length"))

            # Create a frame to contain the slider and its value display
            slider_frame = ttk.Frame(settings_window)
            slider_frame.pack()

            # Create a slider for password length
            self.password_length_slider = ttk.Scale(slider_frame, from_=6, to=50, variable=self.password_length_var, orient=tk.HORIZONTAL, length=120, command=self.update_password_length_slider)
            self.password_length_slider.pack()

            # Display the selected value of the slider
            self.password_length_display = ttk.Label(slider_frame, textvariable=self.password_length_var)
            self.password_length_display.pack()

            self.include_uppercase_var = tk.BooleanVar(value=self.settings.get_setting("include_uppercase"))
            self.include_uppercase_check = ttk.Checkbutton(settings_window, text="Include Uppercase Letters", variable=self.include_uppercase_var)
            self.include_uppercase_check.pack(pady=5)

            self.include_numbers_var = tk.BooleanVar(value=self.settings.get_setting("include_numbers"))
            self.include_numbers_check = ttk.Checkbutton(settings_window, text="Include Numbers", variable=self.include_numbers_var)
            self.include_numbers_check.pack(pady=5)

            self.include_special_chars_var = tk.BooleanVar(value=self.settings.get_setting("include_special_chars"))
            self.include_special_chars_check = ttk.Checkbutton(settings_window, text="Include Special Characters", variable=self.include_special_chars_var)
            self.include_special_chars_check.pack(pady=10)

            self.save_settings_button = ttk.Button(settings_window, text="Save Settings", command=self.save_settings_and_update_main_window)
            self.save_settings_button.pack(pady=10)
            
        def update_password_length_slider(self, value):
        # Round the value to the nearest integer and update the IntVar
            self.password_length_var.set(round(float(value)))

    if __name__ == "__main__":
        rootpassgen = tk.Tk()
        app = PasswordGeneratorApp(rootpassgen)
        rootpassgen.mainloop()

if hardvar == 6:
    """
        SYSIG - System Information Gatherer

        Simple GUI tool to gather system information in your computer
    """

    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon58 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon58)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    from datetime import datetime

    import time
    import platform
    import socket
    import threading
    import subprocess
    import dearpygui.dearpygui as dpg
    from cpuinfo import get_cpu_info
    import GPUtil
    import psutil
    import humanize


    # Check for AMD support and conditionally import pyadl
    AMD_SUPPORTED = False
    try:
        import pyadl
        _ = pyadl.ADLManager.getInstance().getDevices()
        AMD_SUPPORTED = True
    except ImportError:
        pass
    except Exception as amd_error:
        # Only print the AMD error if no NVIDIA GPUs are detected
        if not GPUtil.getGPUs():
            print(f"Unexpected error while checking for AMD support: {amd_error}")

    # Check for Windows and conditionally import winreg
    if platform.system() == 'Windows':
        import winreg
    else:
        winreg = None

    gci = get_cpu_info()
    WIN_WIDTH = 800
    WIN_HEIGHT = 400

    dpg.create_context()

    gpu_temp_texts = {}  # Store NVIDIA GPU temp text IDs
    amd_gpu_temp_texts = {}  # Store AMD GPU temp text IDs
    gpu_progress_bars = {}  # Store NVIDIA GPU progress bar IDs

    # Get CPU Total Utilization
    def get_cpu_util():
        """Get CPU Total Utilization"""

        while True:
            cpu_val = psutil.cpu_percent(interval=1, percpu=False)
            dpg.set_value(cpu_progress_bar, 1.0 / 100.0 * cpu_val)
            dpg.configure_item(cpu_progress_bar, overlay=f"{cpu_val}%")


    # entry
    with dpg.window(
            label=f"Computer Name: {platform.node()}",
            no_close=True,
            no_resize=True,
            no_move=True,
            width=WIN_WIDTH - 18,
            height=WIN_HEIGHT
    ) as main_window:
        with dpg.collapsing_header(label="Processor"):
            with dpg.group(horizontal=True):
                dpg.add_text(f"{gci['brand_raw']} @", bullet=True)
                dpg.add_text(f"{gci['hz_actual_friendly']}")
            with dpg.group(horizontal=True):
                dpg.add_text("CPU Utilization(Total):", bullet=True)
                threading.Thread(target=get_cpu_util, args=(), daemon=True).start()
                cpu_progress_bar = dpg.add_progress_bar(default_value=0.0, overlay="0.0%", width=200)
            dpg.add_text(f"{gci['count']} Total Core/s", bullet=True)
            dpg.add_text(f"{gci['arch']} Architecture", bullet=True)
            with dpg.tree_node(label="Cache/s"):
                try:
                    l1_i = humanize.naturalsize(gci['l1_instruction_cache_size'], gnu=True)
                    dpg.add_text(f"L1 Instruction Cache Size: {l1_i}")
                except KeyError:
                    dpg.add_text("L1 Instruction Cache Size: Can't determine")

                try:
                    l1_d = humanize.naturalsize(gci['l1_data_cache_size'], gnu=True)
                    dpg.add_text(f"L1 Data Cache Size: {l1_d}")
                except KeyError:
                    dpg.add_text("L1 Data Cache Size: Can't determine")

                try:
                    l2 = humanize.naturalsize(gci['l2_cache_size'], gnu=True)
                    dpg.add_text(f"L2 Cache Size: {l2}")
                except KeyError:
                    dpg.add_text("L2 Cache Size: Can't determine")

                try:
                    l3 = humanize.naturalsize(gci['l3_cache_size'], gnu=True)
                    dpg.add_text(f"L3 Cache Size: {l3}")
                except KeyError:
                    dpg.add_text("L3 Cache Size: Can't determine")

            with dpg.tree_node(label="Flags"):
                with dpg.table(
                    header_row=False,
                    resizable=True,
                    policy=dpg.mvTable_SizingStretchProp,
                    row_background=True,
                    borders_outerV=True,
                    borders_innerV=True,
                    borders_outerH=True,
                    borders_innerH=True,
                    delay_search=True
                ):
                    COL = 11
                    FLAG = 0
                    flags = gci['flags']

                    for _ in range(COL):
                        dpg.add_table_column()

                    # https://github.com/hoffstadt/DearPyGui/discussions/1918#discussioncomment-3960795
                    rows = int(len(flags) / COL) + 1
                    for row in range(rows):
                        with dpg.table_row():
                            for col in range(COL):
                                FLAG = row * COL + col
                                if FLAG >= len(flags):
                                    dpg.add_text("---")
                                else:
                                    dpg.add_text(f"{flags[FLAG]}")

        with dpg.collapsing_header(label="Graphics"):
            gpu_temp_placeholder = dpg.add_group(horizontal=False)
            gpu_list = []

            def handle_nvidia_gpus():
                """handle NVIDIA GPUs"""
                gpus = GPUtil.getGPUs()
                for gpu in gpus:
                    if gpu.id not in gpu_temp_texts:
                        dpg.add_text(
                            f"Graphics Name: {gpu.name}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        with dpg.group(horizontal=True, parent=gpu_temp_placeholder):
                            dpg.add_text("GPU Utilization:", bullet=True)
                            gpu_progress_bar = dpg.add_progress_bar(
                                default_value=0.0,
                                overlay="0.0%",
                                width=200
                            )
                            gpu_progress_bars[gpu.id] = gpu_progress_bar

                        gpu_temp_text_id = dpg.add_text(
                            f"Temperature: {gpu.temperature}°C",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        gpu_temp_texts[gpu.id] = gpu_temp_text_id
                    else:
                        dpg.set_value(
                            gpu_temp_texts[gpu.id],
                            f"Temperature: {gpu.temperature}°C"
                        )

            def handle_amd_gpus():
                """handle AMD GPUs"""
                if not AMD_SUPPORTED:
                    return

                amd_manager = pyadl.ADLManager.getInstance()
                devices = amd_manager.getDevices()
                for device in devices:
                    temperature_data = device.getCurrentTemperature()
                    if temperature_data is not None:
                        if device.adapterName not in amd_gpu_temp_texts:
                            dpg.add_text(
                            f"AMD GPU {device.adapterName}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        amd_gpu_temp_text_id = dpg.add_text(
                            f"Temperature: {temperature_data}°C",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        amd_gpu_temp_texts[device.adapterName] = amd_gpu_temp_text_id
                    else:
                        dpg.set_value(
                            amd_gpu_temp_texts[device.adapterName],
                            f"Temperature: {temperature_data}°C"
                        )

            def update_gpu_temperature():
                """Get GPU Temperature and Util Updates"""
                while True:
                    try:
                        handle_nvidia_gpus()
                    except ImportError as import_error:
                        dpg.add_text(
                            f"Error importing GPUtil: {import_error}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                    except Exception as general_exception:
                        dpg.add_text(
                            f"Error fetching NVIDIA GPU information: {general_exception}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )

                    try:
                        handle_amd_gpus()
                    except Exception as general_exception:
                        dpg.add_text(
                            f"Error fetching AMD GPU temperature: {general_exception}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )

                    time.sleep(1)

            # Get GPU Utilization
            def get_gpu_util():
                """Get GPU Utilization"""
                while True:
                    try:
                        gpus = GPUtil.getGPUs()
                        for gpu in gpus:
                            gpu_val = gpu.load * 100
                            dpg.set_value(gpu_progress_bars[gpu.id], 1.0 / 100.0 * gpu_val)
                            dpg.configure_item(gpu_progress_bars[gpu.id], overlay=f"{gpu_val:.2f}%")
                    except (ImportError, Exception) as general_exception:
                        print(f"An error occurred: {general_exception}")
                    time.sleep(1)

        with dpg.collapsing_header(label="Memory"):
            mem = psutil.virtual_memory()
            mem_used = humanize.naturalsize(mem.used)
            mem_percent = mem.percent
            mem_avail = humanize.naturalsize(mem.available)
            mem_total = humanize.naturalsize(mem.total)
            dpg.add_text("MAIN MEMORY", color=(0, 255, 0))
            dpg.add_text(f"Used Memory: {mem_used}({mem_percent}%)", bullet=True)
            dpg.add_text(f"Available Memory: {mem_avail}", bullet=True)
            dpg.add_text(f"Total Memory: {mem_total}", bullet=True)

            swap = psutil.swap_memory()
            swap_used = humanize.naturalsize(swap.used)
            swap_percent = swap.percent
            swap_free = humanize.naturalsize(swap.free)
            swap_total = humanize.naturalsize(swap.total)
            dpg.add_text("SWAP MEMORY", color=(0, 255, 0))
            dpg.add_text(f"Used Swap Memory: {swap_used}({swap_percent}%)", bullet=True)
            dpg.add_text(f"Free Swap Memory: {swap_free}", bullet=True)
            dpg.add_text(f"Total Swap Memory: {swap_total}", bullet=True)

        with dpg.collapsing_header(label="Disk"):
            with dpg.table(
                resizable=True,
                policy=dpg.mvTable_SizingStretchProp,
                borders_outerV=True,
                borders_innerV=True,
                borders_outerH=True,
                borders_innerH=True,
                delay_search=True
            ):
                dpg.add_table_column(label="Device")
                dpg.add_table_column(label="Mount point")
                dpg.add_table_column(label="File System type")
                dpg.add_table_column(label="Used")
                dpg.add_table_column(label="Free")
                dpg.add_table_column(label="Total")

                prts = psutil.disk_partitions()
                for prt in prts:
                    with dpg.table_row():
                        for row in range(8):
                            dpg.add_text(f"{prt.device}", color=(0, 255, 0))
                            dpg.add_text(f"{prt.mountpoint}")
                            dpg.add_text(f"{prt.fstype}")
                            try:
                                usage = psutil.disk_usage(prt.mountpoint)
                            except PermissionError:
                                dpg.add_text("Can't determine")
                                continue
                            dpg.add_text(f"{humanize.naturalsize(usage.used)}({usage.percent}%)")
                            dpg.add_text(f"{humanize.naturalsize(usage.free)}")
                            dpg.add_text(f"{humanize.naturalsize(usage.total)}")

        with dpg.collapsing_header(label="Network"):
            addr_list = psutil.net_if_addrs()
            for name, addresses in addr_list.items():
                with dpg.group(horizontal=True):
                    dpg.add_text("Interface Name: ")
                    dpg.add_text(f"{name}", color=(0, 255, 0))
                for address in addresses:
                    if address.family == socket.AF_INET:
                        dpg.add_text(f"IP Address: {address.address}", bullet=True)
                        dpg.add_text(f"Subnet Mask: {address.netmask}", bullet=True)
                    if address.family == psutil.AF_LINK:
                        dpg.add_text(f"MAC Address: {address.address}", bullet=True)

        with dpg.collapsing_header(label="Operating System"):
            if platform.system() == 'Windows':
                try:
                    BRAND = subprocess.check_output('wmic csproduct get vendor', shell=True)
                    BRAND = BRAND.decode('utf-8').strip().split('\n')[1]
                    MODEL = subprocess.check_output('wmic csproduct get name', shell=True)
                    MODEL = MODEL.decode('utf-8').strip().split('\n')[1]

                    dpg.add_text(f"Brand: {BRAND}", bullet=True)
                    dpg.add_text(f"Model: {MODEL}", bullet=True)
                except subprocess.CalledProcessError:
                    dpg.add_text("Brand: Can't determine", bullet=True)
                    dpg.add_text("Model: Can't determine", bullet=True)

            elif platform.system() == 'Linux':
                try:
                    BRAND = subprocess.check_output('dmidecode -s system-manufacturer', shell=True)
                    BRAND = BRAND.decode('utf-8').strip()
                    MODEL = subprocess.check_output('dmidecode -s system-product-name', shell=True)
                    MODEL = MODEL.decode('utf-8').strip()

                    dpg.add_text(f"Brand: {BRAND}", bullet=True)
                    dpg.add_text(f"Model: {MODEL}", bullet=True)
                except subprocess.CalledProcessError:
                    dpg.add_text("Brand: Can't determine", bullet=True)
                    dpg.add_text("Model: Can't determine", bullet=True)

            uname = platform.uname()
            dpg.add_text(f"System: {uname.system}", bullet=True)
            if uname.system == "Windows":
                if int(uname.version[5:]) > 22000:
                    dpg.add_text("Version: 11", bullet=True)
            dpg.add_text(f"Machine: {uname.machine}", bullet=True)

            timestamp = psutil.boot_time()
            bt = datetime.fromtimestamp(timestamp)
            boot = bt.strftime("%m/%d/%Y %I:%M:%S %p")
            dpg.add_text(f"Last boot timestamp: {boot}", bullet=True)

            if platform.system() == "Windows":
                with dpg.tree_node(label="BIOS"):
                    bios = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\DESCRIPTION\System\BIOS")
                    vendor = winreg.QueryValueEx(bios, "BIOSVendor")
                    version = winreg.QueryValueEx(bios, "BIOSVersion")

                    dpg.add_text(f"Vendor: {vendor[0]}", bullet=True)
                    dpg.add_text(f"Version: {version[0]}", bullet=True)

    threading.Thread(target=update_gpu_temperature, daemon=True).start()
    threading.Thread(target=get_gpu_util, daemon=True).start()

    dpg.create_viewport(
        title="System Information Gatherer",
        #small_icon="res/icon.ico",
        #large_icon="res/icon.ico",
        resizable=False,
        max_width=WIN_WIDTH,
        max_height=WIN_HEIGHT
    )
    dpg.setup_dearpygui()
    dpg.set_primary_window(main_window, True)
    dpg.show_viewport()
    dpg.start_dearpygui()
    dpg.destroy_context()

if screenvar == 7:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon59 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon59)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    def ScreenRec():
        from datetime import datetime
        class ScreenRecorderApp:
            def __init__(self, master):
                self.master = master
                self.master.title("Screen Recorder")
                self.image_icon60 = PhotoImage(file = "img/reclogo.png")
                self.master.iconphoto(False, self.image_icon60)

                self.recording = False

                # Butonul de start înregistrare
                self.record_button = tk.Button(master, text="Start Recording", command=self.toggle_recording, bg="gray40", fg="lime green", bd=7)
                self.record_button.pack(pady=10)

                # Butonul de oprire înregistrare
                self.stop_button = tk.Button(master, text="Stop Recording", command=self.stop_recording, bg="black", fg="red", bd=7, state=tk.DISABLED)
                self.stop_button.pack(pady=5)

                # Butonul de captură de ecran
                self.capture_button = tk.Button(master, text="Capture Screen", command=self.capture_screen, bg="gray40", fg="lime green", bd=7)
                self.capture_button.pack(pady=5)

            def start_recording(self):
                self.recording = True
                self.master.iconify()  # Minimizează fereastra Tkinter
                self.record_button.config(text="Recording...", bg="black", fg="white", state=tk.DISABLED)
                self.stop_button.config(bg="gray40", fg="red", state=tk.NORMAL)
                threading.Thread(target=self.record_screen).start()

            def stop_recording(self):
                self.recording = False
                self.master.deiconify()  # Restaurează fereastra Tkinter
                self.record_button.config(text="Start Recording", bg="gray40", fg="lime green", state=tk.NORMAL)
                self.stop_button.config(bg="black", fg="white", state=tk.DISABLED)

            def toggle_recording(self):
                if self.recording:
                    self.stop_recording()
                else:
                    self.start_recording()

            def record_screen(self):
                # Set up video writer
                width, height = pyautogui.size()
                fourcc = cv2.VideoWriter_fourcc(*'XVID')
                
                # Get current time
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                
                out = cv2.VideoWriter(f'screen_record_{current_time}.avi', fourcc, 20.0, (width, height))

                while self.recording:
                    # Capture screen
                    screenshot = pyautogui.screenshot()
                    frame = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                    out.write(frame)

                # Release video writer
                out.release()

            def capture_screen(self):
                self.master.iconify()  # Minimizează fereastra Tkinter
                
                # Capture screen
                screenshot = pyautogui.screenshot()
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                screenshot.save(f'screenshot_{current_time}.png')
                
                self.master.deiconify()  # Restaurează fereastra Tkinter

        scrrec = tk.Tk()
        app = ScreenRecorderApp(scrrec)
        scrrec.resizable(False, False)
        scrrec.config(bg="gray20")
        scrrec.geometry("150x150")
        scrrec.mainloop()

    ScreenRec()

if zipvar == 8:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon61 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon61)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()


    def ZIPF():
        import os
        import subprocess
        import tkinter as tk
        from tkinter import filedialog, messagebox, ttk
        import zipfile
        from tkinter import simpledialog



        class Window:
            def __init__(self, master):
                self.file_sel = ""
                master.title("Create/Extract ZIP files")
                master.resizable(False, False)
                image_icon62 = PhotoImage(file = "img/complogo.png")
                master.iconphoto(False, image_icon62)
                self.frame1 = ttk.LabelFrame(master, height=100, width=400, text="Actions")
                self.frame1.pack(padx=10, pady=10)
                self.frame2 = ttk.LabelFrame(master, height=100, width=400, text="Information about zip file")
                self.frame2.pack(padx=10, pady=10)
                self.frame3 = ttk.LabelFrame(master, height=100, width=400, text="List of files and folders inside zip file")
                self.frame3.pack(padx=10, pady=10)

                self.button1 = ttk.Button(self.frame1, text="Browse zip file", command=self.button_file)
                self.button1.pack(side=tk.LEFT, padx=10, pady=10)

                self.button2 = ttk.Button(self.frame1, text="Unzip directory", command=self.change_dir)
                self.button2.pack(side=tk.LEFT, padx=10, pady=10)

                self.button3 = ttk.Button(self.frame1, text="Extract All", command=self.button_extract_all)
                self.button3.pack(side=tk.LEFT, padx=10, pady=10)

                self.button4 = ttk.Button(self.frame1, text="Extract Selection", command=self.button_extract_sel)
                self.button4.pack(side=tk.LEFT, padx=10, pady=10)
                
                self.button5 = ttk.Button(self.frame1, text="Create ZIP", command=self.button_create_zip)
                self.button5.pack(side=tk.LEFT, padx=10, pady=10)

                self.label_frame_2 = ttk.Label(self.frame2, text="Select a zip file", width=100)
                self.label_frame_2.pack(padx=10, pady=10)

                self.treeview = ttk.Treeview(self.frame3, show="tree", selectmode="extended")
                self.treeview.pack(padx=10, pady=10)
                self.treeview["column"] = ("one")
                self.treeview.column("one", width=400)
                self.treeview.bind("<<TreeviewSelect>>", self.callback)

                self.label1 = ttk.Label(master)
                self.label1.pack()
                
            def button_create_zip(self):
                dir_path = filedialog.askdirectory()
                if dir_path:
                    zip_file_path = filedialog.asksaveasfilename(defaultextension=".zip", filetypes=[("ZIP files", "*.zip")])
                    if zip_file_path:
                        with zipfile.ZipFile(zip_file_path, 'w') as z:
                            for root, _, files in os.walk(dir_path):
                                for file in files:
                                    file_path = os.path.join(root, file)
                                    rel_path = os.path.relpath(file_path, dir_path)
                                    z.write(file_path, rel_path)
                        messagebox.showinfo("Success", "ZIP archive created successfully.")



            def callback(self, event):
                self.button4.config(state="enabled")
                print(self.treeview.selection())

            def button_file(self):
                self.file_sel = self.find_file("file")
                if self.is_zip(self.file_sel):
                    zip1 = ZipData(self.file_sel)
                    self.update_label(1)
                    self.label_frame_2.config(text="You have selected the zip file " + self.file_sel + "\n" + str(zip1.len_zip()) + " items found in the zip file")
                    self.button3.config(state="enabled")
                    for elt in zip1.info():
                        elt_split = elt.split("/")
                        if "" in elt_split:
                            elt_split.remove("")
                        if len(elt_split) == 1:
                            parent = ""
                        else:
                            parent = "/".join(elt_split[:-1])

                        if not self.treeview.exists(parent):
                            self.treeview.insert("", "end", parent, text=elt_split[0])

                        self.treeview.insert(parent, "end", "/".join(elt_split), text=elt_split[-1])

            def button_extract_all(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_all()
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def button_extract_sel(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_sel(self.treeview.selection())
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def clean_window(self):
                self.update_label(2)
                self.label_frame_2.config(text="")
                for i in self.treeview.get_children():
                    self.treeview.delete(i)
                subprocess.Popen("explorer " + os.getcwd())

            @staticmethod
            def find_file(f_type):
                f_name = ""
                if f_type == "file":
                    file_name = filedialog.askopenfile()
                    if file_name:
                        f_name = file_name.name
                return f_name

            @staticmethod
            def is_zip(zip_path):
                if zip_path[-4:] != ".zip":
                    messagebox.showerror("Type file error", "You need to select a zip file")
                    return False
                else:
                    return True

            def change_dir(self):
                """ Change the current directory """
                dir_path = filedialog.askdirectory()
                if dir_path:
                    os.chdir(dir_path)
                    self.update_label(1)


            def update_label(self, val):
                if val == 1:
                    self.label1.config(text="The zip file will be extracted in the directory " + self.find_dir())
                if val == 2:
                    self.label1.config(text="Zip file successfully extracted")

            @staticmethod
            def find_dir():
                cwd = os.getcwd()
                return cwd


        class ZipData:
            def __init__(self, file):
                self.file = file

            def extract_all(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    z.extractall()

            def extract_sel(self, file_name):
                with zipfile.ZipFile(self.file, 'r') as z:
                    for f_name in file_name:
                        z.extract(f_name)

            def len_zip(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    nb_items = len(z.namelist())
                    return nb_items

            def info(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    return z.namelist()


        if __name__ == "__main__":
            ziproot = tk.Tk()
            win = Window(ziproot)
            ziproot.mainloop()

    ZIPF()

if compvar == 9:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon63 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon63)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()


    # Importuri standard
    import argparse
    import sys
    import os
    import difflib
    import mimetypes
    import filecmp

    # Importuri pentru interfața grafică
    try:
        from tkinter import *
        from tkinter.filedialog import askopenfilename, askdirectory
        from tkinter.simpledialog import askstring
        from tkinter.messagebox import showerror
        from tkinter import font
        from tkinter import ttk
        from tkinter.ttk import Treeview
    except ImportError:    # Python 2 fallback
        from Tkinter import *
        from tkFileDialog import askopenfilename, askdirectory
        from tkSimpleDialog import askstring
        from tkMessageBox import showerror
        from tkFont import Font
        import ttk
        from ttk import Treeview

    class DiffCode:
        SIMILAR = 0         # starts with '  '
        RIGHTONLY = 1       # starts with '+ '
        LEFTONLY = 2        # starts with '- '
        CHANGED = 3         # either three or four lines with the prefixes ('-', '+', '?'), ('-', '?', '+') or ('-', '?', '+', '?') respectively

    class DifflibParser:
        def __init__(self, text1, text2):
            self.__text1 = text1
            self.__text2 = text2
            self.__diff = list(difflib.ndiff(text1, text2))
            self.__currentLineno = 0

        def __iter__(self):
            return self

        def __next__(self):  # python3
            result = {}
            if self.__currentLineno >= len(self.__diff):
                raise StopIteration
            currentLine = self.__diff[self.__currentLineno]
            code = currentLine[:2]
            line = currentLine[2:]
            result['line'] = line
            if code == '  ':
                result['code'] = DiffCode.SIMILAR
            elif code == '- ':
                incrementalChange = self.__tryGetIncrementalChange(self.__currentLineno)
                if not incrementalChange:
                    result['code'] = DiffCode.LEFTONLY
                else:
                    result['code'] = DiffCode.CHANGED
                    result['leftchanges'] = incrementalChange['left'] if 'left' in incrementalChange else None
                    result['rightchanges'] = incrementalChange['right'] if 'right' in incrementalChange else None
                    result['newline'] = incrementalChange['newline']
                    self.__currentLineno += incrementalChange['skiplines']
            elif code == '+ ':
                result['code'] = DiffCode.RIGHTONLY
            self.__currentLineno += 1
            return result

        next = __next__  # for Python 2
        
        def __tryGetIncrementalChange(self, lineno):
            lineOne = self.__diff[lineno] if lineno < len(self.__diff) else None
            lineTwo = self.__diff[lineno + 1] if lineno + 1 < len(self.__diff) else None
            lineThree = self.__diff[lineno + 2] if lineno + 2 < len(self.__diff) else None
            lineFour = self.__diff[lineno + 3] if lineno + 3 < len(self.__diff) else None

            changes = {}
            # ('-', '?', '+', '?') case
            if lineOne and lineOne[:2] == '- ' and \
               lineTwo and lineTwo[:2] == '? ' and \
               lineThree and lineThree[:2] == '+ ' and \
               lineFour and lineFour[:2] == '? ':
                changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                changes['right'] = [i for (i,c) in enumerate(lineFour[2:]) if c in ['+', '^']]
                changes['newline'] = lineThree[2:]
                changes['skiplines'] = 3
                return changes
            # ('-', '+', '?')
            elif lineOne and lineOne[:2] == '- ' and \
               lineTwo and lineTwo[:2] == '+ ' and \
               lineThree and lineThree[:2] == '? ':
                changes['right'] = [i for (i,c) in enumerate(lineThree[2:]) if c in ['+', '^']]
                changes['left'] = []
                changes['newline'] = lineTwo[2:]
                changes['skiplines'] = 2
                return changes
            # ('-', '?', '+')
            elif lineOne and lineOne[:2] == '- ' and \
               lineTwo and lineTwo[:2] == '? ' and \
               lineThree and lineThree[:2] == '+ ':
                changes['right'] = []
                changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                changes['newline'] = lineThree[2:]
                changes['skiplines'] = 2
                return changes
            # no incremental change
            else:
                return None
        
    class SearchTextDialog(Frame):

        def __init__(self, parent, textwidgets, searchButtonCallback):
            Frame.__init__(self, parent)

            self.parent = parent
            self.__searchCallback = searchButtonCallback
            self.__textwidgets = textwidgets
            self.__searchStr = None
            self.initUI()

        def initUI(self):
            self.searchTextFrame = Frame(self.parent)

            self.searchTextEntry = Entry(self)
            self.searchTextEntry.pack(fill=BOTH, expand=True, side=LEFT)

            self.__matchCaseVar = IntVar()
            self.__matchCaseVar.set(0)
            self.searchTextCheckbutton = Checkbutton(self, text='Match case', variable=self.__matchCaseVar, command=lambda *x: self.clearSearch())
            self.searchTextCheckbutton.pack(side=LEFT, padx=10)

            self.searchTextButton = Button(self, text='Find', command=self.nextResult)
            self.searchTextButton.pack(side=LEFT)

            self.searchTextEntry.bind('<Return>', self.nextResult)
            self.searchTextButton.bind('<Return>', self.nextResult)
            self.__curSearchResult = {'term': None, 'indices': ['0.0'] * len(self.__textwidgets)}
            self.__insession = False

        def getSearchTerm(self):
            return self.searchTextEntry.get()

        def focus(self):
            self.searchTextEntry.focus_set()
            self.searchTextEntry.select_range(0, END)
            self.__insession = True

        def nextResult(self, *args):
            if not self.__insession: return

            searchStr = self.searchTextEntry.get()

            if not self.__searchStr or self.__searchStr != searchStr:
                self.__searchStr = searchStr
                self.__curSearchResult = {'term': searchStr, 'indices': ['0.0'] * len(self.__textwidgets)}

            if searchStr in ['', None]: return

            countVar = StringVar()
            for i,t in enumerate(self.__textwidgets):
                if self.__curSearchResult['indices'][i] == -1: continue
                nextIdx = float(self.__curSearchResult['indices'][i]) + 1
                pos = t.search(self.__searchStr, nextIdx, END, nocase=self.__matchCaseVar.get() == 0)
                self.__curSearchResult['indices'][i] = pos if pos else -1

            self.__searchCallback(self.__curSearchResult)

        def clearSearch(self):
            self.__curSearchResult['indices'] = ['0.0'] * len(self.__textwidgets)

        def unfocus(self):
            self.clearSearch()
            self.__insession = False

    class MainWindowUI:

    # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |
    # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |                                     menu bar                                                  |
    # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |               |                                     search bar                                |
    # |               |          search entry                                                 | button|
    # |               +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |   treeview    |                                       |                                       |
    # |               |              text area 1              |               text area 2             |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |

        # Rows
        fileTreeRow = filePathLabelsRow = 0
        searchTextRow = 1
        uniScrollbarRow = lineNumbersRow = textAreasRow = 2
        horizontalScrollbarRow = 3

        # Columns
        fileTreeCol = 0
        fileTreeScrollbarCol = 1
        leftLineNumbersCol = leftFilePathLabelsCol = 2    # should span at least two columns
        leftTextAreaCol = leftHorizontalScrollbarCol = 3
        uniScrollbarCol = 4
        rightLineNumbersCol = rightFilePathLabelsCol = 5  # should span at least two columns
        rightTextAreaCol = rightHorizontalScrollbarCol = 6

        # Colors
        whiteColor = '#ffffff'
        redColor = '#ffc4c4'
        darkredColor = '#ff8282'
        grayColor = '#dddddd'
        lightGrayColor = '#eeeeee'
        greenColor = '#c9fcd6'
        darkgreenColor = '#50c96e'
        yellowColor = '#f0f58c'
        darkYellowColor = '#ffff00'
        purpleLight = '#F5EBFC'

        def __init__(self, window):
            self.main_window = window
            self.main_window.grid_rowconfigure(self.filePathLabelsRow, weight=0)
            self.main_window.grid_rowconfigure(self.searchTextRow, weight=0)
            self.main_window.grid_rowconfigure(self.textAreasRow, weight=1)

            self.main_window.grid_columnconfigure(self.fileTreeCol, weight=0)
            self.main_window.grid_columnconfigure(self.fileTreeScrollbarCol, weight=0)
            self.main_window.grid_columnconfigure(self.leftLineNumbersCol, weight=0)
            self.main_window.grid_columnconfigure(self.leftTextAreaCol, weight=1)
            self.main_window.grid_columnconfigure(self.uniScrollbarCol, weight=0)
            self.main_window.grid_columnconfigure(self.rightLineNumbersCol, weight=0)
            self.main_window.grid_columnconfigure(self.rightTextAreaCol, weight=1)
            self.menubar = Menu(self.main_window)
            self.menus = {}
            self.text_area_font = 'TkFixedFont'

        # Center window and set its size
        def center_window(self):
            sw = self.main_window.winfo_screenwidth()
            sh = self.main_window.winfo_screenheight()

            w = 0.7 * sw
            h = 0.7 * sh

            x = (sw - w)/2
            y = (sh - h)/2
            self.main_window.geometry('%dx%d+%d+%d' % (w, h, x, y))
            self.main_window.minsize(int(0.3 * sw), int(0.3 * sh))

        # Menu bar
        def add_menu(self, menuName, commandList):
            self.menus[menuName] = Menu(self.menubar,tearoff=0)
            for c in commandList:
                if 'separator' in c: self.menus[menuName].add_separator()
                else: self.menus[menuName].add_command(label=c['name'], command=c['command'], accelerator=c['accelerator'] if 'accelerator' in c else '')
            self.menubar.add_cascade(label=menuName, menu=self.menus[menuName])
            self.main_window.config(menu=self.menubar)

        # Labels
        def create_file_path_labels(self):
            self.leftFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
            self.leftFileLabel.grid(row=self.filePathLabelsRow, column=self.leftFilePathLabelsCol, columnspan=2)
            self.rightFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
            self.rightFileLabel.grid(row=self.filePathLabelsRow, column=self.rightFilePathLabelsCol, columnspan=2)

        # Search text entry
        def create_search_text_entry(self, searchButtonCallback):
            self.searchTextDialog = SearchTextDialog(self.main_window, [self.leftFileTextArea, self.rightFileTextArea], searchButtonCallback)
            self.searchTextDialog.grid(row=self.searchTextRow, column=self.leftFilePathLabelsCol, columnspan=5, sticky=EW)

            self.searchTextDialog.grid_remove()

        # File treeview
        def create_file_treeview(self):
            self.fileTreeView = Treeview(self.main_window)
            self.fileTreeYScrollbar = Scrollbar(self.main_window, orient='vertical', command=self.fileTreeView.yview)
            self.fileTreeXScrollbar = Scrollbar(self.main_window, orient='horizontal', command=self.fileTreeView.xview)
            self.fileTreeView.configure(yscroll=self.fileTreeYScrollbar.set, xscroll=self.fileTreeXScrollbar.set)

            self.fileTreeView.grid(row=self.fileTreeRow, column=self.fileTreeCol, sticky=NS, rowspan=3)
            self.fileTreeYScrollbar.grid(row=self.fileTreeRow, column=self.fileTreeScrollbarCol, sticky=NS, rowspan=3)
            self.fileTreeXScrollbar.grid(row=self.horizontalScrollbarRow, column=self.fileTreeCol, sticky=EW)

            self.fileTreeView.tag_configure('red', background=self.redColor)
            self.fileTreeView.tag_configure('green', background=self.greenColor)
            self.fileTreeView.tag_configure('yellow', background=self.yellowColor)
            self.fileTreeView.tag_configure('purpleLight', background=self.purpleLight)

            # hide it until needed
            self.fileTreeView.grid_remove()
            self.fileTreeYScrollbar.grid_remove()
            self.fileTreeXScrollbar.grid_remove()

        # Text areas
        def create_text_areas(self):
            self.leftFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
            self.leftFileTextArea.grid(row=self.textAreasRow, column=self.leftTextAreaCol, sticky=NSEW)
            self.leftFileTextArea.config(font=self.text_area_font)
            self.leftFileTextArea.config(wrap='none')

            self.rightFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
            self.rightFileTextArea.grid(row=self.textAreasRow, column=self.rightTextAreaCol, sticky=NSEW)
            self.rightFileTextArea.config(font=self.text_area_font)
            self.rightFileTextArea.config(wrap='none')

            # configuring highlight tags
            self.leftFileTextArea.tag_configure('red', background=self.redColor)
            self.leftFileTextArea.tag_configure('darkred', background=self.darkredColor)
            self.leftFileTextArea.tag_configure('gray', background=self.grayColor)
            self.leftFileTextArea.tag_configure('search', background=self.darkYellowColor)
            self.rightFileTextArea.tag_configure('green', background=self.greenColor)
            self.rightFileTextArea.tag_configure('darkgreen', background=self.darkgreenColor)
            self.rightFileTextArea.tag_configure('gray', background=self.grayColor)
            self.rightFileTextArea.tag_configure('search', background=self.darkYellowColor)
            self.rightFileTextArea.tag_configure('purpleLight', background=self.purpleLight)

            # disable the text areas
            self.leftFileTextArea.config(state=DISABLED)
            self.rightFileTextArea.config(state=DISABLED)

        # Line numbers
        def create_line_numbers(self):
            self.leftLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
            self.leftLinenumbers.grid(row=self.lineNumbersRow, column=self.leftLineNumbersCol, sticky=NS)
            self.leftLinenumbers.config(font=self.text_area_font)
            self.leftLinenumbers.tag_configure('line', justify='right')

            self.rightLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
            self.rightLinenumbers.grid(row=self.lineNumbersRow, column=self.rightLineNumbersCol, sticky=NS)
            self.rightLinenumbers.config(font=self.text_area_font)
            self.rightLinenumbers.tag_configure('line', justify='right')

            # disable the line numbers
            self.leftLinenumbers.config(state=DISABLED)
            self.rightLinenumbers.config(state=DISABLED)

        # Scroll bars
        def scrollBothY(self, action, position, type=None):
            self.leftFileTextArea.yview_moveto(position)
            self.rightFileTextArea.yview_moveto(position)
            self.leftLinenumbers.yview_moveto(position)
            self.rightLinenumbers.yview_moveto(position)

        def updateScrollY(self, first, last, type=None):
            self.leftFileTextArea.yview_moveto(first)
            self.rightFileTextArea.yview_moveto(first)
            self.leftLinenumbers.yview_moveto(first)
            self.rightLinenumbers.yview_moveto(first)
            self.uniScrollbar.set(first, last)

        def scrollBothX(self, action, position, type=None):
            self.leftFileTextArea.xview_moveto(position)
            self.rightFileTextArea.xview_moveto(position)

        def updateScrollX(self, first, last, type=None):
            self.leftFileTextArea.xview_moveto(first)
            self.rightFileTextArea.xview_moveto(first)
            self.leftHorizontalScrollbar.set(first, last)
            self.rightHorizontalScrollbar.set(first, last)

        def create_scroll_bars(self):
            self.uniScrollbar = Scrollbar(self.main_window)
            self.uniScrollbar.grid(row=self.uniScrollbarRow, column=self.uniScrollbarCol, sticky=NS)
            self.uniScrollbar.config(command=self.scrollBothY)
            self.leftFileTextArea.config(yscrollcommand=self.updateScrollY)
            self.rightFileTextArea.config(yscrollcommand=self.updateScrollY)
            self.leftLinenumbers.config(yscrollcommand=self.updateScrollY)
            self.rightLinenumbers.config(yscrollcommand=self.updateScrollY)

            self.leftHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
            self.leftHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.leftHorizontalScrollbarCol, sticky=EW)
            self.leftHorizontalScrollbar.config(command=self.scrollBothX)
            self.leftFileTextArea.config(xscrollcommand=self.updateScrollX)

            self.rightHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
            self.rightHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.rightHorizontalScrollbarCol, sticky=EW)
            self.rightHorizontalScrollbar.config(command=self.scrollBothX)
            self.rightFileTextArea.config(xscrollcommand=self.updateScrollX)

    class MainWindow:
        def start(self, leftpath = None, rightpath = None):
            self.main_window = Tk()
            self.main_window.title('Comparator')
            self.__main_window_ui = MainWindowUI(self.main_window)
            self.image_icon64 = PhotoImage(file = "img/complogo.png")
            self.main_window.iconphoto(False, self.image_icon64)

            self.leftFile = ''
            self.rightFile = ''

            self.__main_window_ui.center_window()
            self.__main_window_ui.create_file_path_labels()
            self.__main_window_ui.create_text_areas()
            self.__main_window_ui.create_search_text_entry(self.__findNext)
            self.__main_window_ui.create_line_numbers()
            self.__main_window_ui.create_scroll_bars()
            self.__main_window_ui.create_file_treeview()
            path_to_my_project = os.getcwd()
            self.__main_window_ui.add_menu('File', [
                {'name': 'Compare Files', 'command': self.__browse_files},
                {'name': 'Compare Directories', 'command': self.__browse_directories},
                {'separator'},
                {'name': 'Exit', 'command': self.__exit, 'accelerator': 'Alt+F4'}
                ])
            self.__main_window_ui.add_menu('Edit', [
                {'name': 'Find', 'command': self.__startFindText, 'accelerator': 'Ctrl+F'},
                {'separator'},
                {'name': 'Cut', 'command': self.__cut, 'accelerator': 'Ctrl+X'},
                {'name': 'Copy', 'command': self.__copy, 'accelerator': 'Ctrl+C'},
                {'name': 'Paste', 'command': self.__paste, 'accelerator': 'Ctrl+P'},
                {'separator'},
                {'name': 'Go To Line', 'command': self.__goToLine, 'accelerator': 'Ctrl+G'}
                ])
            self.__main_window_ui.fileTreeView.bind('<<TreeviewSelect>>', lambda *x:self.treeViewItemSelected())

            if (leftpath and os.path.isdir(leftpath)) or (rightpath and os.path.isdir(rightpath)):
                self.__load_directories(leftpath, rightpath)
            else:
                self.leftFile = leftpath if leftpath else ''
                self.rightFile = rightpath if rightpath else ''
                self.filesChanged()

            self.__bind_key_shortcuts()

            self.main_window.mainloop()

        def __bind_key_shortcuts(self):
            self.main_window.bind('<Control-f>', lambda *x: self.__startFindText())
            self.main_window.bind('<Control-g>', lambda *x: self.__goToLine())
            self.main_window.bind('<Escape>', lambda *x: self.__endFindText())
            self.main_window.bind('<F3>', self.__main_window_ui.searchTextDialog.nextResult)

        def __browse_files(self):
            self.__load_file('left')
            self.__load_file('right')
            self.filesChanged()
            self.__main_window_ui.fileTreeView.grid_remove()
            self.__main_window_ui.fileTreeYScrollbar.grid_remove()
            self.__main_window_ui.fileTreeXScrollbar.grid_remove()

        # Load directories into the treeview
        def __browse_directories(self):
            leftDir = self.__load_directory('left')
            rightDir = self.__load_directory('right')
            self.__load_directories(leftDir, rightDir)

        def __load_directories(self, leftDir, rightDir):
            if leftDir and rightDir:
                self.__main_window_ui.fileTreeView.grid()
                self.__main_window_ui.fileTreeYScrollbar.grid()
                self.__main_window_ui.fileTreeXScrollbar.grid()
                self.__main_window_ui.fileTreeView.delete(*self.__main_window_ui.fileTreeView.get_children())
                self.__browse_process_directory('', leftDir, rightDir)

        # Recursive method to fill the treevie with given directory hierarchy
        def __browse_process_directory(self, parent, leftPath, rightPath):
            if parent == '':
                leftPath = leftPath.rstrip('/')
                rightPath = rightPath.rstrip('/')
                leftDirName = os.path.basename(leftPath)
                rightDirName = os.path.basename(rightPath)
                self.__main_window_ui.fileTreeView.heading('#0', text=leftDirName + ' / ' + rightDirName, anchor=W)
            leftListing = os.listdir(leftPath)
            rightListing = os.listdir(rightPath)
            mergedListing = list(set(leftListing) | set(rightListing))
            painted = FALSE
            for l in mergedListing:
                newLeftPath = leftPath + '/' + l
                newRightPath = rightPath + '/' + l
                bindValue = (newLeftPath, newRightPath)
                # Item in left dir only
                if l in leftListing and l not in rightListing:
                    self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('red','simple'))
                    painted = TRUE
                # Item in right dir only
                elif l in rightListing and l not in leftListing:
                    self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('green','simple'))
                    painted = TRUE
                # Item in both dirs
                else:
                    # If one of the diffed items is a file and the other is a directory, show in yellow indicating a difference
                    if (not os.path.isdir(newLeftPath) and os.path.isdir(newRightPath)) or (os.path.isdir(newLeftPath) and not os.path.isdir(newRightPath)):
                        self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                        painted = TRUE
                    else:
                        # If both are directories, show in white and recurse on contents
                        if os.path.isdir(newLeftPath) and os.path.isdir(newRightPath):
                            oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, open=False)
                            painted = self.__browse_process_directory(oid, newLeftPath, newRightPath)
                            if painted:
                                self.__main_window_ui.fileTreeView.item(oid, tags=('purpleLight', 'simple'))
                        else:
                            # Both are files. diff the two files to either show them in white or yellow
                            if (filecmp.cmp(newLeftPath, newRightPath)):
                                oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('simple'))
                            else:
                                oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                                painted = TRUE
            return painted

        def __load_file(self, pos):
            fname = askopenfilename()
            if fname:
                if pos == 'left':
                    self.leftFile = fname
                else:
                    self.rightFile = fname
                return fname
            else:
                return None

        def __load_directory(self, pos):
            dirName = askdirectory()
            if dirName:
                if pos == 'left':
                    self.__main_window_ui.leftFileLabel.config(text=dirName)
                else:
                    self.__main_window_ui.rightFileLabel.config(text=dirName)
                return dirName
            else:
                return None

        # Callback for changing a file path
        def filesChanged(self):
            self.__main_window_ui.leftLinenumbers.grid_remove()
            self.__main_window_ui.rightLinenumbers.grid_remove()

            if not self.leftFile or not self.rightFile:
                self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.grayColor)
                self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.grayColor)
                return

            if os.path.exists(self.leftFile):
                self.__main_window_ui.leftFileLabel.config(text=self.leftFile)
                self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.whiteColor)
                self.__main_window_ui.leftLinenumbers.grid()
            else:
                self.__main_window_ui.leftFileLabel.config(text='')

            if os.path.exists(self.rightFile):
                self.__main_window_ui.rightFileLabel.config(text=self.rightFile)
                self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.whiteColor)
                self.__main_window_ui.rightLinenumbers.grid()
            else:
                self.__main_window_ui.rightFileLabel.config(text='')

            self.diff_files_into_text_areas()

        def treeViewItemSelected(self):
            item_id = self.__main_window_ui.fileTreeView.focus()
            paths = self.__main_window_ui.fileTreeView.item(item_id)['values']
            if paths == None or len(paths) == 0:
                return
            self.leftFile = paths[0]
            self.rightFile = paths[1]
            self.filesChanged()

        # Insert file contents into text areas and highlight differences
        def diff_files_into_text_areas(self):
            try:
                leftFileContents = open(self.leftFile).read()
            except:
                leftFileContents = ''
            try:
                rightFileContents = open(self.rightFile).read()
            except:
                rightFileContents = ''

            diff = DifflibParser(leftFileContents.splitlines(), rightFileContents.splitlines())

            # enable text area edits so we can clear and insert into them
            self.__main_window_ui.leftFileTextArea.config(state=NORMAL)
            self.__main_window_ui.rightFileTextArea.config(state=NORMAL)
            self.__main_window_ui.leftLinenumbers.config(state=NORMAL)
            self.__main_window_ui.rightLinenumbers.config(state=NORMAL)

            # clear all text areas
            self.__main_window_ui.leftFileTextArea.delete(1.0, END)
            self.__main_window_ui.rightFileTextArea.delete(1.0, END)
            self.__main_window_ui.leftLinenumbers.delete(1.0, END)
            self.__main_window_ui.rightLinenumbers.delete(1.0, END)

            leftlineno = rightlineno = 1
            for line in diff:
                if line['code'] == DiffCode.SIMILAR:
                    self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n')
                    self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n')
                elif line['code'] == DiffCode.RIGHTONLY:
                    self.__main_window_ui.leftFileTextArea.insert('end', '\n', 'gray')
                    self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n', 'green')
                elif line['code'] == DiffCode.LEFTONLY:
                    self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n', 'red')
                    self.__main_window_ui.rightFileTextArea.insert('end', '\n', 'gray')
                elif line['code'] == DiffCode.CHANGED:
                    for (i,c) in enumerate(line['line']):
                        self.__main_window_ui.leftFileTextArea.insert('end', c, 'darkred' if i in line['leftchanges'] else 'red')
                    for (i,c) in enumerate(line['newline']):
                        self.__main_window_ui.rightFileTextArea.insert('end', c, 'darkgreen' if i in line['rightchanges'] else 'green')
                    self.__main_window_ui.leftFileTextArea.insert('end', '\n')
                    self.__main_window_ui.rightFileTextArea.insert('end', '\n')

                if line['code'] == DiffCode.LEFTONLY:
                    self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                    self.__main_window_ui.rightLinenumbers.insert('end', '\n', 'line')
                    leftlineno += 1
                elif line['code'] == DiffCode.RIGHTONLY:
                    self.__main_window_ui.leftLinenumbers.insert('end', '\n', 'line')
                    self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                    rightlineno += 1
                else:
                    self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                    self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                    leftlineno += 1
                    rightlineno += 1

            # calc width of line numbers texts and set it
            self.__main_window_ui.leftLinenumbers.config(width=len(str(leftlineno)))
            self.__main_window_ui.rightLinenumbers.config(width=len(str(rightlineno)))

            # disable text areas to prevent further editing
            self.__main_window_ui.leftFileTextArea.config(state=DISABLED)
            self.__main_window_ui.rightFileTextArea.config(state=DISABLED)
            self.__main_window_ui.leftLinenumbers.config(state=DISABLED)
            self.__main_window_ui.rightLinenumbers.config(state=DISABLED)

        def __cut(self):
            area = self.__getActiveTextArea()
            if area:
                area.event_generate("<<Cut>>")

        def __copy(self):
            area = self.__getActiveTextArea()
            if area:
                area.event_generate("<<Copy>>")

        def __paste(self):
            area = self.__getActiveTextArea()
            if area:
                area.event_generate("<<Paste>>")

        def __getActiveTextArea(self):
            if self.main_window.focus_get() == self.__main_window_ui.leftFileTextArea:
                return self.__main_window_ui.leftFileTextArea
            elif self.main_window.focus_get() == self.__main_window_ui.rightFileTextArea:
                return self.__main_window_ui.rightFileTextArea
            else:
                return None

        def __goToLine(self):
            line = askstring('Go to line', 'Enter line number:')
            if line:
                try:
                    linenumber = int(line)
                    self.__main_window_ui.leftFileTextArea.see(float(linenumber) + 5)
                except:
                    pass

        def __startFindText(self):
            self.__main_window_ui.searchTextDialog.grid()
            self.__main_window_ui.searchTextDialog.focus()

        def __endFindText(self):
            self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
            self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
            self.__main_window_ui.searchTextDialog.unfocus()
            self.__main_window_ui.searchTextDialog.grid_remove()

        def __findNext(self, searchresult):
            term,leftpos,rightpos = searchresult['term'], searchresult['indices'][0], searchresult['indices'][1]
            if leftpos != -1:
                self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.leftFileTextArea.tag_add('search', leftpos, '%s + %sc' % (leftpos, len(term)))
                # scroll to position plus five lines for visibility
                self.__main_window_ui.leftFileTextArea.see(float(leftpos) + 5)
            if rightpos != -1:
                self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.rightFileTextArea.tag_add('search', rightpos, '%s + %sc' % (rightpos, len(term)))
                # scroll to position plus five lines for visibility
                self.__main_window_ui.rightFileTextArea.see(float(rightpos) + 5)

        def __exit(self):
            self.main_window.destroy()

    class FileIO:
        def load_file_to_text_area(self, fname, textArea):
            textArea.config(state=NORMAL)
            try:
                text = open(fname).read()
                textArea.delete(1.0, END) 
                textArea.insert(1.0, text)
            except Exception as e:
                showerror('Open Source File', 'Failed to read file\n"%s". Error: %s' % (fname, e))
            finally:
                textArea.config(state=DISABLED)

    parser = argparse.ArgumentParser(description="pydiff - Tkinter GUI tool based on Python's difflib")
    parser.add_argument('-p', '--paths', metavar=('path1', 'path2'), nargs=2, help='Two paths to compare', required=False)

    args = parser.parse_args()

    leftpath = args.paths[0] if args.paths else None
    rightpath = args.paths[1] if args.paths else None

    main_window = MainWindow()
    main_window.start(leftpath, rightpath)

if pdfvar == 10:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon65 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon65)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()


    gpath = ""

    def openfile():
        tb.delete(0, END)
        global gpath
        filterex = [('PDF File', '*.pdf'), ('All Files', '*.*')]
        userfile = fd.askopenfile(title="Open PDF", filetypes=filterex)
        if userfile:
            tb.insert(0, userfile.name)
            gpath = userfile.name

    def convert_to_word():
        global gpath
        if gpath:
            pdf_document = aw.Document(gpath)
            pdf_document.save("pdf.docx")
            mb.showinfo("Succes", "The file has been converted to Word.")
        else:
            mb.showerror("Error", "No PDF file has been selected.")

    def convert_to_word_and_extract_images():
        global gpath
        if gpath:
            # Converting selected PDF file to Word DOCX format
            pdf_document = aw.Document(gpath)
            pdf_document.save("pdf.docx")

            # Opening the converted DOCX file
            doc = Document("pdf.docx")

            # Retrieving all shapes (images) from the DOCX file
            shapes = doc.get_child_nodes(aw.NodeType.SHAPE, True)
            imageIndex = 0

            # Folder path to save images
            folder_path = "imagini/"

            # Create the folder if it doesn't exist
            if not os.path.exists(folder_path):
                os.makedirs(folder_path)

            # Looping through the shapes (images)
            for shape in shapes:
                shape = shape.as_shape()
                if shape.has_image:
                    # Setting the image file's name
                    imageFileName = f"{folder_path}Image.ExportImages.{imageIndex}_{aw.FileFormatUtil.image_type_to_extension(shape.image_data.image_type)}"

                    # Saving the image
                    shape.image_data.save(imageFileName)
                    imageIndex += 1

            mb.showinfo("Succes", "The file was converted to Word and the images were extracted.")
        else:
            mb.showerror("Error", "No PDF file has been selected.")

    W = Tk()
    W.title("PDF in Word Converter")
    W.geometry("640x400")
    W.config(bg="gray20")
    W.resizable(FALSE, FALSE)
    image_icon66 = PhotoImage(file = "img/complogo.png")
    W.iconphoto(False, image_icon66)
    lb = Label(W, text="Select PDF file", bg="gray40", fg="cyan", bd=1)
    lb.grid(row=1, column=0)
    tb = Entry(W, width=80)
    tb.grid(row=2, column=0)
    tb.focus()

    bt_browse = Button(W, text="Browse", bg="gray40", fg="cyan", width=15, bd=1, command=openfile)
    bt_browse.grid(row=2, column=1, ipady=3)

    bt_convert_to_word = Button(W, text="Convert in Word", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word)
    bt_convert_to_word.grid(row=3, column=0, columnspan=2, pady=5)

    bt_convert_with_images = Button(W, text="Convert in Word and extract images", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word_and_extract_images)
    bt_convert_with_images.grid(row=4, column=0, columnspan=2, pady=5)

    W.mainloop()

if replfindvar == 11:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon67 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon67)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    def ReplAndFind():
        # to create a window
        repl = Tk()
        repl.resizable(False, False)
        repl.title("Find & Replace")
        repl.config(bg="gray20")
        image_icon68 = PhotoImage(file = "img/complogo.png")
        repl.iconphoto(False, image_icon68)
        # root window is the parent window
        framrepl = Frame(repl, bg="gray20")

        # Creating Label, Entry Box, Button
        # and packing them adding label to
        # search box
        Label(framrepl, text='Find', bg="gray20", fg="lime green").pack(side=LEFT)

        # adding of single line text box
        edit = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        # positioning of text box
        edit.pack(side=LEFT, fill=BOTH, expand=1)
        # setting focus
        edit.focus_set()

        # adding of search button
        Find = Button(framrepl, text='Find', bg="gray40", fg="cyan", bd=5)
        Find.pack(side=LEFT)

        Label(framrepl, text="Replace With ", bg="gray20", fg="lime green", bd=1).pack(side=LEFT)

        edit2 = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        edit2.pack(side=LEFT, fill=BOTH, expand=1)
        edit2.focus_set()

        replace = Button(framrepl, text='FindNReplace', bg="gray40", fg="cyan", bd=5)
        replace.pack(side=LEFT)

        refresh = Button(framrepl, text='Refresh', bg="gray40", fg="cyan", bd=5)
        refresh.pack(side=LEFT)

        framrepl.pack(side=TOP)

        # text box in root window
        textrepl = Text(repl, width=120, height=40, bg="#999999")

        # text input area at index 1 in text window
        textrepl.insert('1.0', '''Type your text here''')
        textrepl.pack(side=BOTTOM)


        # function to search string in text
        def find(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()

            if (s):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)

                    if not idx: break
                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))
                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()


        def findNreplace(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()
            r = edit2.get()

            if (s and r):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)
                    print(idx)
                    if not idx: break

                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))

                    textrepl.delete(idx, lastidx)
                    textrepl.insert(idx, r)

                    lastidx = '% s+% dc' % (idx, len(r))

                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()

        def refresh_func():
            textrepl.tag_delete('found')

        # add commands to button
        Find.config(command=find)
        replace.config(command=findNreplace)
        refresh.config(command=refresh_func)
        # binding entry boxes ...
        edit.bind('<Return>',find)
        edit2.bind('<Return>',findNreplace)

        # mainloop function calls the endless
        # loop of the window, so the window will
        # wait for any user interaction till we
        # close it
        repl.mainloop()

    ReplAndFind()

if testvarr == 12:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon69 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon69)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    from tkinter import *
    from tkinter import ttk
    from tkinter import messagebox
    import sqlite3
    import random

    def Delete_question(questionid, tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DELETE FROM "+tablename+" WHERE questionid="+questionid
        cur.execute(querry)
        sql.commit()
        sql.close()
    def SelectAll_Tables():
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
        data = cur.fetchall()
        sql.commit()
        sql.close()
        return data

    def Create_Quiz_Set(id):
        try:
            sql = sqlite3.connect("quiz.db")
            cur = sql.cursor()
            querry = "CREATE TABLE " + id + "(questionid INTEGER PRIMARY KEY,question TEXT NOT NULL, op1 TEXT, op2 TEXT, op3 TEXT, op4 TEXT, answer TEXT NOT NULL)"
            print(querry)
            cur.execute(querry)
            print("table created")
            cur.close()
            sql.commit()
            sql.close()
            return "Success"
        except sqlite3.OperationalError:

            return "sqlite3.OperationalError"

    def InsertValue(questionname, op1, op2, op3, op4, answer, databasename):
        questionid = random.randrange(1000, 1000000000)
        print(questionid)
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        #querry = "INSERT INTO {}(questionid, question, op1, op2, op3, op4, answer) VALUES({},{},{},{},{},{},{})".format(databasename, questionid,questionname, op1, op2, op3, op4, answer)
        #print("INSERT INTO ?(question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?)",(databasename, questionname, op1, op2, op3, op4, answer))
        cur.execute("INSERT INTO "+databasename+"(questionid, question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?,?)",(questionid,questionname, op1, op2, op3, op4, answer))
        cur.close()
        sql.commit()
        sql.close()
        print("data inserted")

    def GetQuistions(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT * FROM "+tablename)
        datas = cur.fetchall()
        cur.close()
        sql.commit()
        sql.close()
        return datas

    def DeleteTable(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DROP TABLE "+tablename
        cur.execute(querry)
        sql.commit()
        sql.close()
        print("table deleted")


    class main_window:
        def Deleteq(self):
            tablename = self.Quizing_Name.get()
            questionid = self.deletequestion_field.get()
            Delete_question(questionid, tablename)
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.Create_Quiz_Set1()
        def Create_Quiz_Set1(self):
            self.Create_Quiz_Frame.destroy()
            self.CreateQuiz_Frame = Frame(self.Recent_Quiz, height=70, width=1000, bd=2, bg="lightblue")
            self.CreateQuiz_Frame.pack()

            self.Quizing_Name = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="lightblue")
            self.Quizing_Name.place(x=20, y=20)
            self.Quizing_Name.insert(0, self.id)
            self.deletequestion_field = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="white")
            self.deletequestion_field.place(y = 20, x = 250)
            self.deletequestion_field.insert(0, "Enter Question Id")
            self.cancel1 = Button(self.CreateQuiz_Frame, text="Cancel", width=6, font=("arial", 12), bg="red",
                                  fg="white", command=self.Cancel_QuizFrame)
            self.cancel1.place(y=20, x=910)

            self.Refresh = Button(self.CreateQuiz_Frame, text="Delete", width=6, font=("arial", 12), bg="tomato", command=self.Deleteq)
            self.Refresh.place(y=20, x=820)
            self.Add_Quiz = Button(self.CreateQuiz_Frame, text="Add Quiz", width=10, font=("arial", 12), bg="green",
                                   fg="white", command=self.Createquitions)
            self.Add_Quiz.place(y=20, x=710)

            self.CreateQuiz_Frame1 = Frame(self.Recent_Quiz, height=500, width=1000, bg="yellow")
            self.CreateQuiz_Frame1.pack(fill=BOTH)

            self.my_canvas = Canvas(self.CreateQuiz_Frame1, height=530)
            self.my_canvas.pack(side=LEFT, fill=BOTH, expand=1)

            self.my_scrollbar = ttk.Scrollbar(self.CreateQuiz_Frame1, orient=VERTICAL, command=self.my_canvas.yview)
            self.my_scrollbar.pack(side=RIGHT, fill=Y)

            self.my_canvas.configure(yscrollcommand=self.my_scrollbar.set)
            self.my_canvas.bind('<Configure>',
                                lambda e: self.my_canvas.configure(scrollregion=self.my_canvas.bbox("all")))

            self.s_frame = Frame(self.my_canvas)

            self.my_canvas.create_window((0, 0), window=self.s_frame, anchor=NW)

            datas = GetQuistions(self.Quizing_Name.get())
            j = 1
            print(datas)
            for data in datas:
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                questionid = Label(f, text=f"{data[0]}")
                questionid.place(x = 800, y = 0)
                t = data[1].split(":")
                text = ""
                for i in t:
                    text += i + " "
                l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {data[2]}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {data[3]}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {data[4]}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {data[5]}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {data[6]}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                j += 1
        def Create_Quiz_Set(self):
            self.id = self.Quiz_Set_Id.get()
            print(self.id)
            if self.id != "":
                datas = SelectAll_Tables()
                d = []
                for data in datas:
                    d.append(str(data[0]))
                print(d)
                if self.id in d:
                    self.Create_Quiz_Set1()
                else:
                    messagebox.showinfo("Warning", "Question is not exists. If you want to create click Create")


        def Addquition(self):
            quition = self.Type_Quitions_Entry.get()
            quition = quition.split(" ")
            quiz = ""
            for i in quition:
                quiz = quiz + i + ":"

            option1 = self.Options1.get()
            option2 = self.Options2.get()
            option3 = self.Options3.get()
            option4 = self.Options4.get()
            answer = self.Answer_Field.get()
            tablename = self.Quizing_Name.get()

            if quition != "" and option1 != "" and option2 != "" and option3 != "" and option4 != "" and answer != "":
                InsertValue(quiz, option1, option2, option3, option4, answer, tablename)
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                datas = GetQuistions(tablename)
                data = datas[0][0]
                texts = quiz.split(":")
                text = ""
                for t in texts:
                    text += t + " "
                questionid = Label(f, text=f"{data}")
                questionid.place(x=800, y=0)
                l = Label(f, text=f"1 . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {option1}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {option2}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {option3}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {option4}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {answer}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                self.Adquestion_Destroy()
            else:
                messagebox.showwarning("Error", "Please enter all field.")
        def Createquitions(self):
            self.Add_quitions_frame = Frame(self.CreateQuiz_Frame, height=160, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Add_quitions_frame.pack()
            self.Type_Quitions_Label = Label(self.Add_quitions_frame, text="Type Question :", font=("arial", 15), bg="lightgreen")
            self.Type_Quitions_Label.place(x = 10, y = 10)
            self.Type_Quitions_Entry = Entry(self.Add_quitions_frame, font=("arial", 15), width=70)
            self.Type_Quitions_Entry.place(x = 200, y = 10)
            self.Options_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Options :", bg="lightgreen")
            self.Options_Label.place(x = 10, y = 60)
            self.Options1 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options1.place(x = 200, y = 60)
            self.Options2 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options2.place(x=320, y=60)
            self.Options3 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options3.place(x=440, y=60)
            self.Options4 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options4.place(x=560, y=60)
            self.Answer_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Answer :", bg="lightgreen")
            self.Answer_Label.place(x = 10, y = 110)
            self.Answer_Field = Entry(self.Add_quitions_frame, font=("arial", 15))
            self.Answer_Field.place(x = 200, y = 110)

            self.Add_Quitionbtn = Button(self.Add_quitions_frame, text="Add Quiz", width=10, font=("arial", 12), bg="green", fg="white", command=self.Addquition)
            self.Add_Quitionbtn.place(x = 700, y = 110)
            self.Cancel_Quitionbtn = Button(self.Add_quitions_frame, text="Cancel", width=10, font=("arial", 12), bg="red",
                                         fg="white", command=self.Adquestion_Destroy)
            self.Cancel_Quitionbtn.place(x=850, y=110)

        def Adquestion_Destroy(self):
            self.Add_quitions_frame.destroy()
            self.CreateQuiz_Frame.configure(height=70)



        def Cancel_QuizFrame(self):
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz)
            self.Create_Quizbtn.place(x=850, y=13)
        def Cancel_QuizFrame1(self):
            self.Create_Quiz_Frame.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz)
            self.Create_Quizbtn.place(x=850, y=13)
        def Create_Quiz(self):
            self.Recent_Quiz1.destroy()
            self.Create_Quizbtn.destroy()
            self.Create_Quiz_Frame = Frame(self.Recent_Quiz, height=150, width=1000, relief=GROOVE, bd=2)
            self.Create_Quiz_Frame.pack()
            self.Quiz_Id = Label(self.Create_Quiz_Frame, text="Quiz Set Name: ", font=("arial", 15))
            self.Quiz_Id.place(x = 10, y = 10)
            self.Quiz_Set_Id = Entry(self.Create_Quiz_Frame, font=("arial", 15))
            self.Quiz_Set_Id.place(x = 160, y = 10)


            self.Create_Setbtn = Button(self.Create_Quiz_Frame, text="Create", font=("arial", 15), bg="green", fg="white", command=self.Create_Quiz_Set2)
            self.Create_Setbtn.place(x = 800, y = 100)
            self.Cancel_Setbtn = Button(self.Create_Quiz_Frame, text="Cancel", font=("arial", 15), bg="red", fg="white", command=self.Cancel_QuizFrame1)
            self.Cancel_Setbtn.place(x=900, y=100)

        def Create_Quiz_Set2(self):
            if self.Quiz_Set_Id.get() != "":
                Create_Quiz_Set(self.Quiz_Set_Id.get())
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def DeleteQuistion(self):
            data = self.textentry.get()
            if data != "":
                DeleteTable(data)
            else:
                messagebox.showwarning("Error", "Please enter question name")
        def ReRun(self):
            self.Result_Frame.destroy()
            self.CreateMain_Window()

        def Your_Result(self, result, text, q):
            self.Test_Frame.destroy()
            self.Result_Frame = Frame(self.window, height=400, width=800, bd=2, relief=GROOVE)
            self.Result_Frame.pack(pady=50)
            self.Result_Frame.propagate(0)
            self.test_name = Label(self.Result_Frame, text=text, font=("arial", 17))
            self.test_name.pack(pady=10)
            self.result_label = Label(self.Result_Frame, text=f"Your Result : {result}/{q}", font=("arial", 17))
            self.result_label.pack(pady=10)
            percentage = (result/q)*100
            self.percentage_label = Label(self.Result_Frame, text=f"Your Percentage : {percentage}", font=("arial", 17))
            self.percentage_label.pack(pady=10)
            if(percentage <= 59):
                self.percentage_label.configure(fg="red")
            else:
                self.percentage_label.configure(fg="green")
            self.Ok_Button = Button(self.Result_Frame, text="Exit",width=20, font=("arial", 15), command=self.ReRun)
            self.Ok_Button.pack(pady=10)

        def Test_Result(self):
            tablename1 = self.Testname.cget("text")
            tablename2 = tablename1.split(":")
            tablename3 = tablename2[1].split(" ")
            data = GetQuistions(tablename3[1])
            self.Answer_Set = []
            self.Result = 0
            for i in range(1, len(data)+1):
                v = f"answer{i}"
                self.Answer_Set.append(vars(self)[v].get())

            for k in range(0, len(data)):
                print(self.Answer_Set[k],"==",data[k][6])
                if self.Answer_Set[k] == data[k][6]:
                    self.Result += 1
                else:
                    self.Result += 0
            self.Your_Result(self.Result, tablename1, len(data))
        def PlayQuition(self):
            d = self.textentry.get()
            if d != "":
                datas = GetQuistions(d)
                self.Toolbar.destroy()
                self.Recent_Quiz.destroy()
                self.Test_Frame = Frame(self.window, bg="lightpink", height=700)
                self.Test_Frame.pack(fill=BOTH)
                self.min = 0
                self.sec = 0
                def runtime():
                    self.time = f"{self.min}:{self.sec}"
                    self.Testtime.configure(text = f"Time : {self.time}")
                    if(self.sec==60):
                        self.min += 1
                        self.sec = 0
                    else:
                        self.sec += 1

                    self.Testtime.after(1000, runtime)
                self.Testtime = Label(self.Test_Frame, text="Time : ", font=("arial", 20), bg="lightpink")
                self.Testtime.pack()
                self.Testname = Label(self.Test_Frame, text=f"Test Name : {d}", font=("arial", 20), bg="lightpink")
                self.Testname.place(x = 20, y = 0)
                self.Test_Frame1 = Frame(self.Test_Frame, height=600)
                self.Test_Frame1.pack(fill=BOTH)
                self.Test_Canvas = Canvas(self.Test_Frame1, height=600, width=950, bg="white")
                self.Test_Canvas.pack(side=LEFT, expand=1, pady=20)

                self.my_scrollbar2 = ttk.Scrollbar(self.Test_Frame1, orient=VERTICAL, command=self.Test_Canvas.yview)
                self.my_scrollbar2.pack(side=RIGHT, fill=Y)

                self.Test_Canvas.configure(yscrollcommand=self.my_scrollbar2.set)
                self.Test_Canvas.bind('<Configure>',
                                 lambda e: self.Test_Canvas.configure(scrollregion=self.Test_Canvas.bbox("all")))

                self.s_frame2 = Frame(self.Test_Canvas, bg="white")

                self.Test_Canvas.create_window((0, 0), window=self.s_frame2, anchor=NW)

                j = 1

                for data in datas:
                    f = Frame(self.s_frame2, height=200, width=950, relief=GROOVE, bd=5)
                    f.pack(pady=5)
                    f.propagate(0)
                    t = data[1].split(":")
                    text = ""
                    for i in t:
                        text += i + " "

                    l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                    l.place(x=5, y=0)
                    op1 = Label(f, text=f"A. {data[2]}", font=("arial", 15), height=1, width=10)
                    op1.place(x=50, y=60)
                    op2 = Label(f, text=f"B. {data[3]}", font=("arial", 15), height=1, width=10)
                    op2.place(x=250, y=60)
                    op3 = Label(f, text=f"C. {data[4]}", font=("arial", 15), height=1, width=10)
                    op3.place(x=450, y=60)
                    op4 = Label(f, text=f"D. {data[5]}", font=("arial", 15), height=1, width=10)
                    op4.place(x=650, y=60)
                    v = f"answer{j}"
                    label = Label(f, text="Answer : ", font=("arial", 15))
                    label.place(x = 50, y = 120)
                    vars(self)[v] = Entry(f, font=("arial", 15))
                    vars(self)[v].place(x = 150, y = 120)

                    j += 1

                self.Submit_Test = Button(self.s_frame2, text="Submit",width=50, bg="lightgreen", font=("arial", 15), command= self.Test_Result)
                self.Submit_Test.pack(pady=30)


                runtime()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")

        def EditQuition(self):
            string = self.textentry.get()
            if string != "":
                self.Create_Quizbtn.invoke()
                self.Quiz_Set_Id.insert(0,string)
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def ReRecent_Quize(self):
            self.Recent_Quiz1 = Frame(self.Recent_Quiz, height=630, width=1000, relief=GROOVE, bg="lightgreen")
            self.Recent_Quiz1.pack()
            self.Recent_Quiz1.propagate(0)
            self.my_canvas1 = Canvas(self.Recent_Quiz1, height=680, width=950, bg="white")
            self.my_canvas1.pack(side=LEFT, expand=1, pady=50)

            self.my_scrollbar1 = ttk.Scrollbar(self.Recent_Quiz1, orient=VERTICAL, command=self.my_canvas1.yview)
            self.my_scrollbar1.pack(side=RIGHT, fill=Y)

            self.my_canvas1.configure(yscrollcommand=self.my_scrollbar1.set)
            self.my_canvas1.bind('<Configure>',
                                 lambda e: self.my_canvas1.configure(scrollregion=self.my_canvas1.bbox("all")))

            self.s_frame1 = Frame(self.my_canvas1, bg="white")

            self.my_canvas1.create_window((0, 0), window=self.s_frame1, anchor=NW)
            self.Recent_Quiz.pack_propagate(0)
            datas = SelectAll_Tables()
            self.textentry = Entry(self.Recent_Quiz1, font=("arial", 15), width=50)
            self.textentry.place(x = 10, y = 10)
            self.playbtn = Button(self.Recent_Quiz1, text="Test", font=("arial", 11), width=10, bg="lightpink",command = self.PlayQuition)
            self.playbtn.place(x=650, y=10)
            self.editbtn = Button(self.Recent_Quiz1, text="Edit", font=("arial", 11), width=10, bg="lightblue", command= self.EditQuition)
            self.editbtn.place(x = 760, y = 10)
            self.deletebtn = Button(self.Recent_Quiz1, text="Delete", font=("arial", 11), width=10, bg="tomato",
                                    command=self.DeleteQuistion)
            self.deletebtn.place(x=870, y=10)
            for data in datas:
                self.frame = Frame(self.s_frame1, height=50, width=950, bg="lightblue", relief=GROOVE, bd=2)
                self.frame.pack(pady=10)
                self.label = Label(self.frame, bg="lightblue",text=f"{data[0]}", font=("arial", 15))
                self.label.place(x=30, y=10)



        def __init__(self, window):

            self.window = window
            self.CreateMain_Window()
            self.window.mainloop()

        def CreateMain_Window(self):
            self.Toolbar = Frame(self.window, height=70, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Toolbar.pack()
            self.Title = Label(self.Toolbar, text="Quiz Application", font=("arial", 22), bg="lightgreen")
            self.Title.place(x=20, y=13)
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("arial", 15), command=self.Create_Quiz)
            self.Create_Quizbtn.place(x=850, y=13)

            self.Recent_Quiz = Frame(self.window, height=630, width=1000, relief=GROOVE, bd=2, bg="white")
            self.Recent_Quiz.pack()

            self.ReRecent_Quize()


    window = Tk()
    window.geometry("1000x700")
    window.resizable(False, False)
    image_icon70 = PhotoImage(file = "img/quizlogo.png")
    window.iconphoto(False, image_icon70)
    main_window(window)

if testvarr2 == 122:
    '''
    # Definirea numele fișierului pentru salvarea cheii
    FILE_NAME = "product_key.txt"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Salvarea cheii în fișier text
            with open(FILE_NAME, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Încărcarea cheii din fișier text
            with open(FILE_NAME, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        sys.exit()

    def valkey():
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    '''

    from tkinter import *
    from tkinter import ttk
    from tkinter import messagebox
    import sqlite3
    import random

    def Delete_question(questionid, tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DELETE FROM "+tablename+" WHERE questionid="+questionid
        cur.execute(querry)
        sql.commit()
        sql.close()
    def SelectAll_Tables():
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
        data = cur.fetchall()
        sql.commit()
        sql.close()
        return data

    def Create_Quiz_Set(id):
        try:
            sql = sqlite3.connect("quiz.db")
            cur = sql.cursor()
            querry = "CREATE TABLE " + id + "(questionid INTEGER PRIMARY KEY,question TEXT NOT NULL, op1 TEXT, op2 TEXT, op3 TEXT, op4 TEXT, answer TEXT NOT NULL)"
            print(querry)
            cur.execute(querry)
            print("table created")
            cur.close()
            sql.commit()
            sql.close()
            return "Success"
        except sqlite3.OperationalError:

            return "sqlite3.OperationalError"

    def InsertValue(questionname, op1, op2, op3, op4, answer, databasename):
        questionid = random.randrange(1000, 1000000000)
        print(questionid)
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        #querry = "INSERT INTO {}(questionid, question, op1, op2, op3, op4, answer) VALUES({},{},{},{},{},{},{})".format(databasename, questionid,questionname, op1, op2, op3, op4, answer)
        #print("INSERT INTO ?(question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?)",(databasename, questionname, op1, op2, op3, op4, answer))
        cur.execute("INSERT INTO "+databasename+"(questionid, question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?,?)",(questionid,questionname, op1, op2, op3, op4, answer))
        cur.close()
        sql.commit()
        sql.close()
        print("data inserted")

    def GetQuistions(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT * FROM "+tablename)
        datas = cur.fetchall()
        cur.close()
        sql.commit()
        sql.close()
        return datas

    def DeleteTable(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DROP TABLE "+tablename
        cur.execute(querry)
        sql.commit()
        sql.close()
        print("table deleted")


    class main_window:
        def Deleteq(self):
            tablename = self.Quizing_Name.get()
            questionid = self.deletequestion_field.get()
            Delete_question(questionid, tablename)
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.Create_Quiz_Set1()
        def Create_Quiz_Set1(self):
            self.Create_Quiz_Frame.destroy()
            self.CreateQuiz_Frame = Frame(self.Recent_Quiz, height=70, width=1000, bd=2, bg="lightblue")
            self.CreateQuiz_Frame.pack()

            self.Quizing_Name = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="lightblue")
            self.Quizing_Name.place(x=20, y=20)
            self.Quizing_Name.insert(0, self.id)
            self.deletequestion_field = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="white")
            self.deletequestion_field.place(y = 20, x = 250)
            self.deletequestion_field.insert(0, "Enter Question Id")
            self.cancel1 = Button(self.CreateQuiz_Frame, text="Cancel", width=6, font=("arial", 12), bg="red",
                                  fg="white", command=self.Cancel_QuizFrame)
            self.cancel1.place(y=20, x=910)

            self.Refresh = Button(self.CreateQuiz_Frame, text="Delete", width=6, font=("arial", 12), bg="tomato", command=self.Deleteq)
            self.Refresh.place(y=20, x=820)
            self.Add_Quiz = Button(self.CreateQuiz_Frame, text="Add Quiz", width=10, font=("arial", 12), bg="green",
                                   fg="white", command=self.Createquitions)
            self.Add_Quiz.place(y=20, x=710)

            self.CreateQuiz_Frame1 = Frame(self.Recent_Quiz, height=500, width=1000, bg="yellow")
            self.CreateQuiz_Frame1.pack(fill=BOTH)

            self.my_canvas = Canvas(self.CreateQuiz_Frame1, height=530)
            self.my_canvas.pack(side=LEFT, fill=BOTH, expand=1)

            self.my_scrollbar = ttk.Scrollbar(self.CreateQuiz_Frame1, orient=VERTICAL, command=self.my_canvas.yview)
            self.my_scrollbar.pack(side=RIGHT, fill=Y)

            self.my_canvas.configure(yscrollcommand=self.my_scrollbar.set)
            self.my_canvas.bind('<Configure>',
                                lambda e: self.my_canvas.configure(scrollregion=self.my_canvas.bbox("all")))

            self.s_frame = Frame(self.my_canvas)

            self.my_canvas.create_window((0, 0), window=self.s_frame, anchor=NW)

            datas = GetQuistions(self.Quizing_Name.get())
            j = 1
            print(datas)
            for data in datas:
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                questionid = Label(f, text=f"{data[0]}")
                questionid.place(x = 800, y = 0)
                t = data[1].split(":")
                text = ""
                for i in t:
                    text += i + " "
                l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {data[2]}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {data[3]}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {data[4]}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {data[5]}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {data[6]}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                j += 1
        def Create_Quiz_Set(self):
            self.id = self.Quiz_Set_Id.get()
            print(self.id)
            if self.id != "":
                datas = SelectAll_Tables()
                d = []
                for data in datas:
                    d.append(str(data[0]))
                print(d)
                if self.id in d:
                    self.Create_Quiz_Set1()
                else:
                    messagebox.showinfo("Warning", "Question is not exists. If you want to create click Create")


        def Addquition(self):
            quition = self.Type_Quitions_Entry.get()
            quition = quition.split(" ")
            quiz = ""
            for i in quition:
                quiz = quiz + i + ":"

            option1 = self.Options1.get()
            option2 = self.Options2.get()
            option3 = self.Options3.get()
            option4 = self.Options4.get()
            answer = self.Answer_Field.get()
            tablename = self.Quizing_Name.get()

            if quition != "" and option1 != "" and option2 != "" and option3 != "" and option4 != "" and answer != "":
                InsertValue(quiz, option1, option2, option3, option4, answer, tablename)
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                datas = GetQuistions(tablename)
                data = datas[0][0]
                texts = quiz.split(":")
                text = ""
                for t in texts:
                    text += t + " "
                questionid = Label(f, text=f"{data}")
                questionid.place(x=800, y=0)
                l = Label(f, text=f"1 . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {option1}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {option2}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {option3}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {option4}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {answer}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                self.Adquestion_Destroy()
            else:
                messagebox.showwarning("Error", "Please enter all field.")
        def Createquitions(self):
            self.Add_quitions_frame = Frame(self.CreateQuiz_Frame, height=160, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Add_quitions_frame.pack()
            self.Type_Quitions_Label = Label(self.Add_quitions_frame, text="Type Question :", font=("arial", 15), bg="lightgreen")
            self.Type_Quitions_Label.place(x = 10, y = 10)
            self.Type_Quitions_Entry = Entry(self.Add_quitions_frame, font=("arial", 15), width=70)
            self.Type_Quitions_Entry.place(x = 200, y = 10)
            self.Options_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Options :", bg="lightgreen")
            self.Options_Label.place(x = 10, y = 60)
            self.Options1 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options1.place(x = 200, y = 60)
            self.Options2 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options2.place(x=320, y=60)
            self.Options3 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options3.place(x=440, y=60)
            self.Options4 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options4.place(x=560, y=60)
            self.Answer_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Answer :", bg="lightgreen")
            self.Answer_Label.place(x = 10, y = 110)
            self.Answer_Field = Entry(self.Add_quitions_frame, font=("arial", 15))
            self.Answer_Field.place(x = 200, y = 110)

            self.Add_Quitionbtn = Button(self.Add_quitions_frame, text="Add Quiz", width=10, font=("arial", 12), bg="green", fg="white", command=self.Addquition, state="disabled")
            self.Add_Quitionbtn.place(x = 700, y = 110)
            self.Cancel_Quitionbtn = Button(self.Add_quitions_frame, text="Cancel", width=10, font=("arial", 12), bg="red",
                                         fg="white", command=self.Adquestion_Destroy)
            self.Cancel_Quitionbtn.place(x=850, y=110)

        def Adquestion_Destroy(self):
            self.Add_quitions_frame.destroy()
            self.CreateQuiz_Frame.configure(height=70)



        def Cancel_QuizFrame(self):
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz, state="disabled")
            self.Create_Quizbtn.place(x=850, y=13)
        def Cancel_QuizFrame1(self):
            self.Create_Quiz_Frame.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz, state="disabled")
            self.Create_Quizbtn.place(x=850, y=13)
        def Create_Quiz(self):
            self.Recent_Quiz1.destroy()
            self.Create_Quizbtn.destroy()
            self.Create_Quiz_Frame = Frame(self.Recent_Quiz, height=150, width=1000, relief=GROOVE, bd=2)
            self.Create_Quiz_Frame.pack()
            self.Quiz_Id = Label(self.Create_Quiz_Frame, text="Quiz Set Name: ", font=("arial", 15))
            self.Quiz_Id.place(x = 10, y = 10)
            self.Quiz_Set_Id = Entry(self.Create_Quiz_Frame, font=("arial", 15))
            self.Quiz_Set_Id.place(x = 160, y = 10)


            self.Create_Setbtn = Button(self.Create_Quiz_Frame, text="Create", font=("arial", 15), bg="green", fg="white", command=self.Create_Quiz_Set2, state="disabled")
            self.Create_Setbtn.place(x = 800, y = 100)
            self.Cancel_Setbtn = Button(self.Create_Quiz_Frame, text="Cancel", font=("arial", 15), bg="red", fg="white", command=self.Cancel_QuizFrame1)
            self.Cancel_Setbtn.place(x=900, y=100)

        def Create_Quiz_Set2(self):
            if self.Quiz_Set_Id.get() != "":
                Create_Quiz_Set(self.Quiz_Set_Id.get())
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def DeleteQuistion(self):
            data = self.textentry.get()
            if data != "":
                DeleteTable(data)
            else:
                messagebox.showwarning("Error", "Please enter question name")
        def ReRun(self):
            self.Result_Frame.destroy()
            self.CreateMain_Window()

        def Your_Result(self, result, text, q):
            self.Test_Frame.destroy()
            self.Result_Frame = Frame(self.window, height=400, width=800, bd=2, relief=GROOVE)
            self.Result_Frame.pack(pady=50)
            self.Result_Frame.propagate(0)
            self.test_name = Label(self.Result_Frame, text=text, font=("arial", 17))
            self.test_name.pack(pady=10)
            self.result_label = Label(self.Result_Frame, text=f"Your Result : {result}/{q}", font=("arial", 17))
            self.result_label.pack(pady=10)
            percentage = (result/q)*100
            self.percentage_label = Label(self.Result_Frame, text=f"Your Percentage : {percentage}", font=("arial", 17))
            self.percentage_label.pack(pady=10)
            if(percentage <= 59):
                self.percentage_label.configure(fg="red")
            else:
                self.percentage_label.configure(fg="green")
            self.Ok_Button = Button(self.Result_Frame, text="Exit",width=20, font=("arial", 15), command=self.ReRun)
            self.Ok_Button.pack(pady=10)

        def Test_Result(self):
            tablename1 = self.Testname.cget("text")
            tablename2 = tablename1.split(":")
            tablename3 = tablename2[1].split(" ")
            data = GetQuistions(tablename3[1])
            self.Answer_Set = []
            self.Result = 0
            for i in range(1, len(data)+1):
                v = f"answer{i}"
                self.Answer_Set.append(vars(self)[v].get())

            for k in range(0, len(data)):
                print(self.Answer_Set[k],"==",data[k][6])
                if self.Answer_Set[k] == data[k][6]:
                    self.Result += 1
                else:
                    self.Result += 0
            self.Your_Result(self.Result, tablename1, len(data))
        def PlayQuition(self):
            d = self.textentry.get()
            if d != "":
                datas = GetQuistions(d)
                self.Toolbar.destroy()
                self.Recent_Quiz.destroy()
                self.Test_Frame = Frame(self.window, bg="lightpink", height=700)
                self.Test_Frame.pack(fill=BOTH)
                self.min = 0
                self.sec = 0
                def runtime():
                    self.time = f"{self.min}:{self.sec}"
                    self.Testtime.configure(text = f"Time : {self.time}")
                    if(self.sec==60):
                        self.min += 1
                        self.sec = 0
                    else:
                        self.sec += 1

                    self.Testtime.after(1000, runtime)
                self.Testtime = Label(self.Test_Frame, text="Time : ", font=("arial", 20), bg="lightpink")
                self.Testtime.pack()
                self.Testname = Label(self.Test_Frame, text=f"Test Name : {d}", font=("arial", 20), bg="lightpink")
                self.Testname.place(x = 20, y = 0)
                self.Test_Frame1 = Frame(self.Test_Frame, height=600)
                self.Test_Frame1.pack(fill=BOTH)
                self.Test_Canvas = Canvas(self.Test_Frame1, height=600, width=950, bg="white")
                self.Test_Canvas.pack(side=LEFT, expand=1, pady=20)

                self.my_scrollbar2 = ttk.Scrollbar(self.Test_Frame1, orient=VERTICAL, command=self.Test_Canvas.yview)
                self.my_scrollbar2.pack(side=RIGHT, fill=Y)

                self.Test_Canvas.configure(yscrollcommand=self.my_scrollbar2.set)
                self.Test_Canvas.bind('<Configure>',
                                 lambda e: self.Test_Canvas.configure(scrollregion=self.Test_Canvas.bbox("all")))

                self.s_frame2 = Frame(self.Test_Canvas, bg="white")

                self.Test_Canvas.create_window((0, 0), window=self.s_frame2, anchor=NW)

                j = 1

                for data in datas:
                    f = Frame(self.s_frame2, height=200, width=950, relief=GROOVE, bd=5)
                    f.pack(pady=5)
                    f.propagate(0)
                    t = data[1].split(":")
                    text = ""
                    for i in t:
                        text += i + " "

                    l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                    l.place(x=5, y=0)
                    op1 = Label(f, text=f"A. {data[2]}", font=("arial", 15), height=1, width=10)
                    op1.place(x=50, y=60)
                    op2 = Label(f, text=f"B. {data[3]}", font=("arial", 15), height=1, width=10)
                    op2.place(x=250, y=60)
                    op3 = Label(f, text=f"C. {data[4]}", font=("arial", 15), height=1, width=10)
                    op3.place(x=450, y=60)
                    op4 = Label(f, text=f"D. {data[5]}", font=("arial", 15), height=1, width=10)
                    op4.place(x=650, y=60)
                    v = f"answer{j}"
                    label = Label(f, text="Answer : ", font=("arial", 15))
                    label.place(x = 50, y = 120)
                    vars(self)[v] = Entry(f, font=("arial", 15))
                    vars(self)[v].place(x = 150, y = 120)

                    j += 1

                self.Submit_Test = Button(self.s_frame2, text="Submit",width=50, bg="lightgreen", font=("arial", 15), command= self.Test_Result)
                self.Submit_Test.pack(pady=30)


                runtime()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")

        def EditQuition(self):
            string = self.textentry.get()
            if string != "":
                self.Create_Quizbtn.invoke()
                self.Quiz_Set_Id.insert(0,string)
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def ReRecent_Quize(self):
            self.Recent_Quiz1 = Frame(self.Recent_Quiz, height=630, width=1000, relief=GROOVE, bg="lightgreen")
            self.Recent_Quiz1.pack()
            self.Recent_Quiz1.propagate(0)
            self.my_canvas1 = Canvas(self.Recent_Quiz1, height=680, width=950, bg="white")
            self.my_canvas1.pack(side=LEFT, expand=1, pady=50)

            self.my_scrollbar1 = ttk.Scrollbar(self.Recent_Quiz1, orient=VERTICAL, command=self.my_canvas1.yview)
            self.my_scrollbar1.pack(side=RIGHT, fill=Y)

            self.my_canvas1.configure(yscrollcommand=self.my_scrollbar1.set)
            self.my_canvas1.bind('<Configure>',
                                 lambda e: self.my_canvas1.configure(scrollregion=self.my_canvas1.bbox("all")))

            self.s_frame1 = Frame(self.my_canvas1, bg="white")

            self.my_canvas1.create_window((0, 0), window=self.s_frame1, anchor=NW)
            self.Recent_Quiz.pack_propagate(0)
            datas = SelectAll_Tables()
            self.textentry = Entry(self.Recent_Quiz1, font=("arial", 15), width=50)
            self.textentry.place(x = 10, y = 10)
            self.playbtn = Button(self.Recent_Quiz1, text="Test", font=("arial", 11), width=10, bg="lightpink",command = self.PlayQuition)
            self.playbtn.place(x=650, y=10)
            self.editbtn = Button(self.Recent_Quiz1, text="Edit", font=("arial", 11), width=10, bg="lightblue", command= self.EditQuition, state="disabled")
            self.editbtn.place(x = 760, y = 10)
            self.deletebtn = Button(self.Recent_Quiz1, text="Delete", font=("arial", 11), width=10, bg="tomato",
                                    command=self.DeleteQuistion, state="disabled")
            self.deletebtn.place(x=870, y=10)
            for data in datas:
                self.frame = Frame(self.s_frame1, height=50, width=950, bg="lightblue", relief=GROOVE, bd=2)
                self.frame.pack(pady=10)
                self.label = Label(self.frame, bg="lightblue",text=f"{data[0]}", font=("arial", 15))
                self.label.place(x=30, y=10)



        def __init__(self, window):

            self.window = window
            self.CreateMain_Window()
            self.window.mainloop()

        def CreateMain_Window(self):
            self.Toolbar = Frame(self.window, height=70, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Toolbar.pack()
            self.Title = Label(self.Toolbar, text="Quiz Application", font=("arial", 22), bg="lightgreen")
            self.Title.place(x=20, y=13)
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("arial", 15), command=self.Create_Quiz, state="disabled")
            self.Create_Quizbtn.place(x=850, y=13)

            self.Recent_Quiz = Frame(self.window, height=630, width=1000, relief=GROOVE, bd=2, bg="white")
            self.Recent_Quiz.pack()

            self.ReRecent_Quize()


    window = Tk()
    window.geometry("1000x700")
    window.resizable(False, False)
    image_icon71 = PhotoImage(file = "img/quizlogo.png")
    window.iconphoto(False, image_icon71)
    main_window(window)

if pdfvwvar == 13:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon70 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon70)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    '''
    from tkinter import Tk
    import setuptools
    import os
    from tkinter import *
    from PIL import ImageTk
    from tkinter import *
    from PIL import Image, ImageTk
    import io
    import pdfplumber
    import PyPDF2
    #import pytesseract
    from tkinter import *
    from tkinter import filedialog, simpledialog, messagebox
    from PIL import Image



    ROOT_PATH = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
    BACKGROUND_COLOR = '#303030'
    HIGHLIGHT_COLOR = '#558de8'

    class DisplayCanvas(Frame):

        def __init__(self, master, page_height, page_width, **kw):
            Frame.__init__(self, master, **kw)
            self.x = self.y = 0

            self.canvas = Canvas(self, height=page_height, width=page_width, bg='#404040', highlightbackground='#353535')

            self.sbarv = Scrollbar(self, orient=VERTICAL, bg='#404040', highlightbackground='#353535')
            self.sbarh = Scrollbar(self, orient=HORIZONTAL, bg='#404040', highlightbackground='#353535')
            self.sbarv.config(command=self.canvas.yview)
            self.sbarh.config(command=self.canvas.xview)

            self.canvas.config(yscrollcommand=self.sbarv.set)
            self.canvas.config(xscrollcommand=self.sbarh.set)

            self.canvas.grid(row=0, column=0, sticky=N+S+E+W)
            self.sbarv.grid(row=0, column=1, stick=N+S)
            self.sbarh.grid(row=1, column=0, sticky=E+W)

            top = self.winfo_toplevel()
            top.bind('<Left>', self.on_left)
            top.bind('<Right>', self.on_right)
            top.bind('<Up>', self.on_up)
            top.bind('<Down>', self.on_down)

            self.canvas.bind("<ButtonPress-1>", self.on_button_press)
            self.canvas.bind("<B1-Motion>", self.on_move_press)
            self.canvas.bind("<ButtonRelease-1>", self.on_button_release)

            self.rect = None
            self.image = None
            self.image_obj = None
            self.pil_image = None
            self.draw = False

            self.start_x = None
            self.start_y = None

            self.canvas.config(scrollregion=self.canvas.bbox("all"))

        def on_button_press(self, event):
            self.start_x = self.canvas.canvasx(event.x)
            self.start_y = self.canvas.canvasy(event.y)

            if not self.rect and self.draw:
                self.rect = self.canvas.create_rectangle(self.x, self.y, 1, 1, outline='red')

        def on_move_press(self, event):
            cur_x = self.canvas.canvasx(event.x)
            cur_y = self.canvas.canvasy(event.y)

            w, h = self.canvas.winfo_width(), self.canvas.winfo_height()
            if event.x > 0.9*w:
                self.on_right()
            elif event.x < 0.1*w:
                self.on_left()
            if event.y > 0.9*h:
                self.on_down()
            elif event.y < 0.1*h:
                self.on_up()

            if self.draw:
                self.canvas.coords(self.rect, self.start_x, self.start_y, cur_x, cur_y)

        def on_left(self, event=None):
            self.canvas.xview_scroll(-1, 'units')

        def on_right(self, event=None):
            self.canvas.xview_scroll(1, 'units')

        def on_up(self, event=None):
            self.canvas.yview_scroll(-1, 'units')

        def on_down(self, event=None):
            self.canvas.yview_scroll(1, 'units')

        def on_button_release(self, event):
            pass

        def update_image(self, image):
            self.pil_image = image
            self.image = ImageTk.PhotoImage(image)
            if self.image_obj is None:
                self.image_obj = self.canvas.create_image(1, 1, image=self.image, anchor=CENTER)
            else:
                self.canvas.itemconfig(self.image_obj, image=self.image)
            self.sbarv.config(command=self.canvas.yview)
            self.sbarh.config(command=self.canvas.xview)
            self.canvas.config(scrollregion=self.canvas.bbox("all"))
            self.canvas.xview_moveto(0.0)
            self.canvas.yview_moveto(0.0)

        def reset(self):
            self.canvas.delete("all")
            self.image_obj = self.canvas.create_image(1, 1, image=self.image, anchor=CENTER)
            self.sbarv.config(command=self.canvas.yview)
            self.sbarh.config(command=self.canvas.xview)
            self.canvas.config(yscrollcommand=self.sbarv.set)
            self.canvas.config(xscrollcommand=self.sbarh.set)
            self.canvas.config(scrollregion=self.canvas.bbox("all"))
            self.rect = None

        def clear(self):
            self.canvas.delete("all")
            self.image_obj = None

        def get_rect(self):
            w, h = self.pil_image.size
            x0, y0 = self.canvas.coords(self.image_obj)
            minx = x0 - w/2.0
            miny = y0 - h/2.0
            if self.rect:
                rect = self.canvas.coords(self.rect)
                rect = [rect[0] + abs(minx), rect[1] + abs(miny), rect[2] + abs(minx), rect[3] + abs(miny)]
                return rect
            else:
                return None
                
                
    class HelpBox(Frame):

        def __init__(self, master, **kw):
            Frame.__init__(self, master, **kw)
            self.columnconfigure(0, weight=1)
            self.rowconfigure(0, weight=0)
            self.rowconfigure(1, weight=0)
            self.rowconfigure(2, weight=0)

            Label(self, text="Meet PDFViewer!", anchor='nw', width=100,
                  font="OpenSans 22 bold", fg='white', bg=BACKGROUND_COLOR, bd=2).grid(row=0, column=0, padx=20, pady=20)

            Label(self, text="Made by Tudor Marmureanu", anchor='nw', width=100,
                  font="OpenSans 10 bold", fg='white', bg=BACKGROUND_COLOR, bd=2).grid(row=2, column=0, padx=20, pady=20)

            text_frame = Frame(self, height=440, width=550, bg=BACKGROUND_COLOR, bd=2, relief=SUNKEN)
            text_frame.grid(row=1, column=0)

            text_frame.grid_propagate(False)

            text_frame.grid_rowconfigure(0, weight=1)
            text_frame.grid_columnconfigure(0, weight=1)

            text_box = Text(text_frame, borderwidth=3, relief="sunken", bg=BACKGROUND_COLOR,
                            fg='white', font="OpenSans 12", wrap='word')

            with open('help.txt', 'r') as infile:
                texts = infile.read()
            texts = [text + '\n\n\n' for text in texts.split('\n\n\n')]

            text_box.insert('1.0', texts[0])
            texts = texts[1:]

            paths = ['open_filepdf.png', 'open_dirpdf.png', 'clearpdf.png',
                     'searchpdf.png', 'extractpdf.png', 'ocrpdf.png']
            self.images = [ImageTk.PhotoImage(Image.open(os.path.join('widgets', path))) for path in paths]

            for text, image in zip(texts, self.images):
                text_box.image_create(END, image=image)
                text_box.insert(END, ' ' + text)

            self.images.extend([ImageTk.PhotoImage(Image.open(os.path.join('widgets', path)))
                                for path in ['prev_filepdf.png', 'next_filepdf.png']])

            text_box.image_create(END, image=self.images[-2])
            text_box.image_create(END, image=self.images[-1])
            text_box.insert(END, ' ' + texts[-2])

            text_box.insert(END, texts[-1].split('\n\n')[0] + '\n')
            self.images.append(ImageTk.PhotoImage(Image.open(os.path.join('toolbarpdf.png'))))
            text_box.image_create(END, image=self.images[-1])
            text_box.insert(END, '\n\n' + '\n\n'.join(texts[-1].split('\n\n')[1:]))

            text_box.config(state=DISABLED)
            text_box.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)

            scroll_bar = Scrollbar(text_frame, command=text_box.yview, bg=BACKGROUND_COLOR)
            scroll_bar.grid(row=0, column=1, sticky='nsew')

            text_box['yscrollcommand'] = scroll_bar.set
            
    class HoverButton(Button):

        def __init__(self, master, tool_tip=None, image_path=None, keep_pressed=False, **kw):
            Button.__init__(self, master=master, **kw)
            self.defaultBackground = self["background"]
            self.bind("<Enter>", self.on_enter)
            self.bind("<Leave>", self.on_leave)
            if keep_pressed:
                self.bind("<Button-1>", self.on_click)
            if image_path:
                self.image = ImageTk.PhotoImage(Image.open(image_path))
                self.configure(image=self.image)
            if tool_tip:
                ToolTip(self, text=tool_tip)

        def on_click(self, e):
            if self['background'] == self.defaultBackground:
                self['background'] = self['activebackground']
            else:
                self['background'] = self.defaultBackground

        def on_enter(self, e):
            self['background'] = self['activebackground']

        def on_leave(self, e):
            self['background'] = self.defaultBackground
            
    class MenuBox(Frame):

        def __init__(self, master=None, image_path=None, **kw):
            Frame.__init__(self, master, **kw)

            self.menu_button = Menubutton(self, width=50, height=50, bg=BACKGROUND_COLOR, bd=0,
                                          highlightthickness=0, activebackground=HIGHLIGHT_COLOR)

            if image_path:
                self.image = ImageTk.PhotoImage(Image.open(image_path))
                self.menu_button.configure(image=self.image)

            self.menu = Menu(self.menu_button, tearoff=False, bg='#404040',
                             fg='white', bd=2, activebackground=HIGHLIGHT_COLOR)

            self.menu_button.config(menu=self.menu)
            self.menu_button.pack(side=LEFT)

            self.menu_button.bind("<Button-1>", lambda e: self.menu_button.event_generate('<<Invoke>>'))

        def add_item(self, title, func, seperator=False):
            self.menu.add_command(label=title, command=func)
            if seperator:
                self.menu.add_separator()
                
    class PDFViewer(Frame):

        def __init__(self, master=None, **kw):
            Frame.__init__(self, master, **kw)
            self.pdf = None
            self.page = None
            self.paths = list()
            self.pathidx = -1
            self.total_pages = 0
            self.pageidx = 0
            self.scale = 1.0
            self.rotate = 0
            self.save_path = None
            self._init_ui()

        def _init_ui(self):
            ws = self.master.winfo_screenwidth()
            hs = self.master.winfo_screenheight()
            h = hs - 100
            w = int(h / 1.414) + 100
            x = (ws / 2) - (w / 2)
            y = (hs / 2) - (h / 2)
            self.master.geometry('%dx%d+%d+%d' % (w, h, x, y))
            self.master.title("PDFViewer")

            self.master.rowconfigure(0, weight=0)
            self.master.rowconfigure(0, weight=0)

            self.rowconfigure(0, weight=1)
            self.columnconfigure(0, weight=0)
            self.columnconfigure(1, weight=0)

            self.configure(bg=BACKGROUND_COLOR, bd=0)

            tool_frame = Frame(self, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            pdf_frame = Frame(self, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)

            tool_frame.grid(row=0, column=0, sticky='news')
            pdf_frame.grid(row=0, column=1, sticky='news')

            # Tool Frame
            tool_frame.columnconfigure(0, weight=1)
            tool_frame.rowconfigure(0, weight=0)
            tool_frame.rowconfigure(1, weight=1)
            tool_frame.rowconfigure(2, weight=0)
            tool_frame.rowconfigure(3, weight=2)

            options = MenuBox(tool_frame, image_path=os.path.join('optionspdf.png'))
            options.grid(row=0, column=0)

            options.add_item('Open Files...', self._open_file)
            options.add_item('Open Directory...', self._open_dir, seperator=True)
            options.add_item('Next File', self._next_file)
            options.add_item('Previous File', self._prev_file, seperator=True)
            options.add_item('Help...', self._help, seperator=True)
            options.add_item('Exit', self.master.quit)

            tools = Frame(tool_frame, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            tools.grid(row=2, column=0)

            HoverButton(tools, image_path=os.path.join('clearpdf.png'), command=self._clear,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Clear",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('open_filepdf.png'), command=self._open_file,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Open Files",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('open_dirpdf.png'), command=self._open_dir,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Open Directory",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('searchpdf.png'), command=self._search_text,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Search Text",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('extractpdf.png'), command=self._extract_text,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Extract Text", keep_pressed=True,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('ocrpdf.png'), command=self._run_ocr,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Run OCR",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)

            file_frame = Frame(tools, width=50, height=50, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            file_frame.pack(pady=2)

            file_frame.columnconfigure(0, weight=1)
            file_frame.columnconfigure(1, weight=1)

            HoverButton(file_frame, image_path=os.path.join('prev_filepdf.png'), command=self._prev_file,
                        width=25, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Previous File",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).grid(row=0, column=0)
            HoverButton(file_frame, image_path=os.path.join('next_filepdf.png'), command=self._next_file,
                        width=25, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Next File",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).grid(row=0, column=1)

            HoverButton(tool_frame, image_path=os.path.join('helppdf.png'), command=self._help,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Help",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).grid(row=3, column=0, sticky='s')

            # PDF Frame
            pdf_frame.columnconfigure(0, weight=1)
            pdf_frame.rowconfigure(0, weight=0)
            pdf_frame.rowconfigure(1, weight=0)

            page_tools = Frame(pdf_frame, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            page_tools.grid(row=0, column=0, sticky='news')

            page_tools.rowconfigure(0, weight=1)
            page_tools.columnconfigure(0, weight=1)
            page_tools.columnconfigure(1, weight=0)
            page_tools.columnconfigure(2, weight=2)
            page_tools.columnconfigure(3, weight=0)
            page_tools.columnconfigure(4, weight=1)

            nav_frame = Frame(page_tools, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            nav_frame.grid(row=0, column=1, sticky='ns')

            HoverButton(nav_frame, image_path=os.path.join('firstpdf.png'),
                        command=self._first_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)
            HoverButton(nav_frame, image_path=os.path.join('prevpdf.png'),
                        command=self._prev_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)

            self.page_label = Label(nav_frame, bg=BACKGROUND_COLOR, bd=0, fg='white', font='Arial 8',
                                    text="Page {} of {}".format(self.pageidx, self.total_pages))
            self.page_label.pack(side=LEFT, expand=True)

            HoverButton(nav_frame, image_path=os.path.join('nextpdf.png'),
                        command=self._next_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)
            HoverButton(nav_frame, image_path=os.path.join('lastpdf.png'),
                        command=self._last_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)

            zoom_frame = Frame(page_tools, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            zoom_frame.grid(row=0, column=3, sticky='ns')

            HoverButton(zoom_frame, image_path=os.path.join('rotatepdf.png'),
                        command=self._rotate, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)
            HoverButton(zoom_frame, image_path=os.path.join('fullscreenpdf.png'),
                        command=self._fit_to_screen, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)

            self.zoom_label = Label(zoom_frame, bg=BACKGROUND_COLOR, bd=0, fg='white', font='Arial 8',
                                    text="Zoom {}%".format(int(self.scale * 100)))
            self.zoom_label.pack(side=RIGHT, expand=True)

            HoverButton(zoom_frame, image_path=os.path.join('zoomoutpdf.png'),
                        command=self._zoom_out, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)
            HoverButton(zoom_frame, image_path=os.path.join('zoominpdf.png'),
                        command=self._zoom_in, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)

            canvas_frame = Frame(pdf_frame, bg=BACKGROUND_COLOR, bd=1, relief=SUNKEN)
            canvas_frame.grid(row=1, column=0, sticky='news')

            self.canvas = DisplayCanvas(canvas_frame, page_height=h-42, page_width=w-70)
            self.canvas.pack()

            self.grid(row=0, column=0, sticky='news')

            self.master.minsize(height=h, width=w)
            self.master.maxsize(height=h, width=w)

        def _reject(self):
            if self.pdf is None:
                return
            self.pathidx = min(self.pathidx + 1, len(self.paths))
            if self.pathidx == len(self.paths):
                self._reset()
                return
            self._load_file()

        def _reset(self):
            self.canvas.clear()
            self.pdf = None
            self.page = None
            self.paths = list()
            self.pathidx = -1
            self.total_pages = 0
            self.pageidx = 0
            self.scale = 1.0
            self.rotate = 0
            self.page_label.configure(text="Page {} of {}".format(self.pageidx, self.total_pages))
            self.zoom_label.configure(text="Zoom {}%".format(int(self.scale * 100)))
            self.master.title("PDFViewer")

        def _clear(self):
            if self.pdf is None:
                return
            self.canvas.reset()
            self._update_page()

        def _zoom_in(self):
            if self.pdf is None:
                return
            if self.scale == 2.5:
                return
            self.scale += 0.1
            self._update_page()

        def _zoom_out(self):
            if self.pdf is None:
                return
            if self.scale == 0.1:
                return
            self.scale -= 0.1
            self._update_page()

        def _fit_to_screen(self):
            if self.pdf is None:
                return
            if self.scale == 1.0:
                return
            self.scale = 1.0
            self._update_page()

        def _rotate(self):
            if self.pdf is None:
                return
            self.rotate = (self.rotate - 90) % 360
            self._update_page()

        def _next_page(self):
            if self.pdf is None:
                return
            if self.pageidx == self.total_pages:
                return
            self.pageidx += 1
            self._update_page()

        def _prev_page(self):
            if self.pdf is None:
                return
            if self.pageidx == 1:
                return
            self.pageidx -= 1
            self._update_page()

        def _last_page(self):
            if self.pdf is None:
                return
            if self.pageidx == self.total_pages:
                return
            self.pageidx = self.total_pages
            self._update_page()

        def _first_page(self):
            if self.pdf is None:
                return
            if self.pageidx == 1:
                return
            self.pageidx = 1
            self._update_page()

        def _next_file(self):
            if self.pdf is None:
                return
            if self.pathidx == len(self.paths) - 1:
                messagebox.showwarning("Warning", "Reached the end of list")
                return
            self.pathidx += 1
            self._load_file()

        def _prev_file(self):
            if self.pdf is None:
                return
            if self.pathidx == 0:
                messagebox.showwarning("Warning", "Reached the end of list")
                return
            self.pathidx -= 1
            self._load_file()

        def _update_page(self):
            page = self.pdf.pages[self.pageidx - 1]
            self.page = page.to_image(resolution=int(self.scale * 80))
            image = self.page.original.rotate(self.rotate)
            self.canvas.update_image(image)
            self.page_label.configure(text="Page {} of {}".format(self.pageidx, self.total_pages))
            self.zoom_label.configure(text="Zoom {}%".format(int(self.scale * 100)))

        def _search_text(self):
            if self.pdf is None:
                return
            text = simpledialog.askstring('Search Text', 'Enter text to search:')
            if text == '' or text is None:
                return
            page = self.pdf.pages[self.pageidx - 1]
            image = page.to_image(resolution=int(self.scale * 80))
            words = [w for w in page.extract_words() if text.lower() in w['text'].lower()]
            image.draw_rects(words)
            image = image.annotated.rotate(self.rotate)
            self.canvas.update_image(image)

        def _extract_text(self):
            if self.pdf is None:
                return
            if not self.canvas.draw:
                self.canvas.draw = True
                self.canvas.configure(cursor='cross')
                return
            self.canvas.draw = False
            self.canvas.configure(cursor='')
            rect = self.canvas.get_rect()
            if rect is None:
                return
            self._clear()
            rect = self._reproject_bbox(rect)
            page = self.pdf.pages[self.pageidx - 1]
            words = page.extract_words()
            min_x = 1000000
            r = None
            for word in words:
                diff = abs(float(word['x0'] - rect[0])) + abs(float(word['top'] - rect[1])) \
                       + abs(float(word['x1'] - rect[2])) + abs(float(word['bottom'] - rect[3]))
                if diff < min_x:
                    min_x = diff
                    r = word
            image = page.to_image(resolution=int(self.scale * 80))
            image.draw_rect(r)
            image = image.annotated.rotate(self.rotate)
            self.canvas.update_image(image)
            simpledialog.askstring("Extract Text", "Text Extracted:", initialvalue=r['text'])

        def _reproject_bbox(self, bbox):
            bbox = [self.page.decimalize(x) for x in bbox]
            x0, y0, x1, y1 = bbox
            px0, py0 = self.page.page.bbox[:2]
            rx0, ry0 = self.page.root.bbox[:2]
            _x0 = (x0 / self.page.scale) - rx0 + px0
            _y0 = (y0 / self.page.scale) - ry0 + py0
            _x1 = (x1 / self.page.scale) - rx0 + px0
            _y1 = (y1 / self.page.scale) - ry0 + py0
            return [_x0, _y0, _x1, _y1]

        def _run_ocr(self):
            if self.pdf is None:
                return
            pdf_pages = list()
            for page in self.pdf.pages:
                image = page.to_image(resolution=100)
                pdf = pytesseract.image_to_pdf_or_hocr(image.original, extension='pdf')
                pdf_pages.append(pdf)

            pdf_writer = PyPDF2.PdfFileWriter()
            for page in pdf_pages:
                pdf = PyPDF2.PdfFileReader(io.BytesIO(page))
                pdf_writer.addPage(pdf.getPage(0))

            dirname = os.path.dirname(self.paths[self.pathidx])
            filename = os.path.basename(self.paths[self.pathidx])

            path = filedialog.asksaveasfilename(title='Save OCR As', defaultextension='.pdf',
                                                initialdir=dirname, initialfile=filename,
                                                filetypes=[('PDF files', '*.pdf'), ('all files', '.*')])
            if path == '' or path is None:
                return

            with open(path, 'wb') as out:
                pdf_writer.write(out)

            self.paths[self.pathidx] = path
            self._load_file()

        @staticmethod
        def _image_to_pdf(path):
            image = Image.open(path)
            pdf = pytesseract.image_to_pdf_or_hocr(image, extension='pdf')

            filename = '.'.join(os.path.basename(path).split('.')[:-1]) + '.pdf'
            dirname = os.path.dirname(path)

            path = filedialog.asksaveasfilename(title='Save Converted PDF As', defaultextension='.pdf',
                                                initialdir=dirname, initialfile=filename,
                                                filetypes=[('PDF files', '*.pdf'), ('all files', '.*')])
            if path == '' or path is None:
                return
            with open(path, 'wb') as out:
                out.write(pdf)
            return path

        def _load_file(self):
            self._clear()
            path = self.paths[self.pathidx]
            filename = os.path.basename(path)
            if filename.split('.')[-1].lower() in ['jpg', 'png']:
                path = self._image_to_pdf(path)
            try:
                self.pdf = pdfplumber.open(path)
                self.total_pages = len(self.pdf.pages)
                self.pageidx = 1
                self.scale = 1.0
                self.rotate = 0
                self._update_page()
                self.master.title("PDFViewer : {}".format(path))
            except (IndexError, IOError, TypeError):
                self._reject()

        def _open_file(self):
            paths = filedialog.askopenfilenames(filetypes=[('PDF files', '*.pdf'),
                                                           ('JPG files', '*.jpg'),
                                                           ('PNG files', '*.png'),
                                                           ('all files', '.*')],
                                                initialdir=os.getcwd(),
                                                title="Select files", multiple=True)
            if not paths or paths == '':
                return
            paths = [path for path in paths if os.path.basename(path).split('.')[-1].lower() in ['pdf', 'jpg', 'png']]
            self.paths = self.paths[:self.pathidx + 1] + list(paths) + self.paths[self.pathidx + 1:]
            self.total_pages = len(self.paths)
            self.pathidx += 1
            self._load_file()

        def _open_dir(self):
            dir_name = filedialog.askdirectory(initialdir=os.getcwd(), title="Select Directory Containing Invoices")
            if not dir_name or dir_name == '':
                return
            paths = os.listdir(dir_name)
            paths = [os.path.join(dir_name, path) for path in paths
                     if os.path.basename(path).split('.')[-1].lower() in ['pdf', 'jpg', 'png']]
            self.paths.extend(paths)
            if not self.paths:
                return
            self.total_pages = len(self.paths)
            self.pathidx += 1
            self._load_file()

        def _help(self):
            ws = self.master.winfo_screenwidth()
            hs = self.master.winfo_screenheight()
            w, h = 600, 600
            x = (ws / 2) - (w / 2)
            y = (hs / 2) - (h / 2)
            help_frame = Toplevel(self)
            help_frame.title("Help")
            help_frame.configure(width=w, height=h, bg=BACKGROUND_COLOR, relief=SUNKEN)
            help_frame.geometry('%dx%d+%d+%d' % (w, h, x, y))
            help_frame.minsize(height=h, width=w)
            help_frame.maxsize(height=h, width=w)
            help_frame.rowconfigure(0, weight=1)
            help_frame.columnconfigure(0, weight=1)
            HelpBox(help_frame, width=w, height=h, bg=BACKGROUND_COLOR, relief=SUNKEN).grid(row=0, column=0)
            
    class ToolTip(object):

        def __init__(self, widget, text):
            self.waittime = 500
            self.wraplength = 180
            self.widget = widget
            self.text = text
            self.widget.bind("<Enter>", self.enter)
            self.widget.bind("<Leave>", self.leave)
            self.widget.bind("<ButtonPress>", self.leave)
            self.idx = None
            self.tw = None

        def enter(self, event=None):
            self.schedule()

        def leave(self, event=None):
            self.unschedule()
            self.hidetip()

        def schedule(self):
            self.unschedule()
            self.idx = self.widget.after(self.waittime, self.showtip)

        def unschedule(self):
            idx = self.idx
            self.idx = None
            if idx:
                self.widget.after_cancel(idx)

        def showtip(self, event=None):
            x, y, cx, cy = self.widget.bbox("insert")
            x += self.widget.winfo_rootx() + 25
            y += self.widget.winfo_rooty() + 20
            self.tw = Toplevel(self.widget)
            self.tw.wm_overrideredirect(True)
            self.tw.wm_geometry("+%d+%d" % (x, y))
            label = Label(self.tw, text=self.text, justify='left',
                          background="#ffffff", relief='solid', borderwidth=1,
                          wraplength=self.wraplength)
            label.pack(ipadx=1)

        def hidetip(self):
            tw = self.tw
            self.tw = None
            if tw:
                tw.destroy()

    rootpdf = Tk()
    PDFViewer()
    rootpdf.mainloop()
    '''
    import tkinter as tk
    from tkinter import filedialog, messagebox
    import os
    import pikepdf
    from PIL import Image
    import fitz

    def get_file_path():
        file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
        return file_path

    def encrypt_decrypt():
        def process_pdf(action):
            password = password_entry.get()
            input_file = get_file_path()

            if action == "Encrypt":
                output_file = "encrypted_" + os.path.basename(input_file)
                encryption = pikepdf.Encryption(owner=password, user=password, R=4)
            else:  # Decrypt
                output_file = "decrypted_" + os.path.basename(input_file)
                try:
                    pdf = pikepdf.open(input_file, password=password)
                    pdf.save(output_file)
                    pdf.close()
                except pikepdf._qpdf.PasswordError:
                    messagebox.showerror("Error", "Invalid password for decryption.")
                    return

            with pikepdf.Pdf.open(input_file) as pdf:
                pdf.save(output_file, encryption=encryption)

            messagebox.showinfo("Success", f"PDF {action}ed successfully!")

        encrypt_decrypt_window = tk.Toplevel()
        encrypt_decrypt_window.title("Encrypt or Decrypt PDF")
        encrypt_decrypt_window.geometry("400x200")
        encrypt_decrypt_window.resizable(False, False)
        encrypt_decrypt_window.config(bg="gray20")
        image_icon72 = PhotoImage(file = "img/securelogo.png")
        encrypt_decrypt_window.iconphoto(False, image_icon72)

        label = tk.Label(encrypt_decrypt_window, text="Enter password:", bg="gray20", fg="cyan")
        label.pack()

        password_entry = tk.Entry(encrypt_decrypt_window, show="*")
        password_entry.pack()

        encrypt_button = tk.Button(encrypt_decrypt_window, text="Encrypt", command=lambda: process_pdf("Encrypt"), bg="gray40", fg="cyan")
        encrypt_button.pack()

        decrypt_button = tk.Button(encrypt_decrypt_window, text="Decrypt", command=lambda: process_pdf("Decrypt"), bg="gray40", fg="cyan")
        decrypt_button.pack()

    def rotate_pages():
        def process_rotation():
            degrees = int(degrees_entry.get())
            input_file = get_file_path()
            output_file = "rotated_" + os.path.basename(input_file)

            with pikepdf.Pdf.open(input_file) as pdf:
                for page in pdf.pages:
                    page.Rotate = degrees
                pdf.save(output_file)

            messagebox.showinfo("Success", "PDF rotated successfully!")

        rotate_window = tk.Toplevel()
        rotate_window.title("Rotate Pages")
        rotate_window.geometry("400x200")
        rotate_window.config(bg="gray20")
        rotate_window.resizable(False, False)
        image_icon73 = PhotoImage(file = "img/complogo.png")
        rotate_window.iconphoto(False, image_icon73)

        label = tk.Label(rotate_window, text="Enter rotation degrees:", bg="gray20", fg="cyan")
        label.pack()

        degrees_entry = tk.Entry(rotate_window)
        degrees_entry.pack()

        rotate_button = tk.Button(rotate_window, text="Rotate", command=process_rotation, bg="gray40", fg="cyan")
        rotate_button.pack()


    def extract_images():
        def process_extraction():
            input_file = get_file_path()
            output_folder = filedialog.askdirectory()

            # Deschide PDF-ul
            pdf = fitz.open(input_file)

            for page_num in range(len(pdf)):
                page = pdf[page_num]
                image_list = page.get_images(full=True)
                
                for image_index, img in enumerate(image_list):
                    # Extrage imaginea
                    xref = img[0]
                    base_image = pdf.extract_image(xref)
                    image_bytes = base_image["image"]

                    # Salvează imaginea
                    image_path = os.path.join(output_folder, f"page{page_num+1}_image{image_index}.png")
                    with open(image_path, "wb") as f:
                        f.write(image_bytes)

                    print("Image saved:", image_path)

            pdf.close()
            messagebox.showinfo("Success", "Images extracted successfully!")

        extract_images_window = tk.Toplevel()
        extract_images_window.title("Extract Images")
        extract_images_window.geometry("400x200")
        extract_images_window.resizable(False, False)
        extract_images_window.config(bg="gray20")
        image_icon74 = PhotoImage(file = "img/complogo.png")
        extract_images_window.iconphoto(False, image_icon74)

        extract_button = tk.Button(extract_images_window, text="Extract", command=process_extraction, bg="gray40", fg="cyan")
        extract_button.pack()

    def get_file_path():
        file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
        return file_path

    def separate_pages():
        def process_separation():
            input_file = get_file_path()
            output_folder = filedialog.askdirectory()

            with pikepdf.Pdf.open(input_file) as pdf:
                for page_num, page in enumerate(pdf.pages, start=1):
                    new_pdf = pikepdf.Pdf.new()
                    new_pdf.pages.append(page)
                    output_file = os.path.join(output_folder, f"page{page_num}.pdf")
                    new_pdf.save(output_file)

            messagebox.showinfo("Success", "Pages separated successfully!")

        separate_pages_window = tk.Toplevel()
        separate_pages_window.title("Separate Pages")
        separate_pages_window.geometry("400x200")
        separate_pages_window.resizable(False, False)
        separate_pages_window.config(bg="gray20")
        image_icon75 = PhotoImage(file = "img/complogo.png")
        separate_pages_window.iconphoto(False, image_icon75)

        separate_button = tk.Button(separate_pages_window, text="Separate", command=process_separation, bg="gray40", fg="cyan")
        separate_button.pack()

    def delete_pages():
        def process_deletion():
            input_file = get_file_path()
            output_file = "deleted_" + os.path.basename(input_file)
            pages_to_delete = list(map(int, pages_entry.get().split(',')))

            with pikepdf.Pdf.open(input_file) as pdf:
                for page_num in sorted(pages_to_delete, reverse=True):
                    del pdf.pages[page_num - 1]
                pdf.save(output_file)

            messagebox.showinfo("Success", "Pages deleted successfully!")

        delete_window = tk.Toplevel()
        delete_window.title("Delete Pages")
        delete_window.geometry("400x200")
        delete_window.resizable(False, False)
        delete_window.config(bg="gray20")
        image_icon76 = PhotoImage(file = "img/complogo.png")
        delete_window.iconphoto(False, image_icon76)

        label = tk.Label(delete_window, text="Enter page numbers to delete (separated by comma):", bg="gray20", fg="cyan")
        label.pack()

        pages_entry = tk.Entry(delete_window)
        pages_entry.pack()

        delete_button = tk.Button(delete_window, text="Delete", command=process_deletion, bg="gray40", fg="cyan")
        delete_button.pack()

    def mainpdf():
        rootpdff = tk.Tk()
        rootpdff.title("PDF Editing Tools")
        rootpdff.geometry("400x300")
        rootpdff.resizable(False, False)
        rootpdff.config(bg="gray20")
        image_icon77 = PhotoImage(file = "img/complogo.png")
        rootpdff.iconphoto(False, image_icon77)

        encrypt_decrypt_button = tk.Button(rootpdff, text="Encrypt or Decrypt PDF", command=encrypt_decrypt, bg="gray40", fg="cyan")
        encrypt_decrypt_button.pack(pady=5)

        rotate_pages_button = tk.Button(rootpdff, text="Rotate Pages", command=rotate_pages, bg="gray40", fg="cyan")
        rotate_pages_button.pack(pady=5)

        extract_images_button = tk.Button(rootpdff, text="Extract Images", command=extract_images, bg="gray40", fg="cyan")
        extract_images_button.pack(pady=5)

        separate_pages_button = tk.Button(rootpdff, text="Separate Pages", command=separate_pages, bg="gray40", fg="cyan")
        separate_pages_button.pack(pady=5)

        delete_pages_button = tk.Button(rootpdff, text="Delete Pages", command=delete_pages, bg="gray40", fg="cyan")
        delete_pages_button.pack(pady=5)

        rootpdff.mainloop()

    mainpdf()

if netwvar == 14:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon78 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon78)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    import tkinter as tk
    import logging
    import time
    import numpy
    import matplotlib.pyplot as plt

    #from Tracker import Tracker
    from datetime import datetime


    import psutil
    import time
    from threading import Thread


    # Index : number of bytes sent
    __BYTES_SENT__ = 0
    # Index : number of bytes received
    __BYTES_RECV__ = 1
    # Index : number of packets sent
    __PACKETS_SENT__ = 2
    # Index : number of packets received
    __PACKETS_RECV__ = 3
    # Index : total number of errors while receiving
    __ERR_IN__ = 4
    # Index : total number of errors while sending
    __ERR_OUT__ = 5
    # Index : total number of incoming packets which were dropped
    __DROP_IN__ = 6
    # Index : total number of outgoing packets which were dropped
    __DROP_OUT__ = 7


    class Tracker:

        def __init__(self):
            self.__reset_bytes_recv_vars__()
            self.__reset_bytes_sent_vars__()
            self.init_total_sent = self.__get_bytes_sent_total__()
            self.init_total_recv = self.__get_bytes_recv_total__()


        def get_total_data_used(self):
            """ Returns the data used since the start 4G/3G ...
            """
            return ((self.__get_bytes_sent_total__() - self.init_total_sent) +
                    (self.__get_bytes_recv_total__() - self.init_total_recv))


        def get_current_upload_speed(self):
            """ Returns the current upload speed in bytes per seconds.
            """
            dtime = time.time() - self.last_bytes_sent_time
            dsent = self.__get_bytes_sent_total__() - self.last_bytes_sent_total
            self.__reset_bytes_sent_vars__()
            return dsent / dtime if dtime != 0 else 0


        def get_current_download_speed(self):
            """ Returns the current downlaod speed in bytes per seconds.
            """
            dtime = time.time() - self.last_bytes_recv_time
            dsent = self.__get_bytes_recv_total__() - self.last_bytes_recv_total
            self.__reset_bytes_recv_vars__()
            return dsent / dtime if dtime != 0 else 0


        def __reset_bytes_sent_vars__(self):
            self.last_bytes_sent_total = self.__get_bytes_sent_total__()
            self.last_bytes_sent_time = time.time()


        def __reset_bytes_recv_vars__(self):
            self.last_bytes_recv_total = self.__get_bytes_recv_total__()
            self.last_bytes_recv_time = time.time()


        def __get_bytes_sent_total__(self):
            return psutil.net_io_counters(pernic=False)[__BYTES_SENT__]


        def __get_bytes_recv_total__(self):
            return psutil.net_io_counters(pernic=False)[__BYTES_RECV__]


    logger = logging.getLogger(__name__)
    # Data shown on the plot represents the last 1 minutes
    DATA_DURATION = 5
    # The data variable
    speeds_recv = []
    speeds_sent = []
    times = []
    def main():
        """ Executes the program.
        """
        #root = tk.Tk()
        #root.title('Internet speed - N3RO')
        
        tracker = Tracker()
        plt.ion()
        last_total_data_used = 0

        while True:
            # Retrieve the up and down speeds
            time.sleep(0.5)
            down_speed = 8 * (tracker.get_current_download_speed() / (2**20))
            up_speed = 8 * (tracker.get_current_upload_speed() / (2**20))

            # Store it
            add_data(down_speed, up_speed)

            # Data used
            total_data_used = round(tracker.get_total_data_used() / (2**20), 3)
            write_data_used(last_total_data_used, total_data_used)
            last_total_data_used = total_data_used

            # Update & display the plot
            recv_curve, = plt.plot(times, speeds_recv)
            sent_curve, = plt.plot(times, speeds_sent)

            plt.legend([recv_curve, sent_curve], ['Download', 'Upload'])
            plt.ylabel('Mb/s', fontsize=8)
            ax = plt.gca()
            ax.tick_params(axis='x', labelsize=6)
            ax.tick_params(axis='y', labelsize=6)

            plt.draw()
            plt.pause(0.0001)
            plt.clf()


    def add_data(down_speed, up_speed):
        if len(times) > 1:
            if divmod((times[-1] - times[0]).total_seconds(), 60)[0] >= DATA_DURATION:
                del times[0]
                del speeds_recv[0]
                del speeds_sent[0]
        speeds_recv.append(down_speed)
        speeds_sent.append(up_speed)
        times.append(datetime.now())


    def write_data_used(last_total_data_used, total_data_used):
        if total_data_used != last_total_data_used:
            if total_data_used > last_total_data_used + 0.5:
                print('!! ' + str(total_data_used) + ' Mo used.')
            elif total_data_used > last_total_data_used + 1:
                print('! ' + str(total_data_used) + ' Mo used.')
            else:
                print(str(total_data_used) + ' Mo used.')


    if __name__ == '__main__':
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s ' +
                                      '-- %(levelname)s ' +
                                      '-- [%(filename)s:%(lineno)s ' +
                                      '-- %(funcName)s() ] ' +
                                      '-- %(message)s')
        stream_handler = logging.StreamHandler()
        stream_handler.setLevel(logging.DEBUG)
        stream_handler.setFormatter(formatter)
        logger.addHandler(stream_handler)

        try:
            main()
        except Exception as e:
            logger.exception('Unexpected error')

if crpvar2 == 155:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    import hashlib
    import os
    import sys
    import threading
    import tkinter as tk
    from pathlib import Path
    from tkinter import *
    from tkinter import filedialog, messagebox

    from Cryptodome.Cipher import AES


    class EncryptionTool:
        def __init__(
            self,
            user_file,
            user_key,
            user_salt,
        ):

            # get the path to input file

            self.user_file = user_file

            self.input_file_size = os.path.getsize(self.user_file)
            self.chunk_size = 1024
            self.total_chunks = self.input_file_size // self.chunk_size + 1

            # convert the key and salt to bytes

            self.user_key = bytes(user_key, "utf-8")
            self.user_salt = bytes(user_key[::-1], "utf-8")

            # get the file extension

            self.file_extension = self.user_file.split(".")[-1]

            # hash type for hashing key and salt

            self.hash_type = "SHA256"

            # encrypted file name

            self.encrypt_output_file = (
                ".".join(self.user_file.split(".")[:-1])
                + "."
                + self.file_extension
                + ".encr"
            )

            # decrypted file name

            self.decrypt_output_file = self.user_file[:-5].split(".")
            self.decrypt_output_file = (
                ".".join(self.decrypt_output_file[:-1])
                + "_decrypted."
                + self.decrypt_output_file[-1]
            )

            # dictionary to store hashed key and salt

            self.hashed_key_salt = dict()

            # hash key and salt into 16 bit hashes

            self.hash_key_salt()

        def read_in_chunks(self, file_object, chunk_size=1024):
            """Lazy function (generator) to read a file piece by piece.
            Default chunk size: 1k.
            """

            while True:
                data = file_object.read(chunk_size)
                if not data:
                    break
                yield data

        def encrypt(self):

            # create a cipher object

            cipher_object = AES.new(
                self.hashed_key_salt["key"], AES.MODE_CFB, self.hashed_key_salt["salt"]
            )

            self.abort()  # if the output file already exists, remove it first

            input_file = open(self.user_file, "rb")
            output_file = open(self.encrypt_output_file, "ab")
            done_chunks = 0

            for piece in self.read_in_chunks(input_file, self.chunk_size):
                encrypted_content = cipher_object.encrypt(piece)
                output_file.write(encrypted_content)
                done_chunks += 1
                yield done_chunks / self.total_chunks * 100

            input_file.close()
            output_file.close()

            # clean up the cipher object

            del cipher_object

        def decrypt(self):

            #  exact same as above function except in reverse

            cipher_object = AES.new(
                self.hashed_key_salt["key"], AES.MODE_CFB, self.hashed_key_salt["salt"]
            )

            self.abort()  # if the output file already exists, remove it first

            input_file = open(self.user_file, "rb")
            output_file = open(self.decrypt_output_file, "xb")
            done_chunks = 0

            for piece in self.read_in_chunks(input_file):
                decrypted_content = cipher_object.decrypt(piece)
                output_file.write(decrypted_content)
                done_chunks += 1
                yield done_chunks / self.total_chunks * 100

            input_file.close()
            output_file.close()

            # clean up the cipher object

            del cipher_object

        def abort(self):
            if os.path.isfile(self.encrypt_output_file):
                os.remove(self.encrypt_output_file)
            if os.path.isfile(self.decrypt_output_file):
                os.remove(self.decrypt_output_file)

        def hash_key_salt(self):

            # --- convert key to hash
            #  create a new hash object

            hasher = hashlib.new(self.hash_type)
            hasher.update(self.user_key)

            # turn the output key hash into 32 bytes (256 bits)

            self.hashed_key_salt["key"] = bytes(hasher.hexdigest()[:32], "utf-8")

            # clean up hash object

            del hasher

            # --- convert salt to hash
            #  create a new hash object

            hasher = hashlib.new(self.hash_type)
            hasher.update(self.user_salt)

            # turn the output salt hash into 16 bytes (128 bits)

            self.hashed_key_salt["salt"] = bytes(hasher.hexdigest()[:16], "utf-8")

            # clean up hash object

            del hasher


    class MainWindow:

        """GUI Wrapper"""

        # configure root directory path relative to this file

        THIS_FOLDER_G = ""
        if getattr(sys, "frozen", False):

            # frozen

            THIS_FOLDER_G = os.path.dirname(sys.executable)
        else:

            # unfrozen

            THIS_FOLDER_G = os.path.dirname(os.path.realpath(__file__))

        def __init__(self, rootcr):
            self.rootcr = rootcr
            self._cipher = None
            self._file_url = tk.StringVar()
            self._secret_key = tk.StringVar()
            self._secret_key_check = tk.StringVar()
            self._salt = tk.StringVar()
            self._status = tk.StringVar()
            self._status.set("---")

            self.should_cancel = False

            rootcr.title("FastEncrypt")
            rootcr.configure(bg="#eeeeee")
            image_icon81 = PhotoImage(file = "img/securelogo.png")
            rootcr.iconphoto(False, image_icon81)
            
            '''
            try:
                icon_img = tk.Image(
                    "photo", file=self.THIS_FOLDER_G + "./files/encrypc.ico"
                )
                rootcr.call("wm", "iconphoto", rootcr._w, icon_img)
            except Exception:
                pass
            '''

            self.menu_bar = tk.Menu(rootcr, bg="#eeeeee", relief=tk.FLAT)
            self.menu_bar.add_command(label="Help", command=self.show_help_callback)
            self.menu_bar.add_command(label="About", command=self.show_about)

            rootcr.configure(menu=self.menu_bar)

            self.file_entry_label = tk.Label(
                rootcr,
                text="Enter File Path Or Click SELECT FILE Button",
                bg="#eeeeee",
                anchor=tk.W,
            )
            self.file_entry_label.grid(
                padx=12,
                pady=(8, 0),
                ipadx=0,
                ipady=1,
                row=0,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.file_entry = tk.Entry(
                rootcr,
                textvariable=self._file_url,
                bg="#fff",
                exportselection=0,
                relief=tk.FLAT,
            )
            self.file_entry.grid(
                padx=15,
                pady=6,
                ipadx=8,
                ipady=8,
                row=1,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.select_btn = tk.Button(
                rootcr,
                text="SELECT FILE",
                command=self.selectfile_callback,
                width=42,
                bg="#3498db",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.select_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=2,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry_label1 = tk.Label(
                rootcr,
                text="Enter Key (To be Remembered while Decryption)",
                bg="#eeeeee",
                anchor=tk.W,
            )
            self.key_entry_label1.grid(
                padx=12,
                pady=(8, 0),
                ipadx=0,
                ipady=1,
                row=3,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry1 = tk.Entry(
                rootcr,
                textvariable=self._secret_key,
                bg="#fff",
                exportselection=0,
                relief=tk.FLAT,
            )
            self.key_entry1.grid(
                padx=15,
                pady=6,
                ipadx=8,
                ipady=8,
                row=4,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry_label2 = tk.Label(
                rootcr, text="Re-enter Key (Validation)", bg="#eeeeee", anchor=tk.W
            )
            self.key_entry_label2.grid(
                padx=12,
                pady=(8, 0),
                ipadx=0,
                ipady=1,
                row=5,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry2 = tk.Entry(
                rootcr,
                textvariable=self._secret_key_check,
                bg="#fff",
                exportselection=0,
                relief=tk.FLAT,
            )
            self.key_entry2.grid(
                padx=15,
                pady=6,
                ipadx=8,
                ipady=8,
                row=6,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.encrypt_btn = tk.Button(
                rootcr,
                text="ENCRYPT",
                command=self.e_check_callback,
                bg="#27ae60",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.encrypt_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=7,
                column=0,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.decrypt_btn = tk.Button(
                rootcr,
                text="DECRYPT",
                command=self.d_check_callback,
                bg="#27ae60",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.decrypt_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=7,
                column=2,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.reset_btn = tk.Button(
                rootcr,
                text="CLEAR",
                command=self.reset_callback,
                bg="#717d7e",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.reset_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=8,
                column=0,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.stop_btn = tk.Button(
                rootcr,
                text="STOP",
                command=self.cancel_callback,
                bg="#aaaaaa",
                fg="#ffffff",
                bd=2,
                state="disabled",
                relief=tk.FLAT,
            )
            self.stop_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=8,
                column=2,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.status_label = tk.Label(
                rootcr,
                textvariable=self._status,
                bg="#eeeeee",
                anchor=tk.W,
                justify=tk.LEFT,
                relief=tk.FLAT,
                wraplength=350,
            )
            self.status_label.grid(
                padx=12,
                pady=(0, 12),
                ipadx=0,
                ipady=1,
                row=9,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            tk.Grid.columnconfigure(rootcr, 0, weight=1)
            tk.Grid.columnconfigure(rootcr, 1, weight=1)
            tk.Grid.columnconfigure(rootcr, 2, weight=1)
            tk.Grid.columnconfigure(rootcr, 3, weight=1)

        def selectfile_callback(self):
            try:
                name = filedialog.askopenfile()
                self._file_url.set(name.name)
            except Exception as e:
                self._status.set(e)
                self.status_label.update()

        def freeze_controls(self):
            self.file_entry.configure(state="disabled")
            self.key_entry1.configure(state="disabled")
            self.key_entry2.configure(state="disabled")
            self.select_btn.configure(state="disabled", bg="#aaaaaa")
            self.encrypt_btn.configure(state="disabled", bg="#aaaaaa")
            self.decrypt_btn.configure(state="disabled", bg="#aaaaaa")
            self.reset_btn.configure(state="disabled", bg="#aaaaaa")
            self.stop_btn.configure(state="normal", bg="#e74c3c")
            self.status_label.update()

        def unfreeze_controls(self):
            self.file_entry.configure(state="normal")
            self.key_entry1.configure(state="normal")
            self.key_entry2.configure(state="normal")
            self.select_btn.configure(state="normal", bg="#3498db")
            self.encrypt_btn.configure(state="normal", bg="#27ae60")
            self.decrypt_btn.configure(state="normal", bg="#27ae60")
            self.reset_btn.configure(state="normal", bg="#717d7e")
            self.stop_btn.configure(state="disabled", bg="#aaaaaa")
            self.status_label.update()

        def e_check_callback(self):

            newPath = Path(self._file_url.get())
            if newPath.is_file():
                pass
            else:
                messagebox.showinfo("EncrypC", "Please Enter a valid File URL !!")
                return

            if len(self._secret_key.get()) == 0:
                messagebox.showinfo("EncrypC", "Please Enter a valid Secret Key !!")
                return
            elif self._secret_key.get() != self._secret_key_check.get():
                messagebox.showinfo("EncrypC", "Passwords do not match !!")
                return

            self.encrypt_callback()

        def d_check_callback(self):

            newPath = Path(self._file_url.get())
            if newPath.is_file():
                pass
            else:
                messagebox.showinfo("EncrypC", "Please Enter a valid File URL !!")
                return

            if self._file_url.get()[-4:] != "encr":
                messagebox.showinfo(
                    "EncrypC",
                    """Provided File is not an Encrypted File !!
    Please Enter an Encrypted File to Decrypt.""",
                )
                return

            if len(self._secret_key.get()) == 0:
                messagebox.showinfo("EncrypC", "Please Enter a Secret Key !!")
                return
            elif self._secret_key.get() != self._secret_key_check.get():
                messagebox.showinfo("EncrypC", "Passwords do not match !!")
                return

            self.decrypt_callback()

        def encrypt_callback(self):
            t1 = threading.Thread(target=self.encrypt_execute)
            t1.start()

        def encrypt_execute(self):
            self.freeze_controls()

            try:
                self._cipher = EncryptionTool(
                    self._file_url.get(), self._secret_key.get(), self._salt.get()
                )
                for percentage in self._cipher.encrypt():
                    if self.should_cancel:
                        break
                    percentage = "{0:.2f}%".format(percentage)
                    self._status.set(percentage)
                    self.status_label.update()

                if self.should_cancel:
                    self._cipher.abort()
                    self._status.set("Cancellation Successful !!")
                    messagebox.showinfo("EncrypC", "Cancellation Successful !!")
                    self._cipher = None
                    self.should_cancel = False
                    self.unfreeze_controls()
                    return

                self._cipher = None
                self.should_cancel = False
                self._status.set("File Encryption Successful !!")
                messagebox.showinfo("EncrypC", "File Encryption Successful !!")
            except Exception as e:

                self._status.set(e)

            self.unfreeze_controls()

        def decrypt_callback(self):
            t2 = threading.Thread(target=self.decrypt_execute)
            t2.start()

        def decrypt_execute(self):
            self.freeze_controls()

            try:
                self._cipher = EncryptionTool(
                    self._file_url.get(), self._secret_key.get(), self._salt.get()
                )
                for percentage in self._cipher.decrypt():
                    if self.should_cancel:
                        break
                    percentage = "{0:.2f}%".format(percentage)
                    self._status.set(percentage)
                    self.status_label.update()

                if self.should_cancel:
                    self._cipher.abort()
                    self._status.set("Cancellation Successful !!")
                    messagebox.showinfo("EncrypC", "Cancellation Successful !!")
                    self._cipher = None
                    self.should_cancel = False
                    self.unfreeze_controls()
                    return

                self._cipher = None
                self.should_cancel = False
                self._status.set("File Decryption Successful !!")
                messagebox.showinfo("EncrypC", "File Decryption Successful !!")
            except Exception as e:

                self._status.set(e)

            self.unfreeze_controls()

        def reset_callback(self):
            self._cipher = None
            self._file_url.set("")
            self._secret_key.set("")
            self._salt.set("")
            self._status.set("---")

        def cancel_callback(self):
            self.should_cancel = True

        def show_help_callback(self):
            messagebox.showinfo(
                "Tutorial",
                """1. Open the Application and Click SELECT FILE Button to select your file e.g. "mydoc.pdf" (OR You can add path manually).
    2. Enter your Key (This should be alphanumeric letters). Remember this so you can Decrypt the file later. (Else you'll lose your file permanently)
    3. Click ENCRYPT Button to encrypt the file. A new encrypted file with ".encr" extention e.g. "mydoc.pdf.encr" will be created in the same directory where the "mydoc.pdf" is.
    4. When you want to Decrypt a file you, will select the file with the ".encr" extention and Enter your Key which you chose at the time of Encryption. Click DECRYPT Button to decrypt. The decrypted file will be of the same name as before with the suffix "decrypted" for e.g. "mydoc_decrypted.pdf".
    5. Click CLEAR Button to reset the input fields and status bar.""",
            )

        def show_about(self):
            messagebox.showinfo(
                "EncrypC v1.7.0",
                """FastEncrypt is a File Encryption Tool based on AES Algorithm. 
    Managed by Tudor Marmureanu.""",
            )


    ROOT = tk.Tk()
    MAIN_WINDOW = MainWindow(ROOT)
    bundle_dir = getattr(sys, "_MEIPASS", os.path.abspath(os.path.dirname(__file__)))
    #path_to_ico = os.path.abspath(os.path.join(bundle_dir, "encrypc.ico"))
    #ROOT.iconbitmap(path_to_ico)
    ROOT.resizable(height=False, width=False)
    ROOT.mainloop()

if aivar == 20:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    def AIChatbot():
        import tkinter as tk
        from tkinter import scrolledtext
        import re
        import subprocess
        import os

        class ChatInterface:
            def __init__(self, masterr):
                self.masterr = masterr
                masterr.title("AI Chatbot")
                
                # Setarea culorilor pentru fereastra principala
                masterr.configure(bg="gray20")
                
                self.chat_history = scrolledtext.ScrolledText(masterr, wrap=tk.WORD, bg="black", fg="#ccff66")
                self.chat_history.pack(expand=True, fill=tk.BOTH)
                
                self.text = """Daca nu poti copia, atunci verifica ca ambele mapari sa fie facute si ca locatiile din fisierul tau txt sa corespunda locatiilor reale din PC si, astfel, copierea se realizeaza instant.
                Copierea se realizeaza mai eficient decat daca ai face manual tot procesul, deoarece locatiile sunt deja precompilate, deci este o maniera mai eficienta cu 20%.
                Daca bara de copiere nu este verde niciodata, atunci locatiile din fisierul tau txt nu corespund sau cuvantul inainte de : este modificat.
                Daca nu se copiaza nimic, atunci verifica maparile si asigura-te ca locatiile corespund cu fisierul txt.
                Acest tool sau program te ajuta sa faci si operatiuni diverse in reteaua ta, inclusiv sa scanezi porturile, sa vezi ce dispozitive se afla in retea sau in VLAN, sa executi diverse comenzi in retea, sa verifici proprietatile hardware ale sistemului tau in timp real, contine si functii care manipuleaza fisierele pdf si multe altele.
                Altceva ar mai fi ca poate sa compare 2 fisiere sau foldere, sa caute o secventa de text si sa o inlocuiasca, genereaza parole in diverse combinatii, ba chiar poate deschide un nou Terminal personalizat si sa cripteze fisiere.
                Licenta are scopul de a limita accesul neautorizat la fel cum este si in cazul conturilor create, adica fiecare cont are un rol predefinit.
                Contul dev nu poate fi accesat decat de Tudor Marmureanu, deoarece nimeni nu are acces full la tot ce contine tocmai din cauza ca se poate da peste cap tot sistemul sau se pot produce pagube in retea.
                Conturile deja predefinite inglobeaza celelalte functionalitati care nu se regasesc in contul it, in principal pentru ca nu au legatura cu procesul de copy.
                Sunt mai multe conturi si functionalitati, insa Tudor Marmureanu nu mi-a dat acces sa dezvalui toata informatia.
                Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale.
                Atat timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii.
                """
                
                self.input_field_label = tk.Label(masterr, text="Ask a question:", bg="gray20", fg="cyan")
                self.input_field_label.pack()

                # Crearea câmpului de intrare cu culori
                self.input_field = tk.Entry(masterr, bg="gray40", fg="#ccff66", insertbackground="cyan")
                self.input_field.pack(expand=True, fill=tk.X)

                self.input_field.bind("<Return>", self.process_input)
                
            def process_input(self, event):
                input_text = self.input_field.get()
                self.input_field.delete(0, tk.END)
                response = self.get_response(input_text)
                self.display_response(input_text, response)
                
            def get_response(self, question):
                if question.lower() == "deschide-mi servicetagul" or question.lower() == "deschide-mi servicetag-ul" or question.lower() == "deschide servicetag-ul" or question.lower() == "deschide-mi servicetag" or question.lower() == "afiseaza-mi servicetag" or question.lower() == "afiseaza-mi servicetagul" or question.lower() == "deschide servicetagul" or question.lower() == "deschide servicetag" or question.lower() == "afiseaza servicetag" or question.lower() == "afiseaza servicetagul" or question.lower() == "afiseaza servicetag-ul" or question.lower() == "afiseaza-mi servicetag-ul":
                    try:
                        output = subprocess.check_output(["wmic", "bios", "get", "serialnumber"]).decode().strip().split("\n")
                        # Service Tag-ul este în al doilea rând al rezultatului
                        service_tag = output[1].strip()
                        try:
                            with open("ServiceTag.txt", 'w') as file:
                                file.write(service_tag)  # Scriem Service Tag-ul în fișier
                            print("The information has been saved to ServiceTag.txt")
                        except Exception as e:
                            print(f"An error occurred while saving to ServiceTag.txt: {e}")
                        return service_tag
                    except Exception as e:
                        print("A apărut o Error:", e)
                        return None
                elif question.lower() == "deschide-mi licenta" or question.lower() == "deschide-mi cheia de licenta" or question.lower() == "afiseaza-mi licenta" or question.lower() == "afiseaza-mi cheia de licenta" or question.lower() == "deschide licenta" or question.lower() == "deschide cheia de licenta" or question.lower() == "afiseaza licenta" or question.lower() == "afiseaza cheia de licenta":
                    try:
                        output = subprocess.check_output(["wmic", "path", "softwarelicensingservice", "get", "OA3xOriginalProductKey"]).decode().strip().split("\n")
                        # Cheia de licență Windows este în ultima linie a rezultatului
                        license_key = output[-1].split(":")[-1].strip()
                        try:
                            with open("WindowsKey.txt", 'w') as file:
                                file.write(license_key)  # Scriem Service Tag-ul în fișier
                            print("The information has been saved to WindowsKey.txt")
                        except Exception as e:
                            print(f"An error occurred while saving to WindowsKey.txt: {e}")
                        return license_key
                    except Exception as e:
                        print("A apărut o Error:", e)
                        return None
                elif question.lower() == "lusrmgr.msc" or question.lower() == "lusrmgr":
                    os.startfile("lusrmgr.msc")
                elif question.lower() == "devmgmt.msc" or question.lower() == "devmgmt" or question.lower() == "device manager":
                    os.startfile("devmgmt.msc")
                elif question.lower() == "edit power plan" or question.lower() == "power plan" or question.lower() == "battery" or question.lower() == "battery plan" or question.lower() == "batery" or question.lower() == "batery plan":
                    try:
                        subprocess.run(["control", "powercfg.cpl"])
                    except Exception as e:
                        print("Error:", e)
                elif question.lower() == "control panel apps" or question.lower() == "control panel" or question.lower() == "appwiz.cpl" or question.lower() == "appwiz" or question.lower() == "apwiz" or question.lower() == "apwiz.cpl":
                    os.startfile("appwiz.cpl")
                elif question.lower() == "sysdm" or question.lower() == "sysdm.cpl" or question.lower() == "windows domain" or question.lower() == "domain" or question.lower() == "domeniu" or question.lower() == "windows domeniu" or question.lower() == "domeniu windows":
                    os.startfile("sysdm.cpl")
                elif question.lower() == "shutdown" or question.lower() == "shutdown pc" or question.lower() == "inchide pc" or question.lower() == "inchide acest pc" or question.lower() == "inchide" or question.lower() == "shutdown laptop" or question.lower() == "inchide laptop" or question.lower() == "inchide acest laptop":
                    subprocess.call("shutdown /s /t 1")
                elif question.lower() == "restart" or question.lower() == "restart pc" or question.lower() == "restarteaza pc" or question.lower() == "restarteaza" or question.lower() == "restart laptop" or question.lower() == "restarteaza laptop" or question.lower() == "restarteaza acest pc" or question.lower() == "restarteaza acest laptop":
                    subprocess.call("shutdown /r /t 1")
                elif question.lower() == "logout" or question.lower() == "logout pc" or question.lower() == "log out" or question.lower() == "logout laptop" or question.lower() == "log out pc" or question.lower() == "log out laptop":
                    subprocess.call("shutdown -l")
                elif question.lower() == "system info" or question.lower() == "system information" or question.lower() == "display system info" or question.lower() == "afiseaza informatiile sistemului" or question.lower() == "afiseaza informatiile pc-ului" or question.lower() == "afiseaza informatiile pcului" or question.lower() == "afiseaza informatiile laptopului" or question.lower() == "afiseaza informatiile" or question.lower() == "afiseaza-mi informatiile sistemului" or question.lower() == "afiseaza-mi informatiile pc-ului" or question.lower() == "afiseaza-mi informatiile pcului" or question.lower() == "afiseaza-mi informatiile laptopului" or question.lower() == "afiseaza-mi informatiile":
                    try:
                        info = subprocess.check_output(['systeminfo']).decode('utf-8').split('\n')
                        formatted_info = [item.rstrip() for item in info]
                        try:
                            with open("SystemInfo.txt", 'w') as file:
                                file.write('\n'.join(formatted_info))
                            print("The information has been saved to SystemInfo.txt")
                        except Exception as e:
                            print(f"An error occurred while saving to SystemInfo.txt: {e}")
                        self.chat_history.insert(tk.END, "AI: System info:\n")
                        for item in formatted_info:
                            self.chat_history.insert(tk.END, "AI: " + item + "\n")
                        self.chat_history.insert(tk.END, "\n")
                        self.text_area.insert(tk.END, "System info:\n")
                        for item in formatted_info:
                            self.text_area.insert(tk.END, item + "\n")
                        self.text_area.insert(tk.END, "\n")
                        return formatted_info
                    except Exception as e:
                        print("A apărut o Error:", e)
                        return []

                elif question.lower() == "afiseaza device-urile conectate la retea" or question.lower() == "afiseaza device-urile conectate la reteaua mea" or question.lower() == "afiseaza deviceurile conectate la retea" or question.lower() == "afiseaza deviceurile conectate la reteaua mea" or question.lower() == "afiseaza-mi device-urile conectate la retea" or question.lower() == "afiseaza-mi device-urile conectate la reteaua mea" or question.lower() == "afiseaza-mi deviceurile conectate la retea" or question.lower() == "afiseaza-mi deviceurile conectate la reteaua mea" or question.lower() == "show devices on network" or question.lower() == "arata device-urile conectate la retea" or question.lower() == "arata device-urile conectate la reteaua mea" or question.lower() == "arata deviceurile conectate la retea" or question.lower() == "arata deviceurile conectate la reteaua mea" or question.lower() == "arata-mi device-urile conectate la retea" or question.lower() == "arata-mi device-urile conectate la reteaua mea" or question.lower() == "arata-mi deviceurile conectate la retea" or question.lower() == "arata-mi deviceurile conectate la reteaua mea":
                    output_arp = subprocess.check_output(['arp', '-a']).decode('utf-8')
                    output_netstat = subprocess.check_output(['netstat', '-an']).decode('utf-8')
                    self.chat_history.insert(tk.END, "AI: Active devices on the network:\n" + output_arp + "\n\n")
                    self.chat_history.insert(tk.END, "AI: Network connections and open ports:\n" + output_netstat + "\n\n")
                    with open('devices_on_network.txt', 'w') as f:
                        f.write("Active devices on the network:\n" + output_arp + "\n\n")
                        f.write("Network connections and open ports:\n" + output_netstat)
                    self.text_area.insert(tk.END, "Active devices on the network:\n" + output_arp + "\n\n")
                    self.text_area.insert(tk.END, "Network connections and open ports:\n" + output_netstat + "\n\n")
                elif question.lower() == "afiseaza toate parolele wi-fi" or question.lower() == "afiseaza toate parolele wifi" or question.lower() == "afiseaza parolele wi-fi" or question.lower() == "afiseaza parolele wifi" or question.lower() == "afiseaza-mi toate parolele wi-fi" or question.lower() == "afiseaza-mi toate parolele wifi" or question.lower() == "afiseaza-mi parolele wi-fi" or question.lower() == "afiseaza-mi parolele wifi" or question.lower() == "arata toate parolele wi-fi" or question.lower() == "arata toate parolele wifi" or question.lower() == "arata parolele wi-fi" or question.lower() == "arata parolele wifi" or question.lower() == "arata-mi toate parolele wi-fi" or question.lower() == "arata-mi toate parolele wifi" or question.lower() == "arata-mi parolele wi-fi" or question.lower() == "arata-mi parolele wifi" or question.lower() == "show wifi passwords" or question.lower() == "afiseaza parolele wifi" or question.lower() == "show wifi pass" or question.lower() == "show wifi paswords" or question.lower() == "show wifi pas" or question.lower() == "show wi-fi passwords" or question.lower() == "afiseaza parolele wifi" or question.lower() == "show wi-fi pass" or question.lower() == "show wi-fi paswords" or question.lower() == "show wi-fi pas" or question.lower() == "vreau sa imi afisezi parolele wifi" or question.lower() == "vreau sa imi afisezi parolele wi-fi":
                    try:
                        output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8')
                        self.chat_history.insert(tk.END, "AI: " + output + "\n")
                    except subprocess.CalledProcessError as e:
                        error_msg = "Error: " + e.output.decode('utf-8')
                        self.chat_history.insert(tk.END, "AI: " + error_msg + "\n")

                    with open("Wifi_Passwords.txt", "w") as file:
                        data = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
                        profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]
                        for i in profiles:
                            results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', i, 'key=clear']).decode('utf-8').split('\n')
                            results = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
                            try:
                                file.write("{:<30}|  {:<}\n".format(i, results[0]))
                                self.chat_history.insert(tk.END, "AI: " + "{:<30}|  {:<}\n".format(i, results[0]) + "\n")
                            except IndexError:
                                file.write("{:<30}|  {:<}\n".format(i, ""))
                                self.chat_history.insert(tk.END, "AI: " + "{:<30}|  {:<}\n".format(i, "") + "\n")
                            except Exception as ex:
                                file.write("Password Not Found\n")
                                self.chat_history.insert(tk.END, "AI: Password Not Found\n" + "\n")
                
                elif question.lower() == "cine esti" or question.lower() == "ce esti" or question.lower() == "cine esti tu" or question.lower() == "ce esti tu" or question.lower() == "cine esti?" or question.lower() == "ce esti?" or question.lower() == "cine esti tu?" or question.lower() == "ce esti tu?":
                    response = "Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale. Atata timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii."
                    self.chat_history.insert(tk.END, "AI: " + response + "\n")
                else:
                    # Verificăm dacă întrebarea conține semnul întrebării '?'
                    if '?' in question:
                        # Eliminăm semnul întrebării din întrebare
                        question = question.replace('?', '')
                    unique_sentences = set()
                    # Lista cuvintelor cheie de omis
                    skip_words = {"scanezi", "priveste", "cu", "privire", "la", "voastre", "noastre", "mele", "tale", "ale", "voi", "un", "exista", "locatiilor", "locatii", "locatiile", "dns", "DNS", "VLAN", "vlan", "vad", "vezi", "vazut", "azi", "cat", "deci", "asadar", "cazul", "caz", "contrar", "alte", "altele", "altor", "construit", "daca", "parca", "prin", "intermediul", "ajutor", "ajutorul", "ajutoare", "baza", "bazez", "bazezi", "bazam", "bazati", "puternic", "slab", "dar", "doar", "numai", "intrucat", "incat", "soare", "frig", "furtuna", "ninge", "ploua", "stele", "sunt", "au", "am", "rol", "faci", "fac", "facem", "faceti", "faceau", "faceati", "faceam", "aveam", "aveai", "aveati", "aveti", "avem", "o", "situatie", "situatii", "niciodata", "aia", "acum", "acea", "aceea", "fisiere", "fisierele", "fisierelor", "fisier", "fisierul", "directorul", "director", "directoare", "directoarele", "arhiva", "zip", "ZIP", "arhive", "arhivele", "arhivelor", "cont", "conturi", "conturile", "conturilor", "fa", "-", "mi", "ti", "l", "le", "lor", "lui", "meu", "noastra", "voastra", "ei", "ea", "eu", "tu", "am", "ai", "voua", "va", "v", "i", "ai", "ti", "voi", "noua", "mie", "mi", "as", "m", "ar", "ne", "va", "place", "placea", "placut", "copi", "copii", "instant", "astfel", "altfel", "legatura", "au", "cu", "cu copierea", "inglobeaza", "principal", "in", "procesul", "de", "deja", "nicicand", "niciunde", "nici", "faca", "candva", "cand", "de", "ce", "face", "acest", "acestui", "acestora", "putea", "unde", "cum", "care", "este", "e", "sa", "fisiere", "chiar", "daca", "in", "timp", "real", "realmente", "si", "multe", "mult", "alt", "alte", "altele", "peste", "produce", "contine", "contin", "cauza", "cap", "tot", "toti", "toate", "poate", "are", "poti", "as", "merge", "functioneaza", "pentru", "ca", "deoarece", "daca", "tocmai", "din", "cauza", "la", "avea", "avem", "aveai", "ai", "fi", "a", "fost", "eram", "era", "musai", "trebuie", "trebuia", "trebuit", "mai", "imi", "ne", "ii", "cheie", "cheia", "chei", "merge", "mergea", "mers", "o", "poate", "realiza", "nu", "pot", "poti", "nimic", "se", "putea", "prea", "?"}
                    # Filtrăm cuvintele din întrebare eliminând cuvintele cheie
                    words_in_question = set(word for word in re.split(r'\W+', question.lower()) if word not in skip_words)
                    for sentence in self.text.split('.'):
                        # Verificăm dacă orice cuvânt din întrebare filtrată se regăsește în propoziția curentă
                        if any(word in re.split(r'\W+', sentence.lower()) for word in words_in_question):
                            unique_sentences.add(sentence.strip())
                    response = '\n'.join(unique_sentences) if unique_sentences else "Imi pare rau, dar nu am fost antrenat sa raspund la aceasta cerere. Voi primi actualizari constante."
                    return response

                
            def display_response(self, input_text, response):
                self.chat_history.insert(tk.END, "You: " + input_text + "\n")
                self.chat_history.insert(tk.END, "AI: " + response + "\n\n")
                
        rootai = tk.Tk()
        chat_interface = ChatInterface(rootai)
        image_icon120 = PhotoImage(file = "img/ailogo.png")
        rootai.iconphoto(False, image_icon120)
        rootai.mainloop()
    AIChatbot()

if notepadvar == 21:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox, colorchooser, font
    from tkinter.scrolledtext import ScrolledText
    import os
    import re
    import webbrowser
    import pygments
    from pygments.lexers import get_lexer_by_name, get_all_lexers
    from pygments.styles import get_all_styles
    from pygments.token import Token

    class LineNumberedText(tk.Frame):
        def __init__(self, parent, *args, **kwargs):
            tk.Frame.__init__(self, parent)
            self.text = ScrolledText(self, *args, **kwargs)
            self.line_numbers = tk.Text(self, width=4, padx=4, bg='#f0f0f0', bd=0,
                                   highlightthickness=0, takefocus=0)
            self.line_numbers.tag_configure('line_numbers', justify='right')
            
            self.text.grid(row=0, column=1, sticky="nsew")
            self.line_numbers.grid(row=0, column=0, sticky="nsew")
            
            self.text.bind('<KeyRelease>', self.on_key_release)
            self.text.bind('<ButtonRelease-1>', self.on_key_release)
            self.text.bind('<MouseWheel>', self.on_key_release)
            self.text.bind('<Configure>', self.on_key_release)
            
            self.columnconfigure(1, weight=1)
            self.rowconfigure(0, weight=1)
            
            # Initial line numbers update
            self.on_key_release()
            
        def on_key_release(self, event=None):
            self.update_line_numbers()
            
        def update_line_numbers(self):
            line_count = self.text.get('1.0', tk.END).count('\n')
            if line_count <= 0:
                line_count = 1
                
            line_number_content = '\n'.join(str(i) for i in range(1, line_count + 1))
            self.line_numbers.config(state=tk.NORMAL)
            self.line_numbers.delete('1.0', tk.END)
            self.line_numbers.insert('1.0', line_number_content)
            self.line_numbers.config(state=tk.DISABLED)
            
            # Sync scrolling
            self.line_numbers.yview_moveto(self.text.yview()[0])
            
        def highlight_line(self, line_number, bg_color='#e0e0e0'):
            self.text.tag_remove('active_line', '1.0', tk.END)
            self.text.tag_add('active_line', f'{line_number}.0', f'{line_number + 1}.0')
            self.text.tag_config('active_line', background=bg_color)

    class SyntaxHighlighter:
        def __init__(self, text_widget):
            self.text = text_widget
            self.current_lexer = None
            self.current_style = 'default'
            self.token_tags = {}
            self._setup_tags()
            
        def _setup_tags(self):
            # Configure tags for different token types
            self.token_tags = {
                Token.Keyword: 'keyword',
                Token.String: 'string',
                Token.Name.Function: 'function',
                Token.Name.Class: 'class',
                Token.Comment: 'comment',
                Token.Number: 'number',
                Token.Operator: 'operator',
                Token.Name.Builtin: 'builtin',
                Token.Literal: 'literal',
                Token.String.Doc: 'docstring',
                Token.Name.Decorator: 'decorator',
            }
            
            # Default styling
            self.text.tag_configure('keyword', foreground='#0000FF', font=('Courier New', 10, 'bold'))
            self.text.tag_configure('string', foreground='#A31515')
            self.text.tag_configure('function', foreground='#795E26')
            self.text.tag_configure('class', foreground='#267f99', font=('Courier New', 10, 'bold'))
            self.text.tag_configure('comment', foreground='#008000', font=('Courier New', 10, 'italic'))
            self.text.tag_configure('number', foreground='#098658')
            self.text.tag_configure('operator', foreground='#000000')
            self.text.tag_configure('builtin', foreground='#0000FF')
            self.text.tag_configure('literal', foreground='#A31515')
            self.text.tag_configure('docstring', foreground='#008000', font=('Courier New', 10, 'italic'))
            self.text.tag_configure('decorator', foreground='#AF00DB')
        
        def set_lexer(self, language):
            try:
                self.current_lexer = get_lexer_by_name(language)
                return True
            except pygments.util.ClassNotFound:
                self.current_lexer = None
                return False
        
        def set_style(self, style_name):
            try:
                style = pygments.styles.get_style_by_name(style_name)
                self.current_style = style_name
                
                # Update tag configurations based on the style
                for token_type, tag_name in self.token_tags.items():
                    if token_type in style:
                        style_attrs = style.style_for_token(token_type)
                        fg = style_attrs['color']
                        bg = style_attrs['bgcolor']
                        bold = style_attrs['bold']
                        italic = style_attrs['italic']
                        
                        kwargs = {}
                        if fg:
                            kwargs['foreground'] = f'#{fg}'
                        if bg:
                            kwargs['background'] = f'#{bg}'
                            
                        font_style = ('Courier New', 10)
                        if bold and italic:
                            font_style = ('Courier New', 10, 'bold italic')
                        elif bold:
                            font_style = ('Courier New', 10, 'bold')
                        elif italic:
                            font_style = ('Courier New', 10, 'italic')
                            
                        kwargs['font'] = font_style
                        self.text.tag_configure(tag_name, **kwargs)
                
                return True
            except pygments.util.ClassNotFound:
                return False
        
        def highlight(self):
            if not self.current_lexer:
                return
                
            # Remove all existing tags
            for tag in self.token_tags.values():
                self.text.tag_remove(tag, '1.0', tk.END)
                
            # Get text content
            content = self.text.get('1.0', tk.END)
            
            # Tokenize text using pygments
            tokens = pygments.lex(content, self.current_lexer)
            
            # Apply tags for each token
            pos = 0
            for token_type, value in tokens:
                # Find all token types that match
                for token_pattern, tag_name in self.token_tags.items():
                    if token_type in token_pattern:
                        start_index = f"1.0+{pos}c"
                        end_index = f"1.0+{pos + len(value)}c"
                        self.text.tag_add(tag_name, start_index, end_index)
                        break
                pos += len(value)


    class FindReplaceDialog(tk.Toplevel):
        def __init__(self, parent, text_widget):
            super().__init__(parent)
            self.text = text_widget
            self.title("Find & Replace")
            self.geometry("400x150")
            self.resizable(False, False)
            
            # Variables
            self.find_var = tk.StringVar()
            self.replace_var = tk.StringVar()
            self.case_sensitive_var = tk.BooleanVar()
            self.whole_word_var = tk.BooleanVar()
            self.regex_var = tk.BooleanVar()
            
            # Create UI
            ttk.Label(self, text="Find:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            ttk.Entry(self, textvariable=self.find_var, width=30).grid(row=0, column=1, padx=5, pady=5)
            
            ttk.Label(self, text="Replace:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
            ttk.Entry(self, textvariable=self.replace_var, width=30).grid(row=1, column=1, padx=5, pady=5)
            
            options_frame = ttk.Frame(self)
            options_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="w")
            
            ttk.Checkbutton(options_frame, text="Case sensitive", variable=self.case_sensitive_var).pack(side=tk.LEFT)
            ttk.Checkbutton(options_frame, text="Whole word", variable=self.whole_word_var).pack(side=tk.LEFT)
            ttk.Checkbutton(options_frame, text="Regular expression", variable=self.regex_var).pack(side=tk.LEFT)
            
            button_frame = ttk.Frame(self)
            button_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5)
            
            ttk.Button(button_frame, text="Find Next", command=self.find_next).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Replace", command=self.replace).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Replace All", command=self.replace_all).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Close", command=self.destroy).pack(side=tk.LEFT, padx=5)
            
            self.last_search_pos = "1.0"
            self.found_items = []
            self.current_match = -1
            
        def find_next(self):
            search_str = self.find_var.get()
            if not search_str:
                return
                
            start_pos = self.text.index(tk.INSERT)
            
            # Remove previous highlights
            self.text.tag_remove('search_highlight', '1.0', tk.END)
            
            search_kwargs = {"nocase": not self.case_sensitive_var.get()}
            
            if self.regex_var.get():
                # Use regex search
                content = self.text.get('1.0', tk.END)
                flags = 0 if self.case_sensitive_var.get() else re.IGNORECASE
                try:
                    pattern = re.compile(search_str, flags)
                    matches = list(pattern.finditer(content))
                    
                    if not matches:
                        messagebox.showinfo("Find", "No match found")
                        return
                    
                    self.found_items = []
                    for match in matches:
                        start_idx = f"1.0+{match.start()}c"
                        end_idx = f"1.0+{match.end()}c"
                        self.found_items.append((start_idx, end_idx))
                        self.text.tag_add('search_highlight', start_idx, end_idx)
                    
                    self.current_match = (self.current_match + 1) % len(self.found_items)
                    self.text.tag_config('search_highlight', background='yellow')
                    self.text.see(self.found_items[self.current_match][0])
                    self.text.mark_set(tk.INSERT, self.found_items[self.current_match][0])
                    
                except re.error as e:
                    messagebox.showerror("Regex Error", f"Invalid regular expression: {e}")
            else:
                # Use normal search
                found_pos = self.text.search(search_str, start_pos, **search_kwargs)
                if not found_pos:
                    # Try from the beginning if not found
                    found_pos = self.text.search(search_str, '1.0', **search_kwargs)
                    
                if not found_pos:
                    messagebox.showinfo("Find", "No match found")
                    return
                    
                end_pos = f"{found_pos}+{len(search_str)}c"
                self.text.tag_add('search_highlight', found_pos, end_pos)
                self.text.tag_config('search_highlight', background='yellow')
                self.text.see(found_pos)
                self.text.mark_set(tk.INSERT, found_pos)
                self.last_search_pos = end_pos
        
        def replace(self):
            search_str = self.find_var.get()
            replace_str = self.replace_var.get()
            
            if not search_str:
                return
                
            # First find the current occurrence
            self.find_next()
            
            # Then replace if found
            try:
                sel_start = self.text.index(tk.SEL_FIRST)
                sel_end = self.text.index(tk.SEL_LAST)
                self.text.delete(sel_start, sel_end)
                self.text.insert(sel_start, replace_str)
            except tk.TclError:
                # No selection, do nothing
                pass
        
        def replace_all(self):
            search_str = self.find_var.get()
            replace_str = self.replace_var.get()
            
            if not search_str:
                return
                
            # Start from the beginning
            self.text.mark_set(tk.INSERT, '1.0')
            count = 0
            
            if self.regex_var.get():
                # Use regex replace all
                content = self.text.get('1.0', tk.END)
                flags = 0 if self.case_sensitive_var.get() else re.IGNORECASE
                try:
                    pattern = re.compile(search_str, flags)
                    new_content, count = pattern.subn(replace_str, content)
                    if count > 0:
                        self.text.delete('1.0', tk.END)
                        self.text.insert('1.0', new_content)
                    messagebox.showinfo("Replace All", f"{count} occurrences replaced")
                except re.error as e:
                    messagebox.showerror("Regex Error", f"Invalid regular expression: {e}")
            else:
                # Use normal search and replace
                search_kwargs = {"nocase": not self.case_sensitive_var.get()}
                current_pos = '1.0'
                
                while True:
                    found_pos = self.text.search(search_str, current_pos, tk.END, **search_kwargs)
                    if not found_pos:
                        break
                        
                    end_pos = f"{found_pos}+{len(search_str)}c"
                    self.text.delete(found_pos, end_pos)
                    self.text.insert(found_pos, replace_str)
                    current_pos = f"{found_pos}+{len(replace_str)}c"
                    count += 1
                    
                messagebox.showinfo("Replace All", f"{count} occurrences replaced")


    class ThemeManager:
        def __init__(self, editor):
            self.editor = editor
            self.current_theme = "default"
            
            # Define themes
            self.themes = {
                "default": {
                    "background": "#FFFFFF",
                    "foreground": "#000000",
                    "line_numbers_bg": "#F0F0F0",
                    "line_numbers_fg": "#000000",
                    "cursor": "#000000",
                    "selection_bg": "#ADD6FF",
                    "active_line_bg": "#E8F2FE",
                    "font": ("Courier New", 10),
                },
                "dark": {
                    "background": "#1E1E1E",
                    "foreground": "#D4D4D4",
                    "line_numbers_bg": "#252526",
                    "line_numbers_fg": "#858585",
                    "cursor": "#AEAFAD",
                    "selection_bg": "#264F78",
                    "active_line_bg": "#282828",
                    "font": ("Courier New", 10),
                },
                "monokai": {
                    "background": "#272822",
                    "foreground": "#F8F8F2",
                    "line_numbers_bg": "#3E3D32",
                    "line_numbers_fg": "#90908A",
                    "cursor": "#F8F8F0",
                    "selection_bg": "#49483E",
                    "active_line_bg": "#3E3D32",
                    "font": ("Courier New", 10),
                },
                "solarized_light": {
                    "background": "#FDF6E3",
                    "foreground": "#657B83",
                    "line_numbers_bg": "#EEE8D5",
                    "line_numbers_fg": "#839496",
                    "cursor": "#586E75",
                    "selection_bg": "#EEE8D5",
                    "active_line_bg": "#EEE8D5",
                    "font": ("Courier New", 10),
                },
                "solarized_dark": {
                    "background": "#002B36",
                    "foreground": "#839496",
                    "line_numbers_bg": "#073642",
                    "line_numbers_fg": "#586E75",
                    "cursor": "#93A1A1",
                    "selection_bg": "#073642",
                    "active_line_bg": "#073642",
                    "font": ("Courier New", 10),
                }
            }
        
        def apply_theme(self, theme_name):
            if theme_name not in self.themes:
                return False
                
            theme = self.themes[theme_name]
            self.current_theme = theme_name
            
            # Apply theme to text editor
            self.editor.text.config(
                background=theme["background"],
                foreground=theme["foreground"],
                insertbackground=theme["cursor"],
                selectbackground=theme["selection_bg"],
                font=theme["font"]
            )
            
            # Apply theme to line numbers
            self.editor.line_numbers.config(
                background=theme["line_numbers_bg"],
                foreground=theme["line_numbers_fg"],
                font=theme["font"]
            )
            
            # Apply theme to active line highlighting
            self.editor.text.tag_config('active_line', background=theme["active_line_bg"])
            
            return True
        
        def add_custom_theme(self, name, settings):
            self.themes[name] = settings
            
        def get_theme_names(self):
            return list(self.themes.keys())


    class AdvancedNotepad:
        def __init__(self, rootntpadd):
            self.rootntpadd = rootntpadd
            self.rootntpadd.title("Advanced Notepad")
            self.rootntpadd.geometry("1000x600")
            
            # Set application icon
            try:
                self.rootntpadd.iconbitmap("notepad.ico")  # Replace with your icon file
            except:
                pass  # Ignore if icon file is not found
                
            # Initialize variables
            self.current_file = None
            self.modified = False
            
            # Create main frame
            self.main_frame = ttk.Frame(rootntpadd)
            self.main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Create the editor with line numbers
            self.editor = LineNumberedText(self.main_frame)
            self.editor.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Set font
            default_font = font.Font(family="Courier New", size=10)
            self.editor.text.configure(font=default_font, wrap=tk.NONE, undo=True)
            
            # Initialize syntax highlighter
            self.syntax_highlighter = SyntaxHighlighter(self.editor.text)
            self.syntax_highlighter.set_lexer("python")  # Default to Python syntax
            
            # Initialize theme manager
            self.theme_manager = ThemeManager(self.editor)
            self.theme_manager.apply_theme("default")
            
            # Create menu bar - moved after theme_manager initialization
            self.create_menu_bar()
            
            # Create toolbar
            self.create_toolbar()
            
            # Create status bar
            self.status_bar = ttk.Frame(rootntpadd)
            self.status_bar.pack(fill=tk.X, side=tk.BOTTOM)
            
            self.status_text = ttk.Label(self.status_bar, text="Line: 1, Col: 0")
            self.status_text.pack(side=tk.LEFT, padx=5)
            
            self.language_label = ttk.Label(self.status_bar, text="Python")
            self.language_label.pack(side=tk.RIGHT, padx=5)
            
            # Bind events
            self.editor.text.bind("<KeyRelease>", self.on_key_release)
            self.editor.text.bind("<ButtonRelease-1>", self.update_status_bar)
            self.editor.text.bind("<Control-f>", self.show_find_dialog)
            self.editor.text.bind("<Control-h>", self.show_find_dialog)
            self.editor.text.bind("<Control-s>", self.save_file)
            self.editor.text.bind("<Control-o>", self.open_file)
            self.editor.text.bind("<Control-n>", self.new_file)
            self.editor.text.bind("<Control-w>", self.close_file)
            
            # Initial status bar update
            self.update_status_bar()
            
            # Set focus to the editor
            self.editor.text.focus_set()
            
        def create_menu_bar(self):
            menubar = tk.Menu(self.rootntpadd)
            
            # File menu
            file_menu = tk.Menu(menubar, tearoff=0)
            file_menu.add_command(label="New", accelerator="Ctrl+N", command=self.new_file)
            file_menu.add_command(label="Open", accelerator="Ctrl+O", command=self.open_file)
            file_menu.add_command(label="Save", accelerator="Ctrl+S", command=self.save_file)
            file_menu.add_command(label="Save As", command=self.save_as_file)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.exit_app)
            menubar.add_cascade(label="File", menu=file_menu)
            
            # Edit menu
            edit_menu = tk.Menu(menubar, tearoff=0)
            edit_menu.add_command(label="Undo", accelerator="Ctrl+Z", command=lambda: self.editor.text.event_generate("<<Undo>>"))
            edit_menu.add_command(label="Redo", accelerator="Ctrl+Y", command=lambda: self.editor.text.event_generate("<<Redo>>"))
            edit_menu.add_separator()
            edit_menu.add_command(label="Cut", accelerator="Ctrl+X", command=lambda: self.editor.text.event_generate("<<Cut>>"))
            edit_menu.add_command(label="Copy", accelerator="Ctrl+C", command=lambda: self.editor.text.event_generate("<<Copy>>"))
            edit_menu.add_command(label="Paste", accelerator="Ctrl+V", command=lambda: self.editor.text.event_generate("<<Paste>>"))
            edit_menu.add_separator()
            edit_menu.add_command(label="Find/Replace", accelerator="Ctrl+F", command=self.show_find_dialog)
            edit_menu.add_command(label="Select All", accelerator="Ctrl+A", command=lambda: self.editor.text.tag_add(tk.SEL, "1.0", tk.END))
            menubar.add_cascade(label="Edit", menu=edit_menu)
            
            # View menu
            view_menu = tk.Menu(menubar, tearoff=0)
            
            # Language submenu
            language_menu = tk.Menu(view_menu, tearoff=0)
            languages = sorted([lexer[0] for lexer in get_all_lexers()])
            
            # Add common languages first
            common_languages = ['Python', 'Java', 'JavaScript', 'HTML', 'CSS', 'C', 'C++', 'C#', 'PHP', 'Ruby', 'SQL', 'XML']
            for lang in common_languages:
                language_menu.add_command(label=lang, command=lambda l=lang: self.set_language(l))
                
            language_menu.add_separator()
            
            # Add all other languages
            for lang in languages:
                if lang not in common_languages:
                    language_menu.add_command(label=lang, command=lambda l=lang: self.set_language(l))
            
            view_menu.add_cascade(label="Language", menu=language_menu)
            
            # Theme submenu
            theme_menu = tk.Menu(view_menu, tearoff=0)
            for theme in self.theme_manager.get_theme_names():
                theme_menu.add_command(label=theme.replace('_', ' ').title(), 
                                     command=lambda t=theme: self.set_theme(t))
            
            view_menu.add_cascade(label="Theme", menu=theme_menu)
            view_menu.add_separator()
            
            # Font submenu
            font_menu = tk.Menu(view_menu, tearoff=0)
            font_menu.add_command(label="Font Settings", command=self.change_font)
            view_menu.add_cascade(label="Font", menu=font_menu)
            
            menubar.add_cascade(label="View", menu=view_menu)
            
            # Tools menu
            tools_menu = tk.Menu(menubar, tearoff=0)
            tools_menu.add_command(label="Word Count", command=self.word_count)
            tools_menu.add_command(label="Character Count", command=self.character_count)
            tools_menu.add_separator()
            tools_menu.add_command(label="Convert to Uppercase", command=self.convert_to_uppercase)
            tools_menu.add_command(label="Convert to Lowercase", command=self.convert_to_lowercase)
            tools_menu.add_command(label="Convert Tabs to Spaces", command=self.convert_tabs_to_spaces)
            menubar.add_cascade(label="Tools", menu=tools_menu)
            
            # Help menu
            help_menu = tk.Menu(menubar, tearoff=0)
            help_menu.add_command(label="About", command=self.show_about)
            help_menu.add_command(label="Keyboard Shortcuts", command=self.show_shortcuts)
            menubar.add_cascade(label="Help", menu=help_menu)
            
            self.rootntpadd.config(menu=menubar)
        
        def create_toolbar(self):
            toolbar_frame = ttk.Frame(self.rootntpadd)
            toolbar_frame.pack(fill=tk.X, padx=5, pady=2)
            
            ttk.Button(toolbar_frame, text="New", command=self.new_file).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Open", command=self.open_file).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Save", command=self.save_file).pack(side=tk.LEFT, padx=2)
            
            ttk.Separator(toolbar_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, padx=5, fill=tk.Y)
            
            ttk.Button(toolbar_frame, text="Cut", command=lambda: self.editor.text.event_generate("<<Cut>>")).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Copy", command=lambda: self.editor.text.event_generate("<<Copy>>")).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Paste", command=lambda: self.editor.text.event_generate("<<Paste>>")).pack(side=tk.LEFT, padx=2)
            
            ttk.Separator(toolbar_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, padx=5, fill=tk.Y)
            
            ttk.Button(toolbar_frame, text="Find", command=self.show_find_dialog).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Word Count", command=self.word_count).pack(side=tk.LEFT, padx=2)
        
        def on_key_release(self, event=None):
            self.update_status_bar()
            self.highlight_current_line()
            
            # Apply syntax highlighting
            if hasattr(self, 'syntax_highlighter') and self.syntax_highlighter.current_lexer:
                self.syntax_highlighter.highlight()
                
            # Mark as modified
            if not self.modified and event and event.char:
                self.modified = True
                self.update_title()
        
        def update_status_bar(self, event=None):
            cursor_position = self.editor.text.index(tk.INSERT)
            line, col = cursor_position.split('.')
            self.status_text.config(text=f"Line: {line}, Col: {col}")
        
        def highlight_current_line(self):
            cursor_position = self.editor.text.index(tk.INSERT)
            line = cursor_position.split('.')[0]
            self.editor.highlight_line(int(line))
        
        def update_title(self):
            filename = os.path.basename(self.current_file) if self.current_file else "Untitled"
            modified_indicator = "*" if self.modified else ""
            self.rootntpadd.title(f"{filename}{modified_indicator} - Advanced Notepad")
        
        def new_file(self, event=None):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to continue?"):
                    return
                    
            self.editor.text.delete('1.0', tk.END)
            self.current_file = None
            self.modified = False
            self.update_title()
            return "break"  # Prevent default behavior
        
        def open_file(self, event=None):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to continue?"):
                    return "break"
                    
            file_path = filedialog.askopenfilename(
                filetypes=[
                    ("All Files", "*.*"),
                    ("Text Files", "*.txt"),
                    ("Python Files", "*.py"),
                    ("HTML Files", "*.html"),
                    ("CSS Files", "*.css"),
                    ("JavaScript Files", "*.js"),
                    ("XML Files", "*.xml"),
                    ("JSON Files", "*.json"),
                    ("Markdown Files", "*.md"),
                ]
            )
            
            if file_path:
                try:
                    with open(file_path, 'r', encoding='utf-8') as file:
                        content = file.read()
                    self.editor.text.delete('1.0', tk.END)
                    self.editor.text.insert('1.0', content)
                    self.current_file = file_path
                    self.modified = False
                    self.update_title()
                    
                    # Detect language based on file extension
                    extension = os.path.splitext(file_path)[1].lower()
                    if extension == '.py':
                        self.set_language('Python')
                    elif extension == '.html':
                        self.set_language('HTML')
                    elif extension == '.css':
                        self.set_language('CSS')
                    elif extension == '.js':
                        self.set_language('JavaScript')
                    elif extension == '.xml':
                        self.set_language('XML')
                    elif extension == '.json':
                        self.set_language('JSON')
                    elif extension == '.md':
                        self.set_language('Markdown')
                        
                except Exception as e:
                    messagebox.showerror("Error", f"Could not open file: {e}")
                    
            return "break"  # Prevent default behavior
        
        def save_file(self, event=None):
            if not self.current_file:
                return self.save_as_file()
                
            try:
                with open(self.current_file, 'w', encoding='utf-8') as file:
                    file.write(self.editor.text.get('1.0', tk.END))
                self.modified = False
                self.update_title()
            except Exception as e:
                messagebox.showerror("Error", f"Could not save file: {e}")
                
            return "break"  # Prevent default behavior
        
        def save_as_file(self):
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[
                    ("All Files", "*.*"),
                    ("Text Files", "*.txt"),
                    ("Python Files", "*.py"),
                    ("HTML Files", "*.html"),
                    ("CSS Files", "*.css"),
                    ("JavaScript Files", "*.js"),
                    ("XML Files", "*.xml"),
                    ("JSON Files", "*.json"),
                    ("Markdown Files", "*.md"),
                ]
            )
            
            if file_path:
                self.current_file = file_path
                self.save_file()
                
                # Detect language based on file extension
                extension = os.path.splitext(file_path)[1].lower()
                if extension == '.py':
                    self.set_language('Python')
                elif extension == '.html':
                    self.set_language('HTML')
                elif extension == '.css':
                    self.set_language('CSS')
                elif extension == '.js':
                    self.set_language('JavaScript')
                elif extension == '.xml':
                    self.set_language('XML')
                elif extension == '.json':
                    self.set_language('JSON')
                elif extension == '.md':
                    self.set_language('Markdown')
                    
            return "break"  # Prevent default behavior
        
        def close_file(self, event=None):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to continue?"):
                    return "break"
                    
            self.editor.text.delete('1.0', tk.END)
            self.current_file = None
            self.modified = False
            self.update_title()
            return "break"  # Prevent default behavior
        
        def exit_app(self):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to exit?"):
                    return
            self.rootntpadd.destroy()
        
        def show_find_dialog(self, event=None):
            FindReplaceDialog(self.rootntpadd, self.editor.text)
            return "break"  # Prevent default behavior
        
        def set_language(self, language):
            language_map = {
                'Python': 'python',
                'Java': 'java',
                'JavaScript': 'javascript',
                'HTML': 'html',
                'CSS': 'css',
                'C': 'c',
                'C++': 'cpp',
                'C#': 'csharp',
                'PHP': 'php',
                'Ruby': 'ruby',
                'SQL': 'sql',
                'XML': 'xml',
                'JSON': 'json',
                'Markdown': 'markdown',
            }
            
            lexer_name = language_map.get(language, language.lower())
            
            if self.syntax_highlighter.set_lexer(lexer_name):
                self.language_label.config(text=language)
                self.syntax_highlighter.highlight()
            else:
                messagebox.showwarning("Language Support", f"Syntax highlighting for {language} is not available.")
        
        def set_theme(self, theme_name):
            self.theme_manager.apply_theme(theme_name)
            # Re-apply syntax highlighting
            self.syntax_highlighter.highlight()
        
        def change_font(self):
            current_font = font.Font(font=self.editor.text['font'])
            font_dialog = tk.Toplevel(self.rootntpadd)
            font_dialog.title("Font Settings")
            font_dialog.geometry("300x200")
            font_dialog.resizable(False, False)
            
            ttk.Label(font_dialog, text="Family:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            
            # Get system fonts
            font_families = sorted(list(font.families()))
            family_var = tk.StringVar(value=current_font.actual()['family'])
            family_combo = ttk.Combobox(font_dialog, textvariable=family_var, values=font_families, width=20)
            family_combo.grid(row=0, column=1, padx=5, pady=5)
            
            ttk.Label(font_dialog, text="Size:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
            size_var = tk.IntVar(value=current_font.actual()['size'])
            size_combo = ttk.Combobox(font_dialog, textvariable=size_var, values=list(range(8, 25)), width=5)
            size_combo.grid(row=1, column=1, padx=5, pady=5, sticky="w")
            
            # Bold and italic checkboxes
            bold_var = tk.BooleanVar(value='bold' in current_font.actual()['weight'])
            italic_var = tk.BooleanVar(value='italic' in current_font.actual()['slant'])
            
            ttk.Checkbutton(font_dialog, text="Bold", variable=bold_var).grid(row=2, column=0, padx=5, pady=5, sticky="w")
            ttk.Checkbutton(font_dialog, text="Italic", variable=italic_var).grid(row=2, column=1, padx=5, pady=5, sticky="w")
            
            # Preview
            preview_frame = ttk.LabelFrame(font_dialog, text="Preview")
            preview_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
            
            preview_text = tk.Text(preview_frame, height=3, width=30)
            preview_text.insert('1.0', "AaBbCcXxYyZz 123456")
            preview_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            def update_preview():
                weight = 'bold' if bold_var.get() else 'normal'
                slant = 'italic' if italic_var.get() else 'roman'
                preview_font = font.Font(family=family_var.get(), size=size_var.get(), weight=weight, slant=slant)
                preview_text.configure(font=preview_font)
                
            family_combo.bind("<<ComboboxSelected>>", lambda e: update_preview())
            size_combo.bind("<<ComboboxSelected>>", lambda e: update_preview())
            bold_var.trace_add("write", lambda *args: update_preview())
            italic_var.trace_add("write", lambda *args: update_preview())
            
            update_preview()  # Initial preview update
            
            def apply_font():
                weight = 'bold' if bold_var.get() else 'normal'
                slant = 'italic' if italic_var.get() else 'roman'
                new_font = font.Font(family=family_var.get(), size=size_var.get(), weight=weight, slant=slant)
                self.editor.text.configure(font=new_font)
                self.editor.line_numbers.configure(font=new_font)
                font_dialog.destroy()
                
            button_frame = ttk.Frame(font_dialog)
            button_frame.grid(row=4, column=0, columnspan=2, padx=5, pady=5)
            
            ttk.Button(button_frame, text="Apply", command=apply_font).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Cancel", command=font_dialog.destroy).pack(side=tk.LEFT, padx=5)
        
        def word_count(self):
            text = self.editor.text.get('1.0', tk.END)
            words = len(text.split())
            lines = len(text.splitlines())
            chars = len(text)
            messagebox.showinfo("Statistics", f"Words: {words}\nLines: {lines}\nCharacters: {chars}")
        
        def character_count(self):
            text = self.editor.text.get('1.0', tk.END)
            chars = len(text) - 1  # Subtract one for the final newline
            chars_no_spaces = len(text.replace(" ", "").replace("\n", "").replace("\t", ""))
            messagebox.showinfo("Character Count", f"Characters (with spaces): {chars}\nCharacters (without spaces): {chars_no_spaces}")
        
        def convert_to_uppercase(self):
            try:
                if self.editor.text.tag_ranges(tk.SEL):
                    selected_text = self.editor.text.get(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.delete(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.insert(tk.INSERT, selected_text.upper())
            except tk.TclError:
                # No selection, convert all text
                text = self.editor.text.get('1.0', tk.END)
                self.editor.text.delete('1.0', tk.END)
                self.editor.text.insert('1.0', text.upper())
        
        def convert_to_lowercase(self):
            try:
                if self.editor.text.tag_ranges(tk.SEL):
                    selected_text = self.editor.text.get(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.delete(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.insert(tk.INSERT, selected_text.lower())
            except tk.TclError:
                # No selection, convert all text
                text = self.editor.text.get('1.0', tk.END)
                self.editor.text.delete('1.0', tk.END)
                self.editor.text.insert('1.0', text.lower())
        
        def convert_tabs_to_spaces(self):
            text = self.editor.text.get('1.0', tk.END)
            text = text.replace("\t", "    ")  # Replace tabs with 4 spaces
            self.editor.text.delete('1.0', tk.END)
            self.editor.text.insert('1.0', text)
        
        def show_about(self):
            about_dialog = tk.Toplevel(self.rootntpadd)
            about_dialog.title("About Advanced Notepad")
            about_dialog.geometry("400x300")
            about_dialog.resizable(False, False)
            
            about_text = """Advanced Notepad

    Version 1.0

    Features:
    - Syntax highlighting for multiple languages
    - Line numbering
    - Multiple themes
    - Find and replace with regex support
    - Code folding
    - And more!

    """
            
            ttk.Label(about_dialog, text=about_text, justify=tk.CENTER, wraplength=380).pack(expand=True, fill=tk.BOTH, padx=10, pady=10)
            ttk.Button(about_dialog, text="Close", command=about_dialog.destroy).pack(pady=10)
        
        def show_shortcuts(self):
            shortcuts_dialog = tk.Toplevel(self.rootntpadd)
            shortcuts_dialog.title("Keyboard Shortcuts")
            shortcuts_dialog.geometry("400x400")
            
            shortcuts_text = """
    Keyboard Shortcuts:

    File Operations:
      Ctrl+N     New File
      Ctrl+O     Open File
      Ctrl+S     Save File
      Ctrl+W     Close File

    Edit Operations:
      Ctrl+Z     Undo
      Ctrl+Y     Redo
      Ctrl+X     Cut
      Ctrl+C     Copy
      Ctrl+V     Paste
      Ctrl+A     Select All
      Ctrl+F     Find/Replace

    Navigation:
      Home       Start of Line
      End        End of Line
      Ctrl+Home  Start of Document
      Ctrl+End   End of Document
      Ctrl+G     Go to Line
    """
            
            shortcuts_frame = ttk.Frame(shortcuts_dialog)
            shortcuts_frame.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)
            
            shortcuts_text_widget = tk.Text(shortcuts_frame, wrap=tk.WORD, height=20, width=40)
            shortcuts_text_widget.insert('1.0', shortcuts_text)
            shortcuts_text_widget.config(state=tk.DISABLED)
            shortcuts_text_widget.pack(expand=True, fill=tk.BOTH)
            
            ttk.Button(shortcuts_dialog, text="Close", command=shortcuts_dialog.destroy).pack(pady=10)


    if __name__ == "__main__":
        rootntpadd = tk.Tk()
        app = AdvancedNotepad(rootntpadd)
        rootntpadd.mainloop()

if paintvar == 22:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    def OpenPaint():
        from tkinter import filedialog, messagebox, colorchooser
        import PIL.ImageGrab as ImageGrab
        from PIL import Image, ImageDraw
        import PIL
        global color, image, draw  # adăugăm variabilele globale pentru imagine și obiectul draw
        color = 'black'
        Width = 600
        Height = 440

        rootpnt = Tk()

        def save():
            filename = filedialog.asksaveasfilename(initialfile="untitled.png", defaultextension=".png",
                                                    filetypes=[("PNG files", "*.png"), ("All files", "*.*")])
            if filename:
                image.save(filename)

        def change_color(c):
            global color
            color = c

        def pick_color():
            global color
            picked = colorchooser.askcolor()
            if picked[1]:
                color = picked[1]

        def drawing(event):
            x1, y1 = (event.x - 1), (event.y - 1)
            x2, y2 = (event.x + 1), (event.y + 1)
            canvas.create_oval((x1, y1, x2, y2), fill=color, outline=color, width=vertical.get())
            draw.ellipse([x1, y1, x2 + vertical.get(), y2 + vertical.get()], outline=color, fill=color)

        def on_closing():
            answer = messagebox.askyesnocancel("QUIT", "DO YOU WANT TO SAVE YOUR WORK?", parent=rootpnt)
            if answer is not None:
                if answer:
                    save()
                rootpnt.destroy()

        def new_canvas():
            canvas.delete('all')
            draw.rectangle([0, 0, Width, Height], fill='white')

        rootpnt.title("Paint")
        rootpnt.geometry('600x550')
        rootpnt.resizable(False, False)
        rootpnt.configure(bg='black')
        rootpnt.protocol("WM_DELETE_WINDOW", on_closing)

        frame = Frame(rootpnt, bg='white')
        color_frame = Frame(frame, bg='black', borderwidth=10)

        menu_bar = Menu(rootpnt)
        rootpnt.config(menu=menu_bar)
        submenu = Menu(menu_bar, tearoff=0)

        menu_bar.add_cascade(label='File', menu=submenu)
        submenu.add_command(label='New Canvas', command=new_canvas)
        submenu.add_command(label='Save', command=save)

        colors = ['black', 'grey', 'brown', 'orange', 'yellow', 'red', 'green', 'turquoise', 'indigo', 'purple', 'blue',
                  'white', 'lime', 'pink', 'gold', 'cyan']
        buttons = []

        for i, col in enumerate(colors):
            button = Button(color_frame, bg=col, width=1, command=lambda col=col: change_color(col))
            buttons.append(button)
            button.grid(row=i // 11, column=i % 11)

        vertical = Scale(frame, from_=1, to=25, label='Size')
        vertical.set(3)

        erase_but = Button(frame, text='Erase', command=lambda: change_color('white'))
        color_but = Button(frame, text='Color', command=pick_color)

        canvas = Canvas(rootpnt, bg='white', width=Width, height=Height)
        canvas.bind('<B1-Motion>', drawing)

        image = Image.new("RGB", (Width, Height), 'white')  # Inițializăm imaginea cu fundal alb
        draw = ImageDraw.Draw(image)

        frame.grid(row=0, column=0, sticky='nsew')
        color_frame.grid(row=0, column=0, padx=20)
        vertical.grid(row=0, column=1)
        erase_but.grid(row=0, column=2, padx=20)
        color_but.grid(row=0, column=3)

        canvas.grid(row=1, column=0)

        # Centralize Window
        rootpnt.update()
        window_width = rootpnt.winfo_width()
        window_height = rootpnt.winfo_height()
        screen_width = rootpnt.winfo_screenwidth()
        screen_height = rootpnt.winfo_screenheight()
        x = int((screen_width / 2) - (window_width / 2))
        y = int((screen_height / 2) - (window_height / 2))
        rootpnt.geometry(f"{window_width}x{window_height}+{x}+{y}")

        rootpnt.mainloop()
    OpenPaint()

if Adm1var == 30:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    import tkinter as tk
    from tkinter import ttk
    import platform
    import os
    import sys
    import re
    import keyword
    import platform
    import subprocess
    import tkinter as tk
    from tkinter import ttk
    from tkinter import font
    import importlib
    import tkinter as tk
    from tkinter import ttk
    from tkinter import filedialog
    import keyword
    import os
    import gc
    import webbrowser
    import subprocess

    import tkinter as tk
    from tkinter import ttk, filedialog
    import platform
    import os
    from os.path import expanduser
    import shutil
    import sys
    import subprocess

    import tkinter as tk
    from tkinter import ttk
    import tkinter.scrolledtext as tkst
    import configparser
    import os
    import sys 

    # configuration.py

    import configparser
    import os
    import sys
    import configparser
    import os

    def create_default_ini_file(file_path):
        if not os.path.exists(file_path):
            mopad_ini_content = """
    [Run]
    mate = mate-terminal -x sh -c "python3 {}; exec bash"
    gnome = gnome-terminal -- sh -c "python3 {}; exec bash"
    kde = konsole --hold -e "python3 {}"
    xterm = xterm -hold -e "python3 {}"
    windows = start cmd /K python {}
    mac = open -a Terminal ./python3 {}

    [Terminal]
    mate = mate-terminal
    gnome = gnome-terminal
    kde = konsole
    xterm = xterm
    windows = start cmd
    mac = open -a Terminal ./

    [Interpreter]
    mate = mate-terminal -x "python3"
    gnome = gnome-terminal -- "python3"
    kde = konsole -e python3
    xterm = xterm python3
    windows = start cmd /K python
    mac = open -a Terminal ./python3

    [System]
    system = windows

    [Password]
    password = 
    """
            with open(file_path, 'w') as config_file:
                config_file.write(mopad_ini_content)

    # Verifică și creează fișierul ini implicit dacă nu există
    create_default_ini_file('mopad.ini')

    # Continuă cu citirea și procesarea configurației din fișierul ini
    config = configparser.ConfigParser()
    config.read('mopad.ini')

    # Extrage și procesează configurația așa cum ai făcut anterior
    # (Exemplu de utilizare config)
    current_system = config['System'].get('system', 'windows')
    print(f"Sistemul actual: {current_system}")

    class Configuration():
        
        def __init__(self):
            
            self.config = configparser.ConfigParser()
            file = self.getDir()
            
            self.config.read(file)
            
        def getDir(self):
            path = os.path.realpath(__file__)      # Pfad ermitteln
            
            basename = self.checkPath(os.path.dirname(path))
            path = basename + '/mopad.ini'
            
            return path
            
        def getRun(self, system):
            return self.config['Run'][system]
        
        def getTerminal(self, system):
            return self.config['Terminal'][system]
        
        def getInterpreter(self, system):
            return self.config['Interpreter'][system]
        
        def getSystem(self):
            return self.config['System']['system']
        
        def getTab(self):
            return self.config['Tab']['tab']
        
        def getFontSize(self):
            return self.config['Size']['size']
        
        def setSystem(self, system):
            self.config['System']['system'] = system

            path = os.path.realpath(__file__)    
            basename = self.checkPath(os.path.dirname(path))

            iniPath = basename + "/mopad.ini"
            
            with open(iniPath, 'w') as f:
                self.config.write(f)

        def setStandard(self):
            config = configparser.ConfigParser()
            
            config['Run'] = {}
            config['Run']['mate'] = 'mate-terminal -x sh -c "python3 {}; exec bash"'
            config['Run']['gnome'] = 'gnome-terminal -- sh -c "python3 {}; exec bash"'
            config['Run']['kde'] = 'konsole --hold -e "python3 {}"'
            config['Run']['xterm'] = 'xterm -hold -e "python3 {}"'
            config['Run']['windows'] = 'start cmd /K python {}'
            config['Run']['mac'] = 'open -a Terminal ./python3 {}'
            
            config['Terminal'] = {}
            config['Terminal']['mate'] = 'mate-terminal'
            config['Terminal']['gnome'] = 'gnome-terminal'
            config['Terminal']['kde'] = 'konsole'
            config['Terminal']['xterm'] = 'xterm'
            config['Terminal']['windows'] = 'start cmd'
            config['Terminal']['mac'] = 'open -a Terminal ./' 
            
            config['Interpreter'] = {}
            config['Interpreter']['mate'] = 'mate-terminal -x "python3"'
            config['Interpreter']['gnome'] = 'gnome-terminal -- "python3"'
            config['Interpreter']['kde'] = 'konsole -e python3'
            config['Interpreter']['xterm'] = 'xterm python3'
            config['Interpreter']['windows'] = 'start cmd /K python'
            config['Interpreter']['mac'] = 'open -a Terminal ./python3'
            
            config['System'] = {}
            config['System']['system'] = ''
            
            config['Tab'] = {}
            config['Tab']['tab'] = '4'
            
            config['Size'] = {}
            config['Size']['size'] = '13'
            
            return config


        def checkPath(self, path):
            if '\\' in path:
                path = path.replace('\\', '/')
            return path


    #if __name__ == '__main__':
    c = Configuration()

    system = c.getSystem()
    runCommand = c.getRun(system)
    terminalCommand = c.getTerminal(system)
    interpreterCommand = c.getInterpreter(system)
        
    #c.setSystem('gnome')  
     
    print(system + ':\n' + runCommand + '\n' + terminalCommand + '\n' + interpreterCommand) 
        



    class TextLineNumbers(tk.Canvas):
        '''
            Canvas for Linenumbers
        '''
        def __init__(self, *args, **kwargs):
            tk.Canvas.__init__(self, *args, **kwargs)
            self.textwidget = None
            self.font_size = 14
            self.configFont()

            
        def configFont(self):
            '''font for linenumbers'''
            system = platform.system().lower()
            if system == "windows":
                self.font = font.Font(family='monospace', size=self.font_size)
            elif system == "linux":
                self.font = font.Font(family='monospace', size=self.font_size)
            else:
                self.font = font.Font(family='monospace', size=self.font_size)


        def attach(self, text_widget):
            self.textwidget = text_widget

        def redraw(self, *args):
            '''redraw line numbers'''
            self.delete("all")

            i = self.textwidget.index("@0,0")
            while True :
                dline= self.textwidget.dlineinfo(i)
                if dline is None: break
                y = dline[1]
                linenum = str(i).split(".")[0]
                self.create_text(1,y,anchor="nw", font=self.font, text=linenum, fill='white')
                i = self.textwidget.index("%s+1line" % i)
            

    class CodeEditor(tk.Text):
        
        '''
            modified text Widget ... thanks to stackoverflow.com :)
        '''
        def __init__(self, *args, **kwargs):
            tk.Text.__init__(self, *args, **kwargs)
            
            self.tk.eval('''
                proc widget_proxy {widget widget_command args} {

                    # call the real tk widget command with the real args
                    set result [uplevel [linsert $args 0 $widget_command]]

                    # generate the event for certain types of commands
                    if {([lindex $args 0] in {insert replace delete}) ||
                        ([lrange $args 0 2] == {mark set insert}) || 
                        ([lrange $args 0 1] == {xview moveto}) ||
                        ([lrange $args 0 1] == {xview scroll}) ||
                        ([lrange $args 0 1] == {yview moveto}) ||
                        ([lrange $args 0 1] == {yview scroll})} {

                        event generate  $widget <<Change>> -when tail
                    }

                    # return the result from the real widget command
                    return $result
                }
                ''')
            self.tk.eval('''
                rename {widget} _{widget}
                interp alias {{}} ::{widget} {{}} widget_proxy {widget} _{widget}
            '''.format(widget=str(self)))
            
            # global variables
            self.filename = None
            self.tab_width = 4
            self.font_size = 14
            self.linenumber = None
            
            # make background black / foreground white
            self.config(insertbackground='#00FF00')
            self.config(background='#000000')
            self.config(foreground='#FFFFFF')
            
            # color when selection is used
            self.tag_config("sel", background="#053582", foreground="white")
            
            # config font
            self.configFont()

            # define keywords: thanks to github.comm
            # see Dvlv/Tkinter-By-Example
            self.KEYWORDS_1 = ["False", "class", "finally", "is",
                               "None", "continue", "lambda", "True", "def", "from",
                               "nonlocal", "and", "del", "global", "not", "as", 
                               "or", "yield", "assert", "import", "pass", "break",
                               "raise"]
            self.KEYWORDS_FLOW = ["if", "else", "elif", "try", "except", "for",\
                                  "in", "while", "return", "with"]

            self.SPACES_REGEX = re.compile("^\s*")
            self.STRING_REGEX_SINGLE = re.compile("'[^'\r\n]*'")
            self.STRING_REGEX_DOUBLE = re.compile('"[^"\r\n]*"')
            self.NUMBER_REGEX = re.compile(r"\b(?=\(*)\d+\.?\d*(?=\)*\,*)\b")
            self.KEYWORDS_REGEX = re.compile("(?=\(*)(?<![a-z])(None|True|False)(?=\)*\,*)")
            self.SELF_REGEX = re.compile("(?=\(*)(?<![a-z])(self)(?=\)*\,*)")
            self.FUNCTIONS_REGEX = re.compile("(?=\(*)(?<![a-z])(print|list|dict|set|int|str|float|input|range|open|tuple)(?=\()")
            self.COMMENTS_REGEX = re.compile("#[^#\r\n]*")
            
            self.REGEX_TO_TAG = {
                self.STRING_REGEX_SINGLE : "string",
                self.STRING_REGEX_DOUBLE : "string",
                self.NUMBER_REGEX : "digit",
                self.KEYWORDS_REGEX : "keywordcaps",
                self.SELF_REGEX : "keyword1",
                self.FUNCTIONS_REGEX : "keywordfunc",
                self.COMMENTS_REGEX : "comment",
            }

            self.tag_config("keyword1", foreground="#448dc4")   
            self.tag_config("keywordcaps", foreground="#CC7A00")
            self.tag_config("keywordflow", foreground="#00b402")
            self.tag_config("keywordfunc", foreground="#ddd313")
            self.tag_config("decorator", foreground="#298fb5")
            self.tag_config("digit", foreground="#ff4d4d")
            self.tag_config("string", foreground="#8e98a1")
            self.tag_config("comment", foreground="#6b6b6b")
            
            # key bindings: 
            self.bind("<KeyRelease>", self.on_key_release, add='+')
            self.bind('<KeyRelease>', self.checkBraces, add='+')
            self.bind("<Tab>", self.tab)
            self.bind('<Return>', self.indent, add='+')
            self.bind('<Return>', self.updateAutoCompleteList, add='+')
            self.bind('<Key>', self.updateAutocompleteEntry, add='+')
            self.bind('<BackSpace>', self.backtab)
            self.bind("<ButtonRelease-3>", self.textPadPopUp)
            self.bind('<Control-x>', self.cut)
            self.bind('<Control-c>', self.copy)
            self.bind('<Control-v>', self.paste)
            
            # set autocompleteList
            self.SetAutoCompleteList()
            
            # other importan variables
            self.charstring = ''
            self.list = []

        
        def tag_keywords(self, event=None, current_index=None):
            if not current_index:
                current_index = self.index(tk.INSERT)
            line_number = current_index.split(".")[0]
            line_beginning = ".".join([line_number, "0"])
            line_text = self.get(line_beginning, line_beginning + " lineend")
            line_words = line_text.split()
            number_of_spaces = self.number_of_leading_spaces(line_text)
            y_position = number_of_spaces

            for tag in self.tag_names():
                self.tag_remove(tag, line_beginning, line_beginning + " lineend")

            self.add_regex_tags(line_number, line_text)

            for word in line_words:
                stripped_word = word.strip("():,")

                word_start = str(y_position)
                word_end = str(y_position + len(stripped_word))
                start_index = ".".join([line_number, word_start])
                end_index = ".".join([line_number, word_end])

                if stripped_word in self.KEYWORDS_1:
                    self.tag_add("keyword1", start_index, end_index)
                elif stripped_word in self.KEYWORDS_FLOW:
                    self.tag_add("keywordflow", start_index, end_index)
                elif stripped_word.startswith("@"):
                    self.tag_add("decorator", start_index, end_index)

                y_position += len(word) + 1

        def tag_all_lines(self):
            final_index = self.index(tk.END)
            final_line_number = int(final_index.split(".")[0])
            
            for line_number in range(final_line_number):
                line_to_tag = ".".join([str(line_number), "0"])
                self.tag_keywords(None, line_to_tag)


        def number_of_leading_spaces(self, line):
            spaces = re.search(self.SPACES_REGEX, line)
            if spaces.group(0) is not None:
                number_of_spaces = len(spaces.group(0))
            else:
                number_of_spaces = 0

            return number_of_spaces

        def add_regex_tags(self, line_number, line_text):
            for regex, tag in self.REGEX_TO_TAG.items():
                for match in regex.finditer(line_text):
                    start, end = match.span()
                    start_index = ".".join([line_number, str(start)])
                    end_index = ".".join([line_number, str(end)])
                    self.tag_add(tag, start_index, end_index)

        def on_key_release(self, event=None):
            #print(event.keysym)
            if event.keysym in ("Up", "Down", "Left", "Right", "Shift_L", "Shift_R"):
                return
            else:
                self.tag_keywords()
            
            # look for colon in last line 
            if event.keysym == 'Return':
                index = self.index(tk.INSERT).split(".")
                actual_line = int(index[0])
                actual_line = self.get("%d.%d" % (actual_line, 0), "%d.end" % (actual_line))
                last_line = int(index[0]) - 1
                last_line_text = self.get("%d.%d" % (last_line, 0), "%d.end" % (last_line))
                
                # remove newline character to look after colon at end of line
                last_line_text = last_line_text.rstrip()
                # look if actual_line is only whitespace:
                actual_line = actual_line.strip(' \n')
                if last_line_text.endswith(':') and actual_line == '':
                    self.insert(tk.INSERT, self.tab_width * ' ')

        # functions for autocomplete
        def SetAutoCompleteList(self):
            '''
                basic autocompleteList with keywords and some important things (for me)
            '''
            
            self.autocompleteList = ['__init__', '__main__','__name__', '__repr__', '__str__',
                    '__dict__', 'args', 'kwargs', "self", "__file__", 'super()'] # autocomplete

            self.kwList = keyword.kwlist
            for item in self.kwList:
                self.autocompleteList.append(item)

        def updateAutoCompleteList(self, event=None):
            '''
                a simple algorithm for parsing the given text and filter important words
            '''
            self.SetAutoCompleteList()
                
            first_list = []
            second_list = []
            
            text = self.get(1.0, tk.END)
            text = text.replace("(", " ").replace(")", " ").replace\
                            ("[", " ").replace("]", " ").replace\
                            (':', " ").replace(',', " ").replace("<", " ").replace\
                            (">", " ").replace("/", " ").replace("=", " ").replace\
                            (";", " ").replace("self.", "").replace('.', ' ')
            
            first_list = text.split('\n')
            
            for row in first_list:
                if row.startswith('import '):
                    try:
                        # try to import global variables from import 
                        # -> this could be made better ... :)
                        module_name = row.replace('import' , ' ')
                        module_name = module_name.split()[0]
                        
                        module = importlib.import_module(module_name, package=None)
                        x = dir(module)

                        for elem in x:
                            if elem.startswith('_'):
                                continue
                            else:
                                second_list.append(elem)
                    
                    except Exception as e:
                        #print(str(e))
                        continue
                            
                elif row.strip().startswith('#') or row.strip().startswith('"""') or\
                   row.strip().startswith("'''"):
                    continue
                else:
                    word_list = row.split()
                    for word in word_list:
                        if re.match("(^[0-9])", word):
                            continue
                        elif '#' in word:
                            continue
                        elif word in self.kwList:
                            continue
                        elif word in self.autocompleteList:
                            continue
                        elif not len(word) < 3:
                            w = re.sub("{}<>;,:]", '', word)
                            second_list.append(w)
            
            # delete doubled entries ...
            x = set(second_list)
            second_list = list(x)

            for word in second_list:
                if len(word) > 25:
                    continue
                self.autocompleteList.append(word)
            #print()
            #print(self.autocompleteList)
            return


        def updateAutocompleteEntry(self, event=None):
            '''
                make new list for the input from the user
            '''
            char = event.char
            key = event.keycode
            sym = event.keysym
            
            # debugging ... :)
            #print(char)
            #print(key)
            
            self.list = []
            if sym in ("Up", "Down", "Left", "Right", "Space", \
                                "Control_R", "Control_L", "Alt_R", "Alt_L", \
                                "Backtab", "Return"):
                
                # set label and variables to none
                self.entry.config(text='---')
                self.list = []
                self.charstring = ''
            
            elif char in [".", "(", ")", '"', "'", ",", "="]:
                self.entry.config(text='---')
                self.list = []
                self.charstring = ''
            
            else:
                self.charstring += char
                for item in self.autocompleteList:
                    if item.startswith(self.charstring):
                        self.list.append(item)
                
                
                if self.list and len(self.charstring)>=2:
                    self.entry.config(text=self.list[0])                            
                else:
                    self.entry.config(text='---')

                if len(self.list) == 3:
                    self.entry.config(text=self.list[0])
                                


        def configFont(self):
            '''
                set the font .... tested only in windows .. if you want to make it cross platform
            '''
            system = platform.system().lower()
            if system == "windows":
                self.font = font.Font(family='Consolas', size=self.font_size)
                self.configure(font=self.font)
            elif system == "linux":
                self.font = font.Font(family='Mono', size=self.font_size)
                self.configure(font=self.font)

        def tab(self, event):
            '''
                make tab(4 * whitespaces) or insert autocomplete when using tab
            '''
            if not self.list:
                self.insert(tk.INSERT, " " * self.tab_width)
            else:
                l = len(self.charstring)
                x, y = self.index(tk.INSERT).split(".")
                y2 = int(y) - l
                y2 = str(y2)
                pos = x + '.' + y2
                self.mark_set('insert', pos)
                self.tag_add("sel", pos, '%d.%d' % (int(x), int(y)))
                self.insert(tk.INSERT, self.list[0])
                if self.tag_ranges("sel"):      # test if selection...
                    self.delete('sel.first', 'sel.last')
                
            self.charstring == ''
            self.entry.config(text='---')
            self.list = []
            
            return 'break'

        def backtab(self, event):
            '''
                make backtab when using backspace
            '''
            self.entry.config(text='---')
            self.list = []
            self.charstring = ''

            chars = self.get("insert linestart", 'insert')
            if not self.tag_ranges("sel"):
                if chars.isspace():     # only if there are whitespaces !
                    if len(chars) >= 4:
                        self.delete("insert-4c", "insert")
                        return 'break'

        def indent(self, event=None):
            '''
                make indent
            '''
            self.entry.config(text='---')
            self.list = []
            self.charstring = ''
            
            index = self.index(tk.INSERT).split(".")
            line_no = int(index[0])
            # position cursor:
            pos = int(index[1])
            
            
            self.updateAutoCompleteList()
            
            if pos == 0:
                return
            
            line_text = self.get("%d.%d" % (line_no, 0),  "%d.end" % (line_no))
            text_only = line_text.lstrip(" ")
            no_of_spaces = len(line_text) - len(text_only)
            
            # if enter was hit in a row that has leading spaces and spaces between
            # cursor and text 
            line_text_cursor = self.get("%d.%d" % (line_no, pos), "%d.end" % (line_no))
            spaces_betweeen = line_text_cursor.lstrip(" ")
            spaces_betweeen = spaces_betweeen.rstrip(" ")
            leading_spaces = len(line_text_cursor) - len(spaces_betweeen)
            #print(leading_spaces)
            
            # if so: delete them for a nice editing feeling
            if leading_spaces:
                no_of_spaces -= leading_spaces

            spaces = '\n' + " " * no_of_spaces
            
            self.insert(tk.INSERT, spaces)
            self.see(self.index(tk.INSERT)) 
            
            # on Return ends:
            return 'break'

        def checkBraces(self, event=None):
            'check braces, paren, brackets '
            key = event.keycode
            sym = event.keysym
            
            line = int(self.index(tk.INSERT).split('.')[0])
            line_text = self.get("%d.%d" % (line, 0), "%d.end" % (line))
            
            self.tag_configure("braceHighlight", foreground="red")
            self.tag_configure('parenHighlight', foreground='red')
            self.tag_configure('bracketHighlight', foreground='red')
            
            # paren ()
            if sym == 'parenleft':
                x = self.isBalancedParen(line_text)
                if x == False:
                    z = line_text.rfind('(')
                else:
                    z = False
                
                if z:
                    self.tag_add("parenHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('parenHighlight', "%d.0"%(line), '%d.end'%(line))
            
            elif sym == 'parenright':
                x = self.isBalancedParen(line_text)
                if x == False:
                    z = line_text.rfind(')')
                else:
                    z = False
                
                if z:
                    self.tag_add("parenHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('parenHighlight', "%d.0"%(line), '%d.end'%(line))
            
            # bracket []
            elif sym == 'bracketleft':
                x = self.isBalancedBracket(line_text)
                if x == False:
                    z = line_text.rfind('[')
                else:
                    z = False
                
                if z:
                    self.tag_add("bracketHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('bracketHighlight', "%d.0"%(line), '%d.end'%(line))
            
            elif sym == 'bracketright':
                x = self.isBalancedBracket(line_text)
                if x == False:
                    z = line_text.rfind(']')
                else:
                    z = False
                
                if z:
                    self.tag_add("bracketHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('bracketHighlight', "%d.0"%(line), '%d.end'%(line))
            
            # brace {}
            elif sym == 'braceleft':
                x = self.isBalancedBrace(line_text)
                if x == False:
                    z = line_text.rfind('{')
                else:
                    z = False
                
                if z:
                    self.tag_add("braceHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('braceHighlight', "%d.0"%(line), '%d.end'%(line))
            
            elif sym == 'braceright':
                x = self.isBalancedBrace(line_text)
                if x == False:
                    z = line_text.rfind('}')
                else:
                    z = False
                
                if z:
                    self.tag_add("braceHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('braceHighlight', "%d.0"%(line), '%d.end'%(line))


            else:
                return

        def isBalancedParen(self, txt):
            braced = 0
            for ch in txt:
                if ch == '(': braced += 1
                if ch == ')':
                    braced -= 1
                    if braced < 0: return False
            return braced == 0

        def isBalancedBracket(self, txt):
            braced = 0
            for ch in txt:
                if ch == '[': braced += 1
                if ch == ']':
                    braced -= 1
                    if braced < 0: return False
            return braced == 0

        def isBalancedBrace(self, txt):
            braced = 0
            for ch in txt:
                if ch == '{': braced += 1
                if ch == '}':
                    braced -= 1
                    if braced < 0: return False
            return braced == 0

        def textPadPopUp(self, event):
            menu = tk.Menu(self, tearoff=False, background='#000000',foreground='white',
                    activebackground='blue', activeforeground='white')
            menu.add_command(label="Undo", compound=tk.LEFT, command=self.undo)
            menu.add_command(label="Redo", compound=tk.LEFT, command=self.redo)
            menu.add_separator()
            menu.add_command(label='Cut', compound=tk.LEFT, command=self.cut)
            menu.add_command(label="Copy", compound=tk.LEFT, command=self.copy)
            menu.add_command(label="Paste", compound=tk.LEFT, command=self.paste)
            menu.add_separator()
            menu.add_command(label="Select All", compound=tk.LEFT, command=self.selectAll)
            menu.add_separator()
            menu.add_command(label="Open Terminal", compound=tk.LEFT, command = self.terminal)
            menu.tk_popup(event.x_root, event.y_root, 0)
        
        def undo(self, event=None):
            try:
                self.edit_undo()
                self.highlightAll()
            except:
                return
        
        def redo(self, event=None):
            try:
                self.edit_redo()
                self.highlightAll()
            except:
                return
        
        def cut(self, event=None):
            self.event_generate("<<Cut>>")
            self.tag_keywords()
            return 'break'
        
        def copy(self, event=None):
            self.event_generate("<<Copy>>")
            self.tag_keywords()
            return 'break'
            
        def paste(self, event=None):
            self.event_generate("<<Paste>>")
            #self.tag_keywords()
            self.highlightAll()
            return 'break'
        
        def selectAll(self, event=None):
            self.tag_add('sel', '1.0', 'end')
        
        def goto(self, event=None):
            pass
        
        def terminal(self, event=None):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            terminalCommand = c.getTerminal(system)
            
            subprocess.call(terminalCommand, shell=True)
        
        def highlightAll(self):
            final_index = self.index(tk.END)
            final_line_number = int(final_index.split(".")[0])

            for line_number in range(final_line_number):
                line_to_tag = ".".join([str(line_number), "0"])
                self.tag_keywords(None, line_to_tag)



    class CodeeditorFrame(ttk.Frame):
        '''
            Codeeditor + Linenumber Frame
        '''

        def __init__(self, master=None):
            super().__init__(master)
            self.pack(expand=True, fill=tk.BOTH)
            self.initUI()

        def initUI(self):
            
            # frame1
            frame1 = ttk.Frame(self)
            frame1.pack(fill=tk.BOTH, expand=True)
            
            # autocompleteEntry (packed on bottom)
            self.autocompleteEntry = ttk.Label(frame1, text='---', font=('Mono', 14))
            self.autocompleteEntry.pack(side='bottom', fill='y')
            
            # scrollbar y
            textScrollY = ttk.Scrollbar(frame1, orient=tk.VERTICAL)
            textScrollY.config(cursor="double_arrow")
            textScrollY.pack(side=tk.RIGHT, fill=tk.Y)
            
            # in tkinter it is important what to pack first (!)
            self.linenumber = TextLineNumbers(frame1, width=45, bg='#000000')
            self.linenumber.pack(side="left", fill="y")
            
            # scrollbar x (packed on bottom)
            textScrollX = ttk.Scrollbar(frame1, orient=tk.HORIZONTAL)
            textScrollX.config(cursor="sb_h_double_arrow")
            textScrollX.pack(side=tk.BOTTOM, fill=tk.X)

            self.textPad = CodeEditor(frame1, undo=True, maxundo=-1, 
                                      autoseparators=True, wrap='none')
            self.textPad.filename = None
            self.textPad.pack(side=tk.TOP, expand=True, fill=tk.BOTH)

            textScrollY.config(command=self.textPad.yview)
            textScrollX.config(command=self.textPad.xview)
            self.textPad.configure(yscrollcommand=textScrollY.set)
            self.textPad.configure(xscrollcommand=textScrollX.set)
            self.linenumber.attach(self.textPad)


            self.textPad.entry = self.autocompleteEntry
            self.textPad.linenumber = self.linenumber
            
            self.textPad.bind("<<Change>>", self.on_change)
            self.textPad.bind("<Configure>", self.on_change)


        def on_change(self, event):
            self.linenumber.redraw()


    #if __name__ == '__main__':
    root = tk.Tk()
    root['bg'] = 'black'
        
    app = CodeeditorFrame()
        
    app.mainloop()
        

    class Dialog(tk.Toplevel):

        def __init__(self, parent, title=None):

            super().__init__(parent)
            self.transient(parent)

            if title:
                self.title(title)

            self.parent = parent

            self.result = None

            body = ttk.Frame(self)
            self.initial_focus = self.body(body)
            body.pack(padx=5, pady=5)

            self.buttonbox()


            if not self.initial_focus:
                self.initial_focus = self

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

            self.initial_focus.focus_set()
            
            # make background black 
            self.configure(bg='#000000')
            
            # no borders ?
            #self.overrideredirect(1)
            
            self.wait_window(self)


        def body(self, master):
            # create dialog body.  return widget that should have
            # initial focus.  this method should be overridden
            pass

        def buttonbox(self):
            # add standard button box. override if you don't want the
            # standard buttons

            box = ttk.Frame(self)
            #box.configure(bg='black')
            
            w = ttk.Button(box, text="OK", width=10, command=self.ok, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            w = ttk.Button(box, text="Cancel", width=10, command=self.cancel)
            w.pack(side=tk.LEFT, padx=5, pady=5)

            #self.bind("<Return>", self.ok)
            #self.bind("<Escape>", self.cancel)

            box.pack()

        def ok(self, event=None):

            if not self.validate():
                self.initial_focus.focus_set() # put focus back
                return

            self.withdraw()
            self.update_idletasks()

            self.apply()

            self.cancel()

        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

        def validate(self):

            return 1 # override

        def apply(self):

            pass # override

        def CheckPath(self, path):
            if '\\' in path:
                path = path.replace('\\', '/')
            return path

    #########################################################
    class NewDirectoryDialog(Dialog):
        
        def body(self, master):
            # get configuration 
            
            # make body
            ttk.Label(master, text="Name of directory:").grid(row=0)
            
            self.e1 = tk.Entry(master)
            self.e1 = tk.Entry(master, bg='black', fg='white')
            self.e1.configure(cursor="xterm green")
            self.e1.configure(insertbackground = "red")
            self.e1.configure(highlightcolor='#448dc4')
            self.e1.grid(row=0, column=1, sticky='nsew')
            
            return self.e1 # initial focus

        def apply(self):
            name = self.e1.get()
            dir = self.CheckPath(os.getcwd())
            dir += '/' + name
            os.mkdir(dir)




    ############################################################

    class RenameDialog(Dialog):
        
        def __init__(self, parent, title=None, item=None):
            self.item = item
            super().__init__(parent, title)
        
        def body(self, master):

            # make body
            ttk.Label(master, text='Current name: ').grid(row=1, column=0)
            ttk.Label(master, text=self.item).grid(row=1, column=1)
            ttk.Label(master, text="New name: ").grid(row=2)
            
            self.e1 = tk.Entry(master)
            self.e1 = tk.Entry(master, bg='black', fg='white')
            self.e1.configure(cursor="xterm green")
            self.e1.configure(insertbackground = "red")
            self.e1.configure(highlightcolor='#448dc4')
            self.e1.grid(row=2, column=1, sticky='nsew')
            
            return self.e1 # initial focus

        def apply(self):
            self.result = 1
            lastName = self.getLastName(self.item)
            cwd = self.CheckPath(os.getcwd()) + '/'
            
            oldFullPath = cwd + lastName 
            
            new = self.e1.get()
            
            newFullPath = cwd + new
            
            try:
                os.rename(oldFullPath, newFullPath)
            except Exception as e:
                print(str(e))
            
        def getLastName(self, item):
            # get LastName
            if item.startswith('>'):
                item = item.replace('> ', '')
                if ('/') in item:
                    item = item.split('/')[-1]
                return item
            elif item.startswith('/'):
                item = item.split('/')[-1]
                return item
            else:
                return item


    #############################################################

    class MessageDialog(Dialog):
        def __init__(self, parent, title, text=None):
            self.text = text
            super().__init__(parent, title)
        
        def body(self, master):
            label1 = ttk.Label(master, text=self.text)
            label1.configure(style="White.TLabel")
            label1.pack()
            
            return label1
        
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            b1 = ttk.Button(box, text="Ok", width=10, command=self.cancel, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()
            

        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.parent.focus_set()
            self.destroy()


    #############################################################


    class MessageYesNoDialog(Dialog):
        def __init__(self, parent, title, text=None):
            self.text = text
            super().__init__(parent, title)
        
        def body(self, master):
            label1 = ttk.Label(master, text=self.text)
            label1.configure(style="White.TLabel")
            label1.pack()
            
            return label1
        
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            b1 = ttk.Button(box, text="Yes", width=10, command=self.apply, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)
            b2 = ttk.Button(box, text="No", width=10, command=self.cancel, default=tk.ACTIVE)
            b2.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()

        def apply(self, event=None):
            self.result = 1
            self.parent.focus_set()
            self.destroy()
            

        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.parent.focus_set()
            self.destroy()


    class InfoDialog(Dialog):

        def __init__(self, parent, title, text, directory, file, size):
            self.text = text
            self.directory = directory
            self.file = file
            self.size = size
            super().__init__(parent, title)

        def body(self, master):
            label1 = ttk.Label(master, text=' ' + self.text + ' ')
            label1.configure(style="Red.TLabel")
            label1.pack()
            label1b = ttk.Label(master, text=' ')
            label1b.configure(style="White.TLabel")
            label1b.pack()
            

        
            if self.directory:
                label2a = ttk.Label(master, text='Type: directory\n', anchor=tk.W)
                label2a.configure(style="White.TLabel")
                label2a.pack()
            else:
                label2a = ttk.Label(master, text='Type: file\n', anchor=tk.W)
                label2a.configure(style="White.TLabel")
                label2a.pack()
            if self.file:
                label3a = ttk.Label(master, text='Size: ' + str(self.size) + ' bytes\n', anchor=tk.W)
                label3a.configure(style="White.TLabel")
                label3a.pack()
                
            return label1
        
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            w = ttk.Button(box, text="OK", width=10, command=self.cancel, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            box.pack()


        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

    #############################################################
    class HelpDialog(Dialog):
        def __init__(self, parent, title):
            super().__init__(parent, title)
        
        def body(self, master):
            tabControl = ttk.Notebook(master)
            
            ##
            # Tab What is
            ##
            tab1 = ttk.Frame(tabControl)
            tabControl.add(tab1, text='What is CrossViper ?')
            tabControl.pack(expand=1, fill='both')
            
            readonlyWhatIs = tkst.ScrolledText(tab1, bg='black', fg='white', wrap='none')
            readonlyWhatIs.pack()
            
            textWhatIs = '''
            MoPad - Morten's cross platform Python Pad
            
            Mopad is an Editor for the "Python Programming Language".
            
            It shows the "python source code" colored (syntax highlighting) and 
            helps you to code with its own auto-complete function.
            
            It can run the codefile (requirement is, that you have installed 
            Python on your OS)
            It can also run the "Python Interpreter" and a terminal window 
            (specific for your current OS) -> this can be modified in the 
            settings (-> which where saved in mopad.ini => it's a text file)
            
            On the bottom-right, you find two buttons => one for searching the 
            current file and the other to analyse the code 
            (-> shows you the classes and functions)
            
            On the left side it has its own file-explorer to 
            copy, delete, rename ... files and folders. Use the pop-up menu
            (right mousebutton).
            '''
            
            readonlyWhatIs.insert(1.0, textWhatIs)
            readonlyWhatIs.configure(state='disabled')


            ##
            # Tab Shortcut
            ##
            
            tab2 = ttk.Frame(tabControl)
            tabControl.add(tab2, text='Shortcuts')
            tabControl.pack(expand=1, fill='both')
            
            readonlyShortcuts = tkst.ScrolledText(tab2, bg='black', fg='white', wrap='none')
            readonlyShortcuts.pack()

            
            textShortcut = '''
            Shortcuts:
            
            New File        -       Ctrl + N
            Open File       -       Ctrl + O
            Save File       -       Ctrl + S
            SaveAs          -       Ctrl + Shift + S
            Print to File   -       Ctrl + P
            Quit Mopad      -       Alt + F4
            Undo            -       Ctrl + Z
            Redo            -       Ctrl + Shift + Z
            Copy            -       Ctrl + C
            Cut             -       Ctrl + X
            Paste           -       Ctrl + V
            Select All      -       Ctrl + A
            Change Tab      -       Alt + Right
            Autocomplete    -       Tab
            Search          -       Ctrl + F
            Class Overview  -       Ctrl + G
            Show Settings   -       F12
            Zoom In         -       Alt + Up
            Zoom Out        -       Alt + Down
            Set Cursor      -       Ctrl + Left / Ctrl + Right
            Show Help       -       F1
            
            '''
            
            readonlyShortcuts.insert(1.0, textShortcut)
            readonlyShortcuts.configure(state='disabled')

            ##
            # Tab About
            ##
            tab3 = ttk.Frame(tabControl)
            tabControl.add(tab3, text='About')
            tabControl.pack(expand=1, fill='both')
            
            readonlyAbout = tkst.ScrolledText(tab3, bg='black', fg='white', wrap='none')
            readonlyAbout.pack()

            textAbout = '''
            Complex IDE - cross platform Python Pad
            
            
            Programmed 2024 by Tudor Marmureanu     
            '''
            readonlyAbout.insert(1.0, textAbout)
            readonlyAbout.configure(state='disabled')

            
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            w = ttk.Button(box, text="OK", width=10, command=self.cancel, default=tk.ACTIVE)
            w.pack(side=tk.BOTTOM, padx=5, pady=5)
            box.pack()
            buttonbox = tk.Frame(self)

        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

    #############################################################
    class GotoDialog(Dialog):
        def __init__(self, parent, title=None):
            self.Pad = parent
            super().__init__(parent, title)

        def body(self, master):
            # make body
            ttk.Label(master, text="Goto Linenumber:").grid(row=0)
            
            #self.e1 = tk.Entry(master)
            
            index = int(self.Pad.index("end-1c linestart").split('.')[0])
            
            var = tk.StringVar()
            var.set("1")
            self.spinbox = tk.Spinbox(master, from_= 1, to=index, textvariable=var, bg='black', fg='white', width=5)
            self.spinbox.grid(row=0, column=1, sticky='nsew')
            self.spinbox.configure(cursor="xterm green")
            self.spinbox.configure(insertbackground = "red")
            self.spinbox.configure(highlightcolor='#448dc4')
            self.spinbox.configure(buttonbackground='green')
            self.spinbox.selection('range', tk.INSERT, tk.END)
            
            return self.spinbox # initial focus

        def buttonbox(self):
            # add standard button box. override if you don't want the
            # standard buttons

            box = ttk.Frame(self)

            w = ttk.Button(box, text="OK", width=10, command=self.apply, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            w = ttk.Button(box, text="Cancel", width=10, command=self.cancel)
            w.pack(side=tk.LEFT, padx=5, pady=5)


            box.pack()
            

        def apply(self, event=None):
            number = self.spinbox.get()
            if number.isnumeric():
                number = int(number)
            else:
                return
            
            #print('number', number)
            
            try:
                self.Pad.mark_set("insert", "%d.0" % (number))
            except Exception as e:
                print(str(e))
                
            self.Pad.see(tk.INSERT)
            self.Pad.focus_set()
            
            self.cancel()
            
        
        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()


    #############################################################

    class SettingsDialog(Dialog):
        
        def body(self, master):
            # get configuration 
            self.master = master
            self.c = Configuration()        # in configuration.py
            self.system = self.c.getSystem()
            self.runCommand = self.c.getRun(self.system)
            self.terminalCommand = self.c.getTerminal(self.system)
            self.interpreterCommand = self.c.getInterpreter(self.system)
            self.master.grid_columnconfigure(1, weight=1)
                
            self.title('Settings')
            
            # make body
            ttk.Label(master, text="Run:").grid(row=0)
            ttk.Label(master, text="Terminal:").grid(row=1)
            ttk.Label(master, text="Interpreter:").grid(row=2)
            
            self.v = tk.IntVar()
            if self.c.getSystem() == 'mate':
                self.v.set(1)
            elif self.c.getSystem() == 'gnome':
                self.v.set(2)
            elif self.c.getSystem() == 'kde':
                self.v.set(3)
            elif self.c.getSystem() == 'xterm':
                self.v.set(4)
            elif self.c.getSystem() == 'windows':
                self.v.set(5)
            elif self.c.getSystem() == 'mac':
                self.v.set(6)

            
            self.e1 = tk.Entry(master, bg='black', fg='white', width=40)
            self.e1.configure(cursor='left_ptr')
            self.e1.configure(insertbackground = "red")
            self.e1.configure(highlightcolor='#448dc4')
            self.e1Label = ttk.Label(master, text = '{} = Filename')
            #self.e1Label.configure(style='White.TLabel')

            self.e2 = tk.Entry(master, bg='black', fg='white', width=40)
            self.e2.configure(cursor='left_ptr')
            self.e2.configure(insertbackground = "red")
            self.e2.configure(highlightcolor='#448dc4')

            self.e3 = tk.Entry(master, bg='black', fg='white', width=40)
            self.e3.configure(cursor='left_ptr')
            self.e3.configure(insertbackground = "red")
            self.e3.configure(highlightcolor='#448dc4')

            
            

            self.mate_radio = ttk.Radiobutton(master, text='Mate', variable=self.v,
                                            command=self.setMate, value=1)
            self.gnome_radio = ttk.Radiobutton(master, text='Gnome', variable=self.v,
                                            command=self.setGnome, value=2)
            self.kde_radio = ttk.Radiobutton(master, text='KDE', variable=self.v,
                                            command=self.setKDE, value=3)
            self.xterm_radio = ttk.Radiobutton(master, text='xterm', variable=self.v,
                                            command=self.setXterm, value=4)
            self.win_radio = ttk.Radiobutton(master, text='Windows', variable=self.v,
                                            command=self.setWindows, value=5)
            self.mac_radio = ttk.Radiobutton(master, text='MacOS', variable=self.v,
                                            command=self.setMac, value=6)



            self.e1.grid(row=0, column=1, sticky='ew')
            self.e1.insert(0, self.runCommand)
            self.e1Label.grid(row=0, column=2, sticky='ew')
            self.e2.grid(row=1, column=1, sticky='ew')
            self.e2.insert(0, self.terminalCommand)
            self.e3.grid(row=2, column=1, sticky='ew')
            self.e3.insert(0, self.interpreterCommand)
            self.mate_radio.grid(row=3, column=0)
            self.gnome_radio.grid(row=3, column=1)
            self.kde_radio.grid(row=3, column=2)
            self.xterm_radio.grid(row=4, column=0)
            self.win_radio.grid(row=4, column=1)
            self.mac_radio.grid(row=4, column=2)
            
            return self.e1 # initial focus
        
        def setStandard(self):
            config = configparser.ConfigParser()
            
            config['Run'] = {}
            config['Run']['mate'] = 'mate-terminal -x sh -c "python3 {}; exec bash"'
            config['Run']['gnome'] = 'gnome-terminal -- sh -c "python3 {}; exec bash"'
            config['Run']['kde'] = 'konsole --hold -e "python3 {}"'
            config['Run']['xterm'] = 'xterm -hold -e "python3 {}"'
            config['Run']['windows'] = 'start cmd /K python {}'
            config['Run']['mac'] = 'open -a Terminal ./python3 {}'
            
            config['Terminal'] = {}
            config['Terminal']['mate'] = 'mate-terminal'
            config['Terminal']['gnome'] = 'gnome-terminal'
            config['Terminal']['kde'] = 'konsole'
            config['Terminal']['xterm'] = 'xterm'
            config['Terminal']['windows'] = 'start cmd'
            config['Terminal']['mac'] = 'open -a Terminal ./' 
            
            config['Interpreter'] = {}
            config['Interpreter']['mate'] = 'mate-terminal -x "python3"'
            config['Interpreter']['gnome'] = 'gnome-terminal -- "python3"'
            config['Interpreter']['kde'] = 'konsole -e python3'
            config['Interpreter']['xterm'] = 'xterm python3'
            config['Interpreter']['windows'] = 'start cmd /K python'
            config['Interpreter']['mac'] = 'open -a Terminal ./python3'
            
            config['System'] = {}
            config['System']['system'] = ''
            
            config['Password'] = {}
            config['Password']['password'] = ''
            
            return config

        def setSystem(self, system):
            system = system
            self.runCommand = self.c.getRun(system)
            self.e1.delete(0, tk.END)
            self.e1.insert(0, self.runCommand)

            self.terminalCommand = self.c.getTerminal(system)
            self.e2.delete(0, tk.END)
            self.e2.insert(0, self.terminalCommand)

            self.interpreterCommand = self.c.getInterpreter(system)
            self.e3.delete(0, tk.END)
            self.e3.insert(0, self.interpreterCommand)


        def setMate(self, event=None):
            self.setSystem('mate')
            
        def setGnome(self, event=None):
            self.setSystem('gnome')

        def setKDE(self, event=None):
            self.setSystem('kde')

        def setXterm(self, event=None):
            self.setSystem('xterm')

        def setWindows(self, event=None):
            self.setSystem('windows')

        def setMac(self, event=None):
            self.setSystem('mac')

        def apply(self):
            value = self.v.get()
            config = self.setStandard()
            
            if value == 1:
                config['System']['system'] = 'mate'
                config['Run']['mate'] = self.e1.get()
                config['Terminal']['mate'] = self.e2.get()
                config['Interpreter']['mate'] = self.e3.get()
        
            elif value == 2:
                config['System']['system'] = 'gnome'
                config['Run']['gnome'] = self.e1.get()
                config['Terminal']['gnome'] = self.e2.get()
                config['Interpreter']['gnome'] =self.e3.get()

            elif value == 3:
                config['System']['system'] = 'kde'
                config['Run']['kde'] = self.e1.get()
                config['Terminal']['kde'] = self.e2.get()
                config['Interpreter']['kde'] = self.e3.get()

            elif value == 4:
                config['System']['system'] = 'xterm'
                config['Run']['xterm'] = self.e1.get()
                config['Terminal']['xterm'] = self.e2.get()
                config['Interpreter']['xterm'] = self.e3.get()

            elif value == 5:
                config['System']['system'] = 'windows'
                config['Run']['windows'] = self.e1.get()
                config['Terminal']['windows'] = self.e2.get()
                config['Interpreter']['windows'] = self.e3.get()

            elif value == 6:
                config['System']['system'] = 'mac'
                config['Run']['mac'] = self.e1.get()
                config['Terminal']['mac'] = self.e2.get()
                config['Interpreter']['mac'] = self.e3.get()

            else:
                return
            
            if getattr(sys, 'frozen', False):
                thisFile = os.path.realpath(sys._MEIPASS)
            else:
                thisFile = os.path.realpath(__file__)      # Pfad ermitteln

            base = os.path.dirname(thisFile)
            base = self.CheckPath(base)

            iniPath = base + "/mopad.ini"
            with open(iniPath, 'w') as f:
                config.write(f)
            


    #########################################################

    class ViewDialog(tk.Toplevel):
        def __init__(self, parent, title=None, textPad=None):

            super().__init__(parent)
            self.transient(parent)
            self.textPad = textPad
            self.configure(bg='black')

            if title:
                self.title(title)

            self.parent = parent

            self.result = None

            body = ttk.Frame(self)
            self.initial_focus = self.body(body)
            body.pack(padx=5, pady=5)

            self.buttonbox()

            self.grab_set()

            if not self.initial_focus:
                self.initial_focus = self

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

            
            self.work()


            self.initial_focus.focus_set()
            self.wait_window(self)
            
            

        def body(self, master):
            self.treeview = ttk.Treeview(self)
            self.treeview.pack()
            self.treeview.bind('<Double-1>', self.OnActivated)

            self.treeview.tag_configure('class', background='black', foreground='yellow')
            self.treeview.tag_configure('function', background='black', foreground='#448dc4')
            self.treeview.tag_configure('something', background='black', foreground='gray')

            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            w = ttk.Button(box, text="OK", width=10, command=self.cancel, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            box.pack()


        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

        def work(self):
            if not self.textPad:
                self.cancel()
            if self.textPad.filename == None or self.textPad.filename == 'noname':
                filename = 'noname'

            if self.textPad.filename:
                filename = self.textPad.filename.split('/')[-1]
            
            if not filename:
                self.cancel()
            
            self.treeview.heading('#0', text=filename)
            self.treeview.column('#0', stretch=tk.YES, minwidth=350, width=350)
            self.i = 0
            
            #filename = self.textPad.filename
            
            textLines = self.textPad.get('1.0', 'end-1c')
            lines = textLines.split('\n')
                        
            self.AddTreeNodes(lines)
            
            #self.treeview.Bind(xxxxx)


        def AddTreeNodes(self, text):
            self.findLine = {}
            x = 0
            for line in text:
                x += 1
                y = 0
                whitespaces = len(line) - len(line.lstrip())
                if 'class' in line:
                    l = line.lstrip()
                    #print(l)
                    if l.startswith('class'):
                        node = self.treeview.insert('', 'end', text=line, tags='class')
                        key = '_class_' + line
                        self.findLine[key] = x
                    
                        for secondLine in text[x:]:
                            whitespacesSecond = len(secondLine) - len(secondLine.lstrip())
                            y += 1
                            newClass = False
                            if newClass == False:
                                if 'class' in secondLine:
                                    l = secondLine.lstrip()
                                    if l.startswith('#'):
                                        continue
                                    newClass = True
                                    key = ''
                                    break
                                elif 'def' in secondLine:
                                    l = secondLine.lstrip()
                                    if l.startswith('def'):
                                        if l.startswith('#'):
                                            continue
                                        else:
                                            if whitespaces < whitespacesSecond:
                                                self.treeview.insert(node, 'end', text=secondLine, tags='function')
                                                key += secondLine
                                                self.findLine[key] = x+y
                                                key = '_class_' + line
                                            else:
                                                break
                elif 'def' in line:
                    whitespaces = len(line) - len(line.lstrip())
                    if whitespaces == 0:
                        l = line.lstrip()
                        if l.startswith('def'):
                            if l.startswith('#'):
                                continue
                            else:
                                node = self.treeview.insert('', 'end', text=line, tags='function')
                                key = '_root_' + line
                                self.findLine[key] = x

                        else:
                            continue
                
                elif 'if __name__ ==' in line:
                    l = line.lstrip()
                    if l.startswith('if __name__'):
                        node = self.treeview.insert('', 'end', line, tags='something')
                        key = '_root_' + line
                        self.findLine[key] = x
            
            #print(self.findLine)

        def OnActivated(self, event):
            item = self.treeview.identify('item', event.x, event.y)
            label =  self.treeview.item(item, "text")

            if label == '':
                self.textPad.mark_set('insert', '1.0')
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()
                return
            
            key = ''
            searchKey = ''
        
            if 'class' in label and 'def' not in label:
                key = '_class_' + label
                z = self.findLine[key]
                self.textPad.mark_set('insert', "%d.0" %(z))
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()

            elif 'def' in label:
                childLabel = label
                
                info = self.treeview.get_children()
                self.nodeList = []
                for i in info:
                    #print(i)
                    if i.startswith('I'):
                        self.nodeList.append(i)
                #print(':', self.nodeList)
                parentLabel = None
                for i in self.nodeList:
                    if i < item:
                        parentLabel = self.treeview.item(i, 'text')
                
                if parentLabel == None:
                    searchKey = '_root_' + childLabel
                    #print('searchKey:' , searchKey)
                    z = self.findLine[searchKey]
                    self.textPad.mark_set('insert', "%d.0" %(z))
                    self.textPad.see(tk.INSERT)
                    self.textPad.focus_force()

                elif parentLabel:
                    if 'class' in parentLabel:
                        try:
                            searchKey = '_class_' + parentLabel
                            searchKey += childLabel
                            z = self.findLine[searchKey]
                            self.textPad.mark_set('insert', "%d.0" %(z))
                            self.textPad.see(tk.INSERT)
                            self.textPad.focus_force()
                        except:
                            #exception class ends -> change to def in _root_ 
                            searchKey = '_root_' + childLabel
                            z = self.findLine[searchKey]
                            self.textPad.mark_set('insert', "%d.0" %(z))
                            self.textPad.see(tk.INSERT)
                            self.textPad.focus_force()
      

                    else:
                        searchKey = '_root_' + childLabel
                        z = self.findLine[searchKey]
                        self.textPad.mark_set('insert', "%d.0" %(z))
                        self.textPad.see(tk.INSERT)
                        self.textPad.focus_force()
                        
            
            elif 'if __name__' in label:
                key = '_root_' + label
                z = self.findLine[key]
                self.textPad.mark_set('insert', "%d.0" %(z))
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()

    #########################################################


    class OpenFileDialog(tk.Toplevel):
        def __init__(self, parent, notebookFrame=None, title=None, text=''):
            super().__init__(parent)
            
            self.firstFilebrowser = notebookFrame.filebrowserFrame
            self.transient(parent)

            # no titlebar ... !
            #self.overrideredirect(1)
            
            self.text = text
            self.parent = parent
            
            self['bg'] = 'black'
            
            if title:
                self.title(title)
            else:
                title='Open'

            # value for get : Yes or No
            self.result = None

            body = ttk.Frame(self)
            label1 = ttk.Label(body, text=self.text)
            label1.configure(style="White.TLabel")
            label1.pack()
            
            self.filebrowserFrame = FilebrowserFrame(body)
            self.filebrowserFrame.parent = self
            
            # add this to know notebookFrame in filebrowserFrame
            self.filebrowserFrame.notebookFrame = notebookFrame
            
            self.tree = self.filebrowserFrame.tree
            self.selected = self.filebrowserFrame.selected

            #self.treeview.bind('<Double-1>', self.apply, add='+')
            #self.treeview.bind('<Return>', self.apply, add='+')
            
            self.filebrowserFrame.pack(expand=True)

            body.pack(padx=5, pady=5)

            self.buttonbox()

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))
           
            self.tree.focus()
           
            # make dialog modal
            self.focus_force() 
            self.grab_set()

        def buttonbox(self):
            box = ttk.Frame(self)
            b1 = ttk.Button(box, text="Close", width=10, command=self.apply, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()

        def apply(self, event=None):
            self.result = 1
                    
            self.parent.focus_set()
            self.firstFilebrowser.refreshTree()
            self.destroy()
            
                
        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.parent.focus_set()
            self.firstFilebrowser.refreshTree()
            self.destroy()


    #########################################################
    class SaveFileDialog(tk.Toplevel):
        def __init__(self, parent, title=None, text=''):

            super().__init__(parent)
            self.transient(parent)
            
            self.text = text
            self.filename = None
            
            if title:
                self.title(title)
            else:
                title='Save'

            self.parent = parent
            self.text = text
            
            # value for get : Yes or No
            self.result = None

            body = ttk.Frame(self)
            label1 = ttk.Label(body, text=self.text)
            label1.configure(style="White.TLabel")

            self.treeview = ttk.Treeview(body)
            self.treeview.tag_configure('row', background='black', foreground='white')
            self.treeview.tag_configure('folder', background='black', foreground='yellow')
            self.treeview.tag_configure('subfolder', background='black', foreground='#448dc4')
            self.treeview.tag_configure('hidden', background='black', foreground='gray')
            
            self.treeview['show'] = 'tree'
            self.treeview.bind("<Double-1>", self.OnDoubleClickTreeview)
            self.treeview.bind("<Button-1>", self.OnClickTreeview)
            self.treeview.bind('<<TreeviewSelect>>', self.on_select)

            
            self.filenameBox = tk.Entry(self, bg='black', fg='white')
            self.filenameBox.configure(cursor="xterm green")
            self.filenameBox.configure(insertbackground = "red")
            self.filenameBox.configure(highlightcolor='#448dc4')
            self.filenameBox.bind("<Return>", self.apply)

            
            
            path = self.checkPath(os.getcwd())
            abspath = os.path.abspath(path)
            
            root_node = self.treeview.insert('', 'end', text=abspath, open=True, tags='folder')
            self.process_directory(root_node, abspath)


            body.pack(padx=5, pady=5)
            label1.pack()
            self.treeview.pack(expand=True)
            self.filenameBox.pack()

            self.buttonbox()

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

            self.configure(bg='black')
            
            # variable fpr selected item
            self.selected = None
            
            self.wait_window(self)

        def refreshTree(self):
            for i in self.treeview.get_children():
                self.treeview.delete(i)
            path = '.'
            abspath = os.path.abspath(path)
            root_node = self.treeview.insert('', 'end', text=abspath, open=True, tags='folder')
            self.process_directory(root_node, abspath)

            
        def process_directory(self, parent, path):
            try:
                l = []
                for p in os.listdir(path):
                    abspath = os.path.join(path, p)
                    isdir = os.path.isdir(abspath)

                    if isdir:
                        item = '> /' + str(p)
                        l.append(item)
                        continue
                        
                    else:
                        item = str(p)
                        l.append(item)
                    
                    # list sort ...
                l.sort()
                #l.reverse()
                
                for items in l:
                    if items.startswith('>'):
                        self.treeview.insert(parent, 'end', text=str(items), open=False, tags='subfolder')
                    elif items.startswith('.'):
                        self.treeview.insert(parent, 'end', text=str(items), open=False, tags='hidden')                    
                    else:
                        self.treeview.insert(parent, 'end', text=str(items), open=False, tags='row')
           
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return
            
        def OnClickTreeview(self, event=None):
            item = self.treeview.identify('item',event.x,event.y)
            dir = self.treeview.item(item, 'text')
            self.checkPath(dir)
            
            if dir:
                if '>' in dir:
                    dir = dir.replace('> ', '')
                
            self.selected = dir
            
            
        def OnDoubleClickTreeview(self, event):
            item = self.treeview.identify('item',event.x,event.y)
            root = os.getcwd()

            
            if self.treeview.item(item, "text").startswith('>'):
                sub = self.treeview.item(item, "text").split()[1]

                dir = root + sub
                dir = self.checkPath(dir)
                try:
                    os.chdir(dir)
                except Exception as e:
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                self.selected = None
                self.refreshTree()
        
            elif '/' in self.treeview.item(item, "text") or '\\' in self.treeview.item(item, "text"):
                os.chdir('..')
                dir = self.checkPath(os.getcwd())
                self.refreshTree()
                return 'break'

            else:
                item = self.treeview.identify('item',event.x,event.y)
                obj = self.treeview.item(item, 'text')
                self.checkPath(obj)
                
                self.selected = obj
                
                if '>' in obj:
                    obj = obj.replace('> ', '')
                    os.chdir(obj)

                elif obj == root:
                    return
                


            self.refreshTree()

        def checkPath(self, path):
            if path:
                if '\\' in path:
                    path = path.replace('\\', '/')
            return path

        def on_select(self, event):
            item = self.treeview.focus()
            
            text = self.treeview.item(item, 'text')


            if text.startswith('>'):
                text = ''
            elif ('/') in text:
                text = ''
            else:
                text = self.treeview.item(item, 'text')
            
            self.filenameBox.delete(0, 'end')
            self.filenameBox.insert(0, text)

            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            b1 = ttk.Button(box, text="Ok", width=10, command=self.apply, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)
            b2 = ttk.Button(box, text="Cancel", width=10, command=self.cancel, default=tk.ACTIVE)
            b2.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()

        def apply(self, event=None):
            self.result = 1
            
            filename = self.filenameBox.get()
            if filename:
                dir = os.getcwd()
                self.filename = dir + '/' + filename
            
            if filename == None or '/' in filename:
                self.result = 0
                self.filename = None
            
            self.parent.focus_set()
            self.destroy()
                
            
        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.filename = None
            self.parent.focus_set()
            self.destroy()
            
    #########################################################

    class FilebrowserFrame(ttk.Frame):
        def __init__(self, parent):
            super().__init__(parent)
            self.parent = parent
            self.initUI()
            #self.initStyle()

            self.selected = []
            self.sourceItem = None
            self.destinationItem = None
            
            self.notebookFrame = None
        
        def initUI(self):
            self.config
            
            treeScrollY = ttk.Scrollbar(self, orient=tk.VERTICAL)
            treeScrollY.config(cursor="double_arrow")
            treeScrollY.pack(side=tk.RIGHT, fill=tk.Y)
            
            self.tree = ttk.Treeview(self)

            self.tree.tag_configure('pythonFile', background='black', foreground='green')
            self.tree.tag_configure('row', background='black', foreground='white')
            self.tree.tag_configure('folder', background='black', foreground='yellow')
            self.tree.tag_configure('subfolder', background='black', foreground='#448dc4')
            self.tree.tag_configure('hidden', background='black', foreground='gray')
        
            self.tree['show'] = 'tree'
            self.tree.bind("<Double-1>", self.OnDoubleClickTreeview)
            self.tree.bind("<Return>", self.OnReturnTreeview)
            self.tree.bind("<Button-1>", self.OnClickTreeview)
            self.tree.bind('<<TreeviewSelect>>', self.OnSelect)
            self.tree.bind("<ButtonRelease-3>", self.treePopUp)
            #self.tree.bind("<FocusIn>", self.refreshTree)
            
            # TreeView
            path = expanduser("~")
            os.chdir(path)
            
            
            root_node = self.tree.insert('', 'end', text=path, open=True, tags='folder')
            self.process_directory(root_node, path)

            self.tree.pack(side=tk.LEFT, expand=True, fill=tk.BOTH)

            treeScrollY.config(command=self.tree.yview)
            self.tree.configure(yscrollcommand=treeScrollY.set)
        
        def OnReturnTreeview(self, event=None):
            item = self.tree.focus()

            if self.tree.item(item, "text") == '': 

                return
            
            elif self.tree.item(item, "text").startswith('>'):
                root = os.getcwd()
                sub = self.tree.item(item, "text").split()[1]
                dir = root + sub
                dir = self.checkPath(dir)
                try:
                    os.chdir(dir)
                except Exception as e:
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                self.selected = None
                self.refreshTree()
                self.parent.title(dir)
        
            elif '/' in self.tree.item(item, "text") or '\\' in self.tree.item(item, "text"):
                os.chdir('..')
                dir = self.checkPath(os.getcwd())
                self.parent.title(dir)
                self.refreshTree()
                return 'break'

            else:
                file = self.tree.item(item,"text")
                dir = os.getcwd()
                dir = self.checkPath(dir)
                filename = dir + '/' + file
                self.tree.config(cursor="X_cursor")
                self.tree.bind('<Double-1>', self.ignore)
                
                try:
                    self.notebookFrame.new()
                    self.notebookFrame.open(filename)

                except Exception as e:

                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                    filename = self.notebookFrame.textPad.filename = None
                    self.notebookFrame.tabChanged()
                    self.notebookFrame.textPad.focus()
                    

                self.tree.config(cursor='')
                self.tree.update()
                self.parent.title(filename)
                
                # workaround 
                # step 2
                self.refreshTree()
                self.tree.update()
                self.tree.after(500, self.bindit)
            
            self.refreshTree()

        
        def OnDoubleClickTreeview(self, event=None):
            item = self.tree.identify('item',event.x,event.y)
            #print("you clicked on", self.tree.item(item,"text"))
            if self.tree.item(item, "text") == '': 

                return
            
            elif self.tree.item(item, "text").startswith('>'):
                root = os.getcwd()
                sub = self.tree.item(item, "text").split()[1]
                dir = root + sub
                dir = self.checkPath(dir)
                try:
                    os.chdir(dir)
                except Exception as e:
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                self.selected = None
                self.refreshTree()
                self.parent.title(dir)
        
            elif '/' in self.tree.item(item, "text") or '\\' in self.tree.item(item, "text"):
                os.chdir('..')
                dir = self.checkPath(os.getcwd())
                self.parent.title(dir)
                self.refreshTree()
                return 'break'

            else:
                file = self.tree.item(item,"text")
                dir = os.getcwd()
                dir = self.checkPath(dir)
                filename = dir + '/' + file
                self.tree.config(cursor="X_cursor")
                self.tree.bind('<Double-1>', self.ignore)
                
                try:
                    self.notebookFrame.new()
                    self.notebookFrame.open(filename)

                except Exception as e:

                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                    filename = self.notebookFrame.textPad.filename = None
                    self.notebookFrame.tabChanged()
                    self.notebookFrame.textPad.focus()
                    #return

                try:
                    self.tree.config(cursor='')
                    self.tree.update()
                    #self.rightPanel.textPad.mark_set("insert", "1.0")
                    self.parent.title(filename)
                    #self.rightPanel.textPad.focus_set()

                
                    # workaround 
                    # step 2
                    self.refreshTree()
                    self.tree.update()
                    self.tree.after(500, self.bindit)
                except:
                    return
            
            self.refreshTree()

        def ignore(self, event):
            # workaround for dismiss OnDoubleClickTreeview to open file twice 
            # step 1
            return 'break'

        def bindit(self):
            # workaround 
            # step 3
            self.tree.bind('<Double-1>', self.OnDoubleClickTreeview)

        def OnClickTreeview(self, event=None):
            item = self.tree.identify('item',event.x,event.y)
            if '/' in self.tree.item(item,"text") or '\\' in self.tree.item(item, "text"):
                self.parent.title(self.checkPath(self.tree.item(item, 'text')))
                    
            else:
                dir = self.checkPath(os.getcwd())
                self.parent.title(dir + '/' + self.checkPath(self.tree.item(item, 'text')))
            #print(item)

        
        def OnSelect(self, event=None):
            self.selected = event.widget.selection()

        def checkPath(self, path):
            if '\\' in path:
                path = path.replace('\\', '/')
            return path

        def treePopUp(self, event=None):
            item = self.tree.identify('item',event.x,event.y)
            self.tree.selection_set(item)
                
            menu = tk.Menu(self, tearoff=False, background='#000000',foreground='white',
                    activebackground='blue', activeforeground='white')
            menu.add_command(label='Info', compound=tk.LEFT, command=self.treeGenerateInfo)
            menu.add_separator()
            menu.add_command(label="Create New Folder", compound=tk.LEFT, command=self.treeGenerateFolder)
            menu.add_separator()
            menu.add_command(label="Copy Item", compound=tk.LEFT, command=self.treeGenerateCopy)
            menu.add_command(label="Paste Item", compound=tk.LEFT, command=self.treeGeneratePaste)
            menu.add_command(label="Rename Item", compound=tk.LEFT, command=self.treeGenerateRename)

            menu.add_separator()
            menu.add_command(label="Delete Item", compound=tk.LEFT, command=self.treeGenerateDelete)
            menu.add_separator()
            menu.add_command(label="Open Terminal", compound=tk.LEFT, command = self.treeGenerateTerminal)
            menu.tk_popup(event.x_root, event.y_root, 0)

        def treeGenerateInfo(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return
            
            self.infoFile()

        def infoFile(self):
            rootDir = self.checkPath(os.getcwd())
            #print(rootDir)
            directory = None
            file = None
            size = None
            if self.selected:
                for idx in self.selected:
                    try:
                        text = self.tree.item(idx)['text']
                    except:
                        self.selected = []
                        return
                if '/' in text or '\\' in text:
                    directory = True
                else:
                    file = True
                if file == True:
                    filename = rootDir + '/' + text
                    size = os.path.getsize(filename)
                    size = format(size, ',d')
                else:
                    filename = text
                text = self.checkPath(text)
                InfoDialog(self, title='Info', text=text, directory=directory, file=file, size=size)
            
            else:
                return

        def treeGenerateFolder(self):
            self.newFolder()
        
        def newFolder(self):
            NewDirectoryDialog(self, title='Create directory')
            self.refreshTree()

        def treeGenerateCopy(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return

            self.copyFile()

        def copyFile(self):
            if not self.selected:
                self.clipboard = ''
                return
            else:
                for idx in self.selected:
                    text = self.tree.item(idx)['text']
            
            self.clipboard = text
            self.homedir = self.checkPath(os.getcwd())
            
            if self.clipboard.startswith('>'):
                dir = self.clipboard.split()[1]
                self.sourceItem = self.homedir + dir
            elif '/' in self.clipboard or '\\' in self.clipboard:
                self.sourceItem = self.homedir
            else:
                self.sourceItem = self.homedir + '/' + self.clipboard
                self.sourceItem = self.checkPath(self.sourceItem)
            
            self.selected = None
            self.parent.title(self.sourceItem + ' -> marked')

        def treeGeneratePaste(self):
            if not self.sourceItem:
                self.parent.title('<No Selection>')
                return
                
            self.pasteFile()

        def pasteFile(self):
            if not self.sourceItem:
                self.parent.title('<No Selection>')
                return
            
            if not self.selected:
                currentDirectory = self.checkPath(os.getcwd())
                self.destinationItem = currentDirectory
                
            if self.selected:
                try:
                    for idx in self.selected:
                        text = self.tree.item(idx)['text']
            
                except Exception as e:
                    #print('this')
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                    return
            
                currentDirectory = self.checkPath(os.getcwd())
            
                if text.startswith('>'):
                    dir = text.split()[1]
                    self.destinationItem = currentDirectory + dir
            
                elif '/' in text or '\\' in text:
                    self.destinationItem = currentDirectory

                else:
                    self.destinationItem = currentDirectory + '/' + text
            
            #print('self.sourceItem:', self.sourceItem)
            #print('self.destinationItem:', self.destinationItem)
            
            if os.path.isfile(self.sourceItem):             # Source == file
                if os.path.isdir(self.destinationItem):     # Destination == directory
                    destination = self.destinationItem      

                    try:
                        shutil.copy2(self.sourceItem, destination)
                        self.refreshTree()

                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return
                
                elif os.path.isfile(self.destinationItem):  # Destination == file
                    destination = os.path.dirname(self.destinationItem)

                    try:
                        shutil.copy2(self.sourceItem, destination)
                        self.refreshTree()

                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return

            elif os.path.isdir(self.sourceItem):            # Source == directory
                if os.path.isdir(self.destinationItem):     # Destination == directory
                    destination = self.destinationItem + '/'
                    basename = self.sourceItem.split('/')[-1]
                    destination = destination + basename
                    destination = self.checkPath(destination)
                    #print('destination:', destination)

                    try:
                        shutil.copytree(self.sourceItem, destination)
                        self.refreshTree()
                    
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return
                
                elif os.path.isfile(self.destinationItem):   # Destination == file
                    destination = os.path.dirname(self.destinationItem) + '/'
                    destination = self.checkPath(destination)
                    basename = self.sourceItem.split('/')[-1]
                    destination = destination + basename
                    #print('destination:', destination)
                    
                    try:
                        shutil.copytree(self.sourceItem, destination)
                        self.refreshTree()
                        
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return
            
            self.selected = None
            self.sourceItem = None
            
            self.parent.title('Done !')

        
        def treeGenerateDelete(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return
            
            self.deleteFile()

        def deleteFile(self):
            rootDir = self.checkPath(os.getcwd())
            directory = None
            file = None
            size = None
            
            if self.selected:
                for idx in self.selected:
                    try:
                        text = self.tree.item(idx)['text']
                    except:
                        self.selected = []
                        return
                
                if '/' in text or '\\' in text:
                    directory = True
                else:
                    file = True
                
                if file == True:
                    filename = rootDir + '/' + text
                else: # directory
                    if text.startswith('>'):
                        dir = text.split()[-1]
                        filename = rootDir + dir
                    elif '/' in text or '\\' in text:
                        filename = text
                    
            else:
                return
            
            filename = self.checkPath(filename)
            
            dialog = MessageYesNoDialog(self, 'Delete', '\n\tDelete\n\n' + filename + '  ?\n\n')
            result = dialog.result
            
            if result == 1:
                if directory:
                    try:
                        shutil.rmtree(filename)
                        self.refreshTree()
                        
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                        
                elif file:
                    try:
                        os.remove(filename)
                        self.refreshTree()
                    
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                
                self.parent.title('Done !')
        
        def treeGenerateRename(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return
                
            obj = self.tree.selection()
            item = self.tree.item(obj)['text']
            
            dialog = RenameDialog(self, title='Rename Item', item=item)
            result = dialog.result
            
            print(result)
            if result:
                self.parent.title('Done !')
            
            self.refreshTree()

        def treeGenerateTerminal(self):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            terminalCommand = c.getTerminal(system)
            
            subprocess.call(terminalCommand, shell=True)

        def process_directory(self, parent, path):
            try:
                l = []
                for p in os.listdir(path):
                    abspath = os.path.join(path, p)
                    isdir = os.path.isdir(abspath)

                    if isdir:
                        item = '> /' + str(p)
                        l.append(item)

                    else:
                        item = str(p)
                        l.append(item)
                    
                l.sort()
                #l.reverse()
                
                for items in l:
                    if items.startswith('>'):
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='subfolder')
                    elif items.startswith('.'):
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='hidden')                    
                    elif items.endswith('.py') or items.endswith('.pyw'):
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='pythonFile')
                    else:
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='row')
           
            except Exception as e:
                print(str(e))
                return

        def refreshTree(self, event=None):
            for i in self.tree.get_children():
                self.tree.delete(i)
            path = '.'
            abspath = os.path.abspath(path)
            root_node = self.tree.insert('', 'end', text=abspath, open=True, tags='folder')
            self.process_directory(root_node, abspath)

    #if __name__ == '__main__':
    root = tk.Tk()
    app = FilebrowserFrame(root)
    app.pack(fill=tk.BOTH, expand=True)
    root.mainloop()

    class NotebookFrame(ttk.Frame):
        def __init__(self, parent):
            super().__init__(parent)
            self.parent = parent
            
            try:
                self.overlord = self.parent.parent
            except:
                self.overlord = None
            
            self.filebrowserFrame = None
            
            self.initUI()
        
        def initUI(self):
            self.buttonFrame = ttk.Frame(self)
            self.initButtons()
            self.notebook = ttk.Notebook(self)
            
            self.buttonFrame.pack(side=tk.TOP, fill=tk.X)
            self.notebook.pack(side=tk.TOP, expand=True, fill=tk.BOTH)
            self.new()
        
        def initButtons(self):
            HOMEPATH = os.path.dirname(__file__) + '/'
            
            # Buttons
            #newIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/newIDE.png')
            newButton = ttk.Button(self.buttonFrame, text="New", command=self.new)
            #newButton.image = newIcon
            newButton.pack(side=tk.LEFT)
            newButton_ttp = CreateToolTip(newButton, 'New')

            #openIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/openIDE.png')
            openButton = ttk.Button(self.buttonFrame, text="Open", command=self.openFileDialog)
            #openButton.image = openIcon
            openButton.pack(side=tk.LEFT)
            openButton_ttp = CreateToolTip(openButton, 'Open') 
            
            #saveIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/saveIDE.png')
            saveButton = ttk.Button(self.buttonFrame, text="Save", command=self.save)
            #saveButton.image = saveIcon
            saveButton.pack(side=tk.LEFT)
            saveButton_ttp = CreateToolTip(saveButton, 'Save')

            #saveAsIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/saveAsIDE.png')
            saveAsButton = ttk.Button(self.buttonFrame, text="Save As", command=self.saveAs)
            #saveAsButton.image = saveAsIcon
            saveAsButton.pack(side=tk.LEFT)
            saveAsButton_ttp = CreateToolTip(saveAsButton, 'Save As')

            #printIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/printIDE.png')
            printButton = ttk.Button(self.buttonFrame, text="Print", command=self.printer)
            #printButton.image = printIcon
            printButton.pack(side=tk.LEFT)
            printButton_ttp = CreateToolTip(printButton, "Print to HTML-File")

            #undoIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/undoIDE.png')
            undoButton = ttk.Button(self.buttonFrame, text="Undo", command=self.undo)
            #undoButton.image = undoIcon
            undoButton.pack(side=tk.LEFT)
            undoButton_ttp = CreateToolTip(undoButton, 'Undo')

            #redoIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/redoIDE.png')
            redoButton = ttk.Button(self.buttonFrame, text="Redo", command=self.redo)
            #redoButton.image = redoIcon
            redoButton.pack(side=tk.LEFT)
            redoButton_ttp = CreateToolTip(redoButton, "Redo")

            #zoomInIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/zoomInIDE.png')
            zoomInButton = ttk.Button(self.buttonFrame, text="Zoom In", command=self.zoomIn)
            #zoomInButton.image = zoomInIcon
            zoomInButton.pack(side=tk.LEFT)
            zoomInButton_ttp = CreateToolTip(zoomInButton, "Zoom In")

            #zoomOutIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/zoomOutIDE.png')
            zoomOutButton = ttk.Button(self.buttonFrame, text="Zoom Out", command=self.zoomOut)
            #zoomOutButton.image = zoomOutIcon
            zoomOutButton.pack(side=tk.LEFT)
            zoomOutButton_ttp = CreateToolTip(zoomOutButton, "Zoom Out")

            #settingsIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/settingsIDE.png')
            settingsButton = ttk.Button(self.buttonFrame, text="Settings", command=self.settings)
            #settingsButton.image = settingsIcon
            settingsButton.pack(side=tk.LEFT)
            settingsButton_ttp = CreateToolTip(settingsButton, "Show Settings")

            #runIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/runIDE.png')
            runButton = ttk.Button(self.buttonFrame, text="Run", command=self.run)
            #runButton.image = runIcon
            runButton.pack(side=tk.RIGHT)
            runButton_ttp = CreateToolTip(runButton, "Run File")
            
            #terminalIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/terminalIDE.png')
            terminalButton = ttk.Button(self.buttonFrame, text="Terminal", command=self.terminal)
            #terminalButton.image = terminalIcon
            terminalButton.pack(side=tk.RIGHT)
            terminalButton_ttp = CreateToolTip(terminalButton, 'Open Terminal')

            #interpreterIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/interpreterIDE.png')
            interpreterButton = ttk.Button(self.buttonFrame, text="Interpreter", command=self.interpreter)
            #interpreterButton.image = interpreterIcon
            interpreterButton.pack(side=tk.RIGHT)
            interpreterButton_ttp = CreateToolTip(interpreterButton, "Open Python Interpreter")

            '''
            viewIcon = tk.PhotoImage(file=self.dir + 'IDE/view.png')
            viewButton = ttk.Button(self.rightBottomFrame, image=viewIcon, command=self.overview)
            viewButton.image = viewIcon
            viewButton.pack(side=tk.RIGHT)
            self.createToolTip(viewButton, 'Class Overview')
            '''
            
            #searchIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/searchIDE.png')
            searchButton = ttk.Button(self.buttonFrame, text="Search", command=self.search)
            #searchButton.image = searchIcon
            searchButton.pack(side=tk.RIGHT)
            searchButton_ttp = CreateToolTip(searchButton, "Search")


            self.searchBox = tk.Entry(self.buttonFrame, bg='black', fg='white')
            self.searchBox.configure(cursor="xterm green")
            self.searchBox.configure(insertbackground = "red")
            self.searchBox.configure(highlightcolor='#448dc4')

            #self.searchBox.bind('<Key>', self.OnSearchBoxChange)
            self.searchBox.bind('<Return>', self.search)
            self.searchBox.pack(side=tk.RIGHT, padx=5)
        
            
        def new(self, event=None):
            self.codeeditorFrame = CodeeditorFrame(self)
            self.notebook.add(self.codeeditorFrame, text='noname')
            self.frameName = self.notebook.select()

            self.textPad = self.codeeditorFrame.textPad
            
            self.notebook.bind("<ButtonRelease-1>", self.tabChanged)
            self.notebook.bind("<ButtonRelease-3>", self.closeContext)
            
            x = len(self.notebook.tabs()) - 1
            self.notebook.select(x)
            self.tabChanged()
        
        def open(self, filename=None, event=None):
            if not filename:
                filename = filedialog.askopenfilename()
            
                if not filename:
                    return
            
            try:
                # open file for reading
                with open(filename, 'r') as f:
                    text = f.read()
            
                # update textPad
                self.textPad.delete('1.0', tk.END)
                self.textPad.insert("1.0", text)
                self.textPad.filename = filename
                self.textPad.tag_all_lines()
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return
                
            # update tab text
            file = self.textPad.filename.split('/')[-1]
            id = self.notebook.index(self.notebook.select())
            self.notebook.tab(id, text=file)
            
            # generate tabChanged event (get new textPad, etc)
            self.tabChanged()
            
            # update autocompleteList from codeeditor
            self.textPad.updateAutoCompleteList()
            self.filebrowserFrame.refreshTree()

        def openFileDialog(self):
            dialog = OpenFileDialog(parent=self.parent, notebookFrame=self, title='Open')

        def save(self, event=None):
            if not self.textPad:
                return
                
            if not self.textPad.filename:
                self.saveAs()
            
            filename = self.textPad.filename
            
            if not filename:
                return
            
            try:
                with open(filename, 'w') as f:
                    text = self.textPad.get("1.0",'end-1c')
                    f.write(text)
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
            
            # update textPad
            self.textPad.filename = filename
            
            # update tab text
            file = self.textPad.filename.split('/')[-1]
            id = self.notebook.index(self.notebook.select())
            self.notebook.tab(id, text=file)
            
            # generate tabChanged event (get new textPad, etc)
            self.tabChanged()
            self.filebrowserFrame.refreshTree()
            
        def saveAs(self, event=None):
            dialog = SaveFileDialog(self, "Save as")
            filename = dialog.filename
            
            if not filename:
                return
            
            try:
                with open(filename, 'w') as f:
                    text = self.textPad.get("1.0",'end-1c')
                    f.write(text)
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
            
            # update textPad
            self.textPad.filename = filename
            
            # update tab text
            file = self.textPad.filename.split('/')[-1]
            id = self.notebook.index(self.notebook.select())
            self.notebook.tab(id, text=file)
            
            # generate tabChanged event (get new textPad, etc)
            self.tabChanged()
            self.filebrowserFrame.refreshTree()

        def printer(self, event=None):
            # print file to html
            if not self.textPad:
                return
                
            if not self.textPad.filename:
                return

            text = self.textPad.get("1.0",'end-1c')
            filename = self.textPad.filename.split('/')[-1]
            kwList = keyword.kwlist
            
            output = "<head>" + filename + "</head>\n"
            output += "<body>\n"
            output += '<pre><code>\n'
            output += text + '\n'
            output += '</pre></code>\n'
            output += "</body>"

            fname = self.textPad.filename + "_.html"
            
            with open(fname, "w") as f:
                f.write(output)
            
            try:
                webbrowser.open(fname)
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return
            
            self.filebrowserFrame.refreshTree()
            
        def undo(self, event=None):
            if self.textPad:
                self.textPad.undo()
            
        def redo(self, event=None):
            if self.textPad:
                self.textPad.redo()
            
        def zoomIn(self, event=None):
            if not self.textPad:
                return
            if self.textPad.font_size < 30:
                self.textPad.font_size += 1
                self.textPad.configFont()
                
                self.textPad.linenumber.font_size +=1
                self.textPad.linenumber.configFont()
                self.textPad.linenumber.redraw()

        def zoomOut(self, event=None):
            if not self.textPad:
                return
            if self.textPad.font_size > 5:
                self.textPad.font_size -= 1
                self.textPad.configFont()
                
                self.textPad.linenumber.font_size -=1
                self.textPad.linenumber.configFont()
                self.textPad.linenumber.redraw()

        def settings(self, event=None):
            dialog = SettingsDialog(self)

        def run(self, event=None):
            if not self.textPad:
                return
            
            filepath = self.textPad.filename
            
            if not filepath:
                return
            
            self.save()

            file = filepath.split('/')[-1]
        
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            runCommand = c.getRun(system).format(file)

            subprocess.call(runCommand, shell=True)

        def terminal(self, event=None):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            terminalCommand = c.getTerminal(system)
            
            try:
                subprocess.call(terminalCommand, shell=True)
            except Exception as e:
                dialog = MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return


        def interpreter(self, event=None):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            interpreterCommand = c.getInterpreter(system)

            subprocess.call(interpreterCommand, shell=True)
        
        def search(self, start=None):
            if not self.textPad:
                return
                
            self.textPad.tag_remove('sel', "1.0", tk.END)
            
            toFind = self.searchBox.get()
            pos = self.textPad.index(tk.INSERT)
            result = self.textPad.search(toFind, str(pos), stopindex=tk.END)
            
            if result:
                length = len(toFind)
                row, col = result.split('.')
                end = int(col) + length
                end = row + '.' + str(end)
                self.textPad.tag_add('sel', result, end)
                self.textPad.mark_set('insert', end)
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()
            else:
                self.textPad.mark_set('insert', '1.0')
                self.textPad.see(tk.INSERT)
                self.textPad.focus()
                self.setEndMessage(400)
                self.searchBox.focus()
                return

        def setEndMessage(self, seconds):
                pathList = __file__.replace('\\', '/')
                pathList = __file__.split('/')[:-1]
            
                self.dir = ''
                for item in pathList:
                    self.dir += item + '/'

                canvas = tk.Canvas(self.textPad, width=64, height=64)
                x = self.textPad.winfo_width() / 2
                y = self.textPad.winfo_height() / 2

                canvas.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
                #image = tk.PhotoImage(file = self.dir + 'IDE/lastIDE.png')
                canvas.create_image(0, 0,  anchor=tk.NW)
                
                self.textPad.update()
                self.after(seconds, self.textPad.entry.config(text='---'))
                
                canvas.destroy()
                self.textPad.update()


        def tabChanged(self, event=None):
            tabs = self.notebook.tabs()
            try:
                id = self.notebook.index(self.notebook.select())
            except:
                return 
                
            name = tabs[id]
            codeframe = self.notebook._nametowidget(name)
            
            self.textPad = codeframe.textPad
        
            self.updateMainWindow()
            self.textPad.focus()
            
        def updateMainWindow(self, event=None):
            if not self.textPad:
                return
                
            if not self.overlord:
                if self.textPad.filename:
                    self.parent.title(self.textPad.filename)
                else:
                    self.parent.title("Complex IDE")
            else:
                if self.textPad.filename:
                    self.overlord.title(self.textPad.filename)
                else:
                    self.overlord.title("Complex IDE")

            
        def closeContext(self, event=None):
            tabs = self.notebook.tabs()
            if not tabs:
                return
            
            menu = tk.Menu(self.notebook, tearoff=False, background='#000000',foreground='white',
                    activebackground='blue', activeforeground='white')
            menu.add_command(label='Close', compound=tk.LEFT, command=self.closeTab)
            menu.tk_popup(event.x_root, event.y_root, 0)
            
        def closeTab(self, event=None):
            id = self.notebook.index(self.notebook.select())
            self.notebook.forget(id)
            
            try:
                x = len(self.notebook.tabs()) - 1
                self.notebook.select(x)
                self.tabChanged()
            except:
                self.textPad = None
                return
            
    ###################################################################
    class CreateToolTip():
        """
        create a tooltip for a given widget
        -> this solution was found on stackoverlow.com :)
        """
        def __init__(self, widget, text='widget info'):
            self.waittime = 500     # miliseconds
            self.wraplength = 180   # pixels
            self.widget = widget
            self.text = text
            self.widget.bind("<Enter>", self.enter)
            self.widget.bind("<Leave>", self.leave)
            self.widget.bind("<ButtonPress>", self.leave)
            self.id = None
            self.tw = None

        def enter(self, event=None):
            self.schedule()

        def leave(self, event=None):
            self.unschedule()
            self.hidetip()

        def schedule(self):
            self.unschedule()
            self.id = self.widget.after(self.waittime, self.showtip)

        def unschedule(self):
            id = self.id
            self.id = None
            if id:
                self.widget.after_cancel(id)

        def showtip(self, event=None):
            x = y = 0
            x, y, cx, cy = self.widget.bbox("insert")
            x += self.widget.winfo_rootx() + 1
            y += self.widget.winfo_rooty() + 40
            
            # creates a toplevel window
            self.tw = tk.Toplevel(self.widget)
            
            # Leaves only the label and removes the app window
            self.tw.wm_overrideredirect(True)
            self.tw.wm_geometry("+%d+%d" % (x, y))
            label = tk.Label(self.tw, text=self.text, justify='left',
                           background="#000000", foreground='yellow',
                           relief='solid', borderwidth=1,
                           wraplength = self.wraplength)
            label.pack(ipadx=1)

        def hidetip(self):
            tw = self.tw
            self.tw= None
            if tw:
                tw.destroy()
    ###################################################################


    #if __name__ == '__main__':
    root = tk.Tk()
    app = NotebookFrame(root)
    app.pack(fill=tk.BOTH, expand=True)
    root.mainloop()

    class Mopad(ttk.Frame):
        '''
            Main App
        '''

        def __init__(self, parent=None):
            super().__init__(parent)
            self.parent = parent
            self.pack(expand=True, fill=tk.BOTH)
            self.initUI()
            self.initStyle()


        def initUI(self):
            
            # PanedWindow
            self.panedWindow = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
            self.panedWindow.pack(fill=tk.BOTH, expand=1)
            
            # InterpreterFrame
            self.filebrowserFrame = FilebrowserFrame(self.parent)
            #self.filebrowserFrame2 = FilebrowserFrame(self.parent)
            #self.filebrowserFrame.pack(side='left', fill='y')

            # NotebookFrame
            self.notebookFrame = NotebookFrame(self.parent)
            #self.notebookFrame.pack(side='right', expand=1, fill='both')
            self.notebookFrame.textPad.bind("<FocusIn>", self.textPadFocus)
            
            # add a variable for fileBrowserFrame to know the notebookFrame
            self.filebrowserFrame.notebookFrame = self.notebookFrame
            self.notebookFrame.filebrowserFrame = self.filebrowserFrame
            
            # add to PanedWindow
            self.panedWindow.add(self.filebrowserFrame)
            self.panedWindow.add(self.notebookFrame)
            #self.panedWindow.add(self.filebrowserFrame2)
            
        def textPadFocus(self, event=None):
            self.notebookFrame.updateMainWindow()

        def initStyle(self):
            self.style = ttk.Style()
            self.style.theme_use('clam')
            
            self.style.configure("Treeview", background="black", 
                    fieldbackground="black", foreground="white",
                    selectbackground='green')
            self.style.configure("Treeview.Heading", background="black", foreground='white', relief='flat')
            self.style.map('Treeview.Heading', 
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])

            self.style.configure('TCheckbutton', background='black',
                    fieldbackground='black', foreground='white')

            self.style.configure('TRadiobutton', background='black',
                    fieldbackground='black', foreground='white')
            self.style.map('TRadiobutton',
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])


            self.style.configure('TSpinbox', background='black',
                    fieldbackground='black', foreground='white')

            self.style.configure('TNotebook', background='black',
                    fieldbackground='black', foreground='white')
            self.style.configure('TNotebook.Tab', background='black',
                    fieldbackground='black', foreground='white')
            self.style.map('TNotebook.Tab',
                foreground=[('selected', 'yellow')],
                background=[('selected', 'black')])
                
            self.style.configure('TFrame', background='black',
                    fieldbackground='black', foreground='white',
                    highlightcolor='white', highlightbackground='black',
                    highlightthickness=5)

            self.style.configure('TLabel', background='black',
                    fieldbackground='black', foreground='green')
            self.style.configure("White.TLabel", background='black',
                    fieldbackground='black', foreground="white")
            self.style.configure("Red.TLabel", background='black',
                    fieldbackground='black', foreground="red")

            self.style.configure('TPanedwindow', background='black',
                    fieldbackground='black', foreground='white')

            self.style.configure('TEntry', background='black',
                    fieldbackground='black', foreground='white')

            self.style.map('TEntry',
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])
            

            self.style.configure('TButton', background='black',
                    fieldbackground='black', foreground='#FFFFFF')
            self.style.configure('Red', background='red')
            self.style.map('TButton',
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])       

            self.style.configure("TScrollbar", background="#1d1d1d",
                                  foreground="#000000", activebackground="#000000",
                                  troughcolor="#000000")
            self.style.map('TScrollbar',
                foreground=[('pressed', '#424242'),
                            ('focus', '#424242'),
                            ('active', '#424242')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])
                    
    def center(win):
        # Center the root screen
        win.update_idletasks()
        width = win.winfo_width()
        frm_width = win.winfo_rootx() - win.winfo_x()
        win_width = width + 2 * frm_width
        height = win.winfo_height()
        titlebar_height = win.winfo_rooty() - win.winfo_y()
        win_height = height + titlebar_height + frm_width
        x = win.winfo_screenwidth() // 2 - win_width // 2
        y = win.winfo_screenheight() // 2 - win_height // 2
        win.geometry('{}x{}+{}+{}'.format(width, height, x, y))
        win.deiconify()
            
    if __name__ == '__main__':
        root = tk.Tk()
        #root['bg'] = 'black'
        
        app = Mopad(root)
        app.master.title('Complex IDE')
        app.master.minsize(width=800, height=600) 
      
        center(root)  
        app.mainloop()
        
if Adm2var == 40:
# Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    __author__ = "Tudor Marmureanu"



    from tkinter import *
    from tkinter import ttk
    from tkinter import colorchooser
    from tkinter import filedialog
    from tkinter import font

    # from fontTopLevel import *

    class pyPROApp:
        def __init__(self, master):
            global dictDesignWindowPropCollect
            dictDesignWindowPropCollect = {}  #### Dictionary to collect properties of the design window
            self.implementFont_determine = 0    ### Variable that works in conjunction with implementFont command
            self.dictCountFont = {}     ### Dicitonary to store font instances for design window widgets
            self.implementImage_determine = 0   ### Variable that works in conjunction with implementImage command
            self.dictCountImage = {}         ### Dictionary to store PhotoImage instances for design window
            self.count_image_instances = 1
            self.commands_all = {}      ### Dictionary to store commands for all widgets

            self.styleWidgetConfigLabel = ttk.Style()       ###ttk.Style for Main and WidgetToplevel widgets
            self.clickWidgetConfig = 0  # Variable that determines if WidgetConfig Window has been opened earlier

            self.numberFont_2 = 1  ###### Variable for New Font Name
            self.isFontToplevel = 0  #### Variable to determine whether FontToplevel is opened

            self.iswinConfigToplevel = 0    ### Variable to determine wheter winConfigToplevel is opned earlier


            global screen_width, screen_height
            self.master = master
            screen_width = windowPRO.winfo_screenwidth()
            screen_height = windowPRO.winfo_screenheight()

        ### Parameters for Title of Design Window
            dictDesignWindowPropCollect["title"] = f"windowDesign.title('Design Window')"
            
        ### Parameters for Geometry of Design Window
            global new_value_width
            new_value_width = int(screen_width / 2)
            global new_value_height
            new_value_height = int(screen_height / 1.57)
            global new_value_position_x
            new_value_position_x = int(screen_width / 4.5)
            global new_value_position_y
            new_value_position_y = int(screen_height / 3.36)
            dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry('{new_value_width}x{new_value_height}+" \
                                                      f"{new_value_position_x}+{new_value_position_y}')"

            ######## Main Window
            windowPRO.title("BuildIt")
            windowPRO.geometry(
                "%dx%d+%d+%d" % (screen_width / 2, screen_height / 8, screen_width / 4.5, (screen_height / 20) - 20))

            ####### Main Menu Widget
            Menu_main = Menu(master)

            ### comms for Code Gen
            def comm4compile_text():
                codeGen = CodeGenerate()
                codeGen.compile2Text()

            def comm4compile_python():
                codeGen2 = CodeGenerate()
                codeGen2.compile2PythonFile()

            command4Code_Gen = Menu()
            command4Code_Gen.add_command(label = "To Python File", command = comm4compile_python)
            command4Code_Gen.add_command(label="To pyPRO's NotePad", command = comm4compile_text)


            ### comms for Beautify
            cascade_change_theme = Menu()
            cascade_change_theme.add_command(label="alt", command=lambda: self.styleWidgetConfigLabel.theme_use("alt"))
            cascade_change_theme.add_command(label="clam", command=lambda: self.styleWidgetConfigLabel.theme_use("clam"))
            cascade_change_theme.add_command(label = "classic", command = lambda: self.styleWidgetConfigLabel.theme_use("classic"))
            cascade_change_theme.add_command(label = "default", command = lambda: self.styleWidgetConfigLabel.theme_use("default"))
            cascade_change_theme.add_command(label="vista", command=lambda: self.styleWidgetConfigLabel.theme_use("vista"))
            cascade_change_theme.add_command(label="winnative", command=lambda: self.styleWidgetConfigLabel.theme_use("winnative"))
            cascade_change_theme.add_command(label="xpnative", command=lambda: self.styleWidgetConfigLabel.theme_use("xpnative"))

            command4Beautify = Menu()
            command4Beautify.add_separator()
            command4Beautify.add_command(label = "Default Theme", command=lambda: self.styleWidgetConfigLabel.theme_use("vista"))
            command4Beautify.add_cascade(label = "Change Theme", menu = cascade_change_theme)
            command4Beautify.add_separator()

            ### comms for Window Setup
            def command4winConfig():
                global winsetupObject
                winsetupObject = DesignWindowSetup()
            command4Window = Menu()
            command4Window.add_command(label = "Window Setup", command = command4winConfig)


            Menu_main.add_cascade(label="Code Gen", menu=command4Code_Gen)  ### CodeGen cass
            Menu_main.add_cascade(label="Beautify", menu = command4Beautify) ### Beautify cass
            Menu_main.add_cascade(label="Edit")
            Menu_main.add_cascade(label="Window", menu = command4Window)
            master.config(menu=Menu_main)  ##### Configure main menu widget to window

            self.toplevel4WidgetToolkit()  #####Run Widget Toolkit Toplevel

        def toplevel4WidgetToolkit(self):  ####### Creates Wigets Toolkit Window and All Inside It
            ####### Top level for Widget Toolkit
            toplevelWidgetToolkit = Toplevel(self.master)
            toplevelWidgetToolkit.transient(self.master)
            toplevelWidgetToolkit.geometry("%dx%d+%d+%d" % (207, screen_height/1.105, screen_width/168, screen_height/35))
            toplevelWidgetToolkit.title("Widgets Toolkit")
            toplevelWidgetToolkit.resizable(False, True)
            print(toplevelWidgetToolkit.winfo_screenwidth())
            ####### Scrollbar for Main Widgets
            scrollbarWidgetToolkit = ttk.Scrollbar(toplevelWidgetToolkit, )
            scrollbarWidgetToolkit.pack(side=RIGHT, fill=Y)

            ####### Canvas for Widget Toolkit
            canvasWidgetToolkit = Canvas(toplevelWidgetToolkit, highlightthickness=0,
                                         yscrollcommand=scrollbarWidgetToolkit.set, width=207,
                                         height=screen_height/1.105)
            canvasWidgetToolkit.pack(side=LEFT, )

            ####### Frame to contain all Main Widgets
            frameWidgetToolkit = ttk.Frame(canvasWidgetToolkit)
            frameWidgetToolkit.pack()
            # n, ne, e, se, s, sw, w, nw, or center
            canvasWidgetToolkit.create_window((0, 0), window=frameWidgetToolkit, anchor=NW)

            scrollbarWidgetToolkit.config(
                command=canvasWidgetToolkit.yview)  #### Set scrollbarWidgetToolkit for canvasWidgetToolkit

            toplevelWidgetToolkit.bind("<Configure>", lambda event: canvasWidgetToolkit.config(
                scrollregion=canvasWidgetToolkit.bbox(ALL)))  #### Bind Scroll region to Configure Event

            ######### Widgets Placement for the Widget Toolkit

            ### All Main Widgets Here

            # Label  for Tk Widgets
            label_tk_widgets = ttk.Label(frameWidgetToolkit, text="tk Widgets", font=("Onyx", 15, "bold"))
            label_tk_widgets.pack(anchor=N, pady=5)

            # Main Button Widget
            self.widget_button = ttk.Button(frameWidgetToolkit, text="Button", style="main.TButton",
                                            command=lambda: self.determineButton("button"))
            self.widget_button.pack(anchor=W, )

            # Main Checkbutton Widget
            widget_checkbutton = ttk.Button(frameWidgetToolkit, text="Checkbutton", style="main.TButton",
                                            command=lambda: self.determineCheckbutton("checkbutton"))
            widget_checkbutton.pack(anchor=W, )

            # Main Entry Widget
            widget_entry = ttk.Button(frameWidgetToolkit, text="Entry", style="main.TButton",
                                      command=lambda: self.determineEntry("entry"))
            widget_entry.pack(anchor=W, )

            # Main Label Widget
            widget_label = ttk.Button(frameWidgetToolkit, text="Label", style="main.TButton",
                                      command=lambda: self.determineLabel("label"))
            widget_label.pack(anchor=W, )

            # Main Listbox Widget
            widget_listbox = ttk.Button(frameWidgetToolkit, text="Listbox", style="main.TButton",
                                        command=lambda: self.determineListbox("listbox"))
            widget_listbox.pack(anchor=W)

            # Main Menu Widget
            widget_menu = ttk.Button(frameWidgetToolkit, text="Menu", style="main.TButton", command=self.mainMenu)
            widget_menu.pack(anchor=W)

            # Main Menubutton Widget
            widget_menubutton = ttk.Button(frameWidgetToolkit, text="Menubutton", style="main.TButton",
                                           command=lambda: self.determineMenubutton("menubutton"))
            widget_menubutton.pack(anchor=W)

            # Main Message Widget
            widget_message = ttk.Button(frameWidgetToolkit, text="Message", style="main.TButton",
                                        command=lambda: self.determineMessage("message"))
            widget_message.pack(anchor=W)

            # Main OptionMenu Widget
            widget_optionmenu = ttk.Button(frameWidgetToolkit, text="OptionMenu", style="main.TButton",
                                           command=lambda: self.mainOptionMenu("optionmenu"))
            widget_optionmenu.pack(anchor=W)

            # Main Radiobutton Widget
            widget_radiobutton = ttk.Button(frameWidgetToolkit, text="Radiobutton", style="main.TButton",
                                            command=lambda: self.determineRadiobutton("radiobutton"))
            widget_radiobutton.pack(anchor=W, )

            # Main Scale - Horizontal
            widget_scalehorizontal = ttk.Button(frameWidgetToolkit, text="Scale - Horizontal", style="main.TButton",
                                                command=lambda: self.determineScale("scale_horizontal"))
            widget_scalehorizontal.pack(anchor=W, )

            # Main Scale - Vertical
            widget_scalevertical = ttk.Button(frameWidgetToolkit, text="Scale - Vertical", style="main.TButton",
                                              command=lambda: self.determineScale("scale_vertical"))
            widget_scalevertical.pack(anchor=W, )

            # Main Scrollbar - Horizontal
            widget_scrollbar = ttk.Button(frameWidgetToolkit, text="Scrollbar - Horizontal", style="main.TButton",
                                          command=lambda: self.determineScrollbar("scrollbar"))
            widget_scrollbar.pack(anchor=W)

            # Main Scrollbar - Vertical
            widget_scrollbar = ttk.Button(frameWidgetToolkit, text="Scrollbar - Vertical", style="main.TButton",
                                          command=lambda: self.determineScrollbar("scrollbar"))
            widget_scrollbar.pack(anchor=W)

            # Main Spinbox Widget
            widget_spinbox = ttk.Button(frameWidgetToolkit, text="Spinbox", style="main.TButton",
                                        command=lambda: self.determineSpinbox("spinbox"))
            widget_spinbox.pack(anchor=W, )

            # Main Text Widget
            widget_text = ttk.Button(frameWidgetToolkit, text="Text", style="main.TButton",
                                     command=lambda: self.determineText("text"))
            widget_text.pack(anchor=W, )

            # Label for Tk Containers
            label_tk_containers = ttk.Label(frameWidgetToolkit, text="tk Containers", font=("Onyx", 15, "bold"))
            label_tk_containers.pack(anchor=N, pady=5)

            # Main Frame Contain
            widget_frame = ttk.Button(frameWidgetToolkit, text="Frame", style="main.TButton",
                                      command=lambda: self.determineFrame("frame"))
            widget_frame.pack(anchor=W, )

            # Main LabelFrame Contain
            widget_labelframe = ttk.Button(frameWidgetToolkit, text="LabelFrame", style="main.TButton",
                                           command=lambda: self.determineLabelFrame("labelframe"))
            widget_labelframe.pack(anchor=W, )

            # Main PanedWindow Contain
            widget_panedwindow = ttk.Button(frameWidgetToolkit, text="PanedWindow", style="main.TButton",
                                            command=lambda: self.determinePanedWindow("panedwindow"))
            widget_panedwindow.pack(anchor=W, )

            # Main Toplevel Contain
            widget_toplevel = ttk.Button(frameWidgetToolkit, text="Toplevel", style="main.TButton",
                                         command=lambda: self.determineToplevel("toplevel"))
            widget_toplevel.pack(anchor=W, )

            # Styling for Main Buttons
            style_main_buttons = ttk.Style()
            style_main_buttons.configure("main.TButton", width=30, anchor=W, )

        def toplevel4WidgetConfig(self):  ############ Contains Attributes available in all Widgets Classes

            self.clickWidgetConfig = 1  #### Variable that determines if WidgetConfig Window has been opened earlier

            ###### Top level for Widgets Config toplevel
            self.toplevelWidgetConfig = Toplevel(self.master, name = "!toplevel_attr_editor")
            self.toplevelWidgetConfig.transient(self.master)
            self.toplevelWidgetConfig.title("Widgets Config")
            self.toplevelWidgetConfig.geometry(
                "%dx%d+%d+%d" % (280, screen_height/1.105, screen_width-300, screen_height/35))
            self.toplevelWidgetConfig.resizable(False, True)

            ### Canvas for Widget Config Toplevel
            canvasWidgetConfig = Canvas(self.toplevelWidgetConfig, width=265, height=screen_height/1.1052,
                                        highlightthickness=0)
            canvasWidgetConfig.pack(side=LEFT)

            ### Frame to host All Widgets in Widget Config Toplevel
            self.frameWidgetConfig = ttk.Frame(canvasWidgetConfig)
            self.frameWidgetConfig.pack(fill = BOTH, expand = 1)

            ### Scrollbar to scroll Frame and hence all Widgets inside it
            scrollbarWidgetConfig = ttk.Scrollbar(self.toplevelWidgetConfig, orient=VERTICAL, command=canvasWidgetConfig.yview)
            scrollbarWidgetConfig.pack(side=RIGHT, fill=Y)

            canvasWidgetConfig.create_window((0, 0), window=self.frameWidgetConfig,
                                             anchor=NW)  ### Canvas Window to host self.frameWidgetConfig

            canvasWidgetConfig.config(
                yscrollcommand=scrollbarWidgetConfig.set)  ###### Set scrollbarWidgetConfig to canvasWidgetConfig

            self.toplevelWidgetConfig.bind("<Configure>", lambda event: canvasWidgetConfig.config(
                scrollregion=canvasWidgetConfig.bbox(ALL)))  #### Bind Scroll region to Configure Event

            # ATTRIBUTES DISPLAY AND EDIT
            ### Edit Attributes Label section
            label4edit_attributes = ttk.Label(self.frameWidgetConfig, text="Edit Attributes", font=("Onyx", 15, "bold"))
            label4edit_attributes.grid(row=100, column=1, sticky=N, columnspan=2, pady=5)

            ### Widget Variable Section
            label4widget_variable = ttk.Label(self.frameWidgetConfig, text="Widget\nVariable", style="widgetconfig.TLabel")
            label4widget_variable.grid(row=101, column=1, sticky=W)
            frame4widget_variable = ttk.Frame(self.frameWidgetConfig)
            frame4widget_variable.grid(row=101, column=2)
            self.entry4widget_variable = Entry(frame4widget_variable, relief=FLAT, disabledbackground = "white")
            self.entry4widget_variable.pack(side=LEFT, padx=3)

            blank_label4command = ttk.Label(frame4widget_variable, text="", anchor=W, width=3)
            blank_label4command.pack(side=LEFT)

            ### activebackground Sec
            def color4activebackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4activebackground.delete(0, END)
                windowObject.entry4activebackground.insert(END, color)

            self.label4activebackground = ttk.Label(self.frameWidgetConfig, text="active\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4activebackground.grid(sticky=W, row=105, column=1)
            self.frame4activebackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4activebackground.grid(row=105, column=2)
            self.entry4activebackground = Entry(self.frame4activebackground, relief=FLAT)
            self.entry4activebackground.pack(side=LEFT, padx=3)
            button4activebackground = ttk.Button(self.frame4activebackground, text=">>", style="moreOptions.TButton",
                                                 command = color4activebackground)
            button4activebackground.pack(side=LEFT)

            ### activeforeground Sec
            def color4activeforeground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4activeforeground.delete(0, END)
                windowObject.entry4activeforeground.insert(END, color)

            self.label4activeforeground = ttk.Label(self.frameWidgetConfig, text="active\nforeground",
                                                    style="widgetconfig.TLabel")
            self.label4activeforeground.grid(sticky=W, row=110, column=1)
            self.frame4activeforeground = ttk.Frame(self.frameWidgetConfig)
            self.frame4activeforeground.grid(row=110, column=2)
            self.entry4activeforeground = Entry(self.frame4activeforeground, )
            self.entry4activeforeground.pack(side=LEFT, padx=3)
            button4activeforeground = ttk.Button(self.frame4activeforeground, text=">>", style="moreOptions.TButton",
                                                 command = color4activeforeground)
            button4activeforeground.pack(side=LEFT)

            ### activestyle Sec
            activestyles = ("dotbox", "none", "underline")
            self.label4activestyle = ttk.Label(self.frameWidgetConfig, text="active\nstyle", style="widgetconfig.TLabel")
            self.label4activestyle.grid(sticky=W, row=120, column=1)
            self.combo4activestyle = ttk.Combobox(self.frameWidgetConfig, values=activestyles)
            self.combo4activestyle.grid(row=120, column=2, ipadx=5)

            ### anchor Sec
            anchors = ("nw", "n", "ne", "w", "center", "e", "sw", "s", "se")
            self.label4anchor = ttk.Label(self.frameWidgetConfig, text="anchor", style="widgetconfig.TLabel")
            self.label4anchor.grid(sticky=W, row=200, column=1)
            self.combo4anchor = ttk.Combobox(self.frameWidgetConfig, values = anchors)
            self.combo4anchor.grid(row=200, column=2, ipadx=5)

            ### aspect Sec
            def command4aspect(new_value):
                new_value = self.int_aspect.get()
                windowObject.int_aspect.set(new_value)

            self.int_aspect = IntVar(value = 100)
            self.label4aspect = ttk.Label(self.frameWidgetConfig, text = "aspect", style = "widgetconfig.TLabel")
            self.label4aspect.grid(sticky = W, row = 250, column = 1)
            self.frame4aspect = Frame(self.frameWidgetConfig, )
            self.frame4aspect.grid(sticky = W, row = 250, column = 2, padx = 25)
            self.label24aspect = Label(self.frame4aspect, text = self.int_aspect.get(), textvariable = self.int_aspect)
            self.label24aspect.pack()
            self.scale4aspect = ttk.Scale(self.frame4aspect, from_ = 1, to = 1000, orient = HORIZONTAL,
                                                variable = self.int_aspect, command = command4aspect)
            self.scale4aspect.pack()

            ### autoseparators
            self.bool_autoseparators = BooleanVar()
            self.bool_autoseparators.set(True)
            self.label4autoseparators = ttk.Label(self.frameWidgetConfig, text="auto\nseparators",
                                                   style="widgetconfig.TLabel")
            self.label4autoseparators.grid(sticky=W, row=260, column=1)
            self.frame4autoseparators = ttk.Frame(self.frameWidgetConfig)
            self.frame4autoseparators.grid(row=260, column=2)
            radioTrue4autoseparators = ttk.Radiobutton(self.frame4autoseparators, text="True",
                                                        variable=self.bool_autoseparators, value=True)
            radioTrue4autoseparators.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4autoseparators = ttk.Radiobutton(self.frame4autoseparators, text="False",
                                                         variable=self.bool_autoseparators, value=False)
            radioFalse4autoseparators.grid(sticky=E, row=1, column=2, padx=20)

            ### background Sec
            def color4background():
                color = colorchooser.askcolor()[1]
                windowObject.entry4background.delete(0, END)
                windowObject.entry4background.insert(END, color)

            self.label4background = ttk.Label(self.frameWidgetConfig, text="background", style="widgetconfig.TLabel")
            self.label4background.grid(sticky=W, row=300, column=1)
            self.frame4background = ttk.Frame(self.frameWidgetConfig)
            self.frame4background.grid(row=300, column=2)
            self.entry4background = Entry(self.frame4background, relief=FLAT)
            self.entry4background.pack(side=LEFT, padx=3)
            button4background = ttk.Button(self.frame4background, text=">>", style="moreOptions.TButton",
                                           command = color4background)
            button4background.pack(side=LEFT)

            ### bitmap Sec
            bitmaps = ("error", "gray75", "gray50", "gray25", "gray12", "hourglass", "info", "questhead", "question",
                       "warning")
            self.label4bitmap = ttk.Label(self.frameWidgetConfig, text="bitmap", style="widgetconfig.TLabel")
            self.label4bitmap.grid(sticky=W, row=400, column=1)
            self.combo4bitmap = ttk.Combobox(self.frameWidgetConfig, values = bitmaps)
            self.combo4bitmap.grid(row=400, column=2, ipadx=5)

            ### blockcursor Sec
            self.bool_blockcursor = BooleanVar()
            self.bool_blockcursor.set(True)
            self.label4blockcursor = ttk.Label(self.frameWidgetConfig, text="blockcursor",
                                                  style="widgetconfig.TLabel")
            self.label4blockcursor.grid(sticky=W, row=410, column=1)
            self.frame4blockcursor = ttk.Frame(self.frameWidgetConfig)
            self.frame4blockcursor.grid(row=410, column=2)
            radioTrue4blockcursor = ttk.Radiobutton(self.frame4blockcursor, text="True",
                                                       variable=self.bool_blockcursor, value=True)
            radioTrue4blockcursor.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4blockcursor = ttk.Radiobutton(self.frame4blockcursor, text="False",
                                                        variable=self.bool_blockcursor, value=False)
            radioFalse4blockcursor.grid(sticky=E, row=1, column=2, padx=20)

            ### borderwidth Sec
            # self.int_borderwidth = IntVar()
            # self.int_borderwidth.set("")
            self.label4borderwidth = ttk.Label(self.frameWidgetConfig, text="borderwidth", style="widgetconfig.TLabel")
            self.label4borderwidth.grid(sticky=W, row=500, column=1)
            self.spinbox4borderwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=200, increment=2, width=10, wrap=True)
                                                   # textvariable = self.int_borderwidth)
            self.spinbox4borderwidth.grid(row=500, column=2)

            ### buttonbackground Sec
            def color4buttonbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4buttonbackground.delete(0, END)
                windowObject.entry4buttonbackground.insert(END, color)

            self.label4buttonbackground = ttk.Label(self.frameWidgetConfig, text="button\nbackground", style="widgetconfig.TLabel")
            self.label4buttonbackground.grid(sticky=W, row=505, column=1)
            self.frame4buttonbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4buttonbackground.grid(row=505, column=2)
            self.entry4buttonbackground = Entry(self.frame4buttonbackground, relief=FLAT)
            self.entry4buttonbackground.pack(side=LEFT, padx=3)
            button4buttonbackground = ttk.Button(self.frame4buttonbackground, text=">>", style="moreOptions.TButton",
                                                 command = color4buttonbackground)
            button4buttonbackground.pack(side=LEFT)

            ### buttoncursor Sec
            buttoncursors = ( "arrow", "based_arrow_down", "based_arrow_up", "boat", "bogosity", "bottom_left_corner",
                              "bottom_right_corner", "bottom_side", "bottom_tee", "box_spiral", "center_ptr", "circle",
                              "clock", "coffee_mug", "cross",
            "cross_reverse", "crosshair", "diamond_cross", "dot", "dotbox", "double_arrow", "draft_large", "draft_small",
            "draped_box", "exchange", "fleur", "gobbler", "gumby", "hand1", "hand2", "heart", "icon", "iron_cross",
            "left_ptr", "left_side", "left_tee", "leftbutton", "ll_angle", "lr_angle", "man", "middlebutton", "mouse",
            "pencil", "pirate", "plus", "question_arrow", "right_ptr", "right_side", "right_tee", "rightbutton",
            "rtl_logo", "sailboat", "sb_down_arrow", "sb_h_double_arrow", "sb_left_arrow", "sb_right_arrow", "sb_up_arrow",
            "sb_v_double_arrow", "shuttle", "sizing", "spider", "spraycan", "star", "target", "tcross", "top_left_arrow",
            "top_left_corner", "top_right_corner", "top_side", "top_tee", "trek", "ul_angle", "umbrella", "ur_angle",
            "watch", "xterm", "X_cursor")
            self.label4buttoncursor = ttk.Label(self.frameWidgetConfig, text="button\ncursor", style="widgetconfig.TLabel")
            self.label4buttoncursor.grid(sticky=W, row=510, column=1)
            self.combo4buttoncursor = ttk.Combobox(self.frameWidgetConfig, values=buttoncursors)
            self.combo4buttoncursor.grid(row=510, column=2, ipadx=5)

            ### buttondownrelief Sec
            buttondownreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4buttondownrelief = ttk.Label(self.frameWidgetConfig, text="buttondown\nrelief", style="widgetconfig.TLabel")
            self.label4buttondownrelief.grid(sticky=W, row=515, column=1)
            self.combo4buttondownrelief = ttk.Combobox(self.frameWidgetConfig, values=buttondownreliefs)
            self.combo4buttondownrelief.grid(row=515, column=2, ipadx=5)

            ### buttonuprelief Sec
            buttonupreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4buttonuprelief = ttk.Label(self.frameWidgetConfig, text="buttonup\nrelief", style="widgetconfig.TLabel")
            self.label4buttonuprelief.grid(sticky=W, row=520, column=1)
            self.combo4buttonuprelief = ttk.Combobox(self.frameWidgetConfig, values=buttonupreliefs)
            self.combo4buttonuprelief.grid(row=520, column=2, ipadx=5)

            ### command Sec
            self.label4command = ttk.Label(self.frameWidgetConfig, text="command", style="widgetconfig.TLabel")
            self.label4command.grid(sticky=W, row=600, column=1)
            self.frame4command = ttk.Frame(self.frameWidgetConfig)
            self.frame4command.grid(row=600, column=2)
            self.entry4command = Entry(self.frame4command, relief=FLAT, )
            self.entry4command.pack(side=LEFT, padx=3)
            blank_label4command = ttk.Label(self.frame4command, text="", anchor=W, width=3)
            blank_label4command.pack(side=LEFT)

            ### compound Sec
            compounds = ("bottom", "center", "left", "right", "top")
            self.label4compound = ttk.Label(self.frameWidgetConfig, text="compound", style="widgetconfig.TLabel")
            self.label4compound.grid(sticky=W, row=610, column=1)
            self.combo4compound = ttk.Combobox(self.frameWidgetConfig, values = compounds)
            self.combo4compound.grid(row=610, column=2, ipadx=5)

            ### Cursor Sec
            cursors = ("arrow", "based_arrow_down", "based_arrow_up", "boat", "bogosity", "bottom_left_corner", "bottom_right_corner",
             "bottom_side", "bottom_tee", "box_spiral", "center_ptr", "circle", "clock", "coffee_mug", "cross",
             "cross_reverse", "crosshair", "diamond_cross", "dot", "dotbox", "double_arrow", "draft_large", "draft_small",
             "draped_box", "exchange", "fleur", "gobbler", "gumby", "hand1", "hand2", "heart", "icon", "iron_cross",
             "left_ptr", "left_side", "left_tee", "leftbutton", "ll_angle", "lr_angle", "man", "middlebutton", "mouse",
             "pencil", "pirate", "plus", "question_arrow", "right_ptr", "right_side", "right_tee", "rightbutton",
             "rtl_logo", "sailboat", "sb_down_arrow", "sb_h_double_arrow", "sb_left_arrow", "sb_right_arrow", "sb_up_arrow",
             "sb_v_double_arrow", "shuttle", "sizing", "spider", "spraycan", "star", "target", "tcross", "top_left_arrow",
             "top_left_corner", "top_right_corner", "top_side", "top_tee", "trek", "ul_angle", "umbrella", "ur_angle",
             "watch", "xterm", "X_cursor")
            self.label4cursor = ttk.Label(self.frameWidgetConfig, text="cursor", style="widgetconfig.TLabel")
            self.label4cursor.grid(sticky=W, row=700, column=1)
            self.combo4cursor = ttk.Combobox(self.frameWidgetConfig, values = cursors)
            self.combo4cursor.grid(row=700, column=2, ipadx=5)

            ### digits Sec
            # self.int_digits = IntVar(value = "")
            self.label4digits = ttk.Label(self.frameWidgetConfig, text="digits",
                                                      style="widgetconfig.TLabel")
            self.label4digits.grid(sticky=W, row=701, column=1)
            self.spinbox4digits = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=17, increment=1, width=10, wrap=True)
                                                          # textvariable = self.int_digits)
            self.spinbox4digits.grid(row=701, column=2)

            ### direction Sec
            directions = ("above", "below", "left", "right")
            self.label4direction = ttk.Label(self.frameWidgetConfig, text="direction", style="widgetconfig.TLabel")
            self.label4direction.grid(sticky=W, row=705, column=1)
            self.combo4direction = ttk.Combobox(self.frameWidgetConfig, values=directions)
            self.combo4direction.grid(row=705, column=2, ipadx=5)

            ### disabledbackground Sec
            def color4disabledbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4disabledbackground.delete(0, END)
                windowObject.entry4disabledbackground.insert(END, color)

            self.label4disabledbackground = ttk.Label(self.frameWidgetConfig, text="disabled\nbackground",
                                                      style="widgetconfig.TLabel")
            self.label4disabledbackground.grid(sticky=W, row=710, column=1)
            self.frame4disabledbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4disabledbackground.grid(row=710, column=2)
            self.entry4disabledbackground = Entry(self.frame4disabledbackground, relief=FLAT)
            self.entry4disabledbackground.pack(side=LEFT, padx=3)
            button4disabledbackground = ttk.Button(self.frame4disabledbackground, text=">>", style="moreOptions.TButton",
                                                   command = color4disabledbackground)
            button4disabledbackground.pack(side=LEFT)

            ### disabledforeground
            def color4disabledforeground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4disabledforeground.delete(0, END)
                windowObject.entry4disabledforeground.insert(END,color)

            self.label4disabledforeground = ttk.Label(self.frameWidgetConfig, text="disabled\nforeground",
                                                      style="widgetconfig.TLabel")
            self.label4disabledforeground.grid(sticky=W, row=800, column=1)
            self.frame4disabledforeground = ttk.Frame(self.frameWidgetConfig)
            self.frame4disabledforeground.grid(row=800, column=2)
            self.entry4disabledforeground = Entry(self.frame4disabledforeground, relief=FLAT)
            self.entry4disabledforeground.pack(side=LEFT, padx=3)
            button4disabledforeground = ttk.Button(self.frame4disabledforeground, text=">>", style="moreOptions.TButton",
                                                   command = color4disabledforeground)
            button4disabledforeground.pack(side=LEFT)

            ### exportselection
            self.bool_exportselection = BooleanVar()
            self.bool_exportselection.set(1)
            self.label4exportselection = ttk.Label(self.frameWidgetConfig, text="export\nselection",
                                                   style="widgetconfig.TLabel")
            self.label4exportselection.grid(sticky=W, row=810, column=1)
            self.frame4exportselection = ttk.Frame(self.frameWidgetConfig)
            self.frame4exportselection.grid(row=810, column=2)
            radioTrue4exportselection = ttk.Radiobutton(self.frame4exportselection, text="True",
                                                        variable=self.bool_exportselection, value=True)
            radioTrue4exportselection.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4exportselection = ttk.Radiobutton(self.frame4exportselection, text="False",
                                                         variable=self.bool_exportselection, value=False)
            radioFalse4exportselection.grid(sticky=E, row=1, column=2, padx=20)

            ### font Sec
            self.label4font = ttk.Label(self.frameWidgetConfig, text="font", style="widgetconfig.TLabel")
            self.label4font.grid(sticky=W, row=900, column=1)
            self.frame4font = ttk.Frame(self.frameWidgetConfig)
            self.frame4font.grid(row=900, column=2, )
            self.entry4font = Entry(self.frame4font, relief=FLAT)
            self.entry4font.pack(side=LEFT, padx=3)
            button4font = ttk.Button(self.frame4font, text=">>", style="moreOptions.TButton",
                                     command=self.executeFontToplevel)
            button4font.pack(side=LEFT)

            ### foreground Sec
            def color4foreground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4foreground.delete(0, END)
                windowObject.entry4foreground.insert(END,color)
            self.label4foreground = ttk.Label(self.frameWidgetConfig, text="foreground", style="widgetconfig.TLabel")
            self.label4foreground.grid(sticky=W, row=1000, column=1)
            self.frame4foreground = ttk.Frame(self.frameWidgetConfig)
            self.frame4foreground.grid(row=1000, column=2)
            self.entry4foreground = Entry(self.frame4foreground, relief=FLAT)
            self.entry4foreground.pack(side=LEFT, padx=3)
            button4foreground = ttk.Button(self.frame4foreground, text=">>", style="moreOptions.TButton",
                                           command = color4foreground)
            button4foreground.pack(side=LEFT)

            ### format Sec
            self.label4format = ttk.Label(self.frameWidgetConfig, text="format", style="widgetconfig.TLabel")
            self.label4format.grid(sticky=W, row=1010, column=1)
            self.frame4format = ttk.Frame(self.frameWidgetConfig)
            self.frame4format.grid(row=1010, column=2)
            self.entry4format = Entry(self.frame4format, relief=FLAT)
            self.entry4format.pack(side=LEFT, padx=3)
            blank_label4format = ttk.Label(self.frame4format, text="", anchor=W, width=3)
            blank_label4format.pack(side=LEFT)

            ### from_ Sec
            # self.int_from_ = IntVar()
            self.label4from_ = ttk.Label(self.frameWidgetConfig, text="from_", style="widgetconfig.TLabel")
            self.label4from_.grid(sticky=W, row=1020, column=1)
            self.frame4from_ = ttk.Frame(self.frameWidgetConfig)
            self.frame4from_.grid(row=1020, column=2)
            self.entry4from_ = Entry(self.frame4from_, relief=FLAT,)
                                     # textvariable = self.int_from_)
            self.entry4from_.pack(side=LEFT, padx=3)
            blank_label4from_ = ttk.Label(self.frame4from_, text="", anchor=W, width=3)
            blank_label4from_.pack(side=LEFT)

            ### handlepad
            # self.int_handlepad = IntVar()
            # self.int_handlepad.set(8)
            self.label4handlepad = ttk.Label(self.frameWidgetConfig, text="handlepad", style="widgetconfig.TLabel")
            self.label4handlepad.grid(sticky=W, row=1030, column=1)
            self.spinbox4handlepad = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment=1, to=50, width=10, wrap=True,)
                                                 # textvariable = self.int_handlepad)
            self.spinbox4handlepad.insert(END, 8)
            self.spinbox4handlepad.grid(row=1030, column=2)

            ### handlesize
            # self.int_handlesize = IntVar(value = 8)
            self.label4handlesize = ttk.Label(self.frameWidgetConfig, text="handlesize", style="widgetconfig.TLabel")
            self.label4handlesize.grid(sticky=W, row=1040, column=1)
            self.spinbox4handlesize = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment=1, to=50, width=10, wrap=True,)
                                                  # textvariable = self.int_handlesize)
            self.spinbox4handlesize.insert(END, 8)
            self.spinbox4handlesize.grid(row=1040, column=2)

            ### height Sec
            self.label4height = ttk.Label(self.frameWidgetConfig, text="height", style="widgetconfig.TLabel")
            self.label4height.grid(sticky=W, row=1100, column=1)
            self.spinbox4height = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment = 5, to = self.label4height.winfo_screenheight(), width=10, wrap = True)
            self.spinbox4height.grid(row=1100, column=2)

            ### highlightbackground Sec
            def color4highlightbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4highlightbackground.delete(0, END)
                windowObject.entry4highlightbackground.insert(END,color)

            self.label4highlightbackground = ttk.Label(self.frameWidgetConfig, text="highlight\nbackground",
                                                       style="widgetconfig.TLabel", )
            self.label4highlightbackground.grid(sticky=W, row=1200, column=1)
            self.frame4highlightbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4highlightbackground.grid(row=1200, column=2)
            self.entry4highlightbackground = Entry(self.frame4highlightbackground, relief=FLAT)
            self.entry4highlightbackground.pack(side=LEFT, padx=3)
            button4highlightbackground = ttk.Button(self.frame4highlightbackground, text=">>", style="moreOptions.TButton",
                                                    command = color4highlightbackground)
            button4highlightbackground.pack(side=LEFT)

            ### highlightcolor Sec
            def color4highlightcolor():
                color = colorchooser.askcolor()[1]
                windowObject.entry4highlightcolor.delete(0, END)
                windowObject.entry4highlightcolor.insert(END,color)

            self.label4highlightcolor = ttk.Label(self.frameWidgetConfig, text="highlight\ncolor",
                                                  style="widgetconfig.TLabel")
            self.label4highlightcolor.grid(sticky=W, row=1300, column=1)
            self.frame4highlightcolor = ttk.Frame(self.frameWidgetConfig)
            self.frame4highlightcolor.grid(row=1300, column=2)
            self.entry4highlightcolor = Entry(self.frame4highlightcolor, relief=FLAT)
            self.entry4highlightcolor.pack(side=LEFT, padx=3)
            button4highlightcolor = ttk.Button(self.frame4highlightcolor, text=">>", style="moreOptions.TButton",
                                               command = color4highlightcolor)
            button4highlightcolor.pack(side=LEFT)

            ### highlightthickness Sec
            # self.int_highlightthickness = IntVar()
            self.label4highlightthickness = ttk.Label(self.frameWidgetConfig, text="highlight\nthickness",
                                                      style="widgetconfig.TLabel")
            self.label4highlightthickness.grid(sticky=W, row=1400, column=1)
            self.spinbox4highlightthickness = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                          wrap=True,)
                                                                    # textvariable = self.int_highlightthickness)
            self.spinbox4highlightthickness.grid(row=1400, column=2)

            ### image Sec
            # def command4scale_imagewidth(value):
            #     value = float(value)
            #     value = int(value)
            #     windowObject.dictCountImage[f"Image{windowObject.count_image_instances-1}"].config(width = value, height = value)
            # def command4scale_imageheight():
            #     pass

            def filedialog4image():
                file_get = filedialog.askopenfile(filetypes = [("Portable Network Graphics (PNG)", "*png")])

                try:
                    file_get.name
                # label_adjustimagewidth = ttk.Label(self.frameWidgetConfig, text = "adjust\nimage\nwidth",
                #                                    style = "widgetconfig.TLabel")
                # label_adjustimagewidth.grid(row = 1406, column = 1)
                # scale_imagewidth = ttk.Scale(self.frameWidgetConfig, from_ = 0, to = 999, command = command4scale_imagewidth)
                # scale_imagewidth.grid(row = 1406, column = 2,)
                #
                # label_adjustimageheight = ttk.Label(self.frameWidgetConfig, text="adjust\nimage\nheight",
                #                                     style="widgetconfig.TLabel")
                # label_adjustimageheight.grid(row=1407, column=1)
                # scale_imageheight = ttk.Scale(self.frameWidgetConfig, from_ = 0, to = 999)
                # scale_imageheight.grid(row = 1407, column = 2)
                except:
                    pass
                else:
                    windowObject.dictCountImage[f"Image{windowObject.count_image_instances}"] = PhotoImage(master = windowDesign,
                                                    file = file_get.name, name = f"image_{windowObject.count_image_instances}")
                    print(file_get.name)
                    windowObject.entry4image.delete(0, END)
                    windowObject.entry4image.insert(END, f"image_{windowObject.count_image_instances}")


                    windowObject.implementImage_determine = 22
                # except:
                #     pass
                # arrangeObject.refreshAttributes()
                # windowObject.count_image_instances += 1

            self.label4image = ttk.Label(self.frameWidgetConfig, text="image", style="widgetconfig.TLabel")
            self.label4image.grid(sticky=W, row=1405, column=1)
            self.frame4image = ttk.Frame(self.frameWidgetConfig)
            self.frame4image.grid(row=1405, column=2)
            self.entry4image = Entry(self.frame4image, relief=FLAT)
            self.entry4image.pack(side=LEFT, padx=3)
            button4image = ttk.Button(self.frame4image, text=">>", style="moreOptions.TButton", command = filedialog4image)
            button4image.pack(side=LEFT)

            ### inactiveselectbackground Sec
            def color4inactiveselectbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4inactiveselectbackground.delete(0, END)
                windowObject.entry4inactiveselectbackground.insert(END,color)

            self.label4inactiveselectbackground = ttk.Label(self.frameWidgetConfig, text="inactive\nselect\nbackground",
                                                            style="widgetconfig.TLabel")
            self.label4inactiveselectbackground.grid(sticky=W, row=1409, column=1)
            self.frame4inactiveselectbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4inactiveselectbackground.grid(row=1409, column=2)
            self.entry4inactiveselectbackground = Entry(self.frame4inactiveselectbackground, relief=FLAT)
            self.entry4inactiveselectbackground.pack(side=LEFT, padx=3)
            button4inactiveselectbackground = ttk.Button(self.frame4inactiveselectbackground, text=">>",
                                                    style="moreOptions.TButton", command = color4inactiveselectbackground)
            button4inactiveselectbackground.pack(side=LEFT)


            ### increment Sec
            # self.int_increment = IntVar()
            self.label4increment = ttk.Label(self.frameWidgetConfig, text="increment", style="widgetconfig.TLabel")
            self.label4increment.grid(sticky=W, row=1411, column=1)
            self.frame4increment = ttk.Frame(self.frameWidgetConfig)
            self.frame4increment.grid(row=1411, column=2)
            self.entry4increment = Entry(self.frame4increment, relief=FLAT, )
                                         # textvariable = self.int_increment)
            self.entry4increment.pack(side=LEFT, padx=3)
            button4increment = ttk.Button(self.frame4increment, text=">>", style="moreOptions.TButton")
            button4increment.pack(side=LEFT)

            ### indicatoron Sec
            self.bool_indicatoron = BooleanVar()
            self.bool_indicatoron.set(1)
            self.label4indicatoron = ttk.Label(self.frameWidgetConfig, text="indicatoron", style="widgetconfig.TLabel")
            self.label4indicatoron.grid(sticky=W, row=1412, column=1)
            self.frame4indicatoron = ttk.Frame(self.frameWidgetConfig)
            self.frame4indicatoron.grid(row=1412, column=2)
            radioTrue4indicatoron = ttk.Radiobutton(self.frame4indicatoron, text="True", variable=self.bool_indicatoron,
                                                  value=True)
            radioTrue4indicatoron.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4indicatoron = ttk.Radiobutton(self.frame4indicatoron, text="False", variable=self.bool_indicatoron,
                                                   value=False)
            radioFalse4indicatoron.grid(sticky=E, row=1, column=2, padx=20)

            ### insertbackground Sec
            def color4insertbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4insertbackground.delete(0, END)
                windowObject.entry4insertbackground.insert(END, color)

            self.label4insertbackground = ttk.Label(self.frameWidgetConfig, text="insert\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4insertbackground.grid(sticky=W, row=1415, column=1)
            self.frame4insertbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4insertbackground.grid(row=1415, column=2)
            self.entry4insertbackground = Entry(self.frame4insertbackground, relief=FLAT)
            self.entry4insertbackground.pack(side=LEFT, padx=3)
            button4insertbackground = ttk.Button(self.frame4insertbackground, text=">>", style="moreOptions.TButton",
                                                 command = color4insertbackground)
            button4insertbackground.pack(side=LEFT)

            ### insertborderwidth Sec
            # self.int_insertborderwidth = IntVar()
            self.label4insertborderwidth = ttk.Label(self.frameWidgetConfig, text="insert\nborderwidth",
                                                     style="widgetconfig.TLabel")
            self.label4insertborderwidth.grid(sticky=W, row=1420, column=1)
            self.spinbox4insertborderwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                         wrap=True,)
                                                         # textvariable = self.int_insertborderwidth)
            self.spinbox4insertborderwidth.grid(row=1420, column=2)

            ### insertofftime Sec
            # self.int_insertofftime = IntVar()
            self.label4insertofftime = ttk.Label(self.frameWidgetConfig, text="insert\nofftime",
                                                 style="widgetconfig.TLabel")
            self.label4insertofftime.grid(sticky=W, row=1425, column=1)
            self.spinbox4insertofftime = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                     wrap=True,)
                                                     # textvariable = self.int_insertofftime)
            self.spinbox4insertofftime.grid(row=1425, column=2)

            ### insertontime Sec
            # self.int_insertontime = IntVar()
            self.label4insertontime = ttk.Label(self.frameWidgetConfig, text="insert\nontime", style="widgetconfig.TLabel")
            self.label4insertontime.grid(sticky=W, row=1430, column=1)
            self.spinbox4insertontime = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                    wrap=True,)
                                                    # textvariable = self.int_insertontime)
            self.spinbox4insertontime.grid(row=1430, column=2)

            ### insertunfocussed
            insertunfocusseds = ("hollow", "solid", "none")
            self.label4insertunfoccussed = ttk.Label(self.frameWidgetConfig, text="insert\nunfocussed",
                                                     style="widgetconfig.TLabel")
            self.label4insertunfoccussed.grid(sticky=W, row=1431, column=1)
            self.combo4insertunfoccussed = ttk.Combobox(self.frameWidgetConfig, values=insertunfocusseds)
            self.combo4insertunfoccussed.grid(row=1431, column=2, ipadx=5)

            ### insertwidth Sec
            # self.int_insertwidth = IntVar()
            self.label4insertwidth = ttk.Label(self.frameWidgetConfig, text="insert\nwidth", style="widgetconfig.TLabel")
            self.label4insertwidth.grid(sticky=W, row=1435, column=1)
            self.spinbox4insertwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10, wrap=True)
                                                   # textvariable = self.int_insertwidth)
            self.spinbox4insertwidth.grid(row=1435, column=2)

            ### invalidcommand Sec
            self.label4invalidcommand = ttk.Label(self.frameWidgetConfig, text="invalid\ncommand",
                                                       style="widgetconfig.TLabel", )
            self.label4invalidcommand.grid(sticky=W, row=1450, column=1)
            self.frame4invalidcommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4invalidcommand.grid(row=1450, column=2)
            self.entry4invalidcommand = Entry(self.frame4invalidcommand, relief=FLAT)
            self.entry4invalidcommand.pack(side=LEFT, padx=3)
            button4invalidcommand = ttk.Button(self.frame4invalidcommand, text=">>", style="moreOptions.TButton")
            button4invalidcommand.pack(side=LEFT)

            ### Justify Sec
            justifys = ("left", "center", "right")
            self.label4justify = ttk.Label(self.frameWidgetConfig, text="justify", style="widgetconfig.TLabel")
            self.label4justify.grid(sticky=W, row=1460, column=1)
            self.combo4justify = ttk.Combobox(self.frameWidgetConfig, values = justifys)
            self.combo4justify.grid(row=1460, column=2, ipadx=5)

            ### label Sec
            self.label4label = ttk.Label(self.frameWidgetConfig, text="label", style="widgetconfig.TLabel")
            self.label4label.grid(sticky=W, row=1470, column=1)
            self.frame4label = ttk.Frame(self.frameWidgetConfig)
            self.frame4label.grid(row=1470, column=2)
            self.entry4label = Entry(self.frame4label, relief=FLAT)
            self.entry4label.pack(side=LEFT, padx=3)
            blank_label4label = ttk.Label(self.frame4label, text="", anchor=W, width=3)
            blank_label4label.pack(side=LEFT)

            ### labelanchor Sec
            labelanchors = ("nw", "n", "ne", "en", "e", "es", "wn", "w", "ws", "sw", "s", "se")
            self.label4labelanchor = ttk.Label(self.frameWidgetConfig, text="labelanchor", style="widgetconfig.TLabel")
            self.label4labelanchor.grid(sticky=W, row=1501, column=1)
            self.combo4labelanchor = ttk.Combobox(self.frameWidgetConfig, values=labelanchors)
            self.combo4labelanchor.grid(row=1501, column=2, ipadx=5)

            ### labelwidget Sec
            self.label4labelwidget = ttk.Label(self.frameWidgetConfig, text="labelwidget", style="widgetconfig.TLabel")
            self.label4labelwidget.grid(sticky=W, row=1502, column=1)
            self.frame4labelwidget = ttk.Frame(self.frameWidgetConfig)
            self.frame4labelwidget.grid(row=1502, column=2)
            self.entry4labelwidget = Entry(self.frame4labelwidget, relief=FLAT)
            self.entry4labelwidget.pack(side=LEFT, padx=3)
            blank_label4labelwidget = ttk.Label(self.frame4labelwidget, text="", anchor=W, width=3)
            blank_label4labelwidget.pack(side=LEFT)

            ### length Sec
            self.label4length = ttk.Label(self.frameWidgetConfig, text="length", style="widgetconfig.TLabel")
            self.label4length.grid(sticky=W, row=1503, column=1)
            self.spinbox4length = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=300, increment=2, width=10, wrap=True)
            self.spinbox4length.grid(row=1503, column=2)

            ### listvariable Sec
            self.label4listvariable = ttk.Label(self.frameWidgetConfig, text="list\nvariable",
                                                  style="widgetconfig.TLabel", )
            self.label4listvariable.grid(sticky=W, row=1504, column=1)
            self.frame4listvariable = ttk.Frame(self.frameWidgetConfig)
            self.frame4listvariable.grid(row=1504, column=2)
            self.entry4listvariable = Entry(self.frame4listvariable, relief=FLAT)
            self.entry4listvariable.pack(side=LEFT, padx=3)
            button4listvariable = ttk.Button(self.frame4listvariable, text=">>", style="moreOptions.TButton")
            button4listvariable.pack(side=LEFT)

            ### maxundo
            # self.int_maxundo = IntVar()
            self.label4maxundo = ttk.Label(self.frameWidgetConfig, text="maxundo", style="widgetconfig.TLabel")
            self.label4maxundo.grid(sticky=W, row=1505, column=1)
            self.frame4maxundo = ttk.Frame(self.frameWidgetConfig)
            self.frame4maxundo.grid(row=1505, column=2)
            self.entry4maxundo = Entry(self.frame4maxundo, relief=FLAT,)
                                       # textvariable = self.int_maxundo)
            self.entry4maxundo.pack(side=LEFT, padx=3)
            blank_label4maxundo = ttk.Label(self.frame4maxundo, text="", anchor=W, width=3)
            blank_label4maxundo.pack(side=LEFT)

            ### menu Sec
            self.label4menu = ttk.Label(self.frameWidgetConfig, text="menu",
                                                style="widgetconfig.TLabel", )
            self.label4menu.grid(sticky=W, row=1506, column=1)
            self.frame4menu = ttk.Frame(self.frameWidgetConfig)
            self.frame4menu.grid(row=1506, column=2)
            self.entry4menu = Entry(self.frame4menu, relief=FLAT)
            self.entry4menu.pack(side=LEFT, padx=3)
            button4menu = ttk.Button(self.frame4menu, text=">>", style="moreOptions.TButton")
            button4menu.pack(side=LEFT)

            ### offrelief Sec
            offreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4offrelief = ttk.Label(self.frameWidgetConfig, text="offrelief", style="widgetconfig.TLabel")
            self.label4offrelief.grid(sticky=W, row=1507, column=1)
            self.combo4offrelief = ttk.Combobox(self.frameWidgetConfig, values=offreliefs)
            self.combo4offrelief.grid(row=1507, column=2, ipadx=5)

            ### opaqueresize Sec
            self.bool_opaqueresize = BooleanVar()
            self.bool_opaqueresize.set(1)
            self.label4opaqueresize = ttk.Label(self.frameWidgetConfig, text="opaque\nresize", style="widgetconfig.TLabel")
            self.label4opaqueresize.grid(sticky=W, row=1508, column=1)
            self.frame4opaqueresize = ttk.Frame(self.frameWidgetConfig)
            self.frame4opaqueresize.grid(row=1508, column=2)
            radioTrue4opaqueresize = ttk.Radiobutton(self.frame4opaqueresize, text="True", variable=self.bool_opaqueresize,
                                                  value=True)
            radioTrue4opaqueresize.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4opaqueresize = ttk.Radiobutton(self.frame4opaqueresize, text="False", variable=self.bool_opaqueresize,
                                                   value=False)
            radioFalse4opaqueresize.grid(sticky=E, row=1, column=2, padx=20)

            ### orient Sec
            orient = ("horizontal", "vertical")
            self.label4orient = label4cursor = ttk.Label(self.frameWidgetConfig, text="orient", style="widgetconfig.TLabel")
            self.label4orient.grid(sticky=W, row=1510, column=1)
            self.combo4orient = ttk.Combobox(self.frameWidgetConfig, values = orient)
            self.combo4orient.grid(row=1510, column=2, ipadx=5)

            ### overrelief Sec
            overreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4overrelief = ttk.Label(self.frameWidgetConfig, text="overrelief", style="widgetconfig.TLabel")
            self.label4overrelief.grid(sticky=W, row=1515, column=1)
            self.combo4overrelief = ttk.Combobox(self.frameWidgetConfig, values = overreliefs)
            self.combo4overrelief.grid(row=1515, column=2, ipadx=5)

            ### padx Sec
            # self.int_padx = IntVar()
            self.label4padx = ttk.Label(self.frameWidgetConfig, text="padx", style="widgetconfig.TLabel")
            self.label4padx.grid(sticky=W, row=1600, column=1)
            self.spinbox4padx = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10, wrap=True)
                                            # textvariable = self.int_padx)
            self.spinbox4padx.grid(row=1600, column=2)

            ### pady Sec
            # self.int_pady = IntVar()
            self.label4pady = ttk.Label(self.frameWidgetConfig, text="pady", style="widgetconfig.TLabel")
            self.label4pady.grid(sticky=W, row=1700, column=1)
            self.spinbox4pady = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10, wrap=True,)
                                            # textvariable = self.int_pady)
            self.spinbox4pady.grid(row=1700, column=2)

            ### readonlybackground
            def color4readonlybackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4readonlybackground.delete(0, END)
                windowObject.entry4readonlybackground.insert(END,color)

            self.label4readonlybackground = ttk.Label(self.frameWidgetConfig, text="readonly\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4readonlybackground.grid(sticky=W, row=1710, column=1)
            self.frame4readonlybackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4readonlybackground.grid(row=1710, column=2)
            self.entry4readonlybackground = Entry(self.frame4readonlybackground, relief=FLAT)
            self.entry4readonlybackground.pack(side=LEFT, padx=3)
            button4readonlybackground = ttk.Button(self.frame4readonlybackground, text=">>", style="moreOptions.TButton",
                                                   command = color4readonlybackground)
            button4readonlybackground.pack(side=LEFT)

            ### relief Sec
            reliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4relief = ttk.Label(self.frameWidgetConfig, text="relief", style="widgetconfig.TLabel")
            self.label4relief.grid(sticky=W, row=1800, column=1)
            self.combo4relief = ttk.Combobox(self.frameWidgetConfig, values = reliefs)
            self.combo4relief.grid(row=1800, column=2, ipadx=5)

            ### repeatdelay Sec
            # self.int_repeatdelay = IntVar()
            self.label4repeatdelay = ttk.Label(self.frameWidgetConfig, text="repeat\ndelay", style="widgetconfig.TLabel")
            self.label4repeatdelay.grid(sticky=W, row=1815, column=1)
            self.spinbox4repeatdelay = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                   wrap=True,)
                                                   # textvariable = self.int_repeatdelay)
            self.spinbox4repeatdelay.grid(row=1815, column=2)

            ### repeatinterval
            # self.int_repeatinterval = IntVar()
            self.label4repeatinterval = ttk.Label(self.frameWidgetConfig, text="repeat\ninterval",
                                                  style="widgetconfig.TLabel")
            self.label4repeatinterval.grid(sticky=W, row=1820, column=1)
            self.spinbox4repeatinterval = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                      wrap=True,)
                                                      # textvariable = self.int_repeatinterval)
            self.spinbox4repeatinterval.grid(row=1820, column=2)

            ### resolution
            # self.int_resolution = IntVar()
            self.label4resolution = ttk.Label(self.frameWidgetConfig, text="resolution",
                                                      style="widgetconfig.TLabel")
            self.label4resolution.grid(sticky=W, row=1821, column=1)
            self.frame4resolution = ttk.Frame(self.frameWidgetConfig)
            self.frame4resolution.grid(row=1821, column=2)
            self.entry4resolution = Entry(self.frame4resolution, relief=FLAT,)
                                          # textvariable = self.int_resolution)
            self.entry4resolution.pack(side=LEFT, padx=3)
            blank_label4resolution = ttk.Label(self.frame4resolution, text="", anchor=W, width=3)
            blank_label4resolution.pack(side=LEFT)

            ### sashcursor
            sashcursors = (
            "arrow", "based_arrow_down", "based_arrow_up", "boat", "bogosity", "bottom_left_corner", "bottom_right_corner",
            "bottom_side", "bottom_tee", "box_spiral", "center_ptr", "circle", "clock", "coffee_mug", "cross",
            "cross_reverse", "crosshair", "diamond_cross", "dot", "dotbox", "double_arrow", "draft_large", "draft_small",
            "draped_box", "exchange", "fleur", "gobbler", "gumby", "hand1", "hand2", "heart", "icon", "iron_cross",
            "left_ptr", "left_side", "left_tee", "leftbutton", "ll_angle", "lr_angle", "man", "middlebutton", "mouse",
            "pencil", "pirate", "plus", "question_arrow", "right_ptr", "right_side", "right_tee", "rightbutton",
            "rtl_logo", "sailboat", "sb_down_arrow", "sb_h_double_arrow", "sb_left_arrow", "sb_right_arrow", "sb_up_arrow",
            "sb_v_double_arrow", "shuttle", "sizing", "spider", "spraycan", "star", "target", "tcross", "top_left_arrow",
            "top_left_corner", "top_right_corner", "top_side", "top_tee", "trek", "ul_angle", "umbrella", "ur_angle",
            "watch", "xterm", "X_cursor")
            self.label4sashcursor = ttk.Label(self.frameWidgetConfig, text="sash\ncursor", style="widgetconfig.TLabel")
            self.label4sashcursor.grid(sticky=W, row=1822, column=1)
            self.combo4sashcursor = ttk.Combobox(self.frameWidgetConfig, values=sashcursors)
            self.combo4sashcursor.grid(row=1822, column=2, ipadx=5)

            ### sashpad Sec
            def command4sashpad(new_value):
                new_value = self.int_sashpad.get()
                windowObject.int_sashpad.set(new_value)

            self.int_sashpad = IntVar(value = 0,)
            self.label4sashpad = ttk.Label(self.frameWidgetConfig, text = "sash\npad", style = "widgetconfig.TLabel")
            self.label4sashpad.grid(sticky = W, row = 1823, column = 1)
            self.frame4sashpad = Frame(self.frameWidgetConfig, )
            self.frame4sashpad.grid(sticky = W, row = 1823, column = 2, padx = 25)
            self.label24sashpad = Label(self.frame4sashpad, textvariable = self.int_sashpad)
            self.label24sashpad.pack()
            self.scale4sashpad = ttk.Scale(self.frame4sashpad, from_ = 1, to = 50,
                                                variable = self.int_sashpad, command = command4sashpad)
            self.scale4sashpad.pack()

            ### sashrelief Sec
            sashreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4sashrelief = ttk.Label(self.frameWidgetConfig, text="sash\nrelief", style="widgetconfig.TLabel")
            self.label4sashrelief.grid(sticky=W, row=1824, column=1)
            self.combo4sashrelief = ttk.Combobox(self.frameWidgetConfig, values=sashreliefs)
            self.combo4sashrelief.grid(row=1824, column=2, ipadx=5)

            ### sashwidth Sec
            def command4sashwidth(new_value):
                new_value = self.int_sashwidth.get()
                windowObject.int_sashwidth.set(new_value)

            self.int_sashwidth = IntVar(value = 3)
            self.label4sashwidth = ttk.Label(self.frameWidgetConfig, text = "sash\nwidth", style = "widgetconfig.TLabel")
            self.label4sashwidth.grid(sticky = W, row = 1825, column = 1)
            self.frame4sashwidth = Frame(self.frameWidgetConfig, )
            self.frame4sashwidth.grid(sticky = W, row = 1825, column = 2, padx = 25)
            self.label24sashwidth = Label(self.frame4sashwidth, textvariable = self.int_sashwidth)
            self.label24sashwidth.pack()
            self.scale4sashwidth = ttk.Scale(self.frame4sashwidth, from_ = 1, to = 50,
                                                variable = self.int_sashwidth, command = command4sashwidth)
            self.scale4sashwidth.pack()

            ### showhandle Sec
            self.bool_showhandle = BooleanVar()
            self.bool_showhandle.set(True)
            self.label4showhandle = ttk.Label(self.frameWidgetConfig, text="show\nhandle", style="widgetconfig.TLabel")
            self.label4showhandle.grid(sticky=W, row=1826, column=1)
            self.frame4showhandle = ttk.Frame(self.frameWidgetConfig)
            self.frame4showhandle.grid(row=1826, column=2)
            radioTrue4showhandle = ttk.Radiobutton(self.frame4showhandle, text="True", variable=self.bool_showhandle,
                                                     value=True)
            radioTrue4showhandle.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4showhandle = ttk.Radiobutton(self.frame4showhandle, text="False",
                                                      variable=self.bool_showhandle,
                                                      value=False)
            radioFalse4showhandle.grid(sticky=E, row=1, column=2, padx=20)


            ### selectbackground Sec
            def color4selectbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4selectbackground.delete(0, END)
                windowObject.entry4selectbackground.insert(END,color)
            self.label4selectbackground = ttk.Label(self.frameWidgetConfig, text="select\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4selectbackground.grid(sticky=W, row=1828, column=1)
            self.frame4selectbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectbackground.grid(row=1828, column=2)
            self.entry4selectbackground = Entry(self.frame4selectbackground, relief=FLAT)
            self.entry4selectbackground.pack(side=LEFT, padx=3)
            button4selectbackground = ttk.Button(self.frame4selectbackground, text=">>", style="moreOptions.TButton",
                                                 command = color4selectbackground)
            button4selectbackground.pack(side=LEFT)

            ### selectborderwidth Sec
            # self.int_selectborderwidth = IntVar()
            self.label4selectborderwidth = ttk.Label(self.frameWidgetConfig, text="select\nborderwidth",
                                                     style="widgetconfig.TLabel")
            self.label4selectborderwidth.grid(sticky=W, row=1830, column=1)
            self.spinbox4selectborderwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                         wrap=True,)
                                                         # textvariable = self.int_selectborderwidth)
            self.spinbox4selectborderwidth.grid(row=1830, column=2)

            ### selectcolor Sec
            def color4selectcolor():
                color = colorchooser.askcolor()[1]
                windowObject.entry4selectcolor.delete(0, END)
                windowObject.entry4selectcolor.insert(END,color)
            self.label4selectcolor = ttk.Label(self.frameWidgetConfig, text="selectcolor",
                                          style="widgetconfig.TLabel")
            self.label4selectcolor.grid(sticky=W, row=1831, column=1)
            self.frame4selectcolor = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectcolor.grid(row=1831, column=2)
            self.entry4selectcolor = Entry(self.frame4selectcolor, relief=FLAT)
            self.entry4selectcolor.pack(side=LEFT, padx=3)
            button4selectcolor = ttk.Button(self.frame4selectcolor, text=">>", style="moreOptions.TButton",
                                            command = color4selectcolor)
            button4selectcolor.pack(side=LEFT)

            ### selectforeground Sec
            def color4selectforeground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4selectforeground.delete(0, END)
                windowObject.entry4selectforeground.insert(END,color)
            self.label4selectforeground = ttk.Label(self.frameWidgetConfig, text="select\nforeground",
                                                    style="widgetconfig.TLabel")
            self.label4selectforeground.grid(sticky=W, row=1835, column=1)
            self.frame4selectforeground = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectforeground.grid(row=1835, column=2)
            self.entry4selectforeground = Entry(self.frame4selectforeground, relief=FLAT)
            self.entry4selectforeground.pack(side=LEFT, padx=3)
            button4selectforeground = ttk.Button(self.frame4selectforeground, text=">>", style="moreOptions.TButton",
                                                 command = color4selectforeground)
            button4selectforeground.pack(side=LEFT)

            ### selectimage Sec
            self.label4selectimage = ttk.Label(self.frameWidgetConfig, text="selectimage", style="widgetconfig.TLabel")
            self.label4selectimage.grid(sticky=W, row=1836, column=1)
            self.frame4selectimage = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectimage.grid(row=1836, column=2)
            self.entry4selectimage = Entry(self.frame4selectimage, relief=FLAT)
            self.entry4selectimage.pack(side=LEFT, padx=3)
            button4selectimage = ttk.Button(self.frame4selectimage, text=">>", style="moreOptions.TButton")
            button4selectimage.pack(side=LEFT)

            ### selectmode Sec
            selectmodes = ("browse", "single", "multiple", "extended")
            self.label4selectmode = ttk.Label(self.frameWidgetConfig, text="select\nmode", style="widgetconfig.TLabel")
            self.label4selectmode.grid(sticky=W, row=1837, column=1)
            self.combo4selectmode = ttk.Combobox(self.frameWidgetConfig, values = selectmodes)
            self.combo4selectmode.grid(row=1837, column=2, ipadx=5)

            ### show Sec
            self.label4show = ttk.Label(self.frameWidgetConfig, text="show", style="widgetconfig.TLabel")
            self.label4show.grid(sticky=W, row=1838, column=1)
            self.frame4show = ttk.Frame(self.frameWidgetConfig)
            self.frame4show.grid(row=1838, column=2)
            self.entry4show = Entry(self.frame4show, relief=FLAT)
            self.entry4show.pack(side=LEFT, padx=3)
            button4show = ttk.Button(self.frame4show, text=">>", style="moreOptions.TButton")
            button4show.pack(side=LEFT)

            ### showvalue Sec
            self.bool_showvalue = BooleanVar()
            self.bool_showvalue.set(1)
            self.label4showvalue = ttk.Label(self.frameWidgetConfig, text="showvalue", style="widgetconfig.TLabel")
            self.label4showvalue.grid(sticky=W, row=1839, column=1)
            self.frame4showvalue = ttk.Frame(self.frameWidgetConfig)
            self.frame4showvalue.grid(row=1839, column=2)
            radioTrue4showvalue = ttk.Radiobutton(self.frame4showvalue, text="True", variable=self.bool_showvalue,
                                                  value=True)
            radioTrue4showvalue.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4showvalue = ttk.Radiobutton(self.frame4showvalue, text="False", variable=self.bool_showvalue,
                                                   value=False)
            radioFalse4showvalue.grid(sticky=E, row=1, column=2, padx=20)

            ### sliderlength Sec
            def command4sliderlength(new_value):
                new_value = self.int_sliderlength.get()
                windowObject.int_sliderlength.set(new_value)

            self.int_sliderlength = IntVar(value = 30)
            self.label4sliderlength = ttk.Label(self.frameWidgetConfig, text = "slider\nlength", style = "widgetconfig.TLabel")
            self.label4sliderlength.grid(sticky = W, row = 1840, column = 1)
            self.frame4sliderlength = Frame(self.frameWidgetConfig, )
            self.frame4sliderlength.grid(sticky = W, row = 1840, column = 2, padx = 25)
            self.label24sliderlength = Label(self.frame4sliderlength, text = self.int_sliderlength.get())
            self.label24sliderlength.pack()
            self.scale4sliderlength = ttk.Scale(self.frame4sliderlength, from_ = 1, to = 500,
                                                variable = self.int_sliderlength, command = command4sliderlength)
            self.scale4sliderlength.pack()

            ### sliderrelief Sec
            sliderreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4sliderrelief = ttk.Label(self.frameWidgetConfig, text="slider\nrelief", style="widgetconfig.TLabel")
            self.label4sliderrelief.grid(sticky=W, row=1841, column=1)
            self.combo4sliderrelief = ttk.Combobox(self.frameWidgetConfig, values=sliderreliefs)
            self.combo4sliderrelief.grid(row=1841, column=2, ipadx=5)

            ### spacing1 Sec
            # self.int_spacing1 = IntVar()
            self.label4spacing1 = ttk.Label(self.frameWidgetConfig, text="spacing1",
                                                     style="widgetconfig.TLabel")
            self.label4spacing1.grid(sticky=W, row=1843, column=1)
            self.spinbox4spacing1 = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                         wrap=True)
                                                # textvariable = self.int_spacing1)
            self.spinbox4spacing1.grid(row=1843, column=2)

            ### spacing2 Sec
            # self.int_spacing2 = IntVar()
            self.label4spacing2 = ttk.Label(self.frameWidgetConfig, text="spacing2",
                                            style="widgetconfig.TLabel")
            self.label4spacing2.grid(sticky=W, row=1844, column=1)
            self.spinbox4spacing2 = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                wrap=True,)
                                                # textvariable = self.int_spacing2)
            self.spinbox4spacing2.grid(row=1844, column=2)

            ### spacing3 Sec
            # self.int_spacing3 = IntVar()
            self.label4spacing3 = ttk.Label(self.frameWidgetConfig, text="spacing3",
                                            style="widgetconfig.TLabel")
            self.label4spacing3.grid(sticky=W, row=1845, column=1)
            self.spinbox4spacing3 = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                wrap=True,)
                                                # textvariable = self.int_spacing3)
            self.spinbox4spacing3.grid(row=1845, column=2)

            ### state Sec
            states = ("active", "disabled", "normal")
            self.label4state = ttk.Label(self.frameWidgetConfig, text="state", style="widgetconfig.TLabel")
            self.label4state.grid(sticky=W, row=1848, column=1)
            self.combo4state = ttk.Combobox(self.frameWidgetConfig, values = states)
            self.combo4state.grid(row=1848, column=2, ipadx=5)

            ### tabs Sec
            self.label4tabs = ttk.Label(self.frameWidgetConfig, text="tabs", style="widgetconfig.TLabel")
            self.label4tabs.grid(sticky=W, row=1850, column=1)
            self.frame4tabs = ttk.Frame(self.frameWidgetConfig)
            self.frame4tabs.grid(row=1850, column=2)
            self.entry4tabs = Entry(self.frame4tabs, relief=FLAT, )
            self.entry4tabs.pack(side=LEFT, padx=3)
            blank_label4tabs = ttk.Label(self.frame4tabs, text="", anchor=W, width=3)
            blank_label4tabs.pack(side=LEFT)

            ### takefocus Sec
            self.bool_takefocus = BooleanVar()
            self.bool_takefocus.set(1)
            self.label4takefocus = ttk.Label(self.frameWidgetConfig, text="takefocus", style="widgetconfig.TLabel")
            self.label4takefocus.grid(sticky=W, row=1900, column=1)
            self.frame4takefocus = ttk.Frame(self.frameWidgetConfig)
            self.frame4takefocus.grid(row=1900, column=2)
            radioTrue4takefocus = ttk.Radiobutton(self.frame4takefocus, text="True", variable=self.bool_takefocus, value=True)
            radioTrue4takefocus.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4takefocus = ttk.Radiobutton(self.frame4takefocus, text="False", variable=self.bool_takefocus, value=False)
            radioFalse4takefocus.grid(sticky=E, row=1, column=2, padx=20)

            ### text Sec
            self.label4text = ttk.Label(self.frameWidgetConfig, text="text", style="widgetconfig.TLabel")
            self.label4text.grid(sticky=W, row=2000, column=1)
            self.frame4text = ttk.Label(self.frameWidgetConfig)
            self.frame4text.grid(row=2000, column=2)
            self.entry4text = Entry(self.frame4text,  relief = FLAT)
            self.entry4text.grid(row=1, column=1, padx = 3 )
            button4text = ttk.Button(self.frame4text, text = ">>", style = "moreOptions.TButton")
            button4text.grid(row = 1, column = 2,)
            xscrollbar4text = ttk.Scrollbar(self.frame4text, orient=HORIZONTAL, command=self.entry4text.xview)
            xscrollbar4text.grid(sticky=EW, row=2, column=1, )
            self.entry4text.config(xscrollcommand=xscrollbar4text.set)

            ### textvariable Sec
            self.label4textvariable = ttk.Label(self.frameWidgetConfig, text="text\nvariable", style="widgetconfig.TLabel")
            self.label4textvariable.grid(sticky=W, row=2005, column=1)
            self.frame4textvariable = ttk.Frame(self.frameWidgetConfig)
            self.frame4textvariable.grid(row=2005, column=2)
            self.entrytextvariable = Entry(self.frame4textvariable, relief=FLAT, )
            self.entrytextvariable.pack(side=LEFT, padx=3)
            blank_label4textvariable = ttk.Label(self.frame4textvariable, text="", anchor=W, width=3)
            blank_label4textvariable.pack(side=LEFT)

            ### tickinterval Sec
            # self.int_tickinterval = IntVar()
            self.label4tickinterval = ttk.Label(self.frameWidgetConfig, text="tick\ninterval",
                                              style="widgetconfig.TLabel")
            self.label4tickinterval.grid(sticky=W, row=2006, column=1)
            self.frame4tickinterval = ttk.Frame(self.frameWidgetConfig)
            self.frame4tickinterval.grid(row=2006, column=2)
            self.entry4tickinterval = Entry(self.frame4tickinterval, relief=FLAT,)
                                            # textvariable = self.int_tickinterval)
            self.entry4tickinterval.pack(side=LEFT, padx=3)
            blank_label4tickinterval = ttk.Label(self.frame4tickinterval, text="", anchor=W, width=3)
            blank_label4tickinterval.pack(side=LEFT)

            ### to Sec
            # self.int_to = IntVar()
            self.label4to = ttk.Label(self.frameWidgetConfig, text="to", style="widgetconfig.TLabel")
            self.label4to.grid(sticky=W, row=2011, column=1)
            self.frame4to = ttk.Frame(self.frameWidgetConfig)
            self.frame4to.grid(row=2011, column=2)
            self.entry4to = Entry(self.frame4to, relief=FLAT, )
                                  # textvariable = self.int_to)
            self.entry4to.pack(side=LEFT, padx=3)
            blank_label4to = ttk.Label(self.frame4to, text="", anchor=W, width=3)
            blank_label4to.pack(side=LEFT)

            ### troughcolor Sec
            def color4troughcolor():
                color = colorchooser.askcolor()[1]
                windowObject.entry4troughcolor.delete(0, END)
                windowObject.entry4troughcolor.insert(END,color)
            self.label4troughcolor = ttk.Label(self.frameWidgetConfig, text="trough\ncolor",
                                                    style="widgetconfig.TLabel")
            self.label4troughcolor.grid(sticky=W, row=2012, column=1)
            self.frame4troughcolor = ttk.Frame(self.frameWidgetConfig)
            self.frame4troughcolor.grid(row=2012, column=2)
            self.entry4troughcolor = Entry(self.frame4troughcolor, relief=FLAT)
            self.entry4troughcolor.pack(side=LEFT, padx=3)
            button4troughcolor = ttk.Button(self.frame4troughcolor, text=">>", style="moreOptions.TButton",
                                            command = color4troughcolor)
            button4troughcolor.pack(side=LEFT)

            ### underline Sec
            # self.int_underline = IntVar()
            self.label4underline = ttk.Label(self.frameWidgetConfig, text="underline", style="widgetconfig.TLabel")
            self.label4underline.grid(sticky=W, row=2013, column=1)
            self.frame4underline = ttk.Frame(self.frameWidgetConfig)
            self.frame4underline.grid(row=2013, column=2)
            self.entry4underline = Entry(self.frame4underline, relief=FLAT, )
                                         # textvariable = self.int_underline)
            self.entry4underline.pack(side=LEFT, padx=3)
            blank_label4underline = ttk.Label(self.frame4underline, text="", anchor=W, width=3)
            blank_label4underline.pack(side=LEFT)

            ### undo
            self.bool_undo = BooleanVar()
            self.bool_undo.set(1)
            self.label4undo = ttk.Label(self.frameWidgetConfig, text="undo", style="widgetconfig.TLabel")
            self.label4undo.grid(sticky=W, row=2015, column=1)
            self.frame4undo = ttk.Frame(self.frameWidgetConfig)
            self.frame4undo.grid(row=2015, column=2)
            radioTrue4undo = ttk.Radiobutton(self.frame4undo, text="True", variable=self.bool_undo,
                                                  value=True)
            radioTrue4undo.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4undo = ttk.Radiobutton(self.frame4undo, text="False", variable=self.bool_undo,
                                                   value=False)
            radioFalse4undo.grid(sticky=E, row=1, column=2, padx=20)

            ### validate Sec
            validates = ("all", "focus", "focusin", "focusout", "key", "none")
            self.label4validate = ttk.Label(self.frameWidgetConfig, text="validate", style="widgetconfig.TLabel")
            self.label4validate.grid(sticky=W, row=2016, column=1)
            self.combo4validate = ttk.Combobox(self.frameWidgetConfig, values=validates)
            self.combo4validate.grid(row=2016, column=2, ipadx=5)

            ###validatecommand Sec
            self.label4validatecommand = ttk.Label(self.frameWidgetConfig, text="validate\ncommand",
                                                   style="widgetconfig.TLabel")
            self.label4validatecommand.grid(sticky=W, row=2017, column=1)
            self.frame4validatecommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4validatecommand.grid(row=2017, column=2)
            self.entry4validatecommand = Entry(self.frame4validatecommand, relief=FLAT, )
            self.entry4validatecommand.pack(side=LEFT, padx=3)
            blank_label4validatecommand = ttk.Label(self.frame4validatecommand, text="", anchor=W, width=3)
            blank_label4validatecommand.pack(side=LEFT)

            ### value Sec
            # self.int_value = IntVar()
            self.label4value = ttk.Label(self.frameWidgetConfig, text="value", style="widgetconfig.TLabel")
            self.label4value.grid(sticky=W, row=2018, column=1)
            self.frame4value = ttk.Frame(self.frameWidgetConfig)
            self.frame4value.grid(row=2018, column=2)
            self.entry4value = Entry(self.frame4value, relief=FLAT,)
                                     # textvariable = self.int_value)
            self.entry4value.pack(side=LEFT, padx=3)
            blank_label4value = ttk.Label(self.frame4value, text="", anchor=W, width=3)
            blank_label4value.pack(side=LEFT)

            ### value(s) Sec
            self.label4values = ttk.Label(self.frameWidgetConfig, text="value(s)", style="widgetconfig.TLabel")
            self.label4values.grid(sticky=W, row=2019, column=1)
            self.frame4values = ttk.Frame(self.frameWidgetConfig)
            self.frame4values.grid(row=2019, column=2)
            self.entry4values = Entry(self.frame4values, relief=FLAT)
            self.entry4values.pack(side=LEFT, padx=3)
            button4values = ttk.Button(self.frame4values, text=">>", style="moreOptions.TButton")
            button4values.pack(side=LEFT)

            ### variable Sec
            self.label4variable = ttk.Label(self.frameWidgetConfig, text="variable", style="widgetconfig.TLabel")
            self.label4variable.grid(sticky=W, row=2020, column=1)
            self.frame4variable = ttk.Frame(self.frameWidgetConfig)
            self.frame4variable.grid(row=2020, column=2)
            self.entry4variable = Entry(self.frame4variable, relief=FLAT, )
            self.entry4variable.pack(side=LEFT, padx=3)
            blank_label4variable = ttk.Label(self.frame4variable, text="", anchor=W, width=3)
            blank_label4variable.pack(side=LEFT)

            ### width Sec
            self.label4width = ttk.Label(self.frameWidgetConfig, text="width", style="widgetconfig.TLabel")
            self.label4width.grid(sticky=W, row=2100, column=1)
            self.spinbox4width = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment = 5, to=self.label4width.winfo_screenwidth(), width = 10, wrap = True)
            self.spinbox4width.grid(row=2100, column=2)

            ### wrap Sec
            self.bool_wrap = BooleanVar()
            self.bool_wrap.set(1)
            self.label4wrap = ttk.Label(self.frameWidgetConfig, text="wrap", style="widgetconfig.TLabel")
            self.label4wrap.grid(sticky=W, row=2105, column=1)
            self.frame4wrap = ttk.Frame(self.frameWidgetConfig)
            self.frame4wrap.grid(row=2105, column=2)
            radioTrue4wrap = ttk.Radiobutton(self.frame4wrap, text="True", variable=self.bool_wrap,
                                                  value=True)
            radioTrue4wrap.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4wrap = ttk.Radiobutton(self.frame4wrap, text="False", variable=self.bool_wrap,
                                                   value=False)
            radioFalse4wrap.grid(sticky=E, row=1, column=2, padx=20)

            ### wrap (for Text) Sec
            wraps = ("char", "word", "none")
            self.label4wrap_Text = ttk.Label(self.frameWidgetConfig, text="wrap", style="widgetconfig.TLabel")
            self.label4wrap_Text.grid(sticky=W, row=2110, column=1)
            self.combo4wrap_Text = ttk.Combobox(self.frameWidgetConfig, values=wraps)
            self.combo4wrap_Text.grid(row=2110, column=2, ipadx=5)

            ### wraplength Sec
            # self.int_wraplength = IntVar()
            self.label4wraplength = ttk.Label(self.frameWidgetConfig, text="wraplength", style="widgetconfig.TLabel")
            self.label4wraplength.grid(sticky=W, row=2200, column=1)
            self.frame4wraplength = ttk.Frame(self.frameWidgetConfig)
            self.frame4wraplength.grid(row=2200, column=2)
            self.entry4wraplength = Entry(self.frame4wraplength, relief=FLAT,)
                                          # textvariable = self.int_wraplength)
            self.entry4wraplength.pack(side=LEFT, padx=3)
            blank_label4wraplength = ttk.Label(self.frame4wraplength, text="", anchor=W, width=3)
            blank_label4wraplength.pack(side=LEFT)

            ### xscrollcommand Sec
            self.label4xscrollcommand = ttk.Label(self.frameWidgetConfig, text="xscroll\ncommand",
                                                  style="widgetconfig.TLabel")
            self.label4xscrollcommand.grid(sticky=W, row=2300, column=1)
            self.frame4xscrollcommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4xscrollcommand.grid(row=2300, column=2)
            self.entry4xscrollcommand = Entry(self.frame4xscrollcommand, relief=FLAT, )
            self.entry4xscrollcommand.pack(side=LEFT, padx=3)
            blank_label4xscrollcommand = ttk.Label(self.frame4xscrollcommand, text="", anchor=W, width=3)
            blank_label4xscrollcommand.pack(side=LEFT)

            ### yscrollcommand Sec
            self.label4yscrollcommand = ttk.Label(self.frameWidgetConfig, text="yscroll\ncommand",
                                                  style="widgetconfig.TLabel")
            self.label4yscrollcommand.grid(sticky=W, row=2400, column=1)
            self.frame4yscrollcommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4yscrollcommand.grid(row=2400, column=2)
            self.entry4yscrollcommand = Entry(self.frame4yscrollcommand, relief=FLAT, )
            self.entry4yscrollcommand.pack(side=LEFT, padx=3)
            blank_label4yscrollcommand = ttk.Label(self.frame4yscrollcommand, text="", anchor=W, width=3)
            blank_label4yscrollcommand.pack(side=LEFT)

            ### Listbox Section to add
            # self.frame4AllListConfig = ttk.Frame(self.frameWidgetConfig)
            # self.frame4AllListConfig.grid(row = 2500, column=1, columnspan=2)
            # ttk.Label(self.frame4AllListConfig, text = "").grid()
            # ttk.Label(self.frame4AllListConfig, text = "").grid()
            #
            # frameListAdd = ttk.Frame(self.frame4AllListConfig)
            # frameListAdd.grid(row=10, column=1, columnspan=2)
            # labelListAdd = ttk.Label(frameListAdd, text="Add List", font=("Courier", 20, "bold"))
            # labelListAdd.pack(side=LEFT, anchor=W)
            # buttonListAdd = ttk.Button(frameListAdd, text="+")
            # buttonListAdd.pack(side=RIGHT, anchor=E)
            #
            # ### List for label, frame and entry variables of the listss
            # self.list_label_list = ["label4List_{x}" for x in range(0, 100)]
            # self.list_frame_list = ["frame4List_{x}" for x in range(0, 100)]
            # self.list_entry_list = ["entry4List_{x}" for x in range(0, 100)]
            # self.row_list = 12  ## Variable for grid of new toggled list
            # self.list_id = 2  ## Variable that toogles list label number
            #
            # def addList():      ### Command for + button
            #     windowObject.list_label_list[windowObject.list_id] = ttk.Label(self.frame4AllListConfig, text=f"List_{windowObject.list_id}",
            #                                                       style="widgetconfig.TLabel")
            #     windowObject.list_label_list[windowObject.list_id].grid(sticky=W, row=windowObject.row_list, column=1)
            #     windowObject.list_frame_list[windowObject.list_id] = ttk.Frame(self.frame4AllListConfig)
            #     windowObject.list_frame_list[windowObject.list_id].grid(row=windowObject.row_list, column=2)
            #     windowObject.list_entry_list[windowObject.list_id] = Entry(windowObject.list_frame_list[windowObject.list_id], relief=FLAT)
            #     windowObject.list_entry_list[windowObject.list_id].pack(side=LEFT, padx=3, pady = 3)
            #
            #     windowObject.row_list += 1
            #     windowObject.list_id += 1
            #
            # buttonListAdd.config(command = addList)
            #
            # self.list_label_list[1] = ttk.Label(self.frame4AllListConfig, text="List_1", style="widgetconfig.TLabel")
            # self.list_label_list[1].grid(sticky=W, row=11, column=1)
            #
            # self.list_frame_list[1] = ttk.Frame(self.frame4AllListConfig)
            # self.list_frame_list[1].grid(row=11, column=2)
            #
            # self.list_entry_list[1] = Entry(self.list_frame_list[1], relief=FLAT)
            # self.list_entry_list[1].pack(side=LEFT, padx=3, pady = 3)
            #
            # button4values = ttk.Button(self.frame4AllListConfig, text=">>", style="moreOptions.TButton",
            #                            command = arrangeObject.createList)
            # button4values.grid(row = 150, column = 2, sticky = E)

            ### PanedWindow Section to add
            self.frame4AllPaneConfig = ttk.Frame(self.frameWidgetConfig)
            self.frame4AllPaneConfig.grid(row = 2600, column=1, columnspan=2)

            ttk.Label(self.frame4AllPaneConfig, text = "").grid()
            ttk.Label(self.frame4AllPaneConfig, text = "").grid()

            framePaneAdd = ttk.Frame(self.frame4AllPaneConfig)
            framePaneAdd.grid(row=10, column=1, columnspan=2)
            labelPaneAdd = ttk.Label(framePaneAdd, text="Add Pane", font=("Courier", 20, "bold"))
            labelPaneAdd.pack(side=LEFT, anchor=W)
            buttonPaneAdd = ttk.Button(framePaneAdd, text="+")
            buttonPaneAdd.pack(side=RIGHT, anchor=E)

                ### List for label, frame and entry variables of the panes
            self.pane_label_list = ["label4Pane_{x}" for x in range(0, 100)]
            self.pane_frame_list = ["frame4Pane_{x}" for x in range(0, 100)]
            self.pane_entry_list = ["entry4Pane_{x}" for x in range(0, 100)]
            self.row_pane = 12     ## Variable for grid of new toggled pane
            self.pane_id = 2        ## Variable that toogles pane label number

            def addPane():      ### Command for + button
                windowObject.pane_label_list[windowObject.pane_id] = ttk.Label(self.frame4AllPaneConfig, text=f"Pane_{windowObject.pane_id}",
                                                                  style="widgetconfig.TLabel")
                windowObject.pane_label_list[windowObject.pane_id].grid(sticky=W, row=windowObject.row_pane, column=1)
                windowObject.pane_frame_list[windowObject.pane_id] = ttk.Frame(self.frame4AllPaneConfig)
                windowObject.pane_frame_list[windowObject.pane_id].grid(row=windowObject.row_pane, column=2)
                windowObject.pane_entry_list[windowObject.pane_id] = Entry(windowObject.pane_frame_list[windowObject.pane_id], relief=FLAT)
                windowObject.pane_entry_list[windowObject.pane_id].pack(side=LEFT, padx=3, pady = 3)

                windowObject.row_pane += 1
                windowObject.pane_id += 1

            buttonPaneAdd.config(command = addPane)

            self.pane_label_list[1] = ttk.Label(self.frame4AllPaneConfig, text="Pane_1", style="widgetconfig.TLabel")
            self.pane_label_list[1].grid(sticky=W, row=11, column=1)

            self.pane_frame_list[1] = ttk.Frame(self.frame4AllPaneConfig)
            self.pane_frame_list[1].grid(row=11, column=2)

            self.pane_entry_list[1] = Entry(self.pane_frame_list[1], relief=FLAT)
            self.pane_entry_list[1].pack(side=LEFT, padx=3, pady = 3)

            button4values = ttk.Button(self.frame4AllPaneConfig, text=">>", style="moreOptions.TButton",
                                       command = arrangeObject.createPane)
            button4values.grid(row = 150, column = 2, sticky = E)


            ##### Styling for Wiget Config Label & Button
            self.styleWidgetConfigLabel.configure("widgetconfig.TLabel", font=("Courier New", 10), padding=3, anchor=W)
            self.styleWidgetConfigLabel.configure("moreOptions.TButton", width=3, anchor=W)

        def widgetTreeview(self):
            self.tree4Widget = ttk.Treeview(windowPRO, )
            self.tree4Widget.pack(side = LEFT, fill=BOTH, expand = 1)
            scroll4Widgettree = ttk.Scrollbar(orient = "vertical", command = self.tree4Widget.yview)
            scroll4Widgettree.pack(side = RIGHT, fill = Y)
            self.tree4Widget["yscrollcommand"] = scroll4Widgettree.set
            self.tree4Widget.insert("", END, iid="Design Window", text="Design Window", open = True)

        ##### Method to validate whether WidgetConfig Toplevel currently exits.
        def validateWidgetConfigTopLevelState(self):
            if self.clickWidgetConfig == 0:  # If NOT exists,
                self.toplevel4WidgetConfig()  # new Toplevel for Widget is created
            elif self.clickWidgetConfig == 1:  # If exists:
                self.toplevelWidgetConfig.destroy()  # Current Toplevel is destroyed
                self.toplevel4WidgetConfig()  # New Toplevel for Widget is created

        ########## Command for Main tk Widgets
        def determineButton(self, widget_value):
            global iswidget
            iswidget = widget_value

        def mainButton(self):
            self.validateWidgetConfigTopLevelState()
            ### Removal of Unavailable Attributes for this Widget
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineCheckbutton(self, widget_value):
            global iswidget
            iswidget = widget_value

        def mainCheckbutton(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineEntry(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainEntry(self):
            self.validateWidgetConfigTopLevelState()

            self.combo4state.config(values = ("active", "disabled", "normal", "readonly"))  ### Add 'readonly' to state
            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        ### Addition of Attributes

        def determineLabel(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainLabel(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineListbox(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainListbox(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()


        def mainMenu(self):
            self.validateWidgetConfigTopLevelState()

        ### Removal of Unavailable Attributes for this Widget

        def determineMenubutton(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainMenubutton(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()


        def determineMessage(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainMessage(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def mainOptionMenu(self, widget_value):
            self.validateWidgetConfigTopLevelState()

            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

            ### Removal of Unavailable Attributes for this Widget
            self.validateWidgetConfigTopLevelState()
            self.label4activebackground.destroy()
            self.label4highlightthickness.destroy()
            self.frame4activebackground.destroy()
            self.spinbox4highlightthickness.destroy()
            self.label4activeforeground.destroy()
            self.label4highlightcolor.destroy()
            self.frame4activeforeground.destroy()
            self.frame4highlightcolor.destroy()
            self.label4anchor.destroy()
            self.label4highlightbackground.destroy()
            self.combo4anchor.destroy()
            self.frame4highlightbackground.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4foreground.destroy()
            self.frame4foreground.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4relief.destroy()
            self.combo4relief.destroy()
            self.label4takefocus.destroy()
            self.frame4takefocus.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4cursor.destroy()
            self.combo4cursor.destroy()
            self.label4borderwidth.destroy()
            self.spinbox4borderwidth.destroy()
            self.label4width.destroy()
            self.spinbox4width.destroy()
            self.label4background.destroy()
            self.frame4background.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineRadiobutton(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainRadiobutton(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavialable Attributes for this widget
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineScale(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainScale(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4height.destroy()  # Remove Height Attribute
            self.spinbox4height.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineScrollbar(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainScrollbar(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4foreground.destroy()  # Remove Foreground Label Attribute
            self.frame4foreground.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineSpinbox(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainSpinbox(self):
            self.validateWidgetConfigTopLevelState()

            self.combo4state.config(values=("active", "disabled", "normal", "readonly"))    ### Add 'readonly' to state
            ### Removal of Unavailable Attributes for this Widget
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineText(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainText(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        ###### Command for Main tk Containers
        def determineFrame(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainFrame(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4font.destroy()  # Remove Font  Attribute
            self.frame4font.destroy()
            self.label4foreground.destroy()  # Remove Foreground Label Attribute
            self.frame4foreground.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineLabelFrame(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainLabelFrame(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determinePanedWindow(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainPanedWindow(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4foreground.destroy()
            self.frame4foreground.destroy()
            self.label4highlightbackground.destroy()
            self.frame4highlightbackground.destroy()
            self.label4highlightcolor.destroy()
            self.frame4highlightcolor.destroy()
            self.label4highlightthickness.destroy()
            self.spinbox4highlightthickness.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4takefocus.destroy()
            self.frame4takefocus.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()

        def determineToplevel(self, widget_value):
            global iswidget
            iswidget = widget_value     ### Widget Deteminant

        def mainToplevel(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4foreground.destroy()
            self.frame4foreground.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()


        ###### Commands for >> Font Buttons
        def executeFontToplevel(self):
            self.numberFont_2
            self.isFontToplevel

            global fontObject

            if self.isFontToplevel == 0:
                fontObject = ChooseFont(self.numberFont_2,
                                        self.toplevelWidgetConfig,)  #### Creates font Object and passes in the CHANGED new font name
            elif self.isFontToplevel == 1:
                fontObject.toplevel4Font.destroy()
                fontObject = ChooseFont(self.numberFont_2,
                                        self.toplevelWidgetConfig,)  #### Creates font Object and passes in the CHANGED new font name
            if self.entry4font.get() == "":
                self.entry4font.insert(0, fontObject.fontNameVariable)
            elif self.entry4font.get() != "":
                self.entry4font.delete(0, END)
                self.entry4font.insert(0, fontObject.fontNameVariable)

            self.numberFont_2 += 1
            self.isFontToplevel = 1


    class ChooseFont:
        def __init__(self, numberFont_1, master):

            self.toplevel4Font = Toplevel(master)

            self.toplevel4Font.resizable(False, False)
            self.fontScreenWidth = self.toplevel4Font.winfo_screenwidth()
            fontScreenHeight = self.toplevel4Font.winfo_screenheight()
            self.toplevel4Font.transient()
            self.toplevel4Font.geometry("%dx%d+%d+%d" % (self.fontScreenWidth/2.973, 445, self.fontScreenWidth/3, fontScreenHeight/2.5))
            # global selectedFont

            self.numberFont_1 = numberFont_1     #### Variable that determines new Font Name
            self.fontNameVariable = "font_{}".format(self.numberFont_1)     ###### Variable for Font Names
            self.dictFontSettings = {"name": self.fontNameVariable, "family": "Segoe UI", "size": 9}

            self.sampleFont = font.Font(family = "Arial", size= 8)
            windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"] = font.Font(root = windowDesign, **self.dictFontSettings) #### Font object for selected font in Font Window

            self.fontWidgets()    ######## Display Font Toplevel Widgets


        def applyFont(self,):
            # global selectedFont

            getFontFamily = self.comboFontFamily.get()
            self.dictFontSettings["family"] = getFontFamily
            self.sampleFont.config(family = getFontFamily)
            
            getFontSize = int(self.spinboxSize.get())
            self.dictFontSettings["size"] = getFontSize
            self.sampleFont.config(size = getFontSize)

            self.text4Preview.tag_config("tagPreviewText", font = self.sampleFont)
            self.groupStyle = (self.checkVariable1.get(), self.checkVariable2.get(), self.checkVariable3.get(), self.checkVariable4.get())  ##### Tuple that commulates responses from check boxes

            def iterateStyle():
                if fontObject.groupStyle[0] == 1:
                    self.sampleFont.config(weight = font.BOLD)
                if fontObject.groupStyle[0] == 0:
                    self.sampleFont.config(weight = font.NORMAL)
                if fontObject.groupStyle[1] == 1:
                    self.sampleFont.config(slant = font.ITALIC)
                if fontObject.groupStyle[1] == 0:
                    self.sampleFont.config(slant = font.ROMAN)
                if fontObject.groupStyle[2] == 1:
                    self.sampleFont.config(overstrike = 1)
                if fontObject.groupStyle[2] == 0:
                    self.sampleFont.config(overstrike = 0)
                if fontObject.groupStyle[3] == 1:
                    self.sampleFont.config(underline = 1)
                if fontObject.groupStyle[3] == 0:
                    self.sampleFont.config(underline = 0)
            self.toplevel4Font.after(1, iterateStyle)


        def applyFont_WidgetEvent(self, event):
            self.applyFont()

        def fontWidgets(self):
            ###### Font Family Sec
                ### Label for font family
            labelFontFamily = ttk.Label(self.toplevel4Font, text = "font family:",)
            labelFontFamily.grid(row = 1, column = 1, sticky = N, padx = 20, pady = 10)
                ### Combobox for font family
            get_families = font.families()   ##### Get all Available Font Families
            self.comboFontFamily = ttk.Combobox(self.toplevel4Font, values = get_families, )
            self.comboFontFamily.grid(row = 2, column = 1, sticky = W, padx = 20, pady = 10)
            self.comboFontFamily.set("Segoe UI")

            ###### Font Size Sec
                ### Label font size
            labelFontSize = ttk.Label(self.toplevel4Font, text = "font size:")
            labelFontSize.grid(row = 3, column = 1, sticky = N, padx = 20, pady = 10)
                ### Spinbox
            ##size_var = IntVar()
            ##size_var.initialize (8)
            self.spinboxSize = ttk.Spinbox(self.toplevel4Font, from_ = 8, to = 98, increment = 3, wrap = True, command = self.applyFont)
            self.spinboxSize.grid(row = 4, column = 1, sticky = W, padx = 20, pady = 10)
            self.spinboxSize.set(9)

            Label(self.toplevel4Font, ).grid(row = 5, column = 1)   ####### Spacing Label
            Label(self.toplevel4Font, ).grid(row = 6, column = 1)

            ###### Separator - Horizontal Sec
            seperatorFontHorizontal = ttk.Separator(self.toplevel4Font, orient = HORIZONTAL,  )
            seperatorFontHorizontal.grid(row = 7, column = 1, columnspan = 4, sticky = EW, )

            ###### Separator - Vertical Sec
            separatorFontVertical = ttk.Separator(self.toplevel4Font, orient = VERTICAL)
            separatorFontVertical.grid(row = 1, column = 2, rowspan = 6, sticky = NS, )

            ###### Preview Section
                ### Label for Preview
            labelPreview = ttk.Label(self.toplevel4Font, text = "Preview: ")
            labelPreview.grid(sticky = N, row = 8, column = 0, columnspan = 5, pady = 10)
                ### Text for Preview
            self.text4Preview = Text(self.toplevel4Font, width = int(self.fontScreenWidth/24)+1, height = 10, relief = FLAT, wrap = WORD)
            self.text4Preview.grid(sticky = W, row = 9, column = 0, columnspan = 5, pady = 5)
            self.text4Preview.insert(END, "abcABC")
            self.text4Preview.tag_add("tagPreviewText", 1.0, END)
            self.text4Preview.tag_config("tagPreviewText", font = self.sampleFont,
                                         justify = CENTER, spacing1 = 10)
            self.text4Preview["state"] = "disabled"

            ###### Font Styling Section
                ### Label for font styling
            labelFontStyle = ttk.Label(self.toplevel4Font, text = "font styling:")
            labelFontStyle.grid(row = 1, column = 3, sticky = N, padx = 40, pady = 10)
                ### Check button to select styling
            self.checkVariable1 = IntVar()
            checkFontStyle1 = ttk.Checkbutton(self.toplevel4Font, text = "Bold", variable = self.checkVariable1, command = self.applyFont)
            checkFontStyle1.grid(row = 2, column = 3, sticky = W, padx = 30)
            self.checkVariable2 = IntVar()
            checkFontStyle2 = ttk.Checkbutton(self.toplevel4Font, text = "Italic", variable = self.checkVariable2, command = self.applyFont)
            checkFontStyle2.grid(row = 3, column = 3, sticky = W, padx = 30)
            self.checkVariable3 = IntVar()
            checkFontStyle3 = ttk.Checkbutton(self.toplevel4Font, text = "Overstrike", variable = self.checkVariable3, command = self.applyFont)
            checkFontStyle3.grid(row = 4, column = 3, sticky = W, padx = 30)
            self.checkVariable4 = IntVar()
            checkFontStyle4 = ttk.Checkbutton(self.toplevel4Font, text = "Underline", variable = self.checkVariable4, command = self.applyFont)
            checkFontStyle4.grid(row = 5, column = 3, sticky = W, padx = 30)

            ####### apply Font Button
            def implementFont():
                try:
                    self.sampleFont.config(family = fontObject.comboFontFamily.get())
                    self.sampleFont.config(size = fontObject.spinboxSize.get())
                    windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(family=fontObject.comboFontFamily.get())
                    windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(size=fontObject.spinboxSize.get())
                    if fontObject.groupStyle[0] == 1:
                        self.dictFontSettings["weight"] = "bold"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(weight = font.BOLD)
                    if fontObject.groupStyle[0] == 0:
                        self.dictFontSettings["weight"] = "normal"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(weight = font.NORMAL)
                    if fontObject.groupStyle[1] == 1:
                        self.dictFontSettings["slant"] = "italic"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(slant = font.ITALIC)
                    if fontObject.groupStyle[1] == 0:
                        self.dictFontSettings["slant"] = "roman"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(slant = font.ROMAN)
                    if fontObject.groupStyle[2] == 1:
                        self.dictFontSettings["overstrike"] = 1
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(overstrike = 1)
                    if fontObject.groupStyle[2] == 0:
                        self.dictFontSettings["overstrike"] = 0
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(overstrike = 0)
                    if fontObject.groupStyle[3] == 1:
                        self.dictFontSettings["underline"] = 1
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(underline = 1)
                    if fontObject.groupStyle[3] == 0:
                        self.dictFontSettings["underline"] = 0
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(underline = 0)

                    windowObject.implementFont_determine = 22
                    arrangeObject.refreshAttributes()
                    windowObject.implementFont_determine = 0
                except AttributeError:
                    pass
            
            def resetFont():
                fontObject.sampleFont.config(family = "Segoe UI", size = 9, weight = font.NORMAL, slant = font.ROMAN,
                                             overstrike = 0, underline = 0)
                windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(family = "Segoe UI", size = 9,
                                                    weight = font.NORMAL, slant = font.ROMAN, overstrike = 0, underline = 0)
                fontObject.comboFontFamily.set("Segoe UI")
                fontObject.spinboxSize.set(9)
                self.checkVariable1.set(0)
                self.checkVariable2.set(0)
                self.checkVariable3.set(0)
                self.checkVariable4.set(0)

            def closeFont():
                fontObject.toplevel4Font.destroy()

            buttonResetFont = ttk.Button(self.toplevel4Font, text="Reset Font", command=resetFont)
            buttonResetFont.grid(row=11, column=1, sticky = W)

            buttonApplyFont = ttk.Button(self.toplevel4Font, text = "Apply Font", command = implementFont)
            buttonApplyFont.grid(row = 11, columnspan = 5)

            buttonCloseFont = ttk.Button(self.toplevel4Font, text = "Close", command = closeFont)
            buttonCloseFont.grid(row = 11, column = 4, sticky = W)

            ###### Styling for All Font Labels
            style4LabelFontStyling = ttk.Style()
            style4LabelFontStyling.configure("TLabel", font = ("Segoe UI", 9, "bold", "italic"))

            ###### Event Handlers
            self.comboFontFamily.bind("<<ComboboxSelected>>", self.applyFont_WidgetEvent)    ####### Combobox Event
            self.spinboxSize.bind("<Return>", self.applyFont_WidgetEvent)              ####### Spinbox Event for Enter Key
            self.comboFontFamily.bind("<Return>", self.applyFont_WidgetEvent)                ####### Combobox Event for Enter Key

    global winConfigStart
    winConfigStart = [0]
    class DesignWindowSetup:
        global winConfigStart
        def __init__(self):
            if windowObject.iswinConfigToplevel == 0:
                winConfigStart[0] = (Toplevel(master = windowPRO))
                self.winConfig(winConfigStart[0])
            elif windowObject.iswinConfigToplevel == 1:
                winConfigStart[0].destroy()
                winConfigStart[0] = Toplevel(master = windowPRO)
                self.winConfig(winConfigStart[0])
            self.exitDesignWindowSetup()

        def winConfig(self,  get_toplevel_winconfig):
            self.toplevel4winConfig = get_toplevel_winconfig
            self.toplevel4winConfig.geometry("%dx%d+%d+%d" % (620, 535,
                                                              windowPRO.winfo_screenwidth()/4, windowPRO.winfo_screenheight()/5))
            global iswinConfigToplevel
            windowObject.iswinConfigToplevel = 1
            self.placeWidgetsDesign()

        def placeWidgetsDesign(self):
            ### Parameter Assignment for windowDesign geometry meth
            global new_value_width
            new_value_width = int(screen_width / 2)
            global new_value_height
            new_value_height = int(screen_height / 1.57)
            global new_value_position_x
            new_value_position_x = int(screen_width / 4.5)
            global new_value_position_y
            new_value_position_y = int(screen_height / 3.36)
            dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}x{new_value_height}+" \
                                                      f"{new_value_position_x}+{new_value_position_y})"

            ### Parameter Assignment for windowDesign resizable meth
            global new_resizable_width
            new_resizable_width = True
            global new_resizable_height
            new_resizable_height = True
            dictDesignWindowPropCollect["resizable"] = f"windowDesign.resizable(width = {new_resizable_width}, " \
                                                       f"height = {new_resizable_height})"

            ### Parameter Assignment for windowDesign overrideredirect
            global new_overrideredirect
            new_overrideredirect = False

            ### Parameter Assignment for maxsize
            global new_maxsize_width
            new_maxsize_width = int(windowPRO.winfo_screenwidth() / 2)
            global new_maxsize_height
            new_maxsize_height = int(windowPRO.winfo_screenheight() / 1.57)

            ### Parameter Assignment for minsize
            global new_minsize_width
            new_minsize_width = int(windowPRO.winfo_screenwidth() / 2)
            global new_minsize_height
            new_minsize_height = int(windowPRO.winfo_screenheight() / 1.57)

            ### main toplevel title
            label4designconfig = ttk.Label(self.toplevel4winConfig, text = "Configure Your GUI Window To Your Taste",
                                           font = ("Courier", 15, "bold"), background = "grey", anchor = CENTER)
            label4designconfig.grid(row = 10, column = 0, columnspan = 9, ipadx = 75)

            Label(self.toplevel4winConfig, text = "").grid(row = 12)

            ### title
            dictDesignWindowPropCollect["title"] = f"windowDesign.title('Design Window')"
            def command4title():
                variable4title = entry4title.get()
                windowDesign.title(variable4title)
                dictDesignWindowPropCollect["title"] = f"windowDesign.title('{variable4title}')"
                
            frame4title_iconphoto = ttk.Frame(self.toplevel4winConfig)
            frame4title_iconphoto.grid(row = 20, column = 0, columnspan = 8)
            label4title = ttk.Label(frame4title_iconphoto, text = "title")
            label4title.grid(row = 20, column = 1, padx = 20)
            entry4title = ttk.Entry(master = frame4title_iconphoto)
            entry4title.grid(row = 20, column = 2,)
            button4title = ttk.Button(frame4title_iconphoto, text=">>", width=3, command = command4title)
            button4title.grid(row=20, column=3, padx=2)

            Label(frame4title_iconphoto, text = "").grid(row = 20, column = 4, padx = 40)

            ### photo
            def command4photo():
                file = filedialog.askopenfile("r", filetypes = [("Portable Network Graphics (PNG)", "*png")])
                value_image = PhotoImage(master = windowDesign, file = file.name)
                windowDesign.iconphoto(False, value_image)
                entry4photo.delete(0,END)
                entry4photo.insert(0, file.name)
                entry4photo["state"] = "readonly"
                dictDesignWindowPropCollect["iconphoto"] = f"PhotoImage(master = windowDesign, file = '{file.name}')"
                dictDesignWindowPropCollect["iconphoto2"] = f"windowDesign.iconphoto(False, IconPhoto)"
                
            label4photo = ttk.Label(frame4title_iconphoto, text = "icon photo")
            label4photo.grid(row = 20, column = 5, padx = 20)
            entry4photo = ttk.Entry(frame4title_iconphoto)
            entry4photo.grid(row = 20, column = 6)
            scroll4photo = ttk.Scrollbar(frame4title_iconphoto, orient = "horizontal", command = entry4photo.xview)
            scroll4photo.grid(row = 21, column = 6, ipadx = 40)
            entry4photo.config(xscrollcommand = scroll4photo.set)
            button4photo = ttk.Button(frame4title_iconphoto, text = ">>", width = 3, command = command4photo)
            button4photo.grid(row = 20, column = 7, padx = 2)

            Label(self.toplevel4winConfig, text = "").grid(row = 27)
            label4geometry = ttk.Label(self.toplevel4winConfig, text = "Geometry (Window Dimensions)",
                                       font = ("Calisto MT", 12, "bold"))
            label4geometry.grid(row = 30, column = 0, columnspan = 2)

            ### geometry width
            def command4width(new_value):
                global new_value_width
                new_value_width = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x,  new_value_position_y))
                label24width.config(text = new_value_width)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y})"
            label4width = ttk.Label(self.toplevel4winConfig, text = "width")
            label4width.grid(row = 40, column = 1)
            int_width = IntVar(value = windowPRO.winfo_screenwidth()/2)
            frame4width = ttk.Frame(self.toplevel4winConfig)
            frame4width.grid(row = 40, column = 2)
            label24width = ttk.Label(frame4width, text = int_width.get())
            label24width.pack()
            scale4width = ttk.Scale(frame4width, variable = int_width, from_ = 50,
                                    to = windowPRO.winfo_screenwidth(), command = command4width)
            scale4width.pack()

            ### geometry height
            def command4height(new_value):
                global new_value_height
                new_value_height = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x,  new_value_position_y))
                label24height.config(text = new_value_height)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y})"
            label4height = ttk.Label(self.toplevel4winConfig, text = "height")
            label4height.grid(row = 50, column = 1)
            int_height = IntVar(value = windowPRO.winfo_screenheight()/1.57)
            frame4height = ttk.Frame(self.toplevel4winConfig)
            frame4height.grid(row = 50, column = 2)
            label24height = ttk.Label(frame4height, text = int_height.get())
            label24height.pack()
            scale4height = ttk.Scale(frame4height, variable = int_height, from_ = 50,
                                     to = windowPRO.winfo_screenheight(), command = command4height)
            scale4height.pack()

            ### position_x relative to screen
            def command4position_x(new_value):
                global new_value_position_x
                new_value_position_x = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x, new_value_position_y))
                label24position_x.config(text = new_value_position_x)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y})"
            label4position_x = ttk.Label(self.toplevel4winConfig, text = "x position of Design Window")
            label4position_x.grid(row = 60, column = 1)
            int_position_x = IntVar(value = windowPRO.winfo_screenwidth()/4.5)
            frame4position_x = ttk.Frame(self.toplevel4winConfig)
            frame4position_x.grid(row = 60, column = 2)
            label24position_x = ttk.Label(frame4position_x, text = int_position_x.get())
            label24position_x.pack()
            scale4position_x = ttk.Scale(frame4position_x, variable = int_position_x, from_ = 0,
                                         to = windowPRO.winfo_screenwidth()-50, command = command4position_x)
            scale4position_x.pack()

            ### position_y relative to screen
            def command4position_y(new_value):
                global new_value_position_y
                new_value_position_y = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x, new_value_position_y))
                label24position_y.config(text = new_value_position_y)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry('{new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y}')"
            label4position_y = ttk.Label(self.toplevel4winConfig, text = "y position of Design Window")
            label4position_y.grid(row = 70, column = 1)
            int_position_y = IntVar(value = windowPRO.winfo_screenheight() / 3.36)
            frame4position_y = ttk.Frame(self.toplevel4winConfig)
            frame4position_y.grid(row = 70, column = 2)
            label24position_y = ttk.Label(frame4position_y, text = int_position_y.get())
            label24position_y.pack()
            scale4position_y = ttk.Scale(frame4position_y, variable = int_position_y, from_ = 0,
                                         to = windowPRO.winfo_screenheight()-50, command = command4position_y)
            scale4position_y.pack()

            ### Window Properties Section Label
            Label(self.toplevel4winConfig, text="").grid(row=71)
            label4geometry = ttk.Label(self.toplevel4winConfig, text="Window Properties",
                                       font=("Calisto MT", 12, "bold"))
            label4geometry.grid(row=72, column=0, columnspan=2, sticky = W)

            ### is resizable_width
            def command4resizable_width():
                global new_resizable_width
                new_resizable_width = bool_resizable_width.get()
                windowDesign.resizable(width = new_resizable_width, height = new_resizable_height)
                dictDesignWindowPropCollect["resizable"] = f"windowDesign.resizable(width = {new_resizable_width}, " \
                                                                 f"height = {new_resizable_height})"
            label4resizable_width = ttk.Label(self.toplevel4winConfig, text = "Is width resizable?")
            label4resizable_width.grid(row = 80, column = 1)
            bool_resizable_width = BooleanVar(value = True)
            frame4resizable_width = ttk.Frame(self.toplevel4winConfig)
            frame4resizable_width.grid(row = 80, column = 2)
            radioTrue4resizable_width = ttk.Radiobutton(frame4resizable_width, variable = bool_resizable_width, text = "Yes",
                                                        value = True, command = command4resizable_width)
            radioTrue4resizable_width.pack(side = LEFT, padx = 20)
            radioFalse4resizable_width = ttk.Radiobutton(frame4resizable_width, variable = bool_resizable_width, text = "No",
                                                         value = False, command = command4resizable_width)
            radioFalse4resizable_width.pack(side = RIGHT)

            ### is resizable height
            def command4resizable_height():
                global new_resizable_height
                new_resizable_height = bool_resizable_height.get()
                windowDesign.resizable(width = new_resizable_width, height = new_resizable_height)
                dictDesignWindowPropCollect["resizable"] = f"windowDesign.resizable(width = {new_resizable_width}, " \
                                                                 f"height = {new_resizable_height})"
            label4resizable_height = ttk.Label(self.toplevel4winConfig, text="Is height resizable?")
            label4resizable_height.grid(row=90, column=1)
            bool_resizable_height = BooleanVar(value=True)
            frame4resizable_height = ttk.Frame(self.toplevel4winConfig)
            frame4resizable_height.grid(row=90, column=2)
            radioTrue4resizable_height = ttk.Radiobutton(frame4resizable_height, variable=bool_resizable_height, text="Yes",
                                                        value=True, command = command4resizable_height)
            radioTrue4resizable_height.pack(side=LEFT, padx=20)
            radioFalse4resizable_height = ttk.Radiobutton(frame4resizable_height, variable=bool_resizable_height, text="No",
                                                         value=False, command = command4resizable_height)
            radioFalse4resizable_height.pack(side=RIGHT)

            ### override redirect flag
            def command4overrideredirect():
                global new_overrideredirect
                new_overrideredirect = bool_overrideredirect.get()
                windowDesign.overrideredirect(new_overrideredirect)
                dictDesignWindowPropCollect["overrideredirect"] = f"windowDesign.overrideredirect({new_overrideredirect})"
            label4overrideredirect = ttk.Label(self.toplevel4winConfig, text = "Set the override redirect flag?")
            label4overrideredirect.grid(row = 100, column = 1)
            bool_overrideredirect = BooleanVar(value = False)
            frame4overrideredirect = ttk.Frame(self.toplevel4winConfig)
            frame4overrideredirect.grid(row = 100, column =2)
            radioTrue4overrideredirect = ttk.Radiobutton(frame4overrideredirect, variable = bool_overrideredirect,
                                                         text="Yes", value = True, command = command4overrideredirect)
            radioTrue4overrideredirect.pack(side = LEFT, padx = 20)
            radioFalse4overrideredirect = ttk.Radiobutton(frame4overrideredirect, variable = bool_overrideredirect,
                                                          text = "No", value = False, command = command4overrideredirect)
            radioFalse4overrideredirect.pack(side = RIGHT)

            ### maxsize
            def command4maxsize():
                new_maxsize_width = entry4maxsize_width.get()
                new_maxsize_height = entry4maxsize_height.get()
                windowDesign.maxsize(width = new_maxsize_width, height = new_maxsize_height)
                dictDesignWindowPropCollect["maxsize"] = f"windowDesign.maxsize(width = {new_maxsize_width}, " \
                                                         f"height = {new_maxsize_height})"
            label4maxsize = ttk.Label(self.toplevel4winConfig, text = "Maximum size for the window")
            label4maxsize.grid(row = 110, column = 1)
            frame4maxsize = ttk.Frame(self.toplevel4winConfig)
            frame4maxsize.grid(row = 110, column = 2)
            label4maxsize_width = ttk.Label(frame4maxsize, text = "width:", font = ("TkDefaultFont", 9, "bold"))
            label4maxsize_width.grid(row = 1, column = 1)
            entry4maxsize_width = ttk.Entry(frame4maxsize, width = 7)
            entry4maxsize_width.grid(row = 2, column = 1, padx = 5)
            label4maxsize_height = ttk.Label(frame4maxsize, text = "height:", font = ("TkDefaultFont", 9, "bold"))
            label4maxsize_height.grid(row=1, column=2)
            entry4maxsize_height = ttk.Entry(frame4maxsize, width = 7)
            entry4maxsize_height.grid(row=2, column=2)
            button4maxsize = ttk.Button(frame4maxsize, width = 3, text = ">>", command = command4maxsize)
            button4maxsize.grid(row = 1, rowspan = 2, column = 3, padx = 10)

            ### minsize
            def command4minsize():
                new_minsize_width = entry4minsize_width.get()
                new_minsize_height = entry4minsize_height.get()
                windowDesign.minsize(width = new_minsize_width, height = new_minsize_height)
                dictDesignWindowPropCollect["minsize"] = f"windowDesign.minsize(width = {new_minsize_width}, " \
                                                         f"height = {new_minsize_height})"
            label4minsize = ttk.Label(self.toplevel4winConfig, text="Minimum size for the window")
            label4minsize.grid(row=120, column=1)
            frame4minsize = ttk.Frame(self.toplevel4winConfig)
            frame4minsize.grid(row=120, column=2)
            label4minsize_width = ttk.Label(frame4minsize, text="width:", font = ("TkDefaultFont", 9, "bold"))
            label4minsize_width.grid(row=1, column=1)
            entry4minsize_width = ttk.Entry(frame4minsize, width=7)
            entry4minsize_width.grid(row=2, column=1, padx=5)
            label4minsize_height = ttk.Label(frame4minsize, text="height:", font = ("TkDefaultFont", 9, "bold"))
            label4minsize_height.grid(row=1, column=2)
            entry4minsize_height = ttk.Entry(frame4minsize, width=7)
            entry4minsize_height.grid(row=2, column=2)
            button4minsize = ttk.Button(frame4minsize, width=3, text=">>", command = command4minsize)
            button4minsize.grid(row=1, rowspan=2, column=3, padx = 10)
            
            def command4okay_button():
                print(dictDesignWindowPropCollect)
                self.toplevel4winConfig.destroy()
            button4okay = ttk.Button(self.toplevel4winConfig, text = "Okay", command = command4okay_button)
            button4okay.grid(row = 130, column = 7)

        def exitDesignWindowSetup(self):
            pass

            

        # def destroy(self):
        #     self.toplevel4winConfig.destroy()

        
    class WidgetArrange:
        def __init__(self):
            global iswidget
            iswidget = 0  ### Variable to determine type of Widget to place on Design Window

            ###  Variables to count type of Widget placed on Design Window
            self.widget_button = 1
            self.widget_checkbutton = 1
            self.widget_entry = 1
            self.widget_label = 1
            self.widget_listbox = 1
            self.widget_menu = 1
            self.widget_menubutton = 1
            self.widget_message = 1
            self.widget_optionmenu = 1
            self.widget_scale = 1
            self.widget_scrollbar = 1
            self.widget_spinbox = 1
            self.widget_text = 1
            self.widget_radiobutton = 1
            self.widget_frame = 1
            self.widget_labelframe = 1
            self.widget_panedwindow = 1
            self.widget_toplevel = 1

            ### Variable List to hold handle Widgets that have been added to the Listbox
            self.list_widget_lists = []  ###

            ### Variable List to hold handle Widgets that have been paned to the PanedWindow
            self.dict_widget_panes = {} ###

            ### Dictionary that contains ATTRIBUTES and VALUES of a widget to be displayed
            self.dictCountWidget = {}

            ### Dictionary that contains place layout configurations of all the widgets
            self.dictLayoutConfig = {}

        def focusWidgetTree(self, event):

            self.focus_get = windowObject.tree4Widget.focus()
            
        def createList(self):

            for gg in windowObject.list_entry_list:
                try:
                    gg.get()
                    self.dictCountWidget[arrangeObject.focus_get].insert(END, gg.get())

                except:
                    pass

                else:
                    if gg.get() in self.list_widget_lists:
                        pass
                    else:
                        self.list_widget_lists.append(gg.get())

        def createPane(self):

            for gg in windowObject.pane_entry_list:
                try:
                    gg.get()
                    self.dictCountWidget[gg.get()].lift(self.dictCountWidget[arrangeObject.focus_get])
                    self.dictCountWidget[arrangeObject.focus_get].add(self.dictCountWidget[gg.get()])

                except:
                    pass

                else:
                    list_panes = list(self.dict_widget_panes.values())
                    print(list_panes)
                    if gg.get() in list_panes:
                        pass
                    else:
                        self.dict_widget_panes[gg.get()] = arrangeObject.focus_get


        def motionRelease(self,event):
            global iswidget
            iswidget = None
            try:
                self.focus_get = event.widget.widgetName
                try:
                    windowObject.tree4Widget.selection_set(self.focus_get)
                except:
                    if self.focus_get.startswith("FramePW"):
                        self.focus_get = event.widget.children["!panedwindow"].widgetName
                        windowObject.tree4Widget.selection_set(self.focus_get)

                event.widget.focus()
                windowObject.tree4Widget.focus(self.focus_get)

                if self.focus_get.startswith("Button"):
                    windowObject.determineButton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainButton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:

                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except:
                                eval(f"windowObject.bool_{k}.set(v[1])")


                elif self.focus_get.startswith("Checkbutton"):
                    windowObject.determineCheckbutton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainCheckbutton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")


                elif self.focus_get.startswith("Entry"):
                    windowObject.determineEntry(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainEntry()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("LabelFrame"):
                    windowObject.determineLabelFrame(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainLabelFrame()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        print(dictAttributeCollect)
                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except:
                                eval(f"windowObject.bool_{k}.set(v[1])")
                                
                                
                elif self.focus_get.startswith("Label"):
                    windowObject.determineLabel(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainLabel()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Listbox"):
                    windowObject.determineListbox(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainListbox()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Menubutton"):
                    windowObject.determineMenubutton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainMenubutton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Message"):
                    windowObject.determineMessage(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainMessage()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        print(dictAttributeCollect)
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                try:
                                    dictAttributeCollect[k][0].delete(0, END)
                                    dictAttributeCollect[k][0].insert(0, v[1])
                                except AttributeError:
                                    eval(f"windowObject.bool_{k}.set(v[1])")
                            except:
                                eval(f"windowObject.int_{k}.set(v[1])")

                elif self.focus_get.startswith("Radiobutton"):
                    windowObject.determineRadiobutton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainRadiobutton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Scale"):
                    windowObject.determineScale(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}

                    if event.widget.winfo_name() == "!scale_h":
                        windowObject.spinbox4width.insert(END, int(res["height"])-70)
                    elif event.widget.winfo_name() == "!scale_v":
                        windowObject.spinbox4width.insert(END, int(res["width"])-70)
                    windowObject.mainScale()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        print(dictAttributeCollect)
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                try:
                                    dictAttributeCollect[k][0].delete(0, END)
                                    dictAttributeCollect[k][0].insert(0, v[1])
                                except AttributeError:
                                    eval(f"windowObject.bool_{k}.set(v[1])")
                            except:
                                eval(f"windowObject.int_{k}.set(v[1])")

                elif self.focus_get.startswith("Spinbox"):
                    windowObject.determineSpinbox(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Text"):
                    windowObject.determineText(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainText()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Frame"):
                    windowObject.determineFrame(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainFrame()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("PanedWindow"):

                    self.dictCountWidget[event.widget.master.widgetName].config(borderwidth = 2, relief = "solid")

                    windowObject.determinePanedWindow(None)
                    res = self.dictCountWidget[event.widget.master.widgetName].place_info()
                    res_sub = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[event.widget.master.widgetName] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    self.dictLayoutConfig[self.focus_get] = {"relwidth": res_sub["relwidth"], "relheight": res_sub["relheight"],
                                                            "anchor": res_sub["anchor"]}
                    windowObject.mainPanedWindow()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                try:
                                    dictAttributeCollect[k][0].delete(0, END)
                                    dictAttributeCollect[k][0].insert(0, v[1])
                                except AttributeError:
                                    eval(f"windowObject.bool_{k}.set(v[1])")
                            except:
                                eval(f"windowObject.int_{k}.set(v[1])")



            except AttributeError:
                pass


        # def release(self, event):
        #     try:
        #         res = self.dictCountWidget[self.identifier].place_info()
        #         print(self.identifier, res)
        #     except AttributeError:
        #         pass

        def refreshAttributes(self):

            try:
                if arrangeObject.focus_get.startswith("Button") == True:
                    # self.dictCountWidget[arrangeObject.focus_get].focus()
                    # print(arrangeObject.focus_get)
                    DragDropResizeWidget.__bases__ = (Button,)

                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]

                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("default"); listAttr.remove("fg");
                    listAttr.remove("height"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.entry4command, windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image, windowObject.combo4justify,
                               windowObject.combo4overrelief, windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.spinbox4repeatdelay, windowObject.spinbox4repeatinterval,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable,
                               windowObject.entry4underline, windowObject.entry4wraplength]
                    for i,j in zip(listAttr, listVal):

                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j,j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                        
                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()

                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)
                    # print(dict_)
                    # print(dictAttributeCollect)
                    # print(dictAttributeEditorUpdate)

                elif arrangeObject.focus_get.startswith("Checkbutton") == True:
                    DragDropResizeWidget.__bases__ = (Checkbutton,)

                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("offvalue"); listAttr.remove("onvalue");
                    listAttr.remove("tristateimage"); listAttr.remove("tristatevalue"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.entry4command, windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image, windowObject.bool_indicatoron,
                               windowObject.combo4justify, windowObject.combo4offrelief,
                               windowObject.combo4overrelief, windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.entry4selectcolor, windowObject.entry4selectimage,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable, windowObject.entry4underline, windowObject.entry4variable,
                               windowObject.entry4wraplength]

                    for i, j in zip(listAttr, listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()

                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Entry") == True:
                    DragDropResizeWidget.__bases__ = (Entry,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg");  listAttr.remove("invcmd");
                    listAttr.remove("vcmd"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.entry4disabledbackground, windowObject.entry4disabledforeground,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4insertbackground,
                               windowObject.spinbox4insertborderwidth, windowObject.spinbox4insertofftime,
                               windowObject.spinbox4insertontime, windowObject.spinbox4insertwidth,
                               windowObject.entry4invalidcommand, windowObject.combo4justify,
                               windowObject.entry4readonlybackground, windowObject.combo4relief,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.entry4show, windowObject.combo4state,
                               windowObject.bool_takefocus, windowObject.entrytextvariable, windowObject.combo4validate,
                               windowObject.entry4validatecommand, windowObject.entry4xscrollcommand]
                    for i,j in zip(listAttr,listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("LabelFrame") == True:
                    DragDropResizeWidget.__bases__ = (LabelFrame,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("class");  listAttr.remove("colormap");
                    listAttr.remove("container"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("visual"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.entry4font, windowObject.entry4foreground, windowObject.entry4highlightbackground,
                               windowObject.entry4highlightcolor, windowObject.spinbox4highlightthickness,
                               windowObject.combo4labelanchor, windowObject.entry4labelwidget,
                               windowObject.spinbox4padx, windowObject.spinbox4pady, windowObject.combo4relief,
                               windowObject.bool_takefocus, windowObject.entry4text]

                    for i,j in zip(listAttr, listVal):
                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    
                    windowPRO.after(40, self.refreshAttributes)


                elif arrangeObject.focus_get.startswith("Label") == True:
                    DragDropResizeWidget.__bases__ = (Label,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image, windowObject.combo4justify,
                               windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable,
                               windowObject.entry4underline, windowObject.entry4wraplength]

                    for i, j in zip(listAttr, listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()
                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Listbox") == True:
                    DragDropResizeWidget.__bases__ = (Listbox,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("setgrid"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.combo4activestyle, windowObject.entry4background,
                               windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.entry4disabledforeground,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness,
                               windowObject.combo4justify, windowObject.entry4listvariable, windowObject.combo4relief,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.combo4selectmode, windowObject.combo4state,
                               windowObject.bool_takefocus, windowObject.entry4xscrollcommand,
                               windowObject.entry4yscrollcommand]

                    for i,j in zip(listAttr,listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Menubutton") == True:
                    DragDropResizeWidget.__bases__ = (Menubutton,)
                    self.dictCountWidget[arrangeObject.focus_get].focus()
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.combo4compound, windowObject.combo4cursor,
                               windowObject.combo4direction, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image,
                               windowObject.bool_indicatoron, windowObject.combo4justify, windowObject.entry4menu,
                               windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.combo4state, windowObject.bool_takefocus,
                               windowObject.entry4text, windowObject.entrytextvariable,
                               windowObject.entry4underline, windowObject.entry4wraplength]

                    for i,j in zip(listAttr, listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()
                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Message") == True:
                    DragDropResizeWidget.__bases__ = (Message,)
                    self.dictCountWidget[arrangeObject.focus_get].focus()

                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.combo4anchor, windowObject.int_aspect,
                               windowObject.entry4background, windowObject.spinbox4borderwidth,
                               windowObject.combo4cursor,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.combo4justify,
                               windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief,  windowObject.bool_takefocus,
                               windowObject.entry4text, windowObject.entrytextvariable, ]

                    for i,j in zip(listAttr, listVal):
                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Radiobutton") == True:
                    DragDropResizeWidget.__bases__ = (Radiobutton,)
                    self.dictCountWidget[arrangeObject.focus_get].focus()
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("tristateimage"); listAttr.remove("tristatevalue"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.entry4command, windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image,
                               windowObject.bool_indicatoron,
                               windowObject.combo4justify, windowObject.combo4offrelief,
                               windowObject.combo4overrelief, windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.entry4selectcolor, windowObject.entry4selectimage,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable, windowObject.entry4underline, windowObject.entry4value,
                               windowObject.entry4variable, windowObject.entry4wraplength]

                    for i,j in zip(listAttr, listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()
                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Scale") == True:
                # self.dictCountWidget[arrangeObject.focus_get].focus()
                # print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bigincrement"), listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg");
                    listAttr.remove("length"); listAttr.remove("orient"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground,
                               windowObject.entry4background, windowObject.spinbox4borderwidth,
                               windowObject.entry4command,
                               windowObject.combo4cursor, windowObject.spinbox4digits,
                               windowObject.entry4font, windowObject.entry4foreground, windowObject.entry4from_,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4label,
                               windowObject.combo4relief, windowObject.spinbox4repeatdelay, windowObject.spinbox4repeatinterval,
                               windowObject.entry4resolution, windowObject.bool_showvalue, windowObject.int_sliderlength,
                               windowObject.combo4sliderrelief,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4tickinterval,
                               windowObject.entry4to, windowObject.entry4troughcolor, windowObject.entry4variable]
                    for i,j in zip(listAttr, listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "label") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Spinbox") == True:
                    DragDropResizeWidget.__bases__ = (Spinbox,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg");  listAttr.remove("invcmd");
                    listAttr.remove("vcmd"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground,windowObject.entry4background,
                               windowObject.spinbox4borderwidth, windowObject.entry4buttonbackground,
                               windowObject.combo4buttoncursor, windowObject.combo4buttondownrelief,
                               windowObject.combo4buttonuprelief, windowObject.entry4command,windowObject.combo4cursor,
                               windowObject.entry4disabledbackground, windowObject.entry4disabledforeground,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4format, windowObject.entry4from_,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4increment,
                               windowObject.entry4insertbackground,
                               windowObject.spinbox4insertborderwidth, windowObject.spinbox4insertofftime,
                               windowObject.spinbox4insertontime, windowObject.spinbox4insertwidth,
                               windowObject.entry4invalidcommand, windowObject.combo4justify,
                               windowObject.entry4readonlybackground, windowObject.combo4relief,
                               windowObject.spinbox4repeatdelay, windowObject.spinbox4repeatinterval,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.combo4state,
                               windowObject.bool_takefocus, windowObject.entrytextvariable, windowObject.entry4to,
                               windowObject.combo4validate, windowObject.entry4validatecommand,
                               windowObject.entry4values, windowObject.bool_wrap, windowObject.entry4xscrollcommand]
                    for i,j in zip(listAttr,listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Text") == True:
                    DragDropResizeWidget.__bases__ = (Text,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("endline"); listAttr.remove("fg");
                    listAttr.remove("height"); listAttr.remove("setgrid"); listAttr.remove("startline");
                    listAttr.remove("tabstyle"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.bool_autoseparators, windowObject.entry4background, windowObject.bool_blockcursor,
                               windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4inactiveselectbackground,
                               windowObject.entry4insertbackground,
                               windowObject.spinbox4insertborderwidth, windowObject.spinbox4insertofftime,
                               windowObject.spinbox4insertontime, windowObject.combo4insertunfoccussed,
                               windowObject.spinbox4insertwidth, windowObject.entry4maxundo, windowObject.spinbox4padx,
                               windowObject.spinbox4pady, windowObject.combo4relief,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.spinbox4spacing1, windowObject.spinbox4spacing2,
                               windowObject.spinbox4spacing3, windowObject.combo4state, windowObject.entry4tabs,
                               windowObject.bool_takefocus, windowObject.bool_undo, windowObject.combo4wrap_Text,
                               windowObject.entry4xscrollcommand, windowObject.entry4yscrollcommand]
                    for i,j in zip(listAttr,listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(1000, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Frame") == True:
                    DragDropResizeWidget.__bases__ = (Frame,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("class");  listAttr.remove("colormap");
                    listAttr.remove("container"); listAttr.remove("height"); listAttr.remove("visual");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth,
                               windowObject.combo4cursor, windowObject.entry4highlightbackground,
                               windowObject.entry4highlightcolor, windowObject.spinbox4highlightthickness,
                               windowObject.spinbox4padx, windowObject.spinbox4pady, windowObject.combo4relief,
                               windowObject.bool_takefocus]

                    for i,j in zip(listAttr, listVal):

                        if j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("PanedWindow") == True:
                    DragDropResizeWidget.__bases__ = (Frame,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("height");
                    listAttr.remove("proxybackground"); listAttr.remove("proxyborderwidth"); listAttr.remove("proxyrelief");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.spinbox4handlepad, windowObject.spinbox4handlesize,
                               windowObject.bool_opaqueresize, windowObject.combo4orient,
                               windowObject.combo4relief, windowObject.combo4sashcursor, windowObject.int_sashpad,
                               windowObject.combo4sashrelief, windowObject.int_sashwidth, windowObject.bool_showhandle]

                    for i,j in zip(listAttr, listVal):

                        if j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)



            except (AttributeError, TclError,):
                # print("okay")
                windowPRO.after(10, self.refreshAttributes)


        def executeWidgetsOnDesignWindow(self, event):
            global iswidget

            try:
                if event.widget.widgetName.startswith("PanedWindow"):
                    self.dictCountWidget[event.widget.master.widgetName].config(borderwidth = 2, relief = SOLID)
                elif event.widget.widgetName.startswith("FramePW"):
                    self.dictCountWidget[event.widget.widgetName].config(borderwidth=2, relief=SOLID)

            except:
                 for ii in self.dictCountWidget:
                     if ii.startswith("FramePW"):
                         self.dictCountWidget[ii].config(borderwidth = 0, relief = SOLID)

            if iswidget == "button":

                dict_[list_button[self.widget_button]] = {"text": f"Button{self.widget_button}"}
                dictAttributeEditorUpdate[list_button[self.widget_button]] = {}     ### Initiate storage of Attributes for every widget

                if str(event.widget) == ".":
                    self.dictLayoutConfig[list_button[self.widget_button]] = {"x": event.x, "y": event.y, "width": 70,
                                                                              "height": 30, "anchor": "nw"}
                elif str(event.widget).startswith(".!scale") == True:
                    self.dictLayoutConfig[list_button[self.widget_button]] = {"x": event.widget.winfo_x() + event.x,
                                                        "y": event.widget.winfo_y() + event.y, "width": 70, "height": 30,
                                                                              "anchor": "nw"}
                elif str(event.widget).startswith(".!dragdropresizewidget") == True:
                    self.dictLayoutConfig[list_button[self.widget_button]] = {"x": event.widget.winfo_x() + event.x,
                                                                              "y": event.widget.winfo_y() + event.y,
                                                                              "width": 70, "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Button{self.widget_button}",
                                                text=f"Button{self.widget_button}")
                windowObject.tree4Widget.selection_set(f"Button{self.widget_button}")
                windowObject.tree4Widget.focus(f"Button{self.widget_button}")
                DragDropResizeWidget.__bases__ = (Button,)
                self.dictCountWidget[f"Button{self.widget_button}"] = DragDropResizeWidget(windowDesign,
                                                                             **dict_[list_button[self.widget_button]])
                self.dictCountWidget[f"Button{self.widget_button}"].place(**self.dictLayoutConfig[list_button[self.widget_button]])
                self.dictCountWidget[f"Button{self.widget_button}"].focus()

                self.dictCountWidget[f"Button{self.widget_button}"].widgetName = f"Button{self.widget_button}"
                windowObject.mainButton()
                windowObject.entry4text.delete(0, END)
                windowObject.entry4text.insert(0, f"Button{self.widget_button}")
                windowObject.entry4widget_variable.insert(END, f"Button{self.widget_button}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_button += 1


            elif iswidget == "checkbutton":
                dict_[list_checkbutton[self.widget_checkbutton]] = {"text": f"Checkbutton{self.widget_checkbutton}"}
                dictAttributeEditorUpdate[
                    list_checkbutton[self.widget_checkbutton]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_checkbutton[self.widget_checkbutton]] = {"x": event.x, "y": event.y, "width": 100,
                                                                                "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Checkbutton{self.widget_checkbutton}",
                                                text=f"Checkbutton{self.widget_checkbutton}")
                windowObject.tree4Widget.selection_set(f"Checkbutton{self.widget_checkbutton}")
                windowObject.tree4Widget.focus(f"Checkbutton{self.widget_checkbutton}")
                DragDropResizeWidget.__bases__ = (Checkbutton,)
                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"] = DragDropResizeWidget(windowDesign,
                                                                                            **dict_[list_checkbutton[self.widget_checkbutton]])
                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"].place(**self.dictLayoutConfig[list_checkbutton[self.widget_checkbutton]])
                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"].focus()

                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"].widgetName = f"Checkbutton{self.widget_checkbutton}"
                windowObject.mainCheckbutton()
                windowObject.entry4text.insert(0, f"Checkbutton{self.widget_checkbutton}")
                windowObject.entry4widget_variable.insert(END, f"Checkbutton{self.widget_checkbutton}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_checkbutton += 1

            elif iswidget == "entry":
                dict_[list_entry[self.widget_entry]] = {}
                dictAttributeEditorUpdate[
                    list_entry[self.widget_entry]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_entry[self.widget_entry]] = {"x": event.x, "y": event.y, "width": 100,
                                                                        "height": 20, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index = END, iid = f"Entry{self.widget_entry}",
                                                text = f"Entry{self.widget_entry}")
                windowObject.tree4Widget.selection_set(f"Entry{self.widget_entry}")
                windowObject.tree4Widget.focus(f"Entry{self.widget_entry}")
                DragDropResizeWidget.__bases__ = (Entry,)
                self.dictCountWidget[f"Entry{self.widget_entry}"] = DragDropResizeWidget(windowDesign, **dict_[list_entry[
                                                                                                self.widget_entry]])
                self.dictCountWidget[f"Entry{self.widget_entry}"].place(**self.dictLayoutConfig[list_entry[self.widget_entry]])
                self.dictCountWidget[f"Entry{self.widget_entry}"].focus()

                self.dictCountWidget[f"Entry{self.widget_entry}"].widgetName = f"Entry{self.widget_entry}"
                windowObject.mainEntry()
                windowObject.entry4widget_variable.insert(END, f"Entry{self.widget_entry}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_entry += 1

            elif iswidget == "label":
                dict_[list_label[self.widget_label]] = {"text": f"Label{self.widget_label}"}
                dictAttributeEditorUpdate[
                    list_label[self.widget_label]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_label[self.widget_label]] = {"x": event.x, "y": event.y, "width": 70,
                                                                        "height": 30, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Label{self.widget_label}",
                                                text=f"Label{self.widget_label}")
                windowObject.tree4Widget.selection_set(f"Label{self.widget_label}")
                windowObject.tree4Widget.focus(f"Label{self.widget_label}")
                DragDropResizeWidget.__bases__ = (Label,)
                self.dictCountWidget[f"Label{self.widget_label}"] = DragDropResizeWidget(windowDesign, **dict_[list_label[
                    self.widget_label]])
                self.dictCountWidget[f"Label{self.widget_label}"].place(**self.dictLayoutConfig[list_label[self.widget_label]])
                self.dictCountWidget[f"Label{self.widget_label}"].focus()

                self.dictCountWidget[f"Label{self.widget_label}"].widgetName = f"Label{self.widget_label}"
                windowObject.mainLabel()
                windowObject.entry4text.insert(0, f"Label{self.widget_label}")
                windowObject.entry4widget_variable.insert(END, f"Label{self.widget_label}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_label += 1

            elif iswidget == "listbox":
                dict_[list_listbox[self.widget_listbox]] = {}
                dictAttributeEditorUpdate[
                    list_listbox[self.widget_listbox]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_listbox[self.widget_listbox]] = {"x": event.x, "y": event.y, "width": 120,
                                                                            "height": 150, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Listbox{self.widget_listbox}",
                                                text=f"Listbox{self.widget_listbox}")
                windowObject.tree4Widget.selection_set(f"Listbox{self.widget_listbox}")
                windowObject.tree4Widget.focus(f"Listbox{self.widget_listbox}")
                DragDropResizeWidget.__bases__ = (Listbox,)
                self.dictCountWidget[f"Listbox{self.widget_listbox}"] = DragDropResizeWidget(windowDesign,
                                                                                **dict_[list_listbox[self.widget_listbox]])
                self.dictCountWidget[f"Listbox{self.widget_listbox}"].place(**self.dictLayoutConfig[list_listbox[self.widget_listbox]])
                self.dictCountWidget[f"Listbox{self.widget_listbox}"].focus()

                self.dictCountWidget[f"Listbox{self.widget_listbox}"].widgetName = f"Listbox{self.widget_label}"
                windowObject.mainListbox()
                windowObject.entry4widget_variable.insert(END, f"Listbox{self.widget_listbox}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_listbox += 1

            elif iswidget == "menubutton":
                dict_[list_menubutton[self.widget_menubutton]] = {"text": f"Menubutton{self.widget_menubutton}"}
                dictAttributeEditorUpdate[
                    list_menubutton[self.widget_menubutton]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_menubutton[self.widget_menubutton]] = {"x": event.x, "y": event.y, "width": 110,
                                                                                  "height": 30, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Menubutton{self.widget_menubutton}",
                                                text=f"Menubutton{self.widget_menubutton}")
                windowObject.tree4Widget.selection_set(f"Menubutton{self.widget_menubutton}")
                windowObject.tree4Widget.focus(f"Menubutton{self.widget_menubutton}")
                DragDropResizeWidget.__bases__ = (Menubutton,)
                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"] = DragDropResizeWidget(windowDesign,
                                                                        **dict_[list_menubutton[self.widget_menubutton]])
                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"].place(**self.dictLayoutConfig[list_menubutton[self.widget_menubutton]])
                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"].focus()

                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"].widgetName = f"Menubutton{self.widget_menubutton}"
                windowObject.mainMenubutton()
                windowObject.entry4text.insert(0, f"Menubutton{self.widget_menubutton}")
                windowObject.entry4widget_variable.insert(END, f"Menubutton{self.widget_menubutton}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_menubutton += 1

            elif iswidget == "message":
                dict_[list_message[self.widget_message]] = {"text": f"Message{self.widget_message}"}
                dictAttributeEditorUpdate[
                    list_message[self.widget_message]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_message[self.widget_message]] = {"x": event.x, "y": event.y, "width": 100,
                                                                            "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Message{self.widget_message}",
                                                text=f"Message{self.widget_message}")
                windowObject.tree4Widget.selection_set(f"Message{self.widget_message}")
                windowObject.tree4Widget.focus(f"Message{self.widget_message}")
                DragDropResizeWidget.__bases__ = (Message,)
                self.dictCountWidget[f"Message{self.widget_message}"] = DragDropResizeWidget(windowDesign,
                                                                            **dict_[list_message[self.widget_message]])
                self.dictCountWidget[f"Message{self.widget_message}"].place(**self.dictLayoutConfig[list_message[self.widget_message]])
                self.dictCountWidget[f"Message{self.widget_message}"].focus()

                self.dictCountWidget[f"Message{self.widget_message}"].widgetName = f"Message{self.widget_message}"
                windowObject.mainMessage()
                windowObject.entry4text.insert(0, f"Message{self.widget_message}")
                windowObject.entry4widget_variable.insert(END, f"Message{self.widget_message}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_message += 1

            elif iswidget == "radiobutton":
                dict_[list_radiobutton[self.widget_radiobutton]] = {"text": f"Radiobutton{self.widget_radiobutton}"}
                dictAttributeEditorUpdate[
                    list_radiobutton[self.widget_radiobutton]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_radiobutton[self.widget_radiobutton]] = {"x": event.x, "y": event.y, "width": 100,
                                                                            "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Radiobutton{self.widget_radiobutton}",
                                                text=f"Radiobutton{self.widget_radiobutton}")
                windowObject.tree4Widget.selection_set(f"Radiobutton{self.widget_radiobutton}")
                windowObject.tree4Widget.focus(f"Radiobutton{self.widget_radiobutton}")
                DragDropResizeWidget.__bases__ = (Radiobutton,)
                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_radiobutton[
                                                                                                 self.widget_radiobutton]])
                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"].place(
                    **self.dictLayoutConfig[list_radiobutton[self.widget_radiobutton]])
                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"].focus()

                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"].widgetName = f"Radiobutton{self.widget_radiobutton}"
                windowObject.mainRadiobutton()
                windowObject.entry4text.insert(0, f"Radiobutton{self.widget_radiobutton}")
                windowObject.entry4widget_variable.insert(END, f"Radiobutton{self.widget_radiobutton}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_radiobutton += 1

            elif iswidget == "scale_horizontal":
                dict_[list_scale[self.widget_scale]] = {"label": f"Scale{self.widget_scale}", "orient": "horizontal"}
                dictAttributeEditorUpdate[
                    list_scale[self.widget_scale]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_scale[self.widget_scale]] = {"x": event.x, "y": event.y, "width": 60,
                                                                            "height": 50, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Scale{self.widget_scale}",
                                                text=f"Scale{self.widget_scale}")
                windowObject.tree4Widget.selection_set(f"Scale{self.widget_scale}")
                windowObject.tree4Widget.focus(f"Scale{self.widget_scale}")
                self.dictCountWidget[f"Scale{self.widget_scale}"] = Scale_H(windowDesign, **dict_[list_scale[
                                                                                                 self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].place(
                    **self.dictLayoutConfig[list_scale[self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].focus()

                self.dictCountWidget[f"Scale{self.widget_scale}"].widgetName = f"Scale{self.widget_scale}"
                windowObject.mainScale()
                windowObject.entry4label.insert(0, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable.insert(END, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_scale += 1

            elif iswidget == "scale_vertical":
                dict_[list_scale[self.widget_scale]] = {"label": f"Scale{self.widget_scale}", "orient": "vertical"}
                dictAttributeEditorUpdate[
                    list_scale[self.widget_scale]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_scale[self.widget_scale]] = {"x": event.x, "y": event.y, "width": 60,
                                                                            "height": 100, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Scale{self.widget_scale}",
                                                text=f"Scale{self.widget_scale}")
                windowObject.tree4Widget.selection_set(f"Scale{self.widget_scale}")
                windowObject.tree4Widget.focus(f"Scale{self.widget_scale}")

                self.dictCountWidget[f"Scale{self.widget_scale}"] = Scale_V(windowDesign, **dict_[list_scale[
                                                                                                 self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].place(
                    **self.dictLayoutConfig[list_scale[self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].focus()

                self.dictCountWidget[f"Scale{self.widget_scale}"].widgetName = f"Scale{self.widget_scale}"
                windowObject.mainScale()
                windowObject.entry4label.insert(0, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable.insert(END, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_scale += 1

            elif iswidget == "spinbox":
                dict_[list_spinbox[self.widget_spinbox]] = {}
                dictAttributeEditorUpdate[
                    list_spinbox[self.widget_spinbox]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_spinbox[self.widget_spinbox]] = {"x": event.x, "y": event.y, "width": 150,
                                                                            "height": 20, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Spinbox{self.widget_spinbox}",
                                                text=f"Spinbox{self.widget_spinbox}")
                windowObject.tree4Widget.selection_set(f"Spinbox{self.widget_spinbox}")
                windowObject.tree4Widget.focus(f"Spinbox{self.widget_spinbox}")
                DragDropResizeWidget.__bases__ = (Spinbox,)
                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_spinbox[
                                                                                                 self.widget_spinbox]])
                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"].place(
                    **self.dictLayoutConfig[list_spinbox[self.widget_spinbox]])
                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"].focus()

                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"].widgetName = f"Spinbox{self.widget_spinbox}"
                windowObject.mainSpinbox()
                windowObject.entry4widget_variable.insert(END, f"Spinbox{self.widget_spinbox}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_spinbox += 1

            elif iswidget == "text":
                dict_[list_text[self.widget_text]] = {}
                dictAttributeEditorUpdate[
                    list_text[self.widget_text]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_text[self.widget_text]] = {"x": event.x, "y": event.y, "width": 300,
                                                                      "height": 300, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index = END, iid = f"Text{self.widget_text}",
                                                text = f"Text{self.widget_text}")
                windowObject.tree4Widget.selection_set(f"Text{self.widget_text}")
                windowObject.tree4Widget.focus(f"Text{self.widget_text}")
                DragDropResizeWidget.__bases__ = (Text,)
                self.dictCountWidget[f"Text{self.widget_text}"] = DragDropResizeWidget(windowDesign, **dict_[list_text[
                                                                                                self.widget_text]])
                self.dictCountWidget[f"Text{self.widget_text}"].place(**self.dictLayoutConfig[list_text[self.widget_text]])
                self.dictCountWidget[f"Text{self.widget_text}"].focus()

                self.dictCountWidget[f"Text{self.widget_text}"].widgetName = f"Text{self.widget_text}"
                windowObject.mainText()
                windowObject.entry4widget_variable.insert(END, f"Text{self.widget_text}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_text += 1

            elif iswidget == "frame":
                dict_[list_frame[self.widget_frame]] = {"borderwidth": 2, "relief": "solid"}
                dictAttributeEditorUpdate[
                    list_frame[self.widget_frame]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_frame[self.widget_frame]] = {"x": event.x, "y": event.y, "width": 200,
                                                                            "height": 200, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Frame{self.widget_frame}",
                                                text=f"Frame{self.widget_frame}")
                windowObject.tree4Widget.selection_set(f"Frame{self.widget_frame}")
                windowObject.tree4Widget.focus(f"Frame{self.widget_frame}")
                DragDropResizeWidget.__bases__ = (Frame,)
                self.dictCountWidget[f"Frame{self.widget_frame}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_frame[
                                                                                                 self.widget_frame]])
                self.dictCountWidget[f"Frame{self.widget_frame}"].place(
                    **self.dictLayoutConfig[list_frame[self.widget_frame]])
                self.dictCountWidget[f"Frame{self.widget_frame}"].focus()

                self.dictCountWidget[f"Frame{self.widget_frame}"].widgetName = f"Frame{self.widget_frame}"
                windowObject.mainFrame()
                windowObject.spinbox4borderwidth.insert(END, 2)
                windowObject.combo4relief.insert(END, "solid")
                windowObject.entry4widget_variable.insert(END, f"Frame{self.widget_frame}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_frame += 1

            elif iswidget == "labelframe":
                dict_[list_labelframe[self.widget_labelframe]] = {"text": f"LabelFrame{self.widget_labelframe}"}
                dictAttributeEditorUpdate[
                    list_labelframe[self.widget_labelframe]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_labelframe[self.widget_labelframe]] = {"x": event.x, "y": event.y, "width": 200,
                                                                            "height": 200, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"LabelFrame{self.widget_labelframe}",
                                                text=f"LabelFrame{self.widget_labelframe}")
                windowObject.tree4Widget.selection_set(f"LabelFrame{self.widget_labelframe}")
                windowObject.tree4Widget.focus(f"LabelFrame{self.widget_labelframe}")
                DragDropResizeWidget.__bases__ = (LabelFrame,)
                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_labelframe[
                                                                                                 self.widget_labelframe]])
                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"].place(
                    **self.dictLayoutConfig[list_labelframe[self.widget_labelframe]])
                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"].focus()

                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"].widgetName = f"LabelFrame{self.widget_labelframe}"
                windowObject.mainLabelFrame()
                windowObject.entry4text.insert(0, f"LabelFrame{self.widget_labelframe}")
                windowObject.entry4widget_variable.insert(END, f"LabelFrame{self.widget_labelframe}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_labelframe += 1

            elif iswidget == "panedwindow":
                dict_[f"FramePW{self.widget_panedwindow}"] = {"borderwidth": 2, "relief": "solid"}
                dict_[list_panedwindow[self.widget_panedwindow]] = {"background": "grey"}
                dictAttributeEditorUpdate[
                    list_panedwindow[self.widget_panedwindow]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_framepw[self.widget_panedwindow]] = {"x": event.x, "y": event.y, "width": 200,
                                                                            "height": 200, "anchor": "nw"}
                self.dictLayoutConfig[list_panedwindow[self.widget_panedwindow]] = {"relwidth": 0.8, "relheight": 1}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"PanedWindow{self.widget_panedwindow}",
                                                text=f"PanedWindow{self.widget_panedwindow}")
                windowObject.tree4Widget.selection_set(f"PanedWindow{self.widget_panedwindow}")
                windowObject.tree4Widget.focus(f"PanedWindow{self.widget_panedwindow}")
                DragDropResizeWidget.__bases__ = (Frame,)
                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"] = DragDropResizeWidget(windowDesign,
                                                                            **dict_[f"FramePW{self.widget_panedwindow}"])

                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"].place(
                    **self.dictLayoutConfig[list_framepw[self.widget_panedwindow]])

                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"] = PanedWindow(
                                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"],
                                                                                             **dict_[list_panedwindow[
                                                                                                 self.widget_panedwindow]])
                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"].place(relwidth = 0.8, relheight = 1)

                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"].focus()

                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"].widgetName = f"FramePW{self.widget_panedwindow}"
                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"].widgetName = f"PanedWindow{self.widget_panedwindow}"
                windowObject.mainPanedWindow()
                windowObject.entry4background.insert(0, "grey")
                windowObject.entry4widget_variable.insert(END, f"PanedWindow{self.widget_panedwindow}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_panedwindow += 1


    class CodeGenerate:
        def __init__(self):
            self.compile2Shell()
            


        def compile2Text(self):
            toplevel4Text = Toplevel(master = windowPRO, name = "toplevel_textbox")
            toplevel4Text.geometry = ("400x400+500+500")
            toplevel4Text.resizable(False, False)

            def copy_gen_codes():
                windowPRO.clipboard_clear()
                windowPRO.clipboard_append(self.string_final_codes)
                label_copy = Label(toplevel4Text, text = "Copied Successfully", font = ("Segoe UI", 10, "bold"))
                label_copy.pack(fill = X, )

            menu4copy = Menu(tearoff = False)
            menu4copy.add_command(label = "Copy", command = copy_gen_codes)
            toplevel4Text.config(menu = menu4copy)

            scroll4CompileText = Scrollbar(master=toplevel4Text, orient="vertical", )
            scroll4CompileText.pack(side=RIGHT, fill=Y)

            text4CompileText = Text(master = toplevel4Text, yscrollcommand = scroll4CompileText.set)
            text4CompileText.insert(END, self.string_final_codes)
            text4CompileText.config(state = "disabled")
            text4CompileText.pack()
            scroll4CompileText.config(command = text4CompileText.yview)




        def compile2PythonFile(self):
            file_gen_code = filedialog.asksaveasfile("w", filetypes = [("Python file","*.py")], defaultextension = ".py")
            print(file_gen_code)
            file_open = open(file_gen_code.name, "w")
            file_open.write(self.string_final_codes)
            file_open.close()


        def compile2Shell(self):
            string_command_all = ""
            string_font_all = ""
            string_image_all = ""
            string_button_all = ""
            string_checkbutton_all = ""
            string_entry_all = ""
            string_frame_all = ""
            string_labelframe_all = ""
            string_label_all = ""
            string_listbox_all = ""
            string_menubutton_all = ""
            string_message_all = ""
            string_radiobutton_all = ""
            string_scale_all = ""
            string_spinbox_all = ""
            string_text_all = ""
            string_framepw_all = ""
            string_panedwindow_all = ""
            string_panes = ""
            ### Run main window and its properties
            string_window_prop = ""
            string_iconphoto = ""
            string_header = "from tkinter import *\nfrom tkinter import font \n\nwindowDesign = Tk()"
            string_commands = ''
            string_mainloop = "windowDesign.mainloop()"
            for k,v in zip(dictDesignWindowPropCollect.keys(), dictDesignWindowPropCollect.values()):
                if k == "iconphoto":
                    string_iconphoto = f"IconPhoto = {v})"
                    continue
                string_window_prop = string_window_prop + v + "\n"
            string_all_header = string_header+"\n"+string_iconphoto+"\n"+string_window_prop

            ##### Commands Output section for Design window widgets
            for com in windowObject.commands_all:
                string_commands = ""
                if windowObject.commands_all[com] == None:
                    continue
                else:
                    com_value = windowObject.commands_all[com]
                    string_commands = string_commands + f"def {com_value}():      # Command for {com}" + "\n"
                    string_commands = string_commands + "    pass"
                string_command_all = string_command_all + string_commands

            for i,j,k in zip(arrangeObject.dictCountWidget.keys(), dict_.items(), arrangeObject.dictLayoutConfig.items()):
                new_dict_main = {}
                new_dict_layout = {}
                if i.startswith("FramePW")|i.startswith("PanedWindow"):
                    continue;

                else:
                    string_font_button = ""
                    string_image_button = ""
                    if i.startswith("Button"):

                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_button = string_font_button + f"{n} = font.Font(name = '{font_name}', " \
                                                                f"family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_button

                        widget_image = j["image"]
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_button = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_button

                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Button("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                          f"anchor = '{k['anchor']}')"
                        widgetStr = f"{i} = {widgetStr}\n"
                        string_button_all = string_button_all + widgetStr


                    if i.startswith("Checkbutton"):
                        string_font_checkbutton = ""
                        string_image_checkbutton = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_checkbutton = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_checkbutton
                        widget_image = j["image"]
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_checkbutton = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_checkbutton

                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Checkbutton("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')"
                        widgetStr = f"{i} = {widgetStr}\n"
                        string_checkbutton_all = string_checkbutton_all + widgetStr


                    if i.startswith("Entry"):
                        string_font_entry = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_entry = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_entry
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Entry("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_entry_all = string_entry_all + widgetStr

                    if i.startswith("Frame"):

                        j = dict(sorted(j[1].items()))
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Frame("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_frame_all = string_frame_all + widgetStr
                        

                    if i.startswith("LabelFrame"):
                        string_font_labelframe = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_labelframe = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_labelframe
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"LabelFrame("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"

                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}," \
                              f"anchor = '{k['anchor']}')\n"
                        string_labelframe_all = string_labelframe_all + widgetStr
                    
                    if i.startswith("Label"):
                        string_font_label = ""
                        string_image_label = ""
                        try:
                            j = dict(sorted(j[1].items()))
                            widget_font = j["font"]
                            for n in windowObject.dictCountFont:
                                if widget_font == windowObject.dictCountFont[n].name:
                                    font_name = windowObject.dictCountFont[n].name
                                    actual = windowObject.dictCountFont[n].actual()
                                    string_font_label = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                          f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                          f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                          f"overstrike = {actual['overstrike']})\n"
                                else:
                                    pass
                            string_font_all = string_font_all + string_font_label
                            widget_image = j["image"]
                            for im in windowObject.dictCountImage:
                                if widget_image == windowObject.dictCountImage[im].name:
                                    image_name = windowObject.dictCountImage[im].name
                                    image_file = windowObject.dictCountImage[im].cget("file")
                                    string_image_label = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                                else:
                                    pass
                            string_image_all = string_image_all + string_image_label

                            k = arrangeObject.dictLayoutConfig[i]
                            widgetStr = f"Label("
                            for jj in j:
                                dd = jj.replace("'", "")
                                dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                                widgetStr = widgetStr + dd
                            widgetStr = widgetStr + ")"
                            widgetStr = f"{i} = {widgetStr}"
                            widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, "\
                                  f"anchor = '{k['anchor']}')\n"
                            string_label_all = string_label_all + widgetStr
                        except KeyError:
                            pass

                    if i.startswith("Listbox"):
                        string_font_listbox = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_listbox = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_listbox
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Listbox("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_listbox_all = string_listbox_all + widgetStr

                    if i.startswith("Menubutton"):
                        string_font_menubutton = ""
                        string_image_menubutton = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_menubutton = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                            widget_image = j["image"]
                        string_font_all = string_font_all + string_font_menubutton
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_menubutton = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_menubutton
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Menubutton("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_menubutton_all = string_menubutton_all + widgetStr

                    if i.startswith("Message"):
                        string_font_message = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_message = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_message
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Message("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_message_all = string_message_all + widgetStr

                    if i.startswith("Radiobutton"):
                        string_font_radiobutton = ""
                        string_image_radiobutton = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_radiobutton = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_radiobutton
                        widget_image = j["image"]
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_radiobutton = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_radiobutton

                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Radiobutton("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_radiobutton_all = string_radiobutton_all + widgetStr

                    if i.startswith("Scale"):
                        string_font_scale = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_scale = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_scale
                        k = arrangeObject.dictLayoutConfig[i]
                        if j["orient"] == "vertical":
                            k_width = int(k["width"])-70
                            widgetStr = f"Scale("
                            for jj in j:
                                dd = jj.replace("'", "")
                                dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                                widgetStr = widgetStr + dd
                            if windowObject.commands_all[i] == None:
                                widgetStr = widgetStr + f" width = {k_width})"
                            else:
                                widgetStr = widgetStr + f"width = {k_width}, command = {windowObject.commands_all[i]})"

                            widgetStr = f"{i} = {widgetStr}"
                            widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, anchor = '{k['anchor']}')\n"
                            string_scale_all = string_scale_all + widgetStr

                        elif j["orient"] == "horizontal":
                            k_height = int(k["height"])-70
                            widgetStr = f"Scale("
                            for jj in j:
                                dd = jj.replace("'", "")
                                dd = f"{dd} = {j[jj], }".replace("(","").replace(")"," ")
                                widgetStr = widgetStr + dd
                            if windowObject.commands_all[i] == None:
                                widgetStr = widgetStr + f" width = {k_height})"
                            else:
                                widgetStr = widgetStr + f"width = {k_height}, command = {windowObject.commands_all[i]})"

                            widgetStr = f"{i} = {widgetStr}"
                            widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, width = {k['width']}, anchor = '{k['anchor']}')\n"
                            string_scale_all = string_scale_all + widgetStr

                    if i.startswith("Spinbox"):
                        string_font_spinbox = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_spinbox = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_spinbox
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Spinbox("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_scale_all = string_scale_all + widgetStr

                    if i.startswith("Text"):
                        string_font_text = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_text = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_text
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Text("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_text_all = string_text_all + widgetStr

            for i, j, k in zip(arrangeObject.dictCountWidget.keys(), dict_.items(), arrangeObject.dictLayoutConfig.items()):
                if i.startswith("FramePW"):
                    j = dict(sorted(j[1].items()))
                    k = arrangeObject.dictLayoutConfig[i]
                    widgetStr = f"Frame("
                    for jj in j:
                        dd = jj.replace("'", "")
                        dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                        widgetStr = widgetStr + dd
                    widgetStr = widgetStr + ")"
                    widgetStr = f"{i} = {widgetStr}"
                    widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                          f"anchor = '{k['anchor']}')\n"
                    masterPW = i
                    string_framepw_all = string_framepw_all + widgetStr

                elif i.startswith("PanedWindow"):
                    j = dict(sorted(j[1].items()))
                    widgetStr = f"PanedWindow({masterPW}, "
                    for jj in j:
                        dd = jj.replace("'", "")
                        dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                        widgetStr = widgetStr + dd
                    widgetStr = widgetStr + ")"

                    widgetStr = f"{i} = {widgetStr}"
                    widgetStr = widgetStr + f"\n{i}.place(relheight = 1, relwidth = 0.8)\n"
                    for ke,val in zip(arrangeObject.dict_widget_panes.keys(), arrangeObject.dict_widget_panes.values()):
                        print(arrangeObject.dict_widget_panes)
                        string_panes = string_panes + f"{ke}.lift()\n"
                        string_panes = string_panes + f"{val}.add({ke})\n"
                    string_panedwindow_all = string_panedwindow_all + widgetStr


            self.string_final_codes = string_all_header + "\n" + string_command_all + "\n" + string_font_all + string_image_all + \
            string_button_all + string_checkbutton_all + string_entry_all + string_frame_all + string_labelframe_all + \
            string_label_all + string_listbox_all + string_menubutton_all + string_message_all + string_radiobutton_all + \
            string_scale_all + string_spinbox_all + string_text_all + string_framepw_all + string_panedwindow_all + \
            string_panes + "\n" + string_mainloop



    class DragDropResizeWidget(Button):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.bind("<Motion>", self.motion1Both)

        def cursorChange(self, event):
            self["cursor"] = windowObject.combo4cursor.get()

        def startDrag(self, event):
            self.start_drag_x = event.x
            self.start_drag_y = event.y

        def motionDrag(self, event):
            self["cursor"] = "bogosity"
            self.place_configure(anchor="nw")
            new_x = (self.winfo_x() + event.x) - self.start_drag_x
            new_y = (self.winfo_y() + event.y) - self.start_drag_y
            self.place(x=new_x, y=new_y)

        def motion1Both(self, event):
            self.xx = self.winfo_x() + int(self.place_info()["width"])
            self.yy = self.winfo_y() + int(self.place_info()["height"])
            self.ttx = event.x + self.winfo_x()
            self.tty = event.y + self.winfo_y()

            if ((self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)) & (
                    (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                self["cursor"] = "bottom_right_corner"
                self.bind("<Button1-Motion>", self.motionBottomRight)

            elif ((self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                    self.winfo_x() == self.ttx - 3)) & (
                    (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                self["cursor"] = "bottom_left_corner"
                self.bind("<Button1-Motion>", self.motionBottomLeft)

            elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                    self.winfo_y() == self.tty - 3)) & (
                    (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                    self.winfo_x() == self.ttx - 3)):
                self["cursor"] = "top_left_corner"
                self.bind("<Button1-Motion>", self.motionTopLeft)

            elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                    self.winfo_y() == self.tty - 3)) & (
                    (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)):
                self["cursor"] = "top_right_corner"
                self.bind("<Button1-Motion>", self.motionTopRight)

            elif (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3):
                self["cursor"] = "right_side"
                self.bind("<Button1-Motion>", self.motionRight)

            elif (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3):
                self["cursor"] = "bottom_side"
                self.bind("<Button1-Motion>", self.motionBottom)

            elif (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (self.winfo_x() == self.ttx - 3):
                self["cursor"] = "left_side"
                self.bind("<Button1-Motion>", self.motionLeft)

            elif (self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (self.winfo_y() == self.tty - 3):
                self["cursor"] = "top_side"
                self.bind("<Button1-Motion>", self.motionTop)


            else:
                self["cursor"] = windowObject.combo4cursor.get()
                self.bind("<Button-1>", self.startDrag)
                self.bind("<Button1-Motion>", self.motionDrag)
                self.bind("<ButtonRelease-1>", self.cursorChange)

        def motionTop(self, event):
            self.place_configure(x=self.winfo_x(), y=(self.winfo_y() + int(self.place_info()["height"])), anchor="sw")
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self.place_configure(height=new_height)

        def motionBottom(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self.place_configure(height=new_height)

        def motionLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = (0 - event.x) + int(self.place_info()["width"])
            self.place_configure(width=new_width)

        def motionRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            self.place_configure(width=new_width)

        def motionTopLeft(self, event):
            self.place_configure(x=self.winfo_x() + int(self.place_info()["width"]),
                                 y=self.winfo_y() + int(self.place_info()["height"]), anchor="se")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = 0 - event.y + int(self.place_info()["height"])
            self.place_configure(width=new_width, height=new_height)

        def motionTopRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y() + int(self.place_info()["height"]), anchor="sw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self.place_configure(width=new_width, height=new_height)

        def motionBottomLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self.place_configure(width=new_width, height=new_height)

        def motionBottomRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self.place_configure(width=new_width, height=new_height)


    class Scale_H(Scale):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.bind("<Motion>", self.motion1Both)

        def cursorChange(self, event):
            self["cursor"] = windowObject.combo4cursor.get()


        def startDrag(self, event):

            self.start_drag_x = event.x
            self.start_drag_y = event.y

        def motionDrag(self, event):
            self["cursor"] = "bogosity"
            self.place_configure(anchor="nw")
            new_x = (self.winfo_x() + event.x) - self.start_drag_x
            new_y = (self.winfo_y() + event.y) - self.start_drag_y
            self.place(x=new_x, y=new_y)

        def motion1Both(self, event):

            if self.identify(event.x, event.y) == "":
                self.xx = self.winfo_x() + int(self.place_info()["width"])
                self.yy = self.winfo_y() + int(self.place_info()["height"])
                self.ttx = event.x + self.winfo_x()
                self.tty = event.y + self.winfo_y()

                if ((self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_right_corner"
                    self.bind("<Button1-Motion>", self.motionBottomRight)

                elif ((self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_left_corner"
                    self.bind("<Button1-Motion>", self.motionBottomLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)):
                    self["cursor"] = "top_left_corner"
                    self.bind("<Button1-Motion>", self.motionTopLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)):
                    self["cursor"] = "top_right_corner"
                    self.bind("<Button1-Motion>", self.motionTopRight)

                elif (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3):
                    self["cursor"] = "right_side"
                    self.bind("<Button1-Motion>", self.motionRight)

                elif (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3):
                    self["cursor"] = "bottom_side"
                    self.bind("<Button1-Motion>", self.motionBottom)

                elif (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (self.winfo_x() == self.ttx - 3):
                    self["cursor"] = "left_side"
                    self.bind("<Button1-Motion>", self.motionLeft)

                elif (self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (self.winfo_y() == self.tty - 3):
                    self["cursor"] = "top_side"
                    self.bind("<Button1-Motion>", self.motionTop)


                else:
                    self["cursor"] = windowObject.combo4cursor.get()
                    self.bind("<Button-1>", self.startDrag)
                    self.bind("<Button1-Motion>", self.motionDrag)
                    self.bind("<ButtonRelease-1>", self.cursorChange)

            else:
                self.bind("<Button1-Motion>", lambda x: None)

        def motionTop(self, event):
            self.place_configure(x=self.winfo_x(), y=(self.winfo_y() + int(self.place_info()["height"])), anchor="sw")
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(height=new_height)

        def motionBottom(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(height=new_height)

        def motionLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = (0 - event.x) + int(self.place_info()["width"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width)

        def motionRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width)

        def motionTopLeft(self, event):
            self.place_configure(x=self.winfo_x() + int(self.place_info()["width"]),
                                 y=self.winfo_y() + int(self.place_info()["height"]), anchor="se")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = 0 - event.y + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)

        def motionTopRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y() + int(self.place_info()["height"]), anchor="sw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)


    class Scale_V(Scale):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.bind("<Motion>", self.motion1Both)

        def cursorChange(self, event):
            self["cursor"] = windowObject.combo4cursor.get()

        def startDrag(self, event):

            self.start_drag_x = event.x
            self.start_drag_y = event.y

        def motionDrag(self, event):
            self["cursor"] = "bogosity"
            self.place_configure(anchor="nw")
            new_x = (self.winfo_x() + event.x) - self.start_drag_x
            new_y = (self.winfo_y() + event.y) - self.start_drag_y
            self.place(x=new_x, y=new_y)

        def motion1Both(self, event):

            if self.identify(event.x, event.y) == "":
                self.xx = self.winfo_x() + int(self.place_info()["width"])
                self.yy = self.winfo_y() + int(self.place_info()["height"])
                self.ttx = event.x + self.winfo_x()
                self.tty = event.y + self.winfo_y()

                if ((self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_right_corner"
                    self.bind("<Button1-Motion>", self.motionBottomRight)

                elif ((self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_left_corner"
                    self.bind("<Button1-Motion>", self.motionBottomLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)):
                    self["cursor"] = "top_left_corner"
                    self.bind("<Button1-Motion>", self.motionTopLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)):
                    self["cursor"] = "top_right_corner"
                    self.bind("<Button1-Motion>", self.motionTopRight)

                elif (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3):
                    self["cursor"] = "right_side"
                    self.bind("<Button1-Motion>", self.motionRight)

                elif (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3):
                    self["cursor"] = "bottom_side"
                    self.bind("<Button1-Motion>", self.motionBottom)

                elif (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (self.winfo_x() == self.ttx - 3):
                    self["cursor"] = "left_side"
                    self.bind("<Button1-Motion>", self.motionLeft)

                elif (self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (self.winfo_y() == self.tty - 3):
                    self["cursor"] = "top_side"
                    self.bind("<Button1-Motion>", self.motionTop)


                else:
                    self["cursor"] = windowObject.combo4cursor.get()
                    self.bind("<Button-1>", self.startDrag)
                    self.bind("<Button1-Motion>", self.motionDrag)
                    self.bind("<ButtonRelease-1>", self.cursorChange)

            else:
                self.bind("<Button1-Motion>", lambda x: None)

        def motionTop(self, event):
            self.place_configure(x=self.winfo_x(), y=(self.winfo_y() + int(self.place_info()["height"])), anchor="sw")
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(height=new_height)

        def motionBottom(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(height=new_height)

        def motionLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = (0 - event.x) + int(self.place_info()["width"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width)

        def motionRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width)

        def motionTopLeft(self, event):
            self.place_configure(x=self.winfo_x() + int(self.place_info()["width"]),
                                 y=self.winfo_y() + int(self.place_info()["height"]), anchor="se")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = 0 - event.y + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

        def motionTopRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y() + int(self.place_info()["height"]), anchor="sw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

    windowPRO = Tk()  ######## Creates Main Window



    windowObject = pyPROApp(windowPRO)  ####### Instance Object for pyPROApp class
    windowObject.widgetTreeview()

    ##### Lists of widget control variables names
    list_button = [f"Button{x}" for x in range(0,1000)]    #### list to contain widget control variables names for Button
    list_checkbutton = [f"Checkbutton{x}" for x in range(0,1000)]   #### list to contain widget control variables names for Checkbutton
    list_entry = [f"Entry{x}" for x in range(0,1000)]
    list_label = [f"Label{x}" for x in range(0,1000)]
    list_listbox = [f"Listbox{x}" for x in range(0,1000)]
    list_menubutton = [f"Menubutton{x}" for x in range (0,1000)]
    list_message = [f"Message{x}" for x in range (0,1000)]
    list_radiobutton = [f"Radiobutton{x}" for x in range(0,1000)]
    list_scale = [f"Scale{x}" for x in range(0,1000)]
    list_scrollbar = [f"Scrollbar{x}" for x in range (0, 1000)]
    list_spinbox = [f"Spinbox{x}" for x in range(0,1000)]
    list_text = [f"Text{x}" for x in range(0,1000)]
    list_frame = [f"Frame{x}" for x in range(0,1000)]
    list_labelframe = [f"LabelFrame{x}" for x in range(0,1000)]
    list_framepw = [f"FramePW{x}" for x in range(0,1000)]
    list_panedwindow = [f"PanedWindow{x}" for x in range(0,1000)]

    dict_ = {}                                      #### Dictionary to hold attributes for control variables
    dictAttributeEditorUpdate = {}                  #### Dictionary to update Attribute Editor for any selected widget
    # dictAttributeCollect = {}                       #### Dictionary to collect attributes to display in Attribute Editor


    arrangeObject = WidgetArrange()  ####### Instance Object for WidgetArrange class
    arrangeObject.refreshAttributes()


    ####### Design Window - To Work On
    windowDesign = Tk()
    windowDesign.title("Design Window")
    windowDesign.geometry("%dx%d+%d+%d" % (screen_width / 2, screen_height / 1.57, screen_width / 4.5, screen_height / 3.36))


    ### Events For Design Window
    windowDesign.bind("<Button-1>", arrangeObject.executeWidgetsOnDesignWindow)
    windowObject.tree4Widget.bind("<<TreeviewSelect>>", arrangeObject.focusWidgetTree)  ### Event for Widget Tree
    windowDesign.bind_all("<ButtonRelease-1>", arrangeObject.motionRelease)

    implementFont_determine = None    ### Variable that determines whether to run implementFont command
    windowPRO.mainloop()
    
if zippassvar == 60:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    import tkinter as tk
    from tkinter import messagebox
    import tkinter as tk
    from tkinter import filedialog, messagebox, ttk
    from os import walk
    from pathlib import Path
    import threading
    import zlib
    from zipfile import ZipFile


    class File(object):
        def __init__(self, full_path):
            self.file_path = full_path
            self.name = None
            self.size = None
            self.file_type = None
            self.parent_folder = None
            self._setup()

        def __repr__(self):
            return f"{self.name}"

        def _setup(self):
            print(self.file_path)
            p = Path(self.file_path)
            self.name = p.name
            if p.suffix == "":
                raise FileNotFoundError(
                    f"{self.file_path} has to be a file not a folder"
                    )

            self.file_type = p.suffix
            self.size = p.stat().st_size  # size displayed in bytes
            self.parent_folder = str(p.parent)


    class Folder(object):
        def __init__(self, full_path, include_subfolders=False):
            self.folder_path = full_path
            self.includes_subfolders = include_subfolders
            self.folder_files = ()
            self._extract_files(include_subfolders)

        def __repr__(self):
            return f"{self.folder_path}"

        def _extract_files(self, seek_subfolders=False):
            all_files = []
            for (dirpath, dirnames, filenames) in walk(self.folder_path, topdown=True):
                for filename in filenames:
                    file_path = fr"{dirpath}\{filename}"
                    print(file_path)
                    file = File(file_path)
                    all_files.append(file)
                if not seek_subfolders:
                    break
            if all_files:
                self.folder_files = tuple(all_files)

        def show_files(self, pretty_print=False):
            print(self)
            if not pretty_print:
                print(self.folder_files)
            else:
                for file in self.folder_files:
                    print(f"Name: {file.name}\n  Size: {file.size}")


    class AttackTargets(object):
        def __init__(self):
            self.targets = []  # a list of file and folder object

        def add_target(self, target):
            # A target is a tuple in the form ["type", "include_subfolders", "target_path"]
            target_type = target[0]
            include_subfolders = target[1]
            target_path = target[2]
            if target_type == "File":
                self._add_target_file(target_path=target_path)
            else:
                self._add_target_folder(target_path=target_path,
                                        include_subfolders=include_subfolders)

        def _add_target_file(self, target_path):
            raw_target = fr"{target_path}"
            t = File(raw_target)
            self.targets.append(t)

        def _add_target_folder(self, target_path, include_subfolders=False):
            raw_target = fr"{target_path}"
            t = Folder(raw_target, include_subfolders)
            self.targets.append(t)

        def get_targets(self):
            return self.targets

        def show_targets(self, pretty_print=False):
            if not self.targets:
                print("There are no targets")
            for count, item in enumerate(self.targets, 1):
                if isinstance(item, File):
                    print(f"Target {count}.\n{item}")
                else:
                    print(f"Target {count}.\n")
                    item.show_files(pretty_print)


    class Controller(object):
        def __init__(self, view):
            super().__init__()
            self.view = view

        def launch_attack(self, password_file, save_destination, hash_type, targets):
            attack_targets = AttackTargets()
            for target in targets:
                attack_targets.add_target(target)
            attack = DictionaryAttack(
                        self.view, password_file, save_destination, hash_type, attack_targets
                    )
            attack.daemon = True
            attack.start()


    class DictionaryAttack(threading.Thread):
        def __init__(self, view, password_file, save_destination, hash_type, targets):
            threading.Thread.__init__(self)
            # Thread attributes
            self.threadID = 1
            self.name = "AttackThread"

            self.view = view
            self.password_file = password_file
            self.save_destination = save_destination
            self.hash_type = hash_type
            self.attack_targets = targets
            self.supported_types = frozenset([".zip"])

        def run(self):  # .start initiates this
            self.view.clear_text_output()  # clear the previous output if any
            self.view.insert_text_message(
                f"### INITIALISING ###",
                update_idle=True
            )
            targets = self.attack_targets.get_targets()
            for target in targets:
                if isinstance(target, File):
                    self._attack_file(target)
                else:
                    self._attack_folder(target)
            self.view.set_current_target("---------")
            self.view.insert_text_message(
                f"### PROGRAM END ###"
            )
            return None

        def _attack_folder(self, target_folder):
            self.view.insert_text_message(
                f"### TARGETING THE FOLDER {target_folder} ###"
            )
            self.view.set_current_target(target_folder)
            for file in target_folder.folder_files:
                self._attack_file(file)
            self.view.insert_text_message(
                f"### EXITING THE FOLDER {target_folder} ###"
            )

        def _attack_file(self, target_file):
            self.view.insert_text_message(
                f"## TARGETING THE FILE {target_file} ##"
            )
            self.view.set_current_target(target_file)

            is_supported_type = self._is_supported_file(target_file)
            if is_supported_type:
                pw_required = self._attempt_open_file(target_file)
                if pw_required:
                    self.view.insert_text_message(
                        f"{target_file} is password protected."
                    )
                    self._crack_file(target_file)
                else:
                    self.view.insert_text_message(
                        f"Ignore. {target_file} is not password protected.\n"
                    )
            else:
                self.view.insert_text_message(
                    f"Ignore {target_file}.\n{target_file.file_type} is not supported.\n"
                )

        def _is_supported_file(self, target):
            return (target.file_type in self.supported_types)

        def _attempt_open_file(self, target):
            path = target.file_path
            if target.file_type == ".zip":
                try:
                    zf = ZipFile(path).testzip()
                except RuntimeError as err:
                    msg = "password required for extraction"
                    if str(err).endswith(msg):
                        return True
                    else:
                        self.view.display_messagebox(err, "showerror")

            return False  # if its not in protected types

        def _crack_file(self, target_file):
            self.view.insert_text_message(f"# ATTEMPTING TO CRACK {target_file} #")
            self.view.insert_text_message("_____", update_idle=True)
            found = False
            last_attempt = 0
            found_password = ""
            # dont use readlines as it will store the whole file in memory..
            # just read line by line
            pws = open(self.password_file, "r", encoding="latin1")
            for attempt, password in enumerate(pws, 1):
                password = password.strip()
                

                if target_file.file_type == ".zip":
                    try:
                        password_byte = bytes(password, "latin1")
                        ZipFile(target_file.file_path).extractall(path=self.save_destination,
                                                                  pwd=password_byte)
                        found = True
                        found_password = password_byte.decode("latin1")
                        last_attempt = attempt
                        break
                    except RuntimeError as err:
                        if str(err).startswith("Bad password"):
                            update_idle = (attempt % 5 == 0)
                            self.view.insert_text_message(
                                f"Attempt {attempt}: '{password}' failed.",
                                update_idle=update_idle
                            )
                            if attempt % 250 == 0:
                                self.view.clear_text_output()
                        else:
                            self.view.display_messagebox(err, "showerror")
                            break
                    except zlib.error as zerr:
                        if str(zerr).startswith("Error -3"):
                            # If there are compression errors then skip
                            continue
                        else:
                            self.view.display_messagebox(zerr, "showerror")
                            break

            pws.close()
            if found:
                self.view.insert_text_message(
                    f"Attempt {last_attempt}: '{found_password}'"
                )
                self.view.insert_text_message("Password Found")
                self.view.insert_text_message(
                    f"The password [{found_password}] found after {last_attempt} attempts",
                    update_idle=True
                )
                self.view.insert_text_message(
                    f"{target_file} has been Cracked!!!"
                )
                self.view.insert_text_message(
                    f"files extracted to {self.save_destination}",
                    update_idle=True
                )
                self.view.insert_text_message(
                    f"password will be saved to {self.save_destination}"
                )
                self.view.insert_text_message(f"________________")
                self._store_password(found_password, target_file.file_path)

            else:
                self.view.insert_text_message(
                    f"Failed to Crack {target_file}",
                    update_idle=True
                )

        def _store_password(self, password, target_path):
            line = f"{password} | {target_path}\n"
            dest = fr"{self.save_destination}\extracted_passwords.txt"
            f = open(dest, "a+")
            f.write(line)
            f.close()
            self.view.insert_text_message(
                f"Found password stored to {dest}"
            )

    # This is our menu
    class NavBar(tk.Menu):
        def __init__(self, parent):
            super().__init__(parent)

            # File
            menu_file = tk.Menu(self, tearoff=0)
            self.add_cascade(label="File", menu=menu_file)
            menu_file.add_command(label="How to use WordSmith", command=parent.OpenHelpPage)
            menu_file.add_command(label="Disclaimer", command=parent.OpenDisclaimerPage)
            menu_file.add_separator()
            menu_file.add_command(label="Exit",
                                  command=parent.quit_application)


    class MainPage(tk.Frame):
        def __init__(self, parent):
            super().__init__(parent)
            MAIN_FONT = ("Yu Gothic UI", 9, "bold")

            frame_styles = {"relief": "groove",
                            "bd": 3,
                            "fg": "#073bb3", "font": MAIN_FONT}
            self.controller = Controller(view=self)

            label_header = tk.Label(parent, text="WordSmith", font=("Verdana Pro Cond Black", 25))
            label_header.place(rely=0.03, relx=0.02)
            label_author = tk.Label(parent, text="by Tudor Marmureanu", font=MAIN_FONT)
            label_author.place(rely=0.07, relx=0.20)

            label_dict_title = tk.Label(parent, text="Select your dictionary list", font=MAIN_FONT)
            label_dict_title.place(rely=0.12, relx=0.02)
            self.label_dict_file = tk.Label(parent, relief="ridge", anchor="w")
            self.label_dict_file.place(rely=0.15, relx=0.02, height=23, width=375)
            btn_dict_file = ttk.Button(parent, text="Browse...", command=self._set_dictionary_list)
            btn_dict_file.place(rely=0.15, relx=0.40)

            label_extract_title = tk.Label(parent, text="Select a path where cracked files will be extracted to", font=MAIN_FONT)
            label_extract_title.place(rely=0.22, relx=0.02)
            self.label_extract_dest = tk.Label(parent, relief="ridge", anchor="w")
            self.label_extract_dest.place(rely=0.25, relx=0.02, height=23, width=375)
            btn_extract_dest = ttk.Button(parent, text="Browse...", command=self._set_extract_path)
            btn_extract_dest.place(rely=0.25, relx=0.40)

            frame_targets = tk.LabelFrame(parent, frame_styles, text="Targets")
            frame_targets.place(rely=0.32, relx=0.02, height=300, width=470)
            btn_add_file = ttk.Button(parent, text="Add a File...", command=self._add_target_file_tv)
            btn_add_file.place(rely=0.84, relx=0.02)
            btn_add_folder = ttk.Button(parent, text="Add a Folder...", command=self._add_target_folder_tv)
            btn_add_folder.place(rely=0.84, relx=0.10)
            self.include_subfolders = tk.BooleanVar(parent)
            ckbtn_subfolders = tk.Checkbutton(parent, variable=self.include_subfolders)
            ckbtn_subfolders.place(rely=0.84, relx=0.20)
            label_subfolders = tk.Label(parent, text="Include Subfolders?", font=MAIN_FONT)

            label_subfolders.place(rely=0.84, relx=0.23)

            hash_types = ("Plain", "MD5")
            self.hash = tk.StringVar(parent)
            opt_menu_hash = ttk.OptionMenu(parent, self.hash, hash_types[0],
                                           *hash_types)
            opt_menu_hash.place(rely=0.90, relx=0.27)

            btn_launch_attack = ttk.Button(parent, text="Launch Dictionary Attack", command=self._launch_dictionary_attack)
            btn_launch_attack.place(rely=0.90, relx=0.12)

            frame_current_target = tk.LabelFrame(parent, frame_styles, text="Current Target")
            frame_current_target.place(rely=0.05, relx=0.50, height=50, width=500)
            self.label_current_target = tk.Label(frame_current_target, text="---------")
            self.label_current_target.pack(side="left")

            # TEXT BOX WIDGET
            frame_output = tk.LabelFrame(parent, frame_styles, text="Attack Output")
            frame_output.place(rely=0.15, relx=0.50, height=475, width=500)

            self.text_output = tk.Text(frame_output,wrap=tk.NONE)
            self.text_output.place(relheight=1, relwidth=1)
            text_scrolly = tk.Scrollbar(frame_output, orient="vertical", command=self.text_output.yview)
            text_scrollx = tk.Scrollbar(frame_output, orient="horizontal", command=self.text_output.xview)
            self.text_output.configure(yscrollcommand=text_scrolly.set, xscrollcommand=text_scrollx.set)
            text_scrolly.pack(side="right", fill="y")
            text_scrollx.pack(side="bottom", fill="x")

            # TREEVIEW WIDGET
            self.tv_target = ttk.Treeview(frame_targets)
            self.tv_target.place(relheight=1, relwidth=1)
            tv_scrolly = tk.Scrollbar(frame_targets, orient="vertical", command=self.tv_target.yview)
            tv_scrollx = tk.Scrollbar(frame_targets, orient="horizontal", command=self.tv_target.xview)
            self.tv_target.configure(yscrollcommand=tv_scrolly.set, xscrollcommand=tv_scrollx.set)
            tv_scrolly.pack(side="right", fill="y")
            tv_scrollx.pack(side="bottom", fill="x")
            self.tv_target["columns"] = ["Type", "Include SubFolders", "Target Path"]
            self.tv_target["show"] = "headings"  # removes empty column
            for col in self.tv_target["columns"]:
                self.tv_target.heading(col, text=col)
                col_width = 110
                if col == "Target Path":
                    col_width = 300
                self.tv_target.column(col, width=col_width)
            # when you double click the treeview item it will delete the row
            self.tv_target.bind("<Double-1>", self._delete_tv_row)

        def _windows_dialog(self, is_folder=False, only_text=False):
            selection = None
            if is_folder:
                selection = filedialog.askdirectory()
            else:
                type1 = ("All Files", "*.*") if not only_text else ("Text Files", "*.txt")
                selection = filedialog.askopenfilename(initialdir="/",
                                                       title="Select a File",
                                                       filetype=[type1])
            return selection

        def _set_dictionary_list(self):
            selection = self._windows_dialog(only_text=True)
            self.label_dict_file["text"] = selection

        def _set_extract_path(self):
            selection = self._windows_dialog(is_folder=True)
            self.label_extract_dest["text"] = selection

        def _add_target_file_tv(self):
            path = self._windows_dialog()
            if not path:
                return None
            row = ["File", "False", path]
            self.tv_target.insert("", "end", values=row)

        def _add_target_folder_tv(self):
            path = self._windows_dialog(is_folder=True)
            if not path:
                return None
            seek_subfolders = self.include_subfolders.get()
            row = ["Folder", str(seek_subfolders), path]
            self.tv_target.insert("", "end", values=row)

        def _delete_tv_row(self, event):
            row = self.tv_target.selection()
            if row:
                self.tv_target.delete(row[0])

        def insert_text_message(self, message, update_idle=False):
            self.text_output.insert("end", f"{message}\n")
            self.text_output.see("end")
            if update_idle:
                self.text_output.update_idletasks()  # prevents gui freezing

        def display_messagebox(self, message, type="showinfo"):
            if type == "showerror":
                messagebox.showerror(title="Error", message=message)
            else:
                messagebox.showinfo(title="Information", message=message)

        def clear_text_output(self):
            self.text_output.delete('1.0', "end")

        def set_current_target(self, current_target):
            self.label_current_target["text"] = current_target

        def _launch_dictionary_attack(self):
            password_hash_type = "Plain Text"  # self.hash.get()
            password_file = self.label_dict_file["text"]
            save_dest = self.label_extract_dest["text"]

            if not password_file or not save_dest:
                msg = "You need to provide a password file and save destination"
                self.display_messagebox(msg, type="showinfo")
                return None

            all_targets = []
            for row_id in self.tv_target.get_children():
                target_info = self.tv_target.item(row_id, "values")
                all_targets.append(target_info)
            # raise message box if there are no targets
            if not all_targets:
                self.display_messagebox("There are no targets", type="showinfo")
            else:
                self.controller.launch_attack(password_file=password_file,
                                              save_destination=save_dest,
                                              hash_type=password_hash_type,
                                              targets=all_targets)


    class BaseWindow(tk.Toplevel):
        def __init__(self):
            super().__init__()
            self.base_frame = tk.Frame(self)
            self.base_frame.pack_propagate(0)
            self.base_frame.pack(fill="both", expand="true")
            self.fonts = ("Trebuchet MS", 9)
            self.geometry("600x200")
            self.resizable(0, 0)


    class HelpPage(BaseWindow):
        def __init__(self):
            super().__init__()

            self.title("How to Use WordSmith")
            bio = (
                "Step 1: Select a file containing a list of passwords.\n"
                "Step 2: Select a Folder where you would like to extracted files "
                "to be saved.\n"
                "Step 3: Add File and/or Folders to the Targets list.\n"
                "Step 4: Choose whether you want to launch a plain text attack or "
                "MD5 attack.\n"
                "Step 5: Launch Attack \n\n"
                "Note: Once finished passwords and file paths will be saved to "
                "the destination you originally chose.\n"
                "Remember to have rights and don't use this for malicious purposes.\n"
                "Created by Tudor Marmureanu.   "
            )
            frame_about = tk.LabelFrame(self.base_frame, text="About WordSmith")
            frame_about.pack(expand=True, fill="both")
            label_about = tk.Label(frame_about, text=bio, font=self.fonts)
            label_about.pack(expand=True)


    class DisclaimerPage(BaseWindow):
        def __init__(self):
            super().__init__()
            self.title("Disclaimer")
            summary = (
                "DO NOT USE THIS FOR MALICIOUS PURPOSES\n"
                "i.e. Stealing the password belonging to a person "
                "or business/corporation is illegal\n"
                "This is a toy project for work purposes \n"
                "(example: A person has forgotten their password and needs those documents. )"
            )
            frame_disc = tk.LabelFrame(self.base_frame, text="WordSmith Disclaimer")
            frame_disc.pack(expand=True, fill="both")
            label_disc = tk.Label(frame_disc, text=summary, font=self.fonts)
            label_disc.pack(expand=True)


    APP_HEIGHT = 600
    APP_WIDTH = 1024


    class Application(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("WordSmith")
            main_frame = tk.Frame(self, height=APP_HEIGHT, width=APP_WIDTH)
            main_frame.pack_propagate(0)
            main_frame.pack(fill="both", expand="true")
            self.resizable(0, 0)
            self.geometry(f"{APP_WIDTH}x{APP_HEIGHT}")

            # Add menu to the application
            menubar = NavBar(self)
            tk.Tk.config(self, menu=menubar)

            # add the frames to the application
            page = MainPage(parent=main_frame)
            page.place(rely=0, relx=0)
            page.tkraise()
            self.protocol("WM_DELETE_WINDOW", self.quit_application)

        def OpenHelpPage(self):
            help = HelpPage()
            help.focus_set()
            help.grab_set()

        def OpenDisclaimerPage(self):
            disclaimer = DisclaimerPage()
            disclaimer.focus_set()
            disclaimer.grab_set()

        def quit_application(self):
            if messagebox.askyesno("Exit", "Do you want to quit the application?"):
                self.destroy()
    # parent is the parent frame that the object is tied to i.e. Frame(root)
    # MainPage(main_frame) means MainPage is tied to the main_frame in application)


    rootzp = Application()
    rootzp.mainloop()

if bkvar == 700:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    import shutil
    import os
    from datetime import datetime
    import tkinter as tk
    from tkinter import filedialog, messagebox

    def backup_files(source_dir, backup_dir):
        try:
            date_str = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_path = os.path.join(backup_dir, f'backup_{date_str}')
            shutil.copytree(source_dir, backup_path)
            messagebox.showinfo("Backup Completed", f'Backup completed: {backup_path}')
        except Exception as e:
            messagebox.showerror("Error", f'An error occurred: {e}')

    def select_source_directory():
        source_dir = filedialog.askdirectory()
        source_entry.delete(0, tk.END)
        source_entry.insert(0, source_dir)

    def select_backup_directory():
        backup_dir = filedialog.askdirectory()
        backup_entry.delete(0, tk.END)
        backup_entry.insert(0, backup_dir)

    def start_backup():
        source_dir = source_entry.get()
        backup_dir = backup_entry.get()
        if not source_dir or not backup_dir:
            messagebox.showwarning("Input Error", "Please select both source and backup directories.")
            return
        backup_files(source_dir, backup_dir)

    # Set up the main application window
    rootbkr = tk.Tk()
    rootbkr.title("Backup Utility")
    rootbkr.geometry("600x150")
    rootbkr.config(bg="gray20")
    rootbkr.resizable(False, False)

    # Configure the style of the labels and entries
    label_style = {'bg': 'gray20', 'fg': '#ccff66'}
    entry_style = {'bg': 'black', 'fg': '#ccff66', 'insertbackground': 'cyan'}

    # Source directory selection
    tk.Label(rootbkr, text="Source Directory:", **label_style).grid(row=0, column=0, padx=10, pady=5)
    source_entry = tk.Entry(rootbkr, width=50, **entry_style)
    source_entry.grid(row=0, column=1, padx=10, pady=5)
    tk.Button(rootbkr, text="Browse...", command=select_source_directory, bg="gray40", fg="#ccff66").grid(row=0, column=2, padx=10, pady=5)

    # Backup directory selection
    tk.Label(rootbkr, text="Backup Directory:", **label_style).grid(row=1, column=0, padx=10, pady=5)
    backup_entry = tk.Entry(rootbkr, width=50, **entry_style)
    backup_entry.grid(row=1, column=1, padx=10, pady=5)
    tk.Button(rootbkr, text="Browse...", command=select_backup_directory, bg="gray40", fg="#ccff66").grid(row=1, column=2, padx=10, pady=5)

    # Backup button
    tk.Button(rootbkr, text="Start Backup", command=start_backup, bg="gray40", fg="#ccff66").grid(row=2, column=0, columnspan=3, pady=20)

    # Run the application
    rootbkr.mainloop()

if rnvar == 710:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    import os
    import tkinter as tk
    from tkinter import filedialog, simpledialog, messagebox

    def rename_files(directory, selected_files, prefix, suffix):
        try:
            for file in selected_files:
                file_path = os.path.join(directory, file)
                if os.path.isfile(file_path):
                    base, ext = os.path.splitext(file)
                    new_name = base
                    if prefix:
                        new_name = f"{prefix}_{new_name}"
                    if suffix:
                        new_name = f"{new_name}_{suffix}"
                    new_name = f"{new_name}{ext}"
                    new_path = os.path.join(directory, new_name)
                    os.rename(file_path, new_path)
            messagebox.showinfo("Success", "Files have been renamed successfully.")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def select_directory():
        directory = filedialog.askdirectory()
        if directory:
            directory_entry.delete(0, tk.END)
            directory_entry.insert(0, directory)
            update_file_list(directory)

    def update_file_list(directory):
        files = os.listdir(directory)
        file_listbox.delete(0, tk.END)
        for file in files:
            file_listbox.insert(tk.END, file)

    def start_renaming():
        directory = directory_entry.get()
        if not directory:
            messagebox.showwarning("Input Error", "Please select a directory.")
            return
        
        selected_files = [file_listbox.get(i) for i in file_listbox.curselection()]
        if not selected_files:
            messagebox.showwarning("Input Error", "Please select at least one file.")
            return

        prefix = prefix_entry.get()
        suffix = suffix_entry.get()

        rename_files(directory, selected_files, prefix, suffix)
        update_file_list(directory)  # Refresh the file list after renaming

    # Set up the main application window
    rootrn = tk.Tk()
    rootrn.title("Batch File Renamer")
    rootrn.configure(bg='gray20')
    rootrn.resizable(False, False)

    # Directory selection
    tk.Label(rootrn, text="Directory:", bg='gray20', fg='#ccff66').grid(row=0, column=0, padx=10, pady=5)
    directory_entry = tk.Entry(rootrn, width=50, bg='black', fg='#ccff66', insertbackground='cyan')
    directory_entry.grid(row=0, column=1, padx=10, pady=5)
    tk.Button(rootrn, text="Browse...", command=select_directory, bg='gray40', fg='#ccff66').grid(row=0, column=2, padx=10, pady=5)

    # File list
    tk.Label(rootrn, text="Files:", bg='gray20', fg='#ccff66', font=('bold')).grid(row=1, column=0, padx=10, pady=5)
    file_listbox = tk.Listbox(rootrn, selectmode=tk.MULTIPLE, width=50, height=15, bg='black', fg='#ccff66', bd=25)
    file_listbox.grid(row=1, column=1, padx=10, pady=5, columnspan=2)

    # Prefix option
    tk.Label(rootrn, text="Prefix:", bg='gray20', fg='#ccff66').grid(row=2, column=0, padx=10, pady=5)
    prefix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
    prefix_entry.grid(row=2, column=1, padx=10, pady=5)

    # Suffix option
    tk.Label(rootrn, text="Suffix:", bg='gray20', fg='#ccff66').grid(row=3, column=0, padx=10, pady=5)
    suffix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
    suffix_entry.grid(row=3, column=1, padx=10, pady=5)

    # Rename button
    tk.Button(rootrn, text="Rename Files", command=start_renaming, bg='gray40', fg='#ccff66').grid(row=4, column=0, columnspan=3, pady=20)

    # Run the application
    rootrn.mainloop()

if kbvar == 1000:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    import tkinter as tk
    from tkinter import messagebox
    from tkinter import filedialog
    from tkinter import ttk
    import json
    import os
    
    class KnowledgeBaseApp:
        def __init__(self, master):
            self.master = master
            self.master.title("Knowledge Base")
            self.master.geometry("920x520")
            self.master.configure(bg="gray20")
            self.master.resizable(False, False)
    
            self.title_label = tk.Label(master, text="Title:", bg="gray20", font=("Arial", 12, "bold"), fg="#ccff66")
            self.title_label.grid(row=0, column=0, sticky=tk.W, padx=10, pady=10)
    
            self.title_entry = tk.Entry(master, font=("Arial", 12), width=40)
            self.title_entry.grid(row=0, column=1, padx=10, pady=10, sticky=tk.W)
    
            self.category_label = tk.Label(master, text="Category:", bg="gray20", font=("Arial", 12, "bold"), fg="#ccff66")
            self.category_label.grid(row=0, column=2, padx=10, pady=10)
    
            self.category_combo = ttk.Combobox(master, values=["Networking", "Hardware", "Linux", "Programming", "Printers", "Apps", "Others"], font=("Arial", 12))
            self.category_combo.grid(row=0, column=3, pady=10, sticky=tk.W)
    
            self.text_label = tk.Label(master, text="Text:", bg="gray20", font=("Arial", 12, "bold"), fg="#ccff66")
            self.text_label.grid(row=1, column=0, sticky=tk.W, padx=10, pady=10)
    
            self.text_entry = tk.Text(master, height=20, width=80, font=("Arial", 12), bd=14, bg="black", fg="cyan", insertbackground="#ccff66", highlightbackground="gray40", highlightcolor="gray40", highlightthickness=7)
            self.text_entry.grid(row=1, column=1, columnspan=4, padx=10, pady=10, sticky=tk.W + tk.E)
    
            self.scrollbar = tk.Scrollbar(master, command=self.text_entry.yview)
            self.scrollbar.grid(row=1, column=5, sticky='nsew')
            self.text_entry.config(yscrollcommand=self.scrollbar.set)
    
            self.save_button = tk.Button(master, text="Save", command=self.save_knowledge, bg="#ff9900", fg="white", font=("Arial", 12))
            self.save_button.grid(row=2, column=0, pady=10, padx=10, sticky=tk.W)
    
            self.open_button = tk.Button(master, text="Open", command=self.open_file, bg="#ff9933", fg="white", font=("Arial", 12))
            self.open_button.grid(row=2, column=1, pady=10, padx=10, sticky=tk.W)
    
            self.folder_combo = ttk.Combobox(master, font=("Arial", 12))
            self.folder_combo.grid(row=2, column=2, padx=10, pady=10, sticky=tk.W)
            self.update_folder_combo()
    
            self.delete_button = tk.Button(master, text="Delete", command=self.delete_file, bg="red", fg="white", font=("Arial", 12))
            self.delete_button.grid(row=2, column=3, pady=10, padx=10, sticky=tk.W)
    
        def save_knowledge(self):
            title = self.title_entry.get()
            text = self.text_entry.get("1.0", tk.END)
            category = self.category_combo.get()
    
            if title.strip() == "" or text.strip() == "":
                messagebox.showerror("Error", "Please enter a title and text to save.")
                return
    
            if category == "":
                messagebox.showerror("Error", "Please select a category.")
                return
    
            knowledge_data = {"title": title, "text": text, "category": category}
    
            # Create the directory based on the selected category if it doesn't exist
            directory = f"KB/{category}"
            if not os.path.exists(directory):
                os.makedirs(directory)
    
            file_name = f"{title}.json"
            file_path = os.path.join(directory, file_name)
    
            if os.path.exists(file_path):
                overwrite = messagebox.askyesno("File Exists", f"A file with the name '{title}.json' already exists in the '{category}' category. Do you want to overwrite its content?")
                if not overwrite:
                    file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON Files", "*.json")], initialdir=directory, initialfile=file_name)
                    if not file_path:
                        return
    
            with open(file_path, "w") as json_file:
                json.dump(knowledge_data, json_file)
    
            self.update_folder_combo()
            messagebox.showinfo("Success", f"Information has been saved to {file_path}.")
    
            # Clear the input fields after saving
            self.title_entry.delete(0, tk.END)
            self.text_entry.delete("1.0", tk.END)
            self.category_combo.set("")
    
        def update_folder_combo(self):
            if not os.path.exists("KB"):
                os.makedirs("KB")
            folders = [f for f in os.listdir("KB") if os.path.isdir(os.path.join("KB", f))]
            self.folder_combo['values'] = folders
    
        def open_file(self):
            file_path = filedialog.askopenfilename(filetypes=[("JSON Files", "*.json")])
    
            if file_path:
                with open(file_path, "r") as json_file:
                    data = json.load(json_file)
                    self.title_entry.delete(0, tk.END)
                    self.title_entry.insert(0, data["title"])
                    self.text_entry.delete("1.0", tk.END)
                    self.text_entry.insert(tk.END, data["text"])
                    if "category" in data:
                        self.category_combo.set(data["category"])
                messagebox.showinfo("Success", f"File {file_path} has been opened.")
    
        def delete_file(self):
            category = self.folder_combo.get()
            if category == "":
                messagebox.showerror("Error", "Please select a category to delete.")
                return
    
            directory = f"KB/{category}"
            file_path = filedialog.askopenfilename(initialdir=directory, filetypes=[("JSON Files", "*.json")])
    
            if file_path:
                os.remove(file_path)
                self.update_folder_combo()
                messagebox.showinfo("Success", f"File {file_path} has been deleted.")
    
    def main():
        root = tk.Tk()
        app = KnowledgeBaseApp(root)
        root.mainloop()
    
    if __name__ == "__main__":
        main()

if passmngrr == 2000:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    import hashlib
    from tkinter.constants import BOTH, CENTER, END, LEFT, RIGHT, VERTICAL, Y
    from tkinter import Button, Canvas, Entry, Frame, Label, Scrollbar, Tk, Checkbutton, BooleanVar
    from functools import partial
    from tkinter import simpledialog
    import string
    from secrets import choice
    import sqlite3
    from tkinter import LabelFrame
    
    
    UPPERCASE = list(string.ascii_uppercase)
    LOWERCASE = list(string.ascii_lowercase)
    NUMBER = list(string.digits)
    SYMBOLS = ['@', '#', '$', '%', '&', '_']
    
    class PasswordGenerator:
    
        def __init__(self):
            self.window = Tk()
            self.window.title("Password Generator")
            self.window.geometry("450x350")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
            # Label Frame for password length
            self.length_frame = LabelFrame(
                self.window, text="Enter the number of characters", bg="gray20", fg="#ccff66")
            self.length_frame.pack(pady=20)
    
            # Label and entry for password length
            self.length_label = Label(
                self.length_frame, text="Password Length:", bg="gray20", fg="#ccff66")
            self.length_label.grid(row=0, column=0, padx=10, pady=5, sticky="w")
            self.length_entry_box = Entry(self.length_frame, width=20, bg="black", fg="lime green", insertbackground="cyan")
            self.length_entry_box.grid(row=1, column=0, padx=10, pady=5)
    
            # Label for custom characters
            self.custom_chars_label = Label(
                self.window, text="Custom Characters:", bg="gray20", fg="#ccff66")
            self.custom_chars_label.pack(anchor='w', padx=20)
    
            # Entry for custom characters
            self.custom_chars_entry = Entry(self.window, width=50, bg="black", fg="lime green", insertbackground="cyan")
            self.custom_chars_entry.pack(pady=5)
    
            # Label for generated password
            self.password_label = Label(
                self.window, text="Generated Password:", bg="gray20", fg="#ccff66")
            self.password_label.pack(anchor='w', padx=20)
    
            # Entry for generated password
            self.password_entry_box = Entry(
                self.window, text="", width=50, bg="black", fg="lime green", insertbackground="cyan")
            self.password_entry_box.pack(pady=5)
    
            # Feedback label
            self.feedback = Label(self.window, bg="gray20")
    
            # Frame for buttons
            self.button_frame = Frame(self.window, bg="gray20")
            self.button_frame.pack(pady=20)
    
            # Generate Password Button
            generate_btn = Button(
                self.button_frame, text="Generate Password", command=self.generate_random_password, bg="gray40", fg="cyan", bd=5)
            generate_btn.grid(row=0, column=0, padx=10)
    
            # Copy Password Button
            copy_btn = Button(self.button_frame,
                            text="Copy Password", command=self.copy_password, bg="gray40", fg="cyan", bd=5)
            copy_btn.grid(row=0, column=1, padx=10)
    
        def generate_random_password(self):
            self.password_entry_box.delete(0, END)
            try:
                password_length = int(self.length_entry_box.get())
                if password_length <= 0:
                    raise ValueError("Password length must be a positive integer")
    
                self.feedback.destroy()  # Destroy feedback if length is there
    
                # Get custom characters from entry box
                custom_chars = self.custom_chars_entry.get()
    
                data = custom_chars if custom_chars else string.ascii_letters + string.digits + string.punctuation
                password = ''.join(choice(data) for _ in range(password_length))
                self.password_entry_box.insert(0, password)
            except ValueError as e:
                self.feedback.destroy()  # Destroy previous feedback if any
                self.feedback = Label(self.window, fg="red", text=str(e))
                self.feedback.place(x=130, y=100)
    
        def copy_password(self):
            self.window.clipboard_clear()
            self.window.clipboard_append(self.password_entry_box.get())
    
    def init_database():
        with sqlite3.connect("password_vault.db") as db:
            cursor = db.cursor()
        cursor.execute("""
                CREATE TABLE IF NOT EXISTS master(
                id INTEGER PRIMARY KEY,
                password TEXT NOT NULL);
                """)
    
        cursor.execute("""
                CREATE TABLE IF NOT EXISTS vault(
                id INTEGER PRIMARY KEY,
                platform TEXT NOT NULL,
                userid TEXT NOT NULL,
                password TEXT NOT NULL);
                """)
        return db, cursor
    
    class VaultMethods:
    
        def __init__(self):
            self.db, self.cursor = init_database()
    
        def popup_entry(self, heading):
            answer = simpledialog.askstring("Enter details", heading)
            return answer
    
        def add_password(self, vault_screen):
            platform = self.popup_entry("Platform")
            userid = self.popup_entry("Username/Email")
            password = self.popup_entry("Password")
    
            insert_cmd = """INSERT INTO vault(platform, userid, password) VALUES (?, ?, ?)"""
            self.cursor.execute(insert_cmd, (platform, userid, password))
            self.db.commit()
            vault_screen()
    
        def update_password(self, id, vault_screen):
            password = self.popup_entry("Enter New Password")
            self.cursor.execute("UPDATE vault SET password = ? WHERE id = ?", (password, id))
            self.db.commit()
            vault_screen()
    
        def remove_password(self, id, vault_screen):
            self.cursor.execute("DELETE FROM vault WHERE id = ?", (id,))
            self.db.commit()
            vault_screen()
    
    class PasswordManager:
    
        def __init__(self):
            self.db, self.cursor = init_database()
            self.window = Tk()
            self.window.update()
            self.window.title("Password Manager")
            self.window.geometry("650x350")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
        def welcome_new_user(self):
            self.window.geometry("450x200")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
            label1 = Label(self.window, text="Create New Master Password", bg="gray20", fg="#ccff66")
            label1.config(anchor=CENTER)
            label1.pack(pady=10)
    
            mp_entry_box = Entry(self.window, width=20, show="*", bg="black", fg="lime green", insertbackground="cyan")
            mp_entry_box.pack()
            mp_entry_box.focus()
    
            label2 = Label(self.window, text="Enter the password again", bg="gray20", fg="#ccff66")
            label2.config(anchor=CENTER)
            label2.pack(pady=10)
    
            rmp_entry_box = Entry(self.window, width=20, show="*", bg="black", fg="lime green", insertbackground="cyan")
            rmp_entry_box.pack()
    
            self.feedback = Label(self.window, bg="gray20")
            self.feedback.pack()
    
            save_btn = Button(self.window, text="Create Password", command=partial(self.save_master_password, mp_entry_box, rmp_entry_box), bg="gray40", fg="cyan", bd=5)
            save_btn.pack(pady=5)
    
        def login_user(self):
            for widget in self.window.winfo_children():
                widget.destroy()
    
            self.window.geometry("450x200")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
            label1 = Label(self.window, text="Enter your master password", bg="gray20", fg="#ccff66")
            label1.config(anchor=CENTER)
            label1.place(x=150, y=50)
    
            self.password_entry_box = Entry(self.window, width=20, show="*", bg="black", fg="lime green", insertbackground="cyan")
            self.password_entry_box.place(x=160, y=80)
            self.password_entry_box.focus()
    
            self.feedback = Label(self.window, bg="gray20")
            self.feedback.place(x=170, y=105)
    
            login_btn = Button(self.window, text="Log In", command=partial(self.check_master_password, self.password_entry_box), bg="gray40", fg="cyan", bd=5)
            login_btn.place(x=200, y=130)
    
        def save_master_password(self, eb1, eb2):
            password1 = eb1.get()
            password2 = eb2.get()
            if password1 == password2:
                hashed_password = self.encrypt_password(password1)
                insert_command = """INSERT INTO master(password) VALUES(?) """
                self.cursor.execute(insert_command, [hashed_password])
                self.db.commit()
                self.login_user()
            else:
                self.feedback.config(text="Passwords do not match", fg="red")
    
        def check_master_password(self, eb):
            hashed_password = self.encrypt_password(eb.get())
            self.cursor.execute("SELECT * FROM master WHERE id = 1 AND password = ?", [hashed_password])
            if self.cursor.fetchall():
                self.password_vault_screen()
            else:
                self.password_entry_box.delete(0, END)
                self.feedback.config(text="Incorrect password", fg="red")
    
        def password_vault_screen(self):
            for widget in self.window.winfo_children():
                widget.destroy()
    
            vault_methods = VaultMethods()
    
            self.window.geometry("850x350")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
            main_frame = Frame(self.window, bg="gray20")
            main_frame.pack(fill=BOTH, expand=1)
    
            main_canvas = Canvas(main_frame, bg="gray20")
            main_canvas.pack(side=LEFT, fill=BOTH, expand=1)
    
            main_scrollbar = Scrollbar(main_frame, orient=VERTICAL, command=main_canvas.yview)
            main_scrollbar.pack(side=RIGHT, fill=Y)
    
            main_canvas.configure(yscrollcommand=main_scrollbar.set)
            main_canvas.bind('<Configure>', lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all")))
    
            second_frame = Frame(main_canvas, bg="gray20")
            main_canvas.create_window((0, 0), window=second_frame, anchor="nw")
    
            generate_password_btn = Button(second_frame, text="Generate Password", command=PasswordGenerator, bg="gray40", fg="cyan", bd=5)
            generate_password_btn.grid(row=1, column=2, pady=10)
    
            add_password_btn = Button(second_frame, text="Add New Password", command=partial(vault_methods.add_password, self.password_vault_screen), bg="gray40", fg="cyan", bd=5)
            add_password_btn.grid(row=1, column=3, pady=10)
    
            lbl = Label(second_frame, text="Platform", bg="gray20", fg="#ccff66")
            lbl.grid(row=2, column=0, padx=40, pady=10)
            lbl = Label(second_frame, text="Email/Username", bg="gray20", fg="#ccff66")
            lbl.grid(row=2, column=1, padx=40, pady=10)
            lbl = Label(second_frame, text="Password", bg="gray20", fg="#ccff66")
            lbl.grid(row=2, column=2, padx=40, pady=10)
    
            self.cursor.execute("SELECT * FROM vault")
    
            if self.cursor.fetchall():
                i = 0
                while True:
                    self.cursor.execute("SELECT * FROM vault")
                    array = self.cursor.fetchall()
    
                    platform_label = Label(second_frame, text=(array[i][1]), bg="gray20", fg="#ccff66")
                    platform_label.grid(column=0, row=i + 3)
    
                    account_label = Label(second_frame, text=(array[i][2]), bg="gray20", fg="#ccff66")
                    account_label.grid(column=1, row=i + 3)
    
                    password_label = Label(second_frame, text=(array[i][3]), bg="gray20", fg="#ccff66")
                    password_label.grid(column=2, row=i + 3)
    
                    copy_btn = Button(second_frame, text="Copy Password", command=partial(self.copy_text, array[i][3]), bg="gray40", fg="cyan", bd=5)
                    copy_btn.grid(column=3, row=i + 3, pady=10, padx=10)
                    update_btn = Button(second_frame, text="Update Password", command=partial(vault_methods.update_password, array[i][0], self.password_vault_screen), bg="gray40", fg="cyan", bd=5)
                    update_btn.grid(column=4, row=i + 3, pady=10, padx=10)
                    remove_btn = Button(second_frame, text="Delete Password", command=partial(vault_methods.remove_password, array[i][0], self.password_vault_screen), bg="gray40", fg="cyan", bd=5)
                    remove_btn.grid(column=5, row=i + 3, pady=10, padx=10)
    
                    i += 1
    
                    self.cursor.execute("SELECT * FROM vault")
                    if len(self.cursor.fetchall()) <= i:
                        break
    
        def encrypt_password(self, password):
            password = password.encode("utf-8")
            encoded_text = hashlib.md5(password).hexdigest()
            return encoded_text
    
        def copy_text(self, text):
            self.window.clipboard_clear()
            self.window.clipboard_append(text)
    
    if __name__ == '__main__':
        db, cursor = init_database()
        cursor.execute("SELECT * FROM master")
        manager = PasswordManager()
        if cursor.fetchall():
            manager.login_user()
        else:
            manager.welcome_new_user()
        manager.window.mainloop()

if pausevar == 10000:
    def pausemain1():
        import tkinter as tk
        from tkinter import ttk, simpledialog, messagebox
        import json
        import os
        from datetime import datetime, timedelta

        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

        # Define the file name
        file_name = "ChooseLocationForPause.txt"
        
        # Check if the file already exists
        if not os.path.exists(file_name):
            # Open the file in write mode and immediately close it
            with open(file_name, 'w'):
                pass
            print(f"File {file_name} has been created. Restart aplication is required...")
            input()
        else:
            print(f"Opening file {file_name}... Done!")
        
        class HelpPopup:
            def __init__(self, parent):
                self.parent = parent
                self.popup = tk.Toplevel(parent)
                self.popup.title("Help")
                #self.popup.geometry("500x500")
                self.popup.resizable(False, False)
        
                help_text = """
                Welcome to the Break Info App!
        
                This application allows you to manage break information for employees or persons.
        
                How to use:
                1. Select a person from the drop-down menu.
                2. Choose a break time from the drop-down menu.
                3. Click on 'Set Break Time' to update the break time for the selected person.
                4. Optionally, click on 'Back to Work' to set the return time after the break.
                5. Use 'Refresh' to see updated information.
                6. Use 'Reset Data' to clear all break and return times for all persons.
                7. Use 'JSON Generator' to generate JSON data for persons and their break times.
                8. Click on 'Save to JSON' in the JSON Generator window to save the generated data to a JSON file.
        
                Configuration File for Path Selection:
                --------------------------------------
                This application uses a configuration file ('ChooseLocationForPause.txt') to store the path for saving JSON files. If the file doesn't exist or is not correctly configured, an error message will be displayed.
        
                To Use:
                --------
                1. Ensure the 'ChooseLocationForPause.txt' file exists in the same directory as this application.
                2. Open the file in a text editor.
                3. Enter the desired path where you want to save JSON files on a new line in the text file.
                4. Save and close the text file.
        
                Note: If the path is invalid or the file is not properly formatted, an error will prompt upon application startup.
        
                For more information or issues, please contact Tudor Marmureanu.
                """
        
                label = ttk.Label(self.popup, text=help_text, wraplength=400, justify="left")
                label.pack(padx=20, pady=20)
        
                ok_button = ttk.Button(self.popup, text="OK", command=self.popup.destroy)
                ok_button.pack(pady=10)
        
        class JSONGeneratorApp:
            def __init__(self, root, parent_app):
                self.root = root
                self.root.title("JSON Generator")
                self.parent_app = parent_app
        
                # Entry for number of persons
                self.num_label = ttk.Label(self.root, text="Number of Persons:")
                self.num_label.pack(padx=20, pady=5)
                self.num_entry = ttk.Entry(self.root)
                self.num_entry.pack(padx=20, pady=5)
        
                # Button to generate entry fields for names
                self.generate_button = ttk.Button(self.root, text="Generate Fields", command=self.generate_fields)
                self.generate_button.pack(padx=20, pady=10)
        
                # Frame to hold the dynamically generated entry fields
                self.names_frame = ttk.Frame(self.root)
                self.names_frame.pack(padx=20, pady=10)
        
                # Save button to save the data to JSON file
                self.save_button = ttk.Button(self.root, text="Save to JSON", command=self.save_to_json)
                self.save_button.pack(padx=20, pady=10)
        
                self.name_entries = []
        
            def generate_fields(self):
                # Clear any existing entry fields
                for widget in self.names_frame.winfo_children():
                    widget.destroy()
        
                self.name_entries = []
                try:
                    num_persons = int(self.num_entry.get())
                    for i in range(num_persons):
                        label = ttk.Label(self.names_frame, text=f"Person {i + 1} Name:")
                        label.pack(padx=5, pady=2)
                        entry = ttk.Entry(self.names_frame)
                        entry.pack(padx=5, pady=2)
                        self.name_entries.append(entry)
                except ValueError:
                    messagebox.showerror("Invalid input", "Please enter a valid number.")
        
            def save_to_json(self):
                persons = [entry.get() for entry in self.name_entries if entry.get().strip()]
                if persons:
                    data = {person: {"break_time": "--", "return_time": ""} for person in persons}
                    with open(self.parent_app.file_path, 'w') as file:
                        json.dump(data, file, indent=4)
                    self.parent_app.persons = persons
                    self.parent_app.update_combobox_values()
                    self.root.destroy()
                else:
                    messagebox.showerror("Input Error", "Please enter valid names for all persons.")
        
        class BreakInfoApp:
            def __init__(self, root):
                self.root = root
                self.root.title("Break Info")
        
                self.file_path = self.get_file_path()
                self.persons = self.load_persons_from_json()
        
                # Create combobox for selecting person
                self.person_label = ttk.Label(self.root, text="Select Person:")
                self.person_label.pack(padx=20, pady=5)
                self.person_combobox = ttk.Combobox(self.root, values=self.persons)
                self.person_combobox.pack(padx=20, pady=5)
        
                # Create combobox for selecting break time
                self.break_time_label = ttk.Label(self.root, text="Select Break Time:")
                self.break_time_label.pack(padx=20, pady=5)
                self.break_time_combobox = ttk.Combobox(self.root, values=self.generate_break_times())
                self.break_time_combobox.pack(padx=20, pady=5)
        
                # Create button to update JSON file
                self.update_button = ttk.Button(self.root, text="Set Break Time", command=self.update_json_file)
                self.update_button.pack(padx=20, pady=10)
        
                # Create button to refresh data
                self.refresh_button = ttk.Button(self.root, text="Refresh", command=self.update_data)
                self.refresh_button.pack(padx=20, pady=10)
        
                # Create button to open return menu
                self.return_button = ttk.Button(self.root, text="Back to Work", command=self.open_return_menu)
                self.return_button.pack(padx=20, pady=10)
        
                # Create button to reset all data
                self.reset_button = ttk.Button(self.root, text="Reset Data", command=self.reset_data)
                self.reset_button.pack(padx=20, pady=10)
        
                # Create button to open JSON generator window
                self.create_users_button = ttk.Button(self.root, text="JSON Generator", command=self.open_json_generator)
                self.create_users_button.pack(padx=20, pady=10)
        
                # Create button to open help popup
                self.help_button = ttk.Button(self.root, text="Help", command=self.open_help_popup)
                self.help_button.pack(padx=20, pady=10)
        
                # Create label to display break info
                self.label = ttk.Label(self.root, text="No data", font=("Helvetica", 16))
                self.label.pack(padx=20, pady=20)
        
                self.ensure_json_file()
                self.update_data()
        
            def open_help_popup(self):
                help_popup = HelpPopup(self.root)
        
            def get_file_path(self):
                config_file = 'ChooseLocationForPause.txt'
                if os.path.exists(config_file):
                    with open(config_file, 'r') as file:
                        return file.readline().strip()
                else:
                    messagebox.showerror("Error", f"Configuration file {config_file} not found.")
                    self.root.destroy()
        
            def load_persons_from_json(self):
                if os.path.exists(self.file_path):
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return list(data.keys())
                else:
                    return []
        
            def generate_break_times(self):
                times = []
                start_hour, start_minute = 7, 45
                end_hour, end_minute = 16, 45
        
                current_hour = start_hour
                current_minute = start_minute
        
                while (current_hour < end_hour) or (current_hour == end_hour and current_minute <= end_minute):
                    times.append(f"{current_hour:02d}:{current_minute:02d}")
                    current_minute += 1
                    if current_minute == 60:
                        current_minute = 0
                        current_hour += 1
        
                return times
        
            def ensure_json_file(self):
                if not os.path.exists(self.file_path):
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                else:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    modified = False
                    for person in self.persons:
                        if person not in data:
                            data[person] = {"break_time": "--", "return_time": ""}
                            modified = True
                        else:
                            if "break_time" not in data[person]:
                                data[person]["break_time"] = "--"
                                modified = True
                            if "return_time" not in data[person]:
                                data[person]["return_time"] = ""
                                modified = True
                    if modified:
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
        
            def read_json_file(self):
                try:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return data
                except Exception as e:
                    return str(e)
        
            def update_json_file(self):
                person = self.person_combobox.get()
                break_time = self.break_time_combobox.get()
                if person and break_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["break_time"] = break_time
                        data[person]["return_time"] = ""  # Clear return time when setting a new break time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and break time")
        
            def update_return_time(self, return_window, person_combobox, return_time_combobox):
                person = person_combobox.get()
                return_time = return_time_combobox.get()
                if person and return_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["return_time"] = return_time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                        return_window.destroy()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and return time")
        
            def open_return_menu(self):
                return_window = tk.Toplevel(self.root)
                return_window.title("Set Return Time")
        
                person_label = ttk.Label(return_window, text="Select Person:")
                person_label.pack(padx=20, pady=5)
                person_combobox = ttk.Combobox(return_window, values=self.persons)
                person_combobox.pack(padx=20, pady=5)
        
                return_time_label = ttk.Label(return_window, text="Select Return Time:")
                return_time_label.pack(padx=20, pady=5)
        
                # Generate times for return time combobox
                break_times = self.generate_break_times()
                return_time_combobox = ttk.Combobox(return_window, values=break_times)
                return_time_combobox.pack(padx=20, pady=5)
        
                # Set default return time to break time + 1 hour
                def set_default_return_time(event):
                    person = person_combobox.get()
                    if person:
                        data = self.read_json_file()
                        if isinstance(data, dict):
                            break_time_str = data[person]["break_time"]
                            break_time = datetime.strptime(break_time_str, "%H:%M")
                            default_return_time = break_time + timedelta(hours=1)
                            default_return_time_str = default_return_time.strftime("%H:%M")
                            if default_return_time_str in break_times:
                                return_time_combobox.set(default_return_time_str)
        
                person_combobox.bind("<<ComboboxSelected>>", set_default_return_time)
        
                update_return_button = ttk.Button(return_window, text="Set Return Time",
                                                command=lambda: self.update_return_time(return_window, person_combobox, return_time_combobox))
                update_return_button.pack(padx=20, pady=10)
        
            def reset_data(self):
                confirmation = messagebox.askyesno("Reset Data", "Are you sure you want to reset all data?")
                if confirmation:
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                    self.update_data()
        
            def update_data(self):
                data = self.read_json_file()
                if isinstance(data, dict):
                    display_text = ""
                    for person, info in data.items():
                        break_time = info.get("break_time", "N/A")
                        return_time = info.get("return_time", "")
                        if return_time:
                            display_text += f"Name: {person}, Break Time: {break_time}, Return Time: {return_time} (Back)\n"
                        else:
                            display_text += f"Name: {person}, Break Time: {break_time}\n"
                    self.label.config(text=display_text)
                else:
                    self.label.config(text=f"Error: {data}")
        
                self.root.after(1000, self.update_data)  # Update every 10 seconds
        
            def open_json_generator(self):
                json_generator_window = tk.Toplevel(self.root)
                JSONGeneratorApp(json_generator_window, self)
        
            def update_combobox_values(self):
                self.person_combobox['values'] = self.persons
        
        if __name__ == "__main__":
            root = tk.Tk()
            app = BreakInfoApp(root)
            root.mainloop()
            
    def pausemain2():
        import tkinter as tk
        from tkinter import ttk, simpledialog, messagebox
        import json
        import os
        from datetime import datetime, timedelta

        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        validation.destroy()
        
        # Define the file name
        file_name = "ChooseLocationForPause.txt"
        
        # Check if the file already exists
        if not os.path.exists(file_name):
            # Open the file in write mode and immediately close it
            with open(file_name, 'w'):
                pass
            print(f"File {file_name} has been created. Restart aplication is required...")
            input()
        else:
            print(f"Opening file {file_name}... Done!")
        
        class HelpPopup:
            def __init__(self, parent):
                self.parent = parent
                self.popup = tk.Toplevel(parent)
                self.popup.title("Help")
                #self.popup.geometry("500x500")
                self.popup.resizable(False, False)
        
                help_text = """
                Welcome to the Break Info App!
        
                This application allows you to manage break information for employees or persons.
        
                How to use:
                1. Select a person from the drop-down menu.
                2. Choose a break time from the drop-down menu.
                3. Click on 'Set Break Time' to update the break time for the selected person.
                4. Optionally, click on 'Back to Work' to set the return time after the break.
                5. Use 'Refresh' to see updated information.
                6. Use 'Reset Data' to clear all break and return times for all persons.
                7. Use 'JSON Generator' to generate JSON data for persons and their break times.
                8. Click on 'Save to JSON' in the JSON Generator window to save the generated data to a JSON file.
        
                Configuration File for Path Selection:
                --------------------------------------
                This application uses a configuration file ('ChooseLocationForPause.txt') to store the path for saving JSON files. If the file doesn't exist or is not correctly configured, an error message will be displayed.
        
                To Use:
                --------
                1. Ensure the 'ChooseLocationForPause.txt' file exists in the same directory as this application.
                2. Open the file in a text editor.
                3. Enter the desired path where you want to save JSON files on a new line in the text file.
                4. Save and close the text file.
        
                Note: If the path is invalid or the file is not properly formatted, an error will prompt upon application startup.
        
                For more information or issues, please contact Tudor Marmureanu.
                """
        
                label = ttk.Label(self.popup, text=help_text, wraplength=400, justify="left")
                label.pack(padx=20, pady=20)
        
                ok_button = ttk.Button(self.popup, text="OK", command=self.popup.destroy)
                ok_button.pack(pady=10)
        
        class JSONGeneratorApp:
            def __init__(self, root, parent_app):
                self.root = root
                self.root.title("JSON Generator")
                self.parent_app = parent_app
        
                # Entry for number of persons
                self.num_label = ttk.Label(self.root, text="Number of Persons:")
                self.num_label.pack(padx=20, pady=5)
                self.num_entry = ttk.Entry(self.root)
                self.num_entry.pack(padx=20, pady=5)
        
                # Button to generate entry fields for names
                self.generate_button = ttk.Button(self.root, text="Generate Fields", command=self.generate_fields)
                self.generate_button.pack(padx=20, pady=10)
        
                # Frame to hold the dynamically generated entry fields
                self.names_frame = ttk.Frame(self.root)
                self.names_frame.pack(padx=20, pady=10)
        
                # Save button to save the data to JSON file
                self.save_button = ttk.Button(self.root, text="Save to JSON", command=self.save_to_json)
                self.save_button.pack(padx=20, pady=10)
        
                self.name_entries = []
        
            def generate_fields(self):
                # Clear any existing entry fields
                for widget in self.names_frame.winfo_children():
                    widget.destroy()
        
                self.name_entries = []
                try:
                    num_persons = int(self.num_entry.get())
                    for i in range(num_persons):
                        label = ttk.Label(self.names_frame, text=f"Person {i + 1} Name:")
                        label.pack(padx=5, pady=2)
                        entry = ttk.Entry(self.names_frame)
                        entry.pack(padx=5, pady=2)
                        self.name_entries.append(entry)
                except ValueError:
                    messagebox.showerror("Invalid input", "Please enter a valid number.")
        
            def save_to_json(self):
                persons = [entry.get() for entry in self.name_entries if entry.get().strip()]
                if persons:
                    data = {person: {"break_time": "--", "return_time": ""} for person in persons}
                    with open(self.parent_app.file_path, 'w') as file:
                        json.dump(data, file, indent=4)
                    self.parent_app.persons = persons
                    self.parent_app.update_combobox_values()
                    self.root.destroy()
                else:
                    messagebox.showerror("Input Error", "Please enter valid names for all persons.")
        
        class BreakInfoApp:
            def __init__(self, root):
                self.root = root
                self.root.title("Break Info")
        
                self.file_path = self.get_file_path()
                self.persons = self.load_persons_from_json()
        
                # Create combobox for selecting person
                self.person_label = ttk.Label(self.root, text="Select Person:")
                self.person_label.pack(padx=20, pady=5)
                self.person_combobox = ttk.Combobox(self.root, values=self.persons)
                self.person_combobox.pack(padx=20, pady=5)
        
                # Create combobox for selecting break time
                self.break_time_label = ttk.Label(self.root, text="Select Break Time:")
                self.break_time_label.pack(padx=20, pady=5)
                self.break_time_combobox = ttk.Combobox(self.root, values=self.generate_break_times())
                self.break_time_combobox.pack(padx=20, pady=5)
        
                # Create button to update JSON file
                self.update_button = ttk.Button(self.root, text="Set Break Time", command=self.update_json_file)
                self.update_button.pack(padx=20, pady=10)
        
                # Create button to refresh data
                self.refresh_button = ttk.Button(self.root, text="Refresh", command=self.update_data)
                self.refresh_button.pack(padx=20, pady=10)
        
                # Create button to open return menu
                self.return_button = ttk.Button(self.root, text="Back to Work", command=self.open_return_menu)
                self.return_button.pack(padx=20, pady=10)
        
                # Create button to reset all data
                self.reset_button = ttk.Button(self.root, text="Reset Data", command=self.reset_data)
                self.reset_button.pack(padx=20, pady=10)
        
                # Create button to open JSON generator window
                self.create_users_button = ttk.Button(self.root, text="JSON Generator", command=self.open_json_generator, state="disabled")
                self.create_users_button.pack(padx=20, pady=10)
        
                # Create button to open help popup
                self.help_button = ttk.Button(self.root, text="Help", command=self.open_help_popup)
                self.help_button.pack(padx=20, pady=10)
        
                # Create label to display break info
                self.label = ttk.Label(self.root, text="No data", font=("Helvetica", 16))
                self.label.pack(padx=20, pady=20)
        
                self.ensure_json_file()
                self.update_data()
        
            def open_help_popup(self):
                help_popup = HelpPopup(self.root)
        
            def get_file_path(self):
                config_file = 'ChooseLocationForPause.txt'
                if os.path.exists(config_file):
                    with open(config_file, 'r') as file:
                        return file.readline().strip()
                else:
                    messagebox.showerror("Error", f"Configuration file {config_file} not found.")
                    self.root.destroy()
        
            def load_persons_from_json(self):
                if os.path.exists(self.file_path):
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return list(data.keys())
                else:
                    return []
        
            def generate_break_times(self):
                times = []
                start_hour, start_minute = 7, 45
                end_hour, end_minute = 16, 45
        
                current_hour = start_hour
                current_minute = start_minute
        
                while (current_hour < end_hour) or (current_hour == end_hour and current_minute <= end_minute):
                    times.append(f"{current_hour:02d}:{current_minute:02d}")
                    current_minute += 1
                    if current_minute == 60:
                        current_minute = 0
                        current_hour += 1
        
                return times
        
            def ensure_json_file(self):
                if not os.path.exists(self.file_path):
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                else:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    modified = False
                    for person in self.persons:
                        if person not in data:
                            data[person] = {"break_time": "--", "return_time": ""}
                            modified = True
                        else:
                            if "break_time" not in data[person]:
                                data[person]["break_time"] = "--"
                                modified = True
                            if "return_time" not in data[person]:
                                data[person]["return_time"] = ""
                                modified = True
                    if modified:
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
        
            def read_json_file(self):
                try:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return data
                except Exception as e:
                    return str(e)
        
            def update_json_file(self):
                person = self.person_combobox.get()
                break_time = self.break_time_combobox.get()
                if person and break_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["break_time"] = break_time
                        data[person]["return_time"] = ""  # Clear return time when setting a new break time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and break time")
        
            def update_return_time(self, return_window, person_combobox, return_time_combobox):
                person = person_combobox.get()
                return_time = return_time_combobox.get()
                if person and return_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["return_time"] = return_time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                        return_window.destroy()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and return time")
        
            def open_return_menu(self):
                return_window = tk.Toplevel(self.root)
                return_window.title("Set Return Time")
        
                person_label = ttk.Label(return_window, text="Select Person:")
                person_label.pack(padx=20, pady=5)
                person_combobox = ttk.Combobox(return_window, values=self.persons)
                person_combobox.pack(padx=20, pady=5)
        
                return_time_label = ttk.Label(return_window, text="Select Return Time:")
                return_time_label.pack(padx=20, pady=5)
        
                # Generate times for return time combobox
                break_times = self.generate_break_times()
                return_time_combobox = ttk.Combobox(return_window, values=break_times)
                return_time_combobox.pack(padx=20, pady=5)
        
                # Set default return time to break time + 1 hour
                def set_default_return_time(event):
                    person = person_combobox.get()
                    if person:
                        data = self.read_json_file()
                        if isinstance(data, dict):
                            break_time_str = data[person]["break_time"]
                            break_time = datetime.strptime(break_time_str, "%H:%M")
                            default_return_time = break_time + timedelta(hours=1)
                            default_return_time_str = default_return_time.strftime("%H:%M")
                            if default_return_time_str in break_times:
                                return_time_combobox.set(default_return_time_str)
        
                person_combobox.bind("<<ComboboxSelected>>", set_default_return_time)
        
                update_return_button = ttk.Button(return_window, text="Set Return Time",
                                                command=lambda: self.update_return_time(return_window, person_combobox, return_time_combobox))
                update_return_button.pack(padx=20, pady=10)
        
            def reset_data(self):
                confirmation = messagebox.askyesno("Reset Data", "Are you sure you want to reset all data?")
                if confirmation:
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                    self.update_data()
        
            def update_data(self):
                data = self.read_json_file()
                if isinstance(data, dict):
                    display_text = ""
                    for person, info in data.items():
                        break_time = info.get("break_time", "N/A")
                        return_time = info.get("return_time", "")
                        if return_time:
                            display_text += f"Name: {person}, Break Time: {break_time}, Return Time: {return_time} (Back)\n"
                        else:
                            display_text += f"Name: {person}, Break Time: {break_time}\n"
                    self.label.config(text=display_text)
                else:
                    self.label.config(text=f"Error: {data}")
        
                self.root.after(1000, self.update_data)  # Update every 10 seconds
        
            def open_json_generator(self):
                json_generator_window = tk.Toplevel(self.root)
                JSONGeneratorApp(json_generator_window, self)
        
            def update_combobox_values(self):
                self.person_combobox['values'] = self.persons
        
        if __name__ == "__main__":
            root = tk.Tk()
            app = BreakInfoApp(root)
            root.mainloop()

    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=pausemain2)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=pausemain1, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

if taskmngrvar == 1000000:
    import tkinter as tk
    from tkinter import ttk, messagebox
    import psutil
    import threading
    import time
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    class CustomTaskManager:
        def __init__(self, root):
            self.root = root
            self.root.title("Task Manager")

            # Stilizare pentru butoane
            style = ttk.Style()
            style.configure("TButton",
                            #foreground="#333333",    # Text mai deschis
                            #background="#2E7D32",    # Fundal mai închis (verde închis)
                            #font=("Helvetica", 12),
                            padding=10,
                            width=15)

            # Stilizare pentru Treeview
            style.configure("Treeview",
                            background="#f0f0f0",
                            foreground="black",
                            rowheight=25,
                            fieldbackground="#f0f0f0")

            # Crearea notebook-ului pentru taburi
            self.notebook = ttk.Notebook(root)
            self.notebook.pack(fill=tk.BOTH, expand=True)

            # Tabul pentru procese
            self.process_frame = ttk.Frame(self.notebook)
            self.notebook.add(self.process_frame, text="Processes")

            # Crearea treeview pentru a afișa procesele
            self.tree = ttk.Treeview(self.process_frame, columns=("pid", "name", "status", "cpu", "memory", "disk"), show='headings')
            self.tree.heading("pid", text="PID")
            self.tree.heading("name", text="Process Name")
            self.tree.heading("status", text="Status")
            self.tree.heading("cpu", text="CPU (%)")
            self.tree.heading("memory", text="Memory (MB)")
            self.tree.heading("disk", text="Disk Read/Write (MB)")

            self.tree.column("pid", width=50)
            self.tree.column("name", width=200)
            self.tree.column("status", width=100)
            self.tree.column("cpu", width=50)
            self.tree.column("memory", width=100)
            self.tree.column("disk", width=150)

            self.tree.pack(fill=tk.BOTH, expand=True)

            # Butoane pentru funcționalități avansate
            self.button_frame = ttk.Frame(self.process_frame)
            self.button_frame.pack(fill=tk.X, pady=10)

            self.kill_button = ttk.Button(self.button_frame, text="Kill Process", command=self.kill_process)
            self.kill_button.pack(side=tk.LEFT, padx=10)

            self.refresh_button = ttk.Button(self.button_frame, text="Refresh", command=self.update_process_list)
            self.refresh_button.pack(side=tk.LEFT, padx=10)

            self.search_entry = ttk.Entry(self.button_frame, width=30)
            self.search_entry.pack(side=tk.LEFT, padx=10)

            self.search_button = ttk.Button(self.button_frame, text="Search", command=self.search_process)
            self.search_button.pack(side=tk.LEFT, padx=10)

            # Tabul pentru resursele sistemului (CPU, Memorie, Rețea, Disc)
            self.resources_frame = ttk.Frame(self.notebook)
            self.notebook.add(self.resources_frame, text="System Resources")

            # Adăugarea unui treeview pentru resursele sistemului
            self.resources_tree = ttk.Treeview(self.resources_frame, columns=("resource", "usage"), show='headings')
            self.resources_tree.heading("resource", text="Resource")
            self.resources_tree.heading("usage", text="Usage")

            self.resources_tree.column("resource", width=200)
            self.resources_tree.column("usage", width=200)

            self.resources_tree.pack(fill=tk.BOTH, expand=True)

            # Inițializarea listei de procese și resurse
            self.update_process_list()
            self.update_system_resources()

            # Inițializarea diagramelor
            self.init_plots()

        def update_process_list(self):
            threading.Thread(target=self._update_process_list, daemon=True).start()

        def _update_process_list(self):
            # Ștergerea tuturor elementelor din treeview
            for item in self.tree.get_children():
                self.tree.delete(item)

            # Obținerea și adăugarea informațiilor despre procese
            processes = []
            for proc in psutil.process_iter(['pid', 'name', 'status', 'cpu_percent', 'memory_info', 'io_counters']):
                try:
                    pid = proc.info['pid']
                    name = proc.info['name']
                    status = proc.info['status']
                    cpu = proc.info['cpu_percent']
                    memory = proc.info['memory_info'].rss / (1024 * 1024)  # Convertirea din bytes în MB
                    io_counters = proc.info['io_counters']
                    disk = (io_counters.read_bytes + io_counters.write_bytes) / (1024 * 1024)  # Convertirea din bytes în MB

                    processes.append((pid, name, status, cpu, memory, disk))
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    print(f"Error accessing process {proc.info['pid']}: {e}")
                    continue

            # Sortare alfabetică după nume
            processes.sort(key=lambda x: x[1].lower())

            # Adăugarea proceselor în Treeview
            for process in processes:
                self.tree.insert("", tk.END, values=process)

        def update_system_resources(self):
            threading.Thread(target=self._update_system_resources, daemon=True).start()

        def _update_system_resources(self):
            while True:
                # Ștergerea tuturor elementelor din treeview-ul resurselor
                for item in self.resources_tree.get_children():
                    self.resources_tree.delete(item)

                # Obținerea informațiilor despre resursele sistemului
                cpu_usage = psutil.cpu_percent(interval=1)
                memory_usage = psutil.virtual_memory().percent
                disk_usage = psutil.disk_usage('/').percent
                net_io = psutil.net_io_counters()
                net_usage = f"Sent: {net_io.bytes_sent / (1024 * 1024):.2f} MB, Received: {net_io.bytes_recv / (1024 * 1024):.2f} MB"

                self.resources_tree.insert("", tk.END, values=("CPU Usage", f"{cpu_usage} %"))
                self.resources_tree.insert("", tk.END, values=("Memory Usage", f"{memory_usage} %"))
                self.resources_tree.insert("", tk.END, values=("Disk Usage", f"{disk_usage} %"))
                self.resources_tree.insert("", tk.END, values=("Network Usage", net_usage))

                # Actualizarea diagramei
                self.update_plots(cpu_usage, memory_usage, disk_usage)

                time.sleep(5)

        def init_plots(self):
            # Inițializarea figurii pentru diagramă
            self.fig, self.ax = plt.subplots(figsize=(4, 4))

            # Crearea unei diagrame goale inițiale
            self.ax.set_title('System Resources')
            self.ax.set_xlabel('Resource')
            self.ax.set_ylabel('Usage (%)')

            # Bară de afișare a diagramei în tkinter
            self.canvas = FigureCanvasTkAgg(self.fig, master=self.resources_frame)
            self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        def update_plots(self, cpu_usage, memory_usage, disk_usage):
            # Actualizarea datelor diagramei
            resources = ['CPU', 'Memory', 'Disk']
            usages = [cpu_usage, memory_usage, disk_usage]

            # Ștergerea datelor anterioare
            self.ax.clear()

            # Re-desenarea diagramei actualizate
            self.ax.bar(resources, usages, color=['#1f77b4', '#ff7f0e', '#2ca02c'])  # Culori pentru fiecare bară

            # Adăugarea unor detalii suplimentare pentru diagrame
            self.ax.set_title('System Resources')
            self.ax.set_xlabel('Resource')
            self.ax.set_ylabel('Usage (%)')

            # Setarea limitei superioare a axei y la 100%
            self.ax.set_ylim(0, 100)

            # Actualizarea vizualizării în fereastră
            self.canvas.draw()

        def kill_process(self):
            selected_item = self.tree.selection()
            if selected_item:
                pid = self.tree.item(selected_item)["values"][0]
                try:
                    proc = psutil.Process(pid)
                    proc.terminate()
                    messagebox.showinfo("Success", f"Process {pid} terminated.")
                    self.update_process_list()
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    messagebox.showerror("Error", str(e))

            else:
                messagebox.showwarning("Warning", "Please select a process to kill.")

        def search_process(self):
            search_query = self.search_entry.get().lower()
            threading.Thread(target=self._search_process, args=(search_query,), daemon=True).start()

        def _search_process(self, search_query):
            for item in self.tree.get_children():
                self.tree.delete(item)

            for proc in psutil.process_iter(['pid', 'name', 'status', 'cpu_percent', 'memory_info', 'io_counters']):
                try:
                    if search_query in proc.info['name'].lower():
                        pid = proc.info['pid']
                        name = proc.info['name']
                        status = proc.info['status']
                        cpu = proc.info['cpu_percent']
                        memory = proc.info['memory_info'].rss / (1024 * 1024)  # Convertirea din bytes în MB
                        io_counters = proc.info['io_counters']
                        disk = (io_counters.read_bytes + io_counters.write_bytes) / (1024 * 1024)  # Convertirea din bytes în MB

                        self.tree.insert("", tk.END, values=(pid, name, status, cpu, memory, disk))
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    print(f"Error accessing process {proc.info['pid']}: {e}")
                    continue

    if __name__ == "__main__":
        roottm = tk.Tk()

        # Stilizare pentru fundalul general al aplicației
        roottm.configure(background="#f0f0f0")

        app = CustomTaskManager(roottm)
        roottm.mainloop()

if junkvar == 77777:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    import os
    import shutil
    from tkinter import *
    from threading import *
    from PIL import ImageTk, Image
    from tkinter import messagebox, filedialog

    file_types = {
    'Documents': ('.pdf', '.doc', '.xls', '.xlsx', '.txt', '.csv', '.xml', '.zip', '.docx', '.DOCX', '.odt', 
                  '.ppt', '.pptx', '.rtf', '.tex', '.epub', '.mobi'),
    'Pictures': ('.jpg', '.jpeg', '.png', '.JPG', '.webp', '.ico', '.gif', '.bmp', '.tiff', '.svg', '.heic'),
    'Videos': ('.mp4', '.mkv', '.3gp', '.flv', '.mpeg', '.avi', '.mov', '.wmv', '.mpg', '.webm', '.m4v'),
    'Music': ('.mp3', '.wav', '.m4a', '.webm', '.flac', '.aac', '.ogg', '.wma'),
    'Programs': ('.py', '.cpp', '.c', '.sh', '.js', '.htm', '.html', '.css', '.java', '.cs', '.php', '.rb', 
                 '.swift', '.go', '.pl', '.json', '.xml', '.sql', '.bat', '.cmd', '.ps1'),
    'Apps': ('.exe', '.apk', '.dmg', '.deb', '.rpm', '.msi', '.bin')
}
    
    class File_Organizer:
        def __init__(self, root):
            # Setting the Tkinter main window
            self.window = root
            self.window.geometry("720x500")
            self.window.title('File Organizer')
            self.window.resizable(width = False, height = False)
            self.window.configure(bg='#cccccc')
            self.selected_dir = ''
            self.browsed = False
            # Frame 1: For the Logo
            self.frame_1 = Frame(self.window,bg='gray90',
            width=280, height=70)
            self.frame_1.pack()
            self.frame_1.place(x=20, y=20)
            self.display_logo()
            # About Button
            About_Btn = Button(self.window, text="About", 
            font=("Kokila", 10, 'bold'), bg="dodger blue", 
            fg="white", width=5, command=self.about_window)
            About_Btn.place(x=600, y=20)
            # Exit Button
            Exit_Btn = Button(self.window, text="Exit", 
            font=("Kokila", 10, 'bold'), bg="dodger blue", 
            fg="white", width=5, command=self.exit_window)
            Exit_Btn.place(x=600, y=60)
            # Frame 2: For the Main Page Widgets
            self.frame_2 = Frame(self.window, bg="#cccccc",
            width=720,height=480)
            self.frame_2.place(x=0, y=110)
            self.main_window()
            
        def display_logo(self):
            image = Image.open('img/junk_logo.png')
            resized_image = image.resize((280, 70))
            self.logo = ImageTk.PhotoImage(resized_image)
            label = Label(self.frame_1, bg='gray90',image=self.logo)
            label.pack()
            
        def main_window(self):
            Heading_Label = Label(self.frame_2, 
            text="Please Select the Folder", 
            font=("Kokila", 20, 'bold'), bg='white')
            Heading_Label.place(x=160, y=20)
            Folder_Button = Button(self.frame_2, text="Select Folder", 
            font=("Kokila", 10, 'bold'), bg="gold", width=10, 
            command=self.select_directory)
            Folder_Button.place(x=130, y=80)
            self.Folder_Entry = Entry(self.frame_2, 
            font=("Helvetica", 12), width=32)
            self.Folder_Entry.place(x=256, y=85)
            Status = Label(self.frame_2, text="Status: ", 
            font=("Kokila", 12, 'bold'), bg='white')
            Status.place(x=180, y=130)
            # Status Label:
            self.Status_Label = Label(self.frame_2, text="Not Started Yet", 
            font=("Kokila", 12), bg="white", fg="red")
            self.Status_Label.place(x=256, y=130)
            Start_Button = Button(self.frame_2, text="Start", 
            font=("Kokila", 13, 'bold'), bg="dodger blue", fg="white", 
            width=8, command=self._threading)
            Start_Button.place(x=300, y=230)
            
        def select_directory(self):
            self.selected_dir = filedialog.askdirectory(title = 
            "Select a location")
            self.Folder_Entry.insert(0, self.selected_dir)
            self.selected_dir = str(self.selected_dir)
            # Checking if the folder path is exists or not
            if os.path.exists(self.selected_dir):
                self.browsed = True
                
        def _threading(self):
            self.x = Thread(target=self.organizer, daemon=True)
            self.x.start()
        
        def organizer(self):
            # If no directory is chosen
            if not self.browsed:
                messagebox.showwarning('No folders are choosen', 
                'Please Select a Folder First')
                return
            try:
                # Showing the current status of the operation
                self.Status_Label.config(text='Processing...')
                self.Current_Path = self.selected_dir
                if os.path.exists(self.Current_Path):
                # self.Folder_List1: stores all the folders that 
                # are already presented in the selected directory
                    self.Folder_List1 = []
                    # self.Folder_List2: stores newly created folders
                    self.Folder_List2 = []
                    self.flag = False
                    for folder, extensions in file_types.items():
                        self.folder_name = folder
                        self.folder_path = os.path.join(self.Current_Path, self.folder_name)
                        # Change the directory to the current 
                        # folder path that we've selected
                        os.chdir(self.Current_Path)
                        # If the folder is already present in that directory
                        if os.path.exists(self.folder_name):
                            self.Folder_List1.append(self.folder_name)
                        # If the folder is not present in that directory,
                        # then create a new folder
                        else:
                            self.Folder_List2.append(self.folder_name)
                            os.mkdir(self.folder_path)
                        
                        # Calling the 'file_finder' function to
                        # find a specific type of file (or extension)
                        # and change their old path to new path.
                        for item in self.file_finder(self.Current_Path, extensions):
                            self.Old_File_Path = os.path.join(self.Current_Path,item)
                            self.New_File_Path = os.path.join(self.folder_path,item)
                            # Moving each file to their new location
                            shutil.move(self.Old_File_Path, self.New_File_Path)
                            self.flag = True
                else:
                    messagebox.showerror('Error!','Please Enter a Valid Path!')
                # Checking if the files are separated or not
                # If `flag` is True: It means the program discovered
                # matching files and they have been organized.
                if self.flag:
                    self.Status_Label.config(text='Done!')
                    messagebox.showinfo('Done!', 'Operation Successful!')
                    self.reset()
                # If `flag` is False: It means the program didn't find
                # any matching files there; only empty folders are created.
                if not self.flag:
                    self.Status_Label.config(text='Complete!')
                    messagebox.showinfo('Done!', 
                    'Folders have been creatednNo Files were there to move')
                    self.reset()
            # If any error occurs
            except Exception as es:
                messagebox.showerror("Error!",f"Error due to {str(es)}")
        
        def file_finder(self, folder_path, file_extensions):
            self.files = []
            for file in os.listdir(folder_path):
                for extension in file_extensions:
                    if file.endswith(extension):
                        self.files.append(file)
            return self.files
            
        def reset(self):
            self.Status_Label.config(text='Not Started Yet')
            self.Folder_Entry.delete(0, END)
            self.selected_dir = ''
            
        def about_window(self):
            info_text = (
                "Developed by Tudor Marmureanu\n\n"
                "File types:\n"
                "Documents: .pdf, .doc, .xls, .xlsx, .txt, .csv, .xml, .zip, .docx, .DOCX, .odt, "
                ".ppt, .pptx, .rtf, .tex, .epub, .mobi\n\n"
                "Pictures: .jpg, .jpeg, .png, .JPG, .webp, .ico, .gif, .bmp, .tiff, .svg, .heic\n\n"
                "Videos: .mp4, .mkv, .3gp, .flv, .mpeg, .avi, .mov, .wmv, .mpg, .webm, .m4v\n\n"
                "Music: .mp3, .wav, .m4a, .webm, .flac, .aac, .ogg, .wma\n\n"
                "Programs: .py, .cpp, .c, .sh, .js, .htm, .html, .css, .java, .cs, .php, .rb, "
                ".swift, .go, .pl, .json, .xml, .sql, .bat, .cmd, .ps1\n\n"
                "Apps: .exe, .apk, .dmg, .deb, .rpm, .msi, .bin"
            )
            messagebox.showinfo("File Organizer", info_text)
        
        def exit_window(self):
            self.window.destroy()
            
    if __name__ == "__main__":
        rootjk = Tk()
        obj = File_Organizer(rootjk)
        rootjk.mainloop()
        
if wbpvar == 123456789:
# Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    from tkinter import *
    from tkinter import ttk
    import tkinter as tk
    from tkinter import filedialog
    import os

    rootwbp = Tk()
    rootwbp.title("Whiteboard Presentation")
    rootwbp.geometry("1050x600+150+50")
    rootwbp.config(bg="#f2f3f5")
    rootwbp.resizable(False, False)

    current_x = 0
    current_y = 0
    color = "black"

    def locate_xy(work):
        global current_x, current_y
        current_x = work.x
        current_y = work.y

    def addline(work):
        global current_x, current_y
        canvas.create_line((current_x, current_y, work.x, work.y), width=get_current_value(), fill=color, capstyle=ROUND, smooth=True)
        current_x, current_y = work.x, work.y

    def show_color(new_color):
        global color
        color = new_color
        
    def new_canvas():
        canvas.delete('all')
        display_palette()

    def insertimage():
        global filename, f_img
        filename = filedialog.askopenfilename(initialdir=os.getcwd(), title="Select image file", filetypes=(("PNG file", "*.png"), ("JPG file", "*.jpg"), ("JPEG file", "*.jpeg"), ("ICON file", "*.ico"), ("All files", "*.*")))
        f_img = tk.PhotoImage(file=filename)
        canvas.create_image(180, 50, image=f_img)
        rootwbp.bind("<B3-Motion>", my_callback)

    def my_callback(event):
        global f_img
        f_img = tk.PhotoImage(file=filename)
        canvas.create_image(event.x, event.y, image=f_img)

    image_icon = PhotoImage(file="img/paintpalette.png")
    rootwbp.iconphoto(False, image_icon)

    eraser = PhotoImage(file="img/eraser.png")
    Button(rootwbp, image=eraser, bg="#f2f3f5", command=new_canvas).place(x=30, y=400)

    importimage = PhotoImage(file="img/insert_picture_icon.png")
    Button(rootwbp, image=importimage, bg="white", command=insertimage).place(x=30, y=450)

    colors = Canvas(rootwbp, bg="#fff", width=37, height=305, bd=0)
    colors.place(x=30, y=60)

    def display_palette():
        color_values = ["black", "gray", "red", "orange", "yellow", "green", "blue", "purple", "#9900ff", "cyan"]
        for i, color_value in enumerate(color_values):
            id = colors.create_rectangle((10, 10 + i * 30, 30, 30 + i * 30), fill=color_value)
            colors.tag_bind(id, '<Button-1>', lambda x, c=color_value: show_color(c))

    display_palette()

    # Frame pentru a conține canvasul și scrollbarul vertical
    canvas_frame = Frame(rootwbp, bd=2, relief=RIDGE)
    canvas_frame.place(x=100, y=10, width=930, height=470)  # Înălțime redusă pentru a face loc scrollbar-ului orizontal

    # Canvas-ul principal
    canvas = Canvas(canvas_frame, background="white", cursor="hand2", scrollregion=(0, 0, 2000, 2000))
    canvas.pack(side=LEFT, fill=BOTH, expand=True)

    # Scrollbar vertical
    v_scroll = Scrollbar(canvas_frame, orient=VERTICAL, command=canvas.yview)
    v_scroll.pack(side=RIGHT, fill=Y)
    canvas.config(yscrollcommand=v_scroll.set)

    # Scrollbar orizontal poziționat sub fereastra albă
    h_scroll = Scrollbar(rootwbp, orient=HORIZONTAL, command=canvas.xview)
    h_scroll.place(x=100, y=480, width=930)  # Poziționat sub fereastra albă
    canvas.config(xscrollcommand=h_scroll.set)

    canvas.bind('<Button-1>', locate_xy)
    canvas.bind('<B1-Motion>', addline)

    # Slider pentru dimensiunea liniei mutat jos
    current_value = tk.DoubleVar()
    def get_current_value():
        return '{:.2f}'.format(current_value.get())

    def slider_changed(event=None):
        value_label.configure(text=get_current_value())

    slider = ttk.Scale(rootwbp, from_=0, to=100, orient="horizontal", variable=current_value, command=slider_changed)
    slider.place(x=450, y=550)  # Mutat la coordonatele de jos

    value_label = ttk.Label(rootwbp, text=get_current_value())
    value_label.place(x=600, y=550)  # Mutat lângă slider, în partea de jos

    rootwbp.mainloop()

if cmvar == 3333:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    import sqlite3
    from tkinter import *
    import tkinter.ttk as ttk
    import tkinter.messagebox as tkMessageBox

    # ============================ SETUP ======================================
    rootcm = Tk()
    rootcm.title("Contact List")
    width = 700
    height = 600
    screen_width = rootcm.winfo_screenwidth()
    screen_height = rootcm.winfo_screenheight()
    x = (screen_width / 2) - (width / 2)
    y = (screen_height / 2) - (height / 2)
    rootcm.geometry(f"{width}x{height}+{int(x)}+{int(y)}")
    rootcm.resizable(0, 0)
    rootcm.config(bg="gray40")

    # ============================ VARIABLES ==================================
    NAME = StringVar()
    SURNAME = StringVar()
    EMAIL = StringVar()
    POSITION = StringVar()
    PHONE = StringVar()
    DETAILS = StringVar()

    # ============================ DATABASE ===================================
    def update_database_schema():
        conn = sqlite3.connect("contacts.db")
        cursor = conn.cursor()
        columns = {
            'surname': 'TEXT',
            'email': 'TEXT',
            'position': 'TEXT',
            'phone': 'TEXT',
            'details': 'TEXT'
        }
        for column, datatype in columns.items():
            try:
                cursor.execute(f"ALTER TABLE `member` ADD COLUMN `{column}` {datatype}")
            except sqlite3.OperationalError:
                pass  # Coloana există deja

        conn.commit()
        cursor.close()
        conn.close()

    update_database_schema()

    def Database():
        conn = sqlite3.connect("contacts.db")
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS `member` (
                mem_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                surname TEXT,
                email TEXT,
                position TEXT,
                phone TEXT,
                details TEXT
            )
        """)
        cursor.execute("SELECT * FROM `member` ORDER BY `surname` ASC")
        fetch = cursor.fetchall()
        for data in fetch:
            tree.insert('', 'end', values=(data))
        cursor.close()
        conn.close()

    # ============================ METHODS ====================================
    def SubmitData():
        if all([NAME.get(), SURNAME.get(), EMAIL.get(), POSITION.get(), PHONE.get(), DETAILS.get()]):
            tree.delete(*tree.get_children())
            conn = sqlite3.connect("contacts.db")
            cursor = conn.cursor()
            cursor.execute("INSERT INTO `member` (name, surname, email, position, phone, details) VALUES (?, ?, ?, ?, ?, ?)", 
                        (NAME.get(), SURNAME.get(), EMAIL.get(), POSITION.get(), PHONE.get(), DETAILS.get()))
            conn.commit()
            cursor.execute("SELECT * FROM `member` ORDER BY `surname` ASC")
            fetch = cursor.fetchall()
            for data in fetch:
                tree.insert('', 'end', values=(data))
            cursor.close()
            conn.close()
            NAME.set("")
            SURNAME.set("")
            EMAIL.set("")
            POSITION.set("")
            PHONE.set("")
            DETAILS.set("")
        else:
            tkMessageBox.showwarning('', 'Please Complete The Required Field', icon="warning")

    def UpdateData():
        if EMAIL.get():
            tree.delete(*tree.get_children())
            conn = sqlite3.connect("contacts.db")
            cursor = conn.cursor()
            cursor.execute("UPDATE `member` SET `name` = ?, `surname` = ?, `email` = ?, `position` = ?, `phone` = ?, `details` = ? WHERE `mem_id` = ?",
                        (NAME.get(), SURNAME.get(), EMAIL.get(), POSITION.get(), PHONE.get(), DETAILS.get(), mem_id))
            conn.commit()
            cursor.execute("SELECT * FROM `member` ORDER BY `surname` ASC")
            fetch = cursor.fetchall()
            for data in fetch:
                tree.insert('', 'end', values=(data))
            cursor.close()
            conn.close()
            NAME.set("")
            SURNAME.set("")
            EMAIL.set("")
            POSITION.set("")
            PHONE.set("")
            DETAILS.set("")
        else:
            tkMessageBox.showwarning('', 'Please Complete The Required Field', icon="warning")

    def OnSelected(event):
        global mem_id, UpdateWindow
        curItem = tree.focus()
        contents = (tree.item(curItem))
        selecteditem = contents['values']
        mem_id = selecteditem[0]
        NAME.set(selecteditem[1])
        SURNAME.set(selecteditem[2])
        EMAIL.set(selecteditem[3])
        POSITION.set(selecteditem[4])
        PHONE.set(selecteditem[5])
        DETAILS.set(selecteditem[6])
        
        UpdateWindow = Toplevel()
        UpdateWindow.title("Update Contact")
        width = 400
        height = 300
        x = (screen_width / 2 + 450) - (width / 2)
        y = (screen_height / 2 + 20) - (height / 2)
        #UpdateWindow.resizable(0, 0)
        UpdateWindow.geometry(f"{width}x{height}+{int(x)}+{int(y)}")

        if 'NewWindow' in globals():
            NewWindow.destroy()

        # Frames and Labels for Update Window
        FormTitle = Frame(UpdateWindow)
        FormTitle.pack(side=TOP)
        ContactForm = Frame(UpdateWindow)
        ContactForm.pack(side=TOP, pady=10)
        
        lbl_title = Label(FormTitle, text="Updating Contacts", font=('arial', 16), bg="orange", width=300)
        lbl_title.pack(fill=X)

        labels = ["Name", "Surname", "Email", "Job Title", "Phone", "Other Details"]
        for idx, label in enumerate(labels):
            Label(ContactForm, text=label, font=('arial', 14), bd=5).grid(row=idx, sticky=W)
            Entry(ContactForm, textvariable=[NAME, SURNAME, EMAIL, POSITION, PHONE, DETAILS][idx], font=('arial', 14)).grid(row=idx, column=1)

        Button(ContactForm, text="Update", width=50, command=UpdateData).grid(row=6, columnspan=2, pady=10)

    def DeleteData():
        if tree.selection():
            result = tkMessageBox.askquestion('', 'Are you sure you want to delete this record?', icon="warning")
            if result == 'yes':
                curItem = tree.focus()
                contents = (tree.item(curItem))
                selecteditem = contents['values']
                tree.delete(curItem)
                conn = sqlite3.connect("contacts.db")
                cursor = conn.cursor()
                cursor.execute("DELETE FROM `member` WHERE `mem_id` = ?", (selecteditem[0],))
                conn.commit()
                cursor.close()
                conn.close()
        else:
            tkMessageBox.showwarning('', 'Please Select Something First!', icon="warning")

    def AddNewWindow():
        global NewWindow
        for var in [NAME, SURNAME, EMAIL, POSITION, PHONE, DETAILS]:
            var.set("")
            
        NewWindow = Toplevel()
        NewWindow.title("Add New Contact")
        width = 400
        height = 300
        x = (screen_width / 2 - 455) - (width / 2)
        y = (screen_height / 2 + 20) - (height / 2)
        #NewWindow.resizable(0, 0)
        NewWindow.geometry(f"{width}x{height}+{int(x)}+{int(y)}")

        if 'UpdateWindow' in globals():
            UpdateWindow.destroy()
        
        # Frames and Labels for Add Window
        FormTitle = Frame(NewWindow)
        FormTitle.pack(side=TOP)
        ContactForm = Frame(NewWindow)
        ContactForm.pack(side=TOP, pady=10)
        
        lbl_title = Label(FormTitle, text="Adding New Contacts", font=('arial', 16), bg="orange", width=300)
        lbl_title.pack(fill=X)

        labels = ["Name", "Surname", "Email", "Position", "Phone", "Other Details"]
        for idx, label in enumerate(labels):
            Label(ContactForm, text=label, font=('arial', 14), bd=5).grid(row=idx, sticky=W)
            Entry(ContactForm, textvariable=[NAME, SURNAME, EMAIL, POSITION, PHONE, DETAILS][idx], font=('arial', 14)).grid(row=idx, column=1)

        Button(ContactForm, text="Save", width=50, command=SubmitData).grid(row=6, columnspan=2, pady=10)

    # ============================ GUI ELEMENTS =================================
    Top = Frame(rootcm, width=500, bd=1, relief=SOLID)
    Top.pack(side=TOP)
    Mid = Frame(rootcm, width=500, bg="gray40")
    Mid.pack(side=TOP)
    MidLeft = Frame(Mid, width=100)
    MidLeft.pack(side=LEFT, pady=10)
    MidLeftPadding = Frame(Mid, width=370, bg="gray40")
    MidLeftPadding.pack(side=LEFT)
    MidRight = Frame(Mid, width=100)
    MidRight.pack(side=RIGHT, pady=10)
    TableMargin = Frame(rootcm, width=500)
    TableMargin.pack(side=TOP)

    lbl_title = Label(Top, text="Contact Management System", font=('arial', 16), bg="gray", width=500)
    lbl_title.pack(fill=X)

    btn_add = Button(MidLeft, text="+ ADD NEW", bg="lightgreen", command=AddNewWindow)
    btn_add.pack()

    btn_delete = Button(MidRight, text="DELETE", bg="red", command=DeleteData)
    btn_delete.pack()

    # Scrollbar and Treeview
    scrollbarx = Scrollbar(TableMargin, orient=HORIZONTAL)
    scrollbary = Scrollbar(TableMargin, orient=VERTICAL)

    tree = ttk.Treeview(TableMargin, columns=("MemberID", "Name", "Surname", "Email", "Position", "Phone", "Details"),
                        height=400, selectmode="extended", yscrollcommand=scrollbary.set, xscrollcommand=scrollbarx.set)
    scrollbary.config(command=tree.yview)
    scrollbary.pack(side=RIGHT, fill=Y)
    scrollbarx.config(command=tree.xview)
    scrollbarx.pack(side=BOTTOM, fill=X)

    tree.heading('MemberID', text="MemberID", anchor=W)
    tree.heading('Name', text="Name", anchor=W)
    tree.heading('Surname', text="Surname", anchor=W)
    tree.heading('Email', text="Email", anchor=W)
    tree.heading('Position', text="Position", anchor=W)
    tree.heading('Phone', text="Phone", anchor=W)
    tree.heading('Details', text="Other Details", anchor=W)

    tree.column('#0', stretch=NO, minwidth=0, width=0)
    tree.column('#1', stretch=NO, minwidth=0, width=80)
    tree.column('#2', stretch=NO, minwidth=0, width=120)
    tree.column('#3', stretch=NO, minwidth=0, width=120)
    tree.column('#4', stretch=NO, minwidth=0, width=120)
    tree.column('#5', stretch=NO, minwidth=0, width=120)
    tree.column('#6', stretch=NO, minwidth=0, width=120)
    tree.column('#7', stretch=NO, minwidth=0, width=150)

    tree.pack()
    tree.bind('<Double-Button-1>', OnSelected)

    # ============================ INITIALIZATION =============================
    if __name__ == '__main__':
        Database()
        rootcm.mainloop()

if pingalivevar == 5566:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    import tkinter as tk
    import subprocess
    import threading
    import time
    import os
    import json
    from queue import Queue
    from tkinter import filedialog, simpledialog, messagebox

    class PingWorker(threading.Thread):
        def __init__(self, ip, queue):
            super().__init__()
            self.ip = ip
            self.queue = queue

        def run(self):
            try:
                response = subprocess.run(['ping', '-n', '1', self.ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=2)
                status = "Online" if "TTL=" in response.stdout.decode('utf-8') else "Offline"
            except subprocess.TimeoutExpired:
                status = "Offline"
            except Exception as e:
                status = "Error"
            self.queue.put((self.ip, status))

    class PingApp:
        def __init__(self, rootSA):
            self.rootSA = rootSA
            self.rootSA.title("Listener - Device Checking")
            self.rootSA.geometry("1000x600")
            self.rootSA.config(bg="gray40")  # #cccccc
            
            self.search_label = tk.Label(rootSA, font=("Arial", 12, "bold"), text="Search:", fg="#ccff66", bg="gray40")
            self.search_label.pack(pady=5)
            
            self.search_entry = tk.Entry(rootSA, fg="cyan", bg="#333333", bd=4, insertbackground="#ccff66")
            self.search_entry.pack(pady=5)
            
            self.search_button = tk.Button(rootSA, text="Filter", fg="cyan", bg="gray20", bd=6, command=self.update_labels)
            self.search_button.pack(pady=5)
            
            # Canvas pentru scroll
            self.canvas = tk.Canvas(rootSA)
            self.canvas.config(bg="#cccccc")
            self.scroll_y = tk.Scrollbar(rootSA, orient="vertical", command=self.canvas.yview)
            self.scroll_y.pack(side="right", fill="y")
            self.canvas.pack(side="left", fill="both", expand=True)
            
            # Frame pentru conținutul scrollabil
            self.frame = tk.Frame(self.canvas)
            self.frame.config(bg="#cccccc")
            self.canvas.create_window((0, 0), window=self.frame, anchor='nw')
            self.frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
            self.canvas.configure(yscrollcommand=self.scroll_y.set)
            
            # Bind mousewheel event
            self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
            
            self.results = {"groups": []}
            self.queue = Queue()
            
            if not os.path.exists("Results_IP"):
                os.makedirs("Results_IP")
            
            self.update_interval = 10
            self.schedule_update()
            
            self.create_menu()
            
            # Load the JSON file if it exists
            #self.load_initial_json()
        
        def _on_mousewheel(self, event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        '''
        def load_initial_json(self):
            json_file_path = "cantare.json"
            if os.path.exists(json_file_path):
                with open(json_file_path, 'r', encoding='utf-8') as file:
                    data = json.load(file)
                    self.results = {"groups": []}
                    for group in data.get("groups", []):
                        group_name = group.get("name")
                        ips = group.get("ips", {})
                        if group_name and ips:
                            self.results["groups"].append({
                                "name": group_name,
                                "ips": {ip: "Unknown" for ip in ips}
                            })
                    self.update_labels()
            else:
                print(f"{json_file_path} not found.")
        '''
        
        def create_menu(self):
            menu = tk.Menu(self.rootSA)
            #menu.config(bg="gray40")
            self.rootSA.config(menu=menu)
            
            file_menu = tk.Menu(menu, tearoff=0)
            menu.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="Open JSON", command=self.open_json)
            file_menu.add_command(label="Create JSON", command=self.create_json)
            file_menu.add_command(label="Edit JSON", command=self.open_edit_json)

        def open_json(self):
            file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
            if file_path:
                with open(file_path, 'r', encoding='utf-8') as file:
                    data = json.load(file)
                    self.results = {"groups": []}
                    for group in data.get("groups", []):
                        group_name = group.get("name")
                        ips = group.get("ips", [])
                        if group_name and ips:
                            self.results["groups"].append({
                                "name": group_name,
                                "ips": {ip: "Unknown" for ip in ips}
                            })
                    self.update_labels()
        
        def create_json(self):
            num_groups = simpledialog.askinteger("Create JSON", "Enter the number of groups:")
            if num_groups and num_groups > 0:
                groups = []
                for i in range(num_groups):
                    group_name = simpledialog.askstring("Create JSON", f"Enter the name of group {i+1}:")
                    ips_input = simpledialog.askstring("Create JSON", f"Enter IP addresses for group '{group_name}' separated by commas:")
                    if group_name and ips_input:
                        ips = [ip.strip() for ip in ips_input.split(',') if ip.strip()]
                        if ips:
                            groups.append({
                                "name": group_name,
                                "ips": {ip: "Unknown" for ip in ips}  # Convertim lista în dicționar
                            })
                if groups:
                    data = {
                        "groups": groups
                    }
                    file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
                    if file_path:
                        with open(file_path, 'w', encoding='utf-8') as file:
                            json.dump(data, file, indent=4)
                    self.results = {"groups": groups}
                    self.update_labels()

        def open_edit_json(self):
            self.edit_window = tk.Toplevel(self.rootSA)
            self.edit_window.title("Edit JSON")
            self.edit_window.geometry("800x400")
            self.edit_window.config(bg="gray40")
            
            self.json_text = tk.Text(self.edit_window, wrap='word', undo=True, bg="black", fg="cyan", bd=6, insertbackground="#ccff66")
            self.json_text.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Button to load JSON content
            load_button = tk.Button(self.edit_window, text="Load JSON", command=self.load_json, bg="gray40", fg="#ccff66", bd=4)
            load_button.pack(side='left', padx=10, pady=5)
            
            # Button to save JSON content
            save_button = tk.Button(self.edit_window, text="Save JSON", command=self.save_json, bg="gray40", fg="#ccff66", bd=4)
            save_button.pack(side='left', padx=10, pady=5)
            
            # Button to close the edit window
            close_button = tk.Button(self.edit_window, text="Close", command=self.edit_window.destroy, bg="gray40", fg="red", bd=4)
            close_button.pack(side='right', padx=10, pady=5)
        
        def load_json(self):
            file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
            if file_path:
                with open(file_path, 'r', encoding='utf-8') as file:
                    json_content = file.read()
                    self.json_text.delete(1.0, tk.END)
                    self.json_text.insert(tk.END, json_content)
        
        def save_json(self):
            try:
                json_content = self.json_text.get(1.0, tk.END)
                data = json.loads(json_content)  # Validate JSON
                file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
                if file_path:
                    with open(file_path, 'w', encoding='utf-8') as file:
                        file.write(json.dumps(data, indent=4))
                    messagebox.showinfo("Success", "JSON saved successfully!")
            except json.JSONDecodeError:
                messagebox.showerror("Error", "Invalid JSON format. Please check your JSON content.")

        def schedule_update(self):
            threading.Thread(target=self.update_results, daemon=True).start()
            self.rootSA.after(self.update_interval * 1000, self.schedule_update)
        
        def update_results(self):
            try:
                ips = [ip for group in self.results.get("groups", []) for ip in group.get("ips", {}).keys()]
                
                self.results = {"groups": [{ "name": group["name"], "ips": {ip: "Unknown" for ip in group["ips"].keys()}} for group in self.results.get("groups", [])]}
                
                ips.sort()
                
                threads = []
                for ip in ips:
                    worker = PingWorker(ip, self.queue)
                    worker.start()
                    threads.append(worker)
                
                for thread in threads:
                    thread.join()
                
                while not self.queue.empty():
                    ip, status = self.queue.get()
                    for group in self.results.get("groups", []):
                        if ip in group["ips"]:
                            group["ips"][ip] = status
                
                timestamp = time.strftime('%Y%m%d-%H%M%S')
                result_file = f"Results_IP/Scann_{timestamp}.json"
                
                with open(result_file, 'w', encoding='utf-8') as output_file:
                    json.dump({
                        "timestamp": time.strftime('%H:%M:%S'),
                        "results": self.results
                    }, output_file, indent=4)
                        
                self.rootSA.after(0, self.update_labels)
                
                if not os.path.exists('Results'):
                    os.makedirs('Results')
                
                timestamp = time.strftime('%Y%m%d-%H%M%S')
                result_file = f"Results_IP/Scann_{timestamp}.json"
                
                with open(result_file, 'w', encoding='utf-8') as output_file:
                    json.dump({
                        "timestamp": time.strftime('%H:%M:%S'),
                        "results": self.results
                    }, output_file, indent=4)
                        
                self.rootSA.after(0, self.update_labels)
            
            except Exception as e:
                print(f"Error: {str(e)}")
        
        def update_labels(self):
            for widget in self.frame.winfo_children():
                widget.destroy()

            search_term = self.search_entry.get().strip().lower()

            max_groups_per_column = 30  # Numărul maxim de grupuri per coloană
            row = 0
            col = 0
            groups_displayed = 0  # Numără grupurile afișate în coloană
            column_spacing = 50  # Spațiul între coloane

            # Afișează grupurile și IP-urile aferente
            for group in self.results.get("groups", []):
                group_name = group.get("name")
                ips = group.get("ips", {})

                # Filtrare IP-uri pe baza termenului de căutare
                filtered_ips = {ip: status for ip, status in ips.items() if search_term in ip}

                if filtered_ips:  # Afișează grupul doar dacă are IP-uri care se potrivesc căutării
                    if groups_displayed >= max_groups_per_column:
                        groups_displayed = 0
                        row = 0
                        col += 2  # Treci la următoarea pereche de coloane

                    tk.Label(self.frame, text=f"Group: {group_name}", font=('Arial', 12, 'bold')).grid(row=row, column=col, columnspan=2, padx=(column_spacing, 20), pady=10, sticky="w")
                    row += 1

                    for ip, status in filtered_ips.items():
                        color = 'green' if status == "Online" else 'red'

                        ip_label = tk.Label(self.frame, text=ip, bg='white', borderwidth=1, relief="solid", padx=5, pady=2)
                        ip_label.grid(row=row, column=col, padx=(column_spacing, 5), pady=2, sticky="w")

                        status_label = tk.Label(self.frame, text=status, bg=color, fg='white', borderwidth=1, relief="solid", padx=5, pady=2)
                        status_label.grid(row=row, column=col + 1, padx=(5, 20), pady=2, sticky="w")

                        row += 1

                    groups_displayed += 1

                    # Reinițializare rând la finalul grupului
                    if row >= max_groups_per_column:
                        row = 0
                        col += 2
                        groups_displayed = 0

    if __name__ == "__main__":
        rootSA = tk.Tk()
        app = PingApp(rootSA)
        rootSA.mainloop()
        
if launchervar == 1990:
    class MultiAppLauncher(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("Multiapp Launcher")
            self.geometry("600x450")
            self.resizable(False, False)
            self.config(bg="#1a1a1a")

            self.processes = []

            # Adăugare Label pentru a lansa aplicațiile
            self.label = tk.Label(self, text="Launch multiple instances of Multiapp.exe", fg="#c2c2d6", bg="#1a1a1a")
            self.label.pack(pady=10)

            self.launch_button = tk.Button(self, text="Launch Applications", fg="#ccff66", bg="#333333", bd=5, command=self.launch_apps)
            self.launch_button.pack(pady=10)

            self.instances_label = tk.Label(self, text="Number of instances:", fg="#c2c2d6", bg="#1a1a1a")
            self.instances_label.pack(pady=5)

            self.instances_entry = tk.Entry(self, fg="#ccff66", bg="#404040", insertbackground="#ccff66")
            self.instances_entry.pack(pady=5)

            self.stop_button = tk.Button(self, text="Stop Applications", fg="#ff6666", bg="#333333", bd=5, command=self.stop_apps)
            self.stop_button.pack(pady=10)

            # Cadru principal pentru conturi cu scrollbar
            self.accounts_canvas = tk.Canvas(self, bg="#1a1a1a")
            self.accounts_frame = tk.Frame(self.accounts_canvas, bg="#1a1a1a")
            self.scrollbar = tk.Scrollbar(self, orient="vertical", command=self.accounts_canvas.yview)
            self.accounts_canvas.configure(yscrollcommand=self.scrollbar.set)

            self.scrollbar.pack(side="right", fill="y")
            self.accounts_canvas.pack(side="left", fill="both", expand=True)
            self.accounts_canvas.create_window((0, 0), window=self.accounts_frame, anchor="nw")

            self.accounts_frame.bind("<Configure>", self.on_frame_configure)

            # Creează cadrele separate pentru conturi
            self.frame_no_key = tk.LabelFrame(self.accounts_frame, text="Accounts without Product Key", fg="#ccff66", bg="#1a1a1a", bd=5, padx=10, pady=10)
            self.frame_with_key = tk.LabelFrame(self.accounts_frame, text="Accounts with Product Key", fg="#ff6666", bg="#1a1a1a", bd=5, padx=10, pady=10)

            self.frame_no_key.pack(pady=10, fill=tk.BOTH, expand=True)
            self.frame_with_key.pack(pady=10, fill=tk.BOTH, expand=True)

            # Citește și afișează conturile
            self.load_accounts()

        def launch_apps(self):
            try:
                multiapp_path = os.path.join(os.getcwd(), "Multiapp.exe")

                if not os.path.exists(multiapp_path):
                    raise FileNotFoundError("Multiapp.exe not found in the current directory.")

                num_instances = int(self.instances_entry.get())
                if num_instances <= 0:
                    raise ValueError("The number must be positive")

                for _ in range(num_instances):
                    process = subprocess.Popen([multiapp_path], cwd=os.getcwd())
                    self.processes.append(process)

                messagebox.showinfo("Success", f"{num_instances} instances have been launched.")
            except FileNotFoundError as fnf_error:
                messagebox.showerror("Error", fnf_error)
            except ValueError as ve:
                messagebox.showerror("Error", f"Invalid value: {ve}")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")

        def stop_apps(self):
            try:
                for proc in psutil.process_iter(['pid', 'name']):
                    if proc.info['name'] == 'Multiapp.exe':
                        proc.terminate()
                        proc.wait()

                self.processes = []
                messagebox.showinfo("Stopped", "All instances of Multiapp.exe have been stopped.")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to stop processes: {e}")

        def load_accounts(self):
            try:
                with open("Accounts.txt", "r") as file:
                    lines = file.readlines()

                # Variabile pentru organizarea layout-ului
                row_no_key = 0
                col_no_key = 0
                row_with_key = 0
                col_with_key = 0

                for line in lines:
                    line = line.strip()
                    if line and '|' not in line and not line.startswith('---'):
                        user_info, password = line.split()[:2]
                        
                        if "product_key" in line:
                            account_label = tk.Label(self.frame_with_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_with_key, column=col_with_key, padx=10, pady=10)
                            col_with_key += 1
                            if col_with_key == 3:
                                col_with_key = 0
                                row_with_key += 1
                        else:
                            account_label = tk.Label(self.frame_no_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_no_key, column=col_no_key, padx=10, pady=10)
                            col_no_key += 1
                            if col_no_key == 3:
                                col_no_key = 0
                                row_no_key += 1

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load accounts: {e}")

        def copy_to_clipboard(self, password):
            self.clipboard_clear()
            self.clipboard_append(password)
            self.update()  # Este necesar pentru ca clipboard-ul să fie actualizat imediat
            messagebox.showinfo("Success", "Password copied to clipboard!")

        def on_frame_configure(self, event):
            """Reconfigurează scroll-ul pentru canvas."""
            self.accounts_canvas.configure(scrollregion=self.accounts_canvas.bbox("all"))

    if __name__ == "__main__":
        appL = MultiAppLauncher()
        appL.mainloop()

if launchervar_admin == 1991:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    class MultiAppLauncher(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("Multiapp Admin Launcher")
            self.geometry("600x450")
            self.resizable(False, False)
            self.config(bg="#1a1a1a")

            self.processes = []

            # Adăugare Label pentru a lansa aplicațiile
            self.label = tk.Label(self, text="Launch multiple instances of Multiapp.exe", fg="#c2c2d6", bg="#1a1a1a")
            self.label.pack(pady=10)

            self.launch_button = tk.Button(self, text="Launch Applications", fg="#ccff66", bg="#333333", bd=5, command=self.launch_apps)
            self.launch_button.pack(pady=10)

            self.instances_label = tk.Label(self, text="Number of instances:", fg="#c2c2d6", bg="#1a1a1a")
            self.instances_label.pack(pady=5)

            self.instances_entry = tk.Entry(self, fg="#ccff66", bg="#404040", insertbackground="#ccff66")
            self.instances_entry.pack(pady=5)

            self.stop_button = tk.Button(self, text="Stop Applications", fg="#ff6666", bg="#333333", bd=5, command=self.stop_apps)
            self.stop_button.pack(pady=10)

            # Cadru principal pentru conturi cu scrollbar
            self.accounts_canvas = tk.Canvas(self, bg="#1a1a1a")
            self.accounts_frame = tk.Frame(self.accounts_canvas, bg="#1a1a1a")
            self.scrollbar = tk.Scrollbar(self, orient="vertical", command=self.accounts_canvas.yview)
            self.accounts_canvas.configure(yscrollcommand=self.scrollbar.set)

            self.scrollbar.pack(side="right", fill="y")
            self.accounts_canvas.pack(side="left", fill="both", expand=True)
            self.accounts_canvas.create_window((0, 0), window=self.accounts_frame, anchor="nw")

            self.accounts_frame.bind("<Configure>", self.on_frame_configure)

            # Creează cadrele separate pentru conturi
            self.frame_no_key = tk.LabelFrame(self.accounts_frame, text="Accounts without Product Key", fg="#ccff66", bg="#1a1a1a", bd=5, padx=10, pady=10)
            self.frame_with_key = tk.LabelFrame(self.accounts_frame, text="Accounts with Product Key", fg="#ff6666", bg="#1a1a1a", bd=5, padx=10, pady=10)

            self.frame_no_key.pack(pady=10, fill=tk.BOTH, expand=True)
            self.frame_with_key.pack(pady=10, fill=tk.BOTH, expand=True)

            # Citește și afișează conturile
            self.load_accounts()

        def launch_apps(self):
            try:
                multiapp_path = os.path.join(os.getcwd(), "Multiapp.exe")

                if not os.path.exists(multiapp_path):
                    raise FileNotFoundError("Multiapp.exe not found in the current directory.")

                num_instances = int(self.instances_entry.get())
                if num_instances <= 0:
                    raise ValueError("The number must be positive")

                for _ in range(num_instances):
                    process = subprocess.Popen([multiapp_path], cwd=os.getcwd())
                    self.processes.append(process)

                messagebox.showinfo("Success", f"{num_instances} instances have been launched.")
            except FileNotFoundError as fnf_error:
                messagebox.showerror("Error", fnf_error)
            except ValueError as ve:
                messagebox.showerror("Error", f"Invalid value: {ve}")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")

        def stop_apps(self):
            try:
                for proc in psutil.process_iter(['pid', 'name']):
                    if proc.info['name'] == 'Multiapp.exe':
                        proc.terminate()
                        proc.wait()

                self.processes = []
                messagebox.showinfo("Stopped", "All instances of Multiapp.exe have been stopped.")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to stop processes: {e}")

        def load_accounts(self):
            self.create_accounts_file()
            try:
                with open("Accounts.txt", "r") as file:
                    lines = file.readlines()

                # Variabile pentru organizarea layout-ului
                row_no_key = 0
                col_no_key = 0
                row_with_key = 0
                col_with_key = 0

                for line in lines:
                    line = line.strip()
                    if line and '|' not in line and not line.startswith('---'):
                        user_info, password = line.split()[:2]
                        
                        if "product_key" in line:
                            account_label = tk.Label(self.frame_with_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_with_key, column=col_with_key, padx=10, pady=10)
                            col_with_key += 1
                            if col_with_key == 3:
                                col_with_key = 0
                                row_with_key += 1
                        else:
                            account_label = tk.Label(self.frame_no_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_no_key, column=col_no_key, padx=10, pady=10)
                            col_no_key += 1
                            if col_no_key == 3:
                                col_no_key = 0
                                row_no_key += 1

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load accounts: {e}")

        def copy_to_clipboard(self, password):
            self.clipboard_clear()
            self.clipboard_append(password)
            self.update()  # Este necesar pentru ca clipboard-ul să fie actualizat imediat
            messagebox.showinfo("Success", "Password copied to clipboard!")

        def on_frame_configure(self, event):
            """Reconfigurează scroll-ul pentru canvas."""
            self.accounts_canvas.configure(scrollregion=self.accounts_canvas.bbox("all"))
        
        def create_accounts_file(self):
            installation_directory = os.getcwd()
            if not installation_directory:
                return
            
            accounts_file_path = os.path.join(installation_directory, "Accounts.txt")
            
            accounts_data = """|___user___|            |___password___|

    user            nopass
    it              copy (+- product_key)
    passgen         passgen
    quiz            test
    quizmaker       quizmaker
    pausemanager    pauze (+- product_key)
    taskmanager     terminator
    launcher        launcher
    hardware        lite
    eventviewer     eventviewer

    --------------------------------------------
    terminal        terminal (+ product_key)
    passgenV2     	passgenV2 (+ product_key)
    system         	realtime (+ product_key)
    screenrec      	screenrec (+ product_key)
    zipmanager     	zipmngr (+ product_key)
    comparator     	comparator (+ product_key)
    convertorpdf   	toword (+ product_key)
    textreplace    	textfind (+ product_key)
    pdftools      	enjoyit (+ product_key)
    bandmonitoring 	networking (+ product_key)
    cryptoV2      	securitate (+ product_key)
    chatbot        	aichatbot (+ product_key)
    notepad        	notepad (+ product_key)
    paint          	paint (+ product_key)
    zippass        	wordsmith (+ product_key)
    backupmanager   	backupmngr (+ product_key)
    renamemanager  	renamer (+ product_key)
    kbmanager      	knowladgebase (+ product_key)
    kbretro         kbretro (+ product_key)
    password       	manager (+ product_key)
    junk           	manager (+ product_key)
    whiteboard     	presentation (+ product_key)
    contact        	manager (+ product_key)
    check          	devices (+ product_key)
    excel           lite (+ product_key)
    reader          office (+ product_key)
    fetcher         repair (+ product_key)
    shell           integrator (+ product_key)
    tudor           fosfataza (+ product_key)
    ide             pycharm (+ product_key)
    tudor           fosfatazaaa (+ product_key)
    tudor           adminlauncher (+ product_key)
    tudor           vnc (+ product_key)
    tudor           assembly (+ product_key)
    sql             editor (+ product_key)
    diagram         canvas (+ product_key)
    tudor           explorer (+ product_key)
    commander		total (+ product_key)
    calendar        calendar (+ product_key)
    alert           monitor (+ product_key)
        """

            with open(accounts_file_path, "w") as accounts_file:
                accounts_file.write(accounts_data.strip())  # Scrie datele în fișier

    if __name__ == "__main__":
        appLA = MultiAppLauncher()
        appLA.mainloop()

if excelvar == 1992:
    import sys
    import subprocess
    import re
    import math
    from PyQt5.QtWidgets import QInputDialog, QApplication, QMainWindow, QTabWidget, QTableView, QFileDialog, QAction, QMenuBar, QMessageBox, QLineEdit, QVBoxLayout, QWidget, QDialog, QVBoxLayout, QTextEdit, QPushButton
    from PyQt5.QtCore import QAbstractTableModel, Qt, QModelIndex
    from openpyxl import load_workbook, Workbook
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class ExcelTableModel(QAbstractTableModel):
        def __init__(self, data, total_rows, total_columns):
            super().__init__()
            self._data = data
            self.total_rows = total_rows
            #self.total_columns = total_columns
            self.total_columns = min(total_columns, 26)

        def rowCount(self, parent=QModelIndex()):
            return self.total_rows

        def columnCount(self, parent=QModelIndex()):
            return self.total_columns

        def data(self, index, role=Qt.DisplayRole):
            if role == Qt.DisplayRole:
                if index.row() < len(self._data) and index.column() < len(self._data[index.row()]):
                    value = self._data[index.row()][index.column()]
                    if isinstance(value, str) and value.startswith('='):
                        return self.evaluate_formula(value)  # Evaluate the formula for display
                    return value if value is not None else ""
                return ""
            elif role == Qt.EditRole:
                return self._data[index.row()][index.column()]  # Return the raw data for editing
            
        def headerData(self, section, orientation, role=Qt.DisplayRole):
            if role == Qt.DisplayRole:
                if orientation == Qt.Horizontal:
                    # Afișează litere pentru coloane, A, B, C, ..., Z
                    return chr(ord('A') + section)
                elif orientation == Qt.Vertical:
                    # Afișează numere pentru rânduri
                    return str(section + 1)
            return None

        def evaluate_formula(self, formula):
            try:
                if formula.startswith(('=SUM', '=AVERAGE', '=MIN', '=MAX', '=COUNT', '=PRODUCT', '=MEDIAN', '=CONCAT', '=POW', '=SQRT')):
                    # Extragem intervalul de celule
                    numbers = re.findall(r'\((.*?)\)', formula)
                    if numbers:
                        cell_range = numbers[0]
                        cells = cell_range.split(':')
                        start_cell = cells[0]
                        end_cell = cells[1]
                        start_col = ord(start_cell[0]) - ord('A')
                        start_row = int(start_cell[1:]) - 1
                        end_col = ord(end_cell[0]) - ord('A')
                        end_row = int(end_cell[1:]) - 1
                        
                        values = []
                        for row in range(start_row, end_row + 1):
                            for col in range(start_col, end_col + 1):
                                cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                                values.append(cell_value)

                        # Evaluăm în funcție de tipul formulei
                        if formula.startswith('=SUM'):
                            return sum(values)
                        elif formula.startswith('=AVERAGE'):
                            return sum(values) / len(values) if values else 0
                        elif formula.startswith('=MIN'):
                            return min(values)
                        elif formula.startswith('=MAX'):
                            return max(values)
                        elif formula.startswith('=COUNT'):
                            return len([v for v in values if v != 0])
                        elif formula.startswith('=PRODUCT'):
                            result = 1
                            for v in values:
                                result *= v
                            return result
                        elif formula.startswith('=MEDIAN'):
                            sorted_values = sorted(values)
                            n = len(sorted_values)
                            if n == 0:
                                return 0
                            if n % 2 == 1:
                                return sorted_values[n // 2]
                            else:
                                return (sorted_values[n // 2 - 1] + sorted_values[n // 2]) / 2
                        elif formula.startswith('=POW'):
                            formula = re.sub(r'[A-Z]\d+', cell_value, formula)
                            # Extragem baza și exponentul
                            base, exponent = map(float, re.findall(r'\((.*?)\)', formula)[0].split(','))
                            return math.pow(base, exponent)

                        # Evaluarea pentru SQRT
                        elif formula.startswith('=SQRT'):
                            formula = re.sub(r'[A-Z]\d+', cell_value, formula)
                            value = float(re.findall(r'\((.*?)\)', formula)[0])
                            return math.sqrt(value)

                # Formula IF (de forma: =IF(conditie, valoare_adevarata, valoare_falsa))
                if formula.startswith('=IF'):
                    condition, true_value, false_value = re.findall(r'\((.*?),(.*?),(.*?)\)', formula)[0]
                    # Înlocuim celulele cu valori în condiție
                    matches = re.findall(r'([A-Z]+)(\d+)', condition)
                    for match in matches:
                        col = ord(match[0]) - ord('A')
                        row = int(match[1]) - 1
                        if 0 <= row < len(self._data) and 0 <= col < len(self._data[row]):
                            cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                            condition = condition.replace(match[0] + match[1], str(cell_value))

                    # Evaluăm condiția și returnăm valoarea corespunzătoare
                    if eval(condition):
                        return eval(true_value)
                    else:
                        return eval(false_value)
                    
                if formula.startswith('=CONCAT'):
                    # Extragem intervalul de celule din formula, între paranteze
                    cell_range = re.findall(r'\((.*?)\)', formula)
                    if cell_range:
                        cell_range = cell_range[0]  # Aici obținem intervalul de celule
                        cells = cell_range.split(':')  # Divizăm după ':', dacă este un interval
                        
                        start_cell = cells[0]
                        end_cell = cells[1] if len(cells) > 1 else start_cell  # Dacă e doar o celulă

                        # Convertim celulele în coordonate de rând și coloană
                        start_col = ord(start_cell[0]) - ord('A')
                        start_row = int(start_cell[1:]) - 1
                        end_col = ord(end_cell[0]) - ord('A')
                        end_row = int(end_cell[1:]) - 1

                        # Concatenăm toate valorile (considerând text și numerice)
                        concatenated_text = ""
                        for row in range(start_row, end_row + 1):
                            for col in range(start_col, end_col + 1):
                                cell_value = self._data[row][col]
                                if cell_value is not None:
                                    concatenated_text += str(cell_value)

                        return concatenated_text
                    

                # Înlocuirea referințelor la celule cu valorile lor pentru alte formule (ex: =A1 + B2)
                matches = re.findall(r'([A-Z]+)(\d+)', formula)
                for match in matches:
                    col = ord(match[0]) - ord('A')
                    row = int(match[1]) - 1
                    if 0 <= row < len(self._data) and 0 <= col < len(self._data[row]):
                        cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                        formula = formula.replace(match[0] + match[1], str(cell_value))
                
                return eval(formula[1:])  # Evaluăm formula fără "="
            except Exception:
                return formula  # Returnăm formula în caz de eroare

        '''
        def evaluate_formula(self, formula):
            # Example evaluation logic (keep as is)
            try:
                # Handle SUM function
                if formula.startswith('=SUM'):
                    # Extract cell range
                    numbers = re.findall(r'\((.*?)\)', formula)
                    if numbers:
                        cell_range = numbers[0]
                        cells = cell_range.split(':')
                        start_cell = cells[0]
                        end_cell = cells[1]
                        start_col = ord(start_cell[0]) - ord('A')
                        start_row = int(start_cell[1:]) - 1
                        end_col = ord(end_cell[0]) - ord('A')
                        end_row = int(end_cell[1:]) - 1
                        
                        total = 0
                        for row in range(start_row, end_row + 1):
                            for col in range(start_col, end_col + 1):
                                total += self._data[row][col] if self._data[row][col] is not None else 0
                        return total
                
                # Replace cell references with their values
                matches = re.findall(r'([A-Z]+)(\d+)', formula)
                for match in matches:
                    col = ord(match[0]) - ord('A')
                    row = int(match[1]) - 1
                    if 0 <= row < len(self._data) and 0 <= col < len(self._data[row]):
                        cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                        formula = formula.replace(match[0] + match[1], str(cell_value))
                return eval(formula[1:])  # Evaluate the formula without the '='
            except Exception:
                return formula  # Return the formula if evaluation fails
        '''

        def setData(self, index, value, role=Qt.EditRole):
            if role == Qt.EditRole:
                if index.isValid():
                    if index.row() < len(self._data) and index.column() < len(self._data[index.row()]):
                        # Check if the value is a formula
                        if isinstance(value, str) and value.startswith('='):
                            self._data[index.row()][index.column()] = value
                        else:
                            try:
                                # Try to convert the value to a number
                                if isinstance(value, str):
                                    value = float(value) if '.' in value else int(value)
                                # If value is already an int or float, just assign it
                                self._data[index.row()][index.column()] = value
                            except ValueError:
                                # Handle non-numeric values as necessary
                                self._data[index.row()][index.column()] = value  # Store the original value

                        self.dataChanged.emit(index, index)
                        return True
            return False


        def flags(self, index):
            if index.isValid():
                return Qt.ItemIsEditable | Qt.ItemIsEnabled | Qt.ItemIsSelectable
            return Qt.NoItemFlags

    class ExcelViewer(QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle('Excel Lite')
            self.setGeometry(100, 100, 800, 600)

            self.main_widget = QWidget()
            self.setCentralWidget(self.main_widget)

            self.layout = QVBoxLayout()
            self.main_widget.setLayout(self.layout)

            self.formula_line_edit = QLineEdit()
            self.formula_line_edit.setReadOnly(True)
            self.layout.addWidget(self.formula_line_edit)

            self.tabs = QTabWidget()
            self.layout.addWidget(self.tabs)

            self.create_menu()
            self.create_empty_sheet()

            self.clipboard_data = []

            self.setStyleSheet("""
            QMainWindow {
                background-color: #2D2D2D;  /* Fundal întunecat */
            }
            QWidget {
                background-color: #3C3F41;  /* Fundal pentru widget-uri */
                color: #ffffff;  /* Text alb */
            }
            QWidget::item:hover {
                background-color: #ccff66;
            }
            QWidget::item:selected {
                background-color: #121212;
            }
            QLineEdit {
                background-color: #4C4F51;  /* Fundal pentru QLineEdit */
                color: #FFFFFF;  /* Text alb */
                border: 1px solid #666;  /* Bordură */
            }
            QTabWidget::pane {
                background: #4d4d4d;  /* Fundal pentru tab-uri */
            }
            QTabBar::tab {
                background: #4d4d4d;  /* Fundal pentru tab-uri */
                color: #ccff66;  /* Text alb */
                padding: 10px;
                border: 2px solid #000000;
            }
            QTabBar::tab:selected {
                background: #121212;  /* Fundal tab selectat */
                color: cyan;
            }
            QPushButton {
                background-color: #4C4F51;  /* Fundal pentru butoane */
                color: #FFFFFF;  /* Text alb */
                border: none;  /* Fără bordură */
                padding: 5px;
            }
            QPushButton:hover {
                background-color: #5A5E61;  /* Fundal la hover */
            }
            QMessageBox {
                background-color: #3C3F41;  /* Fundal pentru QMessageBox */
                color: #FFFFFF;  /* Text alb */
            }
            QTableWidget {
                border: 2px solid #000000;  /* Contur negru pentru tabel */
                gridline-color: #666666;    /* Culoarea liniilor din interiorul tabelului */
                background-color: #3C3F41;  /* Fundal întunecat pentru tabel */
                color: #FFFFFF;              /* Text alb în tabel */
            }
            QTableWidget::item {
                border: 1px solid #666666;  /* Bordură pentru celule */
            }
            QTableWidget::item:selected {
                background-color: #121212;  /* Fundal pentru celule selectate */
            }
            QHeaderView::section {
                background-color: #4C4F51;  /* Fundal pentru antetele rândurilor și coloanelor */
                color: #FFFFFF;              /* Culoare text pentru antete (alb) */
                font-weight: bold;           /* Text îngroșat pentru antete */
            }
        """)

        def create_menu(self):
            menubar = self.menuBar()
            
            file_menu = menubar.addMenu('File')
            
            new_file_action = QAction('New', self)
            new_file_action.triggered.connect(self.open_new_instance)
            file_menu.addAction(new_file_action)

            new_sheet_action = QAction('New Sheet', self)
            new_sheet_action.triggered.connect(self.create_new_sheet)
            file_menu.addAction(new_sheet_action)

            open_action = QAction('Open', self)
            open_action.triggered.connect(self.load_excel_file)
            file_menu.addAction(open_action)

            save_action = QAction('Save', self)
            save_action.triggered.connect(self.save_all_sheets)
            file_menu.addAction(save_action)

            delete_sheet_action = QAction('Delete Sheet', self)
            delete_sheet_action.triggered.connect(self.delete_sheet)
            file_menu.addAction(delete_sheet_action)  # Dacă ai un meniu

            # Edit Menu for Copy, Paste
            edit_menu = menubar.addMenu('Edit')

            # Copy action
            copy_action = QAction('Copy', self)
            copy_action.triggered.connect(self.copy_selected_cells)
            edit_menu.addAction(copy_action)

            # Paste action
            paste_action = QAction('Paste', self)
            paste_action.triggered.connect(self.paste_to_selected_cells)
            edit_menu.addAction(paste_action)
            
            # Help Menu
            help_menu = menubar.addMenu('Help')

            about_action = QAction('About', self)
            about_action.triggered.connect(self.show_about_dialog)
            help_menu.addAction(about_action)

        def show_about_dialog(self):
            dialog = QDialog(self)
            dialog.setWindowTitle("Help - Excel Lite")
            dialog.setGeometry(200, 200, 500, 400)  # Dimensiuni inițiale ale ferestrei

            layout = QVBoxLayout()

            help_text = (
                "Help Menu - Available Functions\n\n"
                "1. SUM (Sum of values in a range)\n"
                "   Formula: =SUM(A1:C3)\n"
                "   Description: Calculates the sum of all values in the range A1 to C3.\n"
                "   Example: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n\n"
                
                "2. AVERAGE (Arithmetic mean)\n"
                "   Formula: =AVERAGE(A1:C3)\n"
                "   Description: Computes the average of the values in the range A1 to C3.\n"
                "   Example: (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9) / 9 = 5\n\n"
                
                "3. MIN (Minimum value)\n"
                "   Formula: =MIN(A1:C3)\n"
                "   Description: Returns the smallest value in the range A1 to C3.\n"
                "   Example: Min value = 1\n\n"
                
                "4. MAX (Maximum value)\n"
                "   Formula: =MAX(A1:C3)\n"
                "   Description: Returns the largest value in the range A1 to C3.\n"
                "   Example: Max value = 9\n\n"
                
                "5. COUNT (Number of non-empty cells)\n"
                "   Formula: =COUNT(A1:C3)\n"
                "   Description: Counts the number of non-empty cells in the range A1 to C3.\n"
                "   Example: 9 (all cells contain values)\n\n"
                
                "6. PRODUCT (Multiplication of values)\n"
                "   Formula: =PRODUCT(A1:C3)\n"
                "   Description: Multiplies all values in the range A1 to C3.\n"
                "   Example: 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 × 9 = 362880\n\n"
                
                "7. MEDIAN (Middle value in a sorted list)\n"
                "   Formula: =MEDIAN(A1:C3)\n"
                "   Description: Returns the median value of the range A1 to C3.\n"
                "   Example: Sorted values: 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
                "   Median = 5\n\n"
                
                "8. CONCAT (Concatenation of values)\n"
                "   Formula: =CONCAT(A1:B2)\n"
                "   Description: Joins all values in the range A1 to B2 into a single string.\n"
                "   Example: Values in A1, B1, A2, B2 are 1, 2, 4, 5\n"
                "   Result: '1245'\n\n"
                
                "Shortcuts:\n"
                "   - Copy: CTRL+C\n"
                "   - Paste: CTRL+V\n"
            )

            text_edit = QTextEdit()
            text_edit.setText(help_text)
            text_edit.setReadOnly(True)  # Face textul non-editabil
            layout.addWidget(text_edit)

            close_button = QPushButton("Close")
            close_button.clicked.connect(dialog.accept)
            layout.addWidget(close_button)

            dialog.setLayout(layout)
            dialog.exec_()  # Afișează fereastra modal


        def keyPressEvent(self, event):
            if event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_C:
                self.copy_selected_cells()
            elif event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_V:
                self.paste_to_selected_cells()

        def copy_selected_cells(self):
            """Copie datele din celulele selectate în clipboard."""
            current_sheet = self.tabs.currentWidget()
            selection_model = current_sheet.selectionModel()
            selected_indexes = selection_model.selectedIndexes()

            if not selected_indexes:
                return

            self.clipboard_data.clear()
            rows = {}
            for index in selected_indexes:
                row = index.row()
                col = index.column()
                if row not in rows:
                    rows[row] = {}
                rows[row][col] = current_sheet.model().data(index, Qt.DisplayRole)
            
            # Organizăm datele copiate într-o listă de liste pentru a păstra ordinea
            sorted_rows = sorted(rows.keys())
            for row in sorted_rows:
                sorted_cols = sorted(rows[row].keys())
                row_data = [rows[row][col] for col in sorted_cols]
                self.clipboard_data.append(row_data)
            
        def paste_to_selected_cells(self):
            """Lipește datele din clipboard în celulele selectate."""
            if not self.clipboard_data:
                return
            
            current_sheet = self.tabs.currentWidget()
            selection_model = current_sheet.selectionModel()
            selected_indexes = selection_model.selectedIndexes()

            if not selected_indexes:
                return
            
            # Vom începe lipirea de la prima celulă selectată
            start_index = selected_indexes[0]
            start_row = start_index.row()
            start_col = start_index.column()

            # Iterăm prin clipboard și lipim în tabel
            for i, row_data in enumerate(self.clipboard_data):
                for j, value in enumerate(row_data):
                    if start_row + i < current_sheet.model().rowCount() and start_col + j < current_sheet.model().columnCount():
                        index = current_sheet.model().index(start_row + i, start_col + j)
                        current_sheet.model().setData(index, value, Qt.EditRole)

        def open_new_instance(self):
            subprocess.Popen([sys.executable, __file__])

        def create_empty_sheet(self):
            # Prompt for the initial sheet name
            sheet_name, ok = QInputDialog.getText(self, 'Input Sheet Name', 'Enter the name of the sheet:')
            if ok and sheet_name:
                data = [[None] * 100 for _ in range(100)]
                self.add_sheet(sheet_name, data)

        def create_new_sheet(self):
            while True:
                sheet_name, ok = QInputDialog.getText(self, 'New Sheet Name', 'Enter the name of the new sheet:')
                if ok and sheet_name:
                    # Check if the name already exists
                    if not any(sheet_name == self.tabs.tabText(i) for i in range(self.tabs.count())):
                        data = [[None] * 100 for _ in range(100)]
                        self.add_sheet(sheet_name, data)
                        break
                    else:
                        QMessageBox.warning(self, 'Warning', 'Sheet name already exists. Please choose another name.')
                else:
                    QMessageBox.warning(self, 'Warning', 'Sheet name cannot be empty. Please enter a valid name.')

        def delete_sheet(self):
            current_index = self.tabs.currentIndex()  # Obține indexul tab-ului curent
            if current_index == -1:
                QMessageBox.warning(self, 'Warning', 'No sheet selected to delete.')
                return
            
            sheet_name = self.tabs.tabText(current_index)  # Obține numele sheet-ului curent

            # Confirmare de ștergere
            reply = QMessageBox.question(self, 'Confirm Delete', f'Are you sure you want to delete the sheet "{sheet_name}"?',
                                        QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            
            if reply == QMessageBox.Yes:
                self.tabs.removeTab(current_index)  # Șterge tab-ul
                # Șterge datele asociate, dacă este cazul
                # self.data.remove(sheet_name)  # De exemplu, dacă ai o dict pentru date
                QMessageBox.information(self, 'Deleted', f'Sheet "{sheet_name}" has been deleted.')


        def load_excel_file(self):
            if self.has_unsaved_changes():
                reply = QMessageBox.warning(self, 'Warning',
                    'Data that has not been saved will be lost. Do you want to continue?',
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if reply == QMessageBox.No:
                    return

            self.tabs.clear()
            options = QFileDialog.Options()
            file_path, _ = QFileDialog.getOpenFileName(self, "Select Excel File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
            
            # Define number of rows and columns
            num_rows, num_columns = 100, 100
            
            if file_path:
                workbook = load_workbook(file_path)
                for sheet_name in workbook.sheetnames:
                    sheet = workbook[sheet_name]
                    data = [[None] * num_columns for _ in range(num_rows)]  # Preallocate with None
                    for row in sheet.iter_rows(max_row=num_rows, max_col=num_columns):
                        for cell in row:
                            data[cell.row - 1][cell.column - 1] = cell.value
                    self.add_sheet(sheet_name, data)


        def add_sheet(self, sheet_name, data):
            model = ExcelTableModel(data, 100, 100)
            table_view = QTableView()
            table_view.setModel(model)
            table_view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
            table_view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
            table_view.setStyleSheet("QTableView { selection-background-color: #121212; }")  # Custom styling for selected cells
            table_view.setStyleSheet("QTableView { background-color: #121212; }")
            table_view.setStyleSheet("QTableView { border: 2px solid #000000;}")
            table_view.setStyleSheet("QTableView { gridline-color: #808080;}")
            table_view.setStyleSheet("QTableView { color: #ffffff;}")
            table_view.setStyleSheet("QTableWidget::item:selected { background-color: #121212;}")

            # Conectează selecția celulei cu funcția de actualizare a QLineEdit
            table_view.selectionModel().selectionChanged.connect(lambda: self.update_formula_display(table_view, model))

            self.tabs.addTab(table_view, sheet_name)

        def update_formula_display(self, table_view, model):
            index = table_view.currentIndex()
            if index.isValid():
                value = model.data(index, Qt.EditRole)  # Obține datele brute (care pot fi o formulă)
                if isinstance(value, str) and value.startswith('='):
                    self.formula_line_edit.setText(value)  # Arată formula în QLineEdit
                else:
                    self.formula_line_edit.setText(str(value))  # Arată valoarea evaluată


        def save_all_sheets(self):
            options = QFileDialog.Options()
            file_path, _ = QFileDialog.getSaveFileName(self, "Save Excel File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
            if file_path:
                workbook = Workbook()
                if "Sheet" in workbook.sheetnames:
                    del workbook["Sheet"]

                for i in range(self.tabs.count()):
                    current_tab = self.tabs.widget(i)
                    model = current_tab.model()
                    sheet_name = self.tabs.tabText(i)
                    sheet = workbook.create_sheet(title=sheet_name)

                    for row_index in range(model.rowCount()):
                        for column_index in range(model.columnCount()):
                            value = model.data(model.index(row_index, column_index), Qt.EditRole)
                            sheet.cell(row=row_index + 1, column=column_index + 1, value=value)

                workbook.save(file_path)

        def has_unsaved_changes(self):
            for i in range(self.tabs.count()):
                current_tab = self.tabs.widget(i)
                model = current_tab.model()
                if any(model.data(model.index(row, column), Qt.EditRole) is not None for row in range(model.rowCount()) for column in range(model.columnCount())):
                    return True
            return False

    if __name__ == '__main__':
        app = QApplication(sys.argv)
        viewer = ExcelViewer()
        viewer.show()
        sys.exit(app.exec_())

if readervar == 1993:
    import sys
    from PyQt5.QtWidgets import (
        QApplication, QMainWindow, QAction, QFileDialog, QTextEdit, QMessageBox,
        QTableWidget, QTableWidgetItem, QVBoxLayout, QWidget, QComboBox, QTabWidget,
        QLabel, QScrollArea
    )
    from PyQt5.QtGui import QIcon
    from docx import Document
    import openpyxl
    from pptx import Presentation
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class OfficeReader(QMainWindow):
        def __init__(self):
            super().__init__()
            self.initUI()

        def initUI(self):
            # Setarea ferestrei principale
            self.setWindowTitle('Office Reader')
            self.setGeometry(100, 100, 800, 600)

            # Aplicarea temei întunecate
            self.setStyleSheet("""
                QMainWindow {
                    background-color: #2e2e2e;
                }
                QTextEdit {
                    background-color: #1e1e1e;
                    color: #dcdcdc;
                }
                QMenuBar {
                    background-color: #1e1e1e;
                    color: #dcdcdc;
                }
                QMenuBar::item:selected {
                    background-color: #3e3e3e;
                }
                QMenu {
                    background-color: #1e1e1e;
                    color: #dcdcdc;
                }
                QMenu::item:selected {
                    background-color: #3e3e3e;
                }
                QPushButton {
                    background-color: #3e3e3e;
                    color: #dcdcdc;
                    border: 1px solid #555555;
                }
                QPushButton:hover {
                    background-color: #4e4e4e;
                }
                QTableWidget {
                    background-color: #1e1e1e;
                    color: #dcdcdc;
                }
                QTabWidget::pane {
                    border: 1px solid #555555;
                }
                QLabel {
                    color: #dcdcdc;
                }
                QTextEdit {
                    border: none;
                }
            """)

            # Creare zona de text pentru afișarea documentelor Word
            self.textEdit = QTextEdit(self)
            self.textEdit.setReadOnly(True)  # Face documentul Word doar în modul de citire
            self.setCentralWidget(self.textEdit)

            # Meniu
            menubar = self.menuBar()
            fileMenu = menubar.addMenu('File')

            # Adăugare acțiune pentru a deschide fișiere
            openFile = QAction(QIcon('open.png'), 'Open', self)
            openFile.setShortcut('Ctrl+O')
            openFile.triggered.connect(self.showDialog)
            fileMenu.addAction(openFile)

        def showDialog(self):
            # Deschide un dialog pentru a selecta fișiere
            fname, _ = QFileDialog.getOpenFileName(self, 'Open file', '', 
                                                   'Word files (*.docx);;Excel files (*.xlsx);;PowerPoint files (*.pptx);;All files (*.*)')
            
            if fname:
                if fname.endswith('.docx'):
                    self.openWordFile(fname)
                elif fname.endswith('.xlsx'):
                    self.openExcelFile(fname)
                elif fname.endswith('.pptx'):
                    self.openPowerPointFile(fname)
                else:
                    self.showError("Unsupported file format!")

        def openWordFile(self, filepath):
            try:
                # Restabilește zona de text pentru afișarea documentului Word
                self.textEdit = QTextEdit(self)
                self.textEdit.setReadOnly(True)  # Face documentul Word doar în modul de citire
                self.setCentralWidget(self.textEdit)

                # Citirea fișierului Word
                doc = Document(filepath)
                fullText = [para.text for para in doc.paragraphs]
                self.textEdit.setText('\n'.join(fullText))
            except Exception as e:
                self.showError(f"Error opening Word file: {str(e)}")

        def openExcelFile(self, filepath):
            try:
                # Deschidem fișierul Excel cu data_only=True pentru a obține valorile calculate
                self.wb = openpyxl.load_workbook(filepath, data_only=True)  # Folosim data_only=True pentru a obține valorile calculate
                
                # Creăm un combo box pentru a selecta sheet-ul
                self.sheetSelector = QComboBox(self)
                self.sheetSelector.addItems(self.wb.sheetnames)
                self.sheetSelector.currentIndexChanged.connect(self.loadSheetData)
                
                # Creăm un label pentru a afișa formula
                self.formulaLabel = QLabel(self)
                self.formulaLabel.setStyleSheet("background-color: #2e2e2e; color: #dcdcdc; padding: 5px;")
                
                # Setăm layout-ul și combo box-ul la început
                layout = QVBoxLayout()
                self.tableWidget = QTableWidget()
                self.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)  # Dezactivează editarea
                self.tableWidget.cellClicked.connect(self.updateFormulaDisplay)
                layout.addWidget(self.sheetSelector)
                layout.addWidget(self.tableWidget)
                layout.addWidget(self.formulaLabel)
                
                container = QWidget()
                container.setLayout(layout)
                self.setCentralWidget(container)
                
                # Încarcă datele pentru sheet-ul selectat inițial
                self.loadSheetData()

            except Exception as e:
                self.showError(f"Error opening Excel file: {str(e)}")

        def loadSheetData(self):
            # Afișează datele din sheet-ul selectat
            selected_sheet = self.sheetSelector.currentText()
            sheet = self.wb[selected_sheet]

            # Setăm numărul de rânduri și coloane
            self.tableWidget.setRowCount(sheet.max_row)
            self.tableWidget.setColumnCount(sheet.max_column)

            # Iterăm prin celulele din sheet și le adăugăm în tabel
            for row_idx, row in enumerate(sheet.iter_rows(values_only=True)):  # Folosim values_only=True pentru a obține doar valorile
                for col_idx, cell in enumerate(row):
                    self.tableWidget.setItem(row_idx, col_idx, QTableWidgetItem(str(cell) if cell else ''))


        def updateFormulaDisplay(self, row, column):
            try:
                # Afișează textul complet al celulei selectate
                selected_sheet = self.sheetSelector.currentText()
                sheet = self.wb[selected_sheet]
                cell = sheet.cell(row=row+1, column=column+1)
                
                cell_value = cell.value
                # Verifică dacă celula conține o formulă
                if cell.data_type == 'f':
                    cell_value = f"Formula: {cell.value}"
                else:
                    cell_value = f"Value: {cell_value}"
                
                self.formulaLabel.setText(cell_value)
            except Exception as e:
                self.formulaLabel.setText("Error displaying cell content")
                print(f"Error updating formula display: {e}")

        def openPowerPointFile(self, filepath):
            try:
                # Creăm un QTabWidget pentru slide-uri
                tabWidget = QTabWidget(self)
                self.setCentralWidget(tabWidget)

                # Deschidem fișierul PowerPoint
                prs = Presentation(filepath)
                
                # Iterăm prin slide-uri și adăugăm fiecare slide în tab-uri
                for slide_idx, slide in enumerate(prs.slides):
                    slide_text = []
                    for shape in slide.shapes:
                        if hasattr(shape, "text"):
                            slide_text.append(shape.text.strip())
                    
                    # Creăm un widget scrollabil pentru fiecare slide
                    slide_widget = QWidget()
                    slide_layout = QVBoxLayout(slide_widget)
                    
                    # Aplicăm stilul întunecat și textul alb
                    label = QLabel("\n".join(slide_text) if slide_text else "No text on this slide")
                    label.setWordWrap(True)
                    label.setStyleSheet("color: #dcdcdc; background-color: #1e1e1e; padding: 10px;")
                    
                    scrollArea = QScrollArea()
                    scrollArea.setWidget(label)
                    scrollArea.setWidgetResizable(True)
                    
                    slide_layout.addWidget(scrollArea)
                    
                    # Adăugăm un tab pentru fiecare slide
                    tabWidget.addTab(slide_widget, f"Slide {slide_idx + 1}")

            except Exception as e:
                self.showError(f"Error opening PowerPoint file: {str(e)}")


        def showError(self, message):
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText(message)
            msg.setWindowTitle("Error")
            msg.exec_()

    if __name__ == '__main__':
        app = QApplication(sys.argv)
        reader = OfficeReader()
        reader.show()
        sys.exit(app.exec_())
        
if hardmvar == 1994:
    import tkinter as tk
    from tkinter import ttk
    import psutil
    import threading
    import time
    from datetime import datetime
    import platform

    try:
        import GPUtil
        gpu_available = True
    except ImportError:
        gpu_available = False

    class CyberpunkSystemMonitor:
        def __init__(self, roothwmn):
            self.roothwmn = roothwmn
            self.roothwmn.title("Hardware Monitor")
            self.roothwmn.geometry("800x800")
            self.roothwmn.resizable(True, True)
            
            # Set window to always be on top
            self.roothwmn.attributes('-topmost', True)
            
            # Cyberpunk neon colors (dark theme)
            self.colors = {
                "bg": "#0f111a",           # Very dark background
                "card_bg": "#1a1c25",      # Slightly lighter card background
                "text": "#ffffff",         # Main white text
                "subtitle": "#8a8d98",     # Secondary light gray text
                "accent": "#8a2be2",       # Dark purple accent
                "cpu": "#00ffff",          # Neon cyan for CPU
                "ram": "#ff00ff",          # Neon magenta for RAM
                "disk": "#7df9ff",         # Light cyan for Disk
                "gpu": "#bf00ff",          # Bright purple for GPU
                "border": "#2a2d3a",       # Card border color
                "highlight": "#614BC0"     # Highlight color
            }
            
            # Window configuration
            self.roothwmn.configure(bg=self.colors["bg"])
            
            # Style configuration
            style = ttk.Style()
            style.theme_use('clam')
            
            # Progressbar styling
            style.configure("CPU.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["cpu"])
            
            style.configure("RAM.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["ram"])
                            
            style.configure("Disk.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["disk"])
                            
            style.configure("GPU.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["gpu"])
            
            # Main frame
            main_frame = tk.Frame(roothwmn, bg=self.colors["bg"], padx=20, pady=20)
            main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Header
            header_frame = tk.Frame(main_frame, bg=self.colors["bg"])
            header_frame.pack(fill=tk.X, pady=(0, 20))
            
            title_label = tk.Label(header_frame, 
                                  text="HARDWARE·MONITOR", 
                                  font=("Consolas", 24, "bold"), 
                                  bg=self.colors["bg"], 
                                  fg=self.colors["cpu"])
            title_label.pack(side=tk.LEFT)
            
            # Display real time and additional data
            time_frame = tk.Frame(header_frame, bg=self.colors["bg"])
            time_frame.pack(side=tk.RIGHT)
            
            self.time_label = tk.Label(time_frame, 
                                      text="", 
                                      font=("Consolas", 12), 
                                      bg=self.colors["bg"], 
                                      fg=self.colors["ram"])
            self.time_label.pack(side=tk.TOP, anchor=tk.E)
            
            self.uptime_label = tk.Label(time_frame, 
                                        text="", 
                                        font=("Consolas", 10), 
                                        bg=self.colors["bg"], 
                                        fg=self.colors["subtitle"])
            self.uptime_label.pack(side=tk.TOP, anchor=tk.E)
            
            # Create grid for cards
            resources_frame = tk.Frame(main_frame, bg=self.colors["bg"])
            resources_frame.pack(fill=tk.BOTH, expand=True)
            
            # Grid layout for cards
            resources_frame.columnconfigure(0, weight=1)
            resources_frame.columnconfigure(1, weight=1)
            resources_frame.rowconfigure(0, weight=1)
            resources_frame.rowconfigure(1, weight=1)
            
            # Card dimensions - ensure all cards have the same size
            card_width = 350
            card_height = 200
            
            # CPU Card
            self.cpu_card = self.create_card(resources_frame, "CPU", self.colors["cpu"], 0, 0, width=card_width, height=card_height)
            
            # RAM Card
            self.ram_card = self.create_card(resources_frame, "RAM", self.colors["ram"], 0, 1, width=card_width, height=card_height)
            
            # Disk Card
            self.disk_card = self.create_card(resources_frame, "STORAGE", self.colors["disk"], 1, 0, width=card_width, height=card_height)
            
            # GPU Card
            if gpu_available:
                self.gpu_card = self.create_card(resources_frame, "GPU", self.colors["gpu"], 1, 1, width=card_width, height=card_height)
            else:
                # If GPU is not available, create a network card
                self.network_card = self.create_card(resources_frame, "NETWORK", self.colors["gpu"], 1, 1, width=card_width, height=card_height)
                self.prev_net_io = psutil.net_io_counters()
                self.network_speed = {"download": 0, "upload": 0}
            
            # Footer with advanced statistics
            footer_frame = tk.Frame(main_frame, bg=self.colors["bg"], pady=10)
            footer_frame.pack(fill=tk.X)
            
            # Processes
            self.processes_label = tk.Label(footer_frame, 
                                          text="Processes: 0", 
                                          font=("Consolas", 10), 
                                          bg=self.colors["bg"], 
                                          fg=self.colors["text"])
            self.processes_label.pack(side=tk.LEFT, padx=(0, 20))
            
            # Temperature (if available)
            self.temp_label = tk.Label(footer_frame, 
                                      text="", 
                                      font=("Consolas", 10), 
                                      bg=self.colors["bg"], 
                                      fg=self.colors["text"])
            self.temp_label.pack(side=tk.LEFT, padx=(0, 20))
            
            # Top processes
            top_processes_frame = tk.Frame(main_frame, bg=self.colors["bg"], pady=10)
            top_processes_frame.pack(fill=tk.X)
            
            top_label = tk.Label(top_processes_frame,
                               text="TOP PROCESSES (CPU)",
                               font=("Consolas", 10, "bold"),
                               bg=self.colors["bg"],
                               fg=self.colors["cpu"])
            top_label.pack(anchor=tk.W)
            
            self.processes_info = tk.Label(top_processes_frame,
                                         text="",
                                         font=("Consolas", 9),
                                         bg=self.colors["bg"],
                                         fg=self.colors["text"],
                                         justify=tk.LEFT)
            self.processes_info.pack(anchor=tk.W, pady=(5, 0))
            
            # Thread for updating data
            self.running = True
            self.update_thread = threading.Thread(target=self.update_stats)
            self.update_thread.daemon = True
            self.update_thread.start()
            
            # When closing the window
            self.roothwmn.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        def create_card(self, parent, title, color, row, column, width=None, height=None):
            # Card frame with fixed dimensions
            card = tk.Frame(parent, bg=self.colors["card_bg"], padx=15, pady=15, 
                           highlightbackground=color, highlightthickness=1, 
                           relief=tk.FLAT, bd=0, width=width, height=height)
            card.grid(row=row, column=column, padx=10, pady=10, sticky="nsew")
            
            # Ensure the card maintains its size
            if width and height:
                card.pack_propagate(False)
            
            # Card title with icon
            title_frame = tk.Frame(card, bg=self.colors["card_bg"])
            title_frame.pack(fill=tk.X, pady=(0, 10))
            
            title_label = tk.Label(title_frame, text=title, 
                                  font=("Consolas", 16, "bold"), 
                                  fg=color, bg=self.colors["card_bg"])
            title_label.pack(side=tk.LEFT)
            
            value_label = tk.Label(title_frame, text="0%", 
                                  font=("Consolas", 16), 
                                  fg=self.colors["text"], bg=self.colors["card_bg"])
            value_label.pack(side=tk.RIGHT)
            
            # Progress bar
            if title == "CPU":
                progress = ttk.Progressbar(card, style="CPU.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            elif title == "RAM":
                progress = ttk.Progressbar(card, style="RAM.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            elif title == "STORAGE":
                progress = ttk.Progressbar(card, style="Disk.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            else:  # GPU or NETWORK
                progress = ttk.Progressbar(card, style="GPU.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            
            progress.pack(fill=tk.X, pady=10)
            
            # Advanced: small histograms for history
            history_frame = tk.Frame(card, bg=self.colors["card_bg"], height=30)
            history_frame.pack(fill=tk.X, pady=(10, 5))
            
            # Create 20 small bars for history
            history_bars = []
            for i in range(20):
                bar = tk.Frame(history_frame, width=8, bg=self.colors["border"])
                bar.pack(side=tk.LEFT, padx=1)
                bar.place(rely=1.0, relheight=0.1, x=i*10, anchor="sw", width=8)
                history_bars.append(bar)
            
            # Info labels
            info_frame = tk.Frame(card, bg=self.colors["card_bg"])
            info_frame.pack(fill=tk.X, pady=5)
            
            info_label = tk.Label(info_frame, text="", 
                                 font=("Consolas", 10), 
                                 fg=self.colors["text"], bg=self.colors["card_bg"])
            info_label.pack(anchor=tk.W)
            
            detail_label = tk.Label(info_frame, text="", 
                                  font=("Consolas", 9), 
                                  fg=self.colors["subtitle"], bg=self.colors["card_bg"])
            detail_label.pack(anchor=tk.W, pady=(5, 0))
            
            # Extra label for advanced details
            extra_label = tk.Label(info_frame, text="", 
                                 font=("Consolas", 9), 
                                 fg=self.colors["subtitle"], bg=self.colors["card_bg"])
            extra_label.pack(anchor=tk.W, pady=(5, 0))
            
            return {
                "frame": card,
                "title": title_label,
                "value": value_label,
                "progress": progress,
                "info": info_label,
                "detail": detail_label,
                "extra": extra_label,
                "history": history_bars,
                "history_data": [0] * 20  # Store history for the graph
            }
        
        def update_stats(self):
            # History data for graphs
            history = {
                "cpu": [0] * 20,
                "ram": [0] * 20,
                "disk": [0] * 20,
                "gpu": [0] * 20 if gpu_available else None,
                "network": None if gpu_available else [0] * 20
            }
            
            while self.running:
                # Update time
                current_time = datetime.now().strftime("%H:%M:%S")
                uptime_seconds = time.time() - psutil.boot_time()
                uptime_days = int(uptime_seconds // 86400)
                uptime_hours = int((uptime_seconds % 86400) // 3600)
                uptime_minutes = int((uptime_seconds % 3600) // 60)
                
                # Update CPU
                cpu_percent = psutil.cpu_percent(interval=0.1)
                cpu_count_physical = psutil.cpu_count(logical=False)
                cpu_count_logical = psutil.cpu_count()
                
                # Add data to history
                history["cpu"].pop(0)
                history["cpu"].append(cpu_percent)
                
                cpu_freq = psutil.cpu_freq()
                if cpu_freq:
                    cpu_freq_current = cpu_freq.current
                    cpu_freq_min = cpu_freq.min if hasattr(cpu_freq, 'min') else "N/A"
                    cpu_freq_max = cpu_freq.max if hasattr(cpu_freq, 'max') else "N/A"
                else:
                    cpu_freq_current = cpu_freq_min = cpu_freq_max = "N/A"
                
                # Update RAM
                ram = psutil.virtual_memory()
                ram_percent = ram.percent
                ram_used = ram.used / (1024 ** 3)  # Convert to GB
                ram_total = ram.total / (1024 ** 3)
                ram_available = ram.available / (1024 ** 3)
                ram_cached = ram.cached / (1024 ** 3) if hasattr(ram, 'cached') else 0
                
                # Add data to history
                history["ram"].pop(0)
                history["ram"].append(ram_percent)
                
                # Update Disk
                disk = psutil.disk_usage('/')
                disk_percent = disk.percent
                disk_used = disk.used / (1024 ** 3)
                disk_total = disk.total / (1024 ** 3)
                
                # IO Info
                try:
                    disk_io = psutil.disk_io_counters()
                    disk_read_mb = disk_io.read_bytes / (1024 ** 2)
                    disk_write_mb = disk_io.write_bytes / (1024 ** 2)
                except:
                    disk_read_mb = disk_write_mb = 0
                
                # Add data to history
                history["disk"].pop(0)
                history["disk"].append(disk_percent)
                
                # Process network information if we don't have GPU
                if not gpu_available:
                    net_io = psutil.net_io_counters()
                    net_sent = (net_io.bytes_sent - self.prev_net_io.bytes_sent) / 1024  # KB/s
                    net_recv = (net_io.bytes_recv - self.prev_net_io.bytes_recv) / 1024  # KB/s
                    self.network_speed["upload"] = net_sent
                    self.network_speed["download"] = net_recv
                    self.prev_net_io = net_io
                    
                    # Add data to history (use download as primary value)
                    net_percent = min(net_recv / 1000 * 100, 100)  # Limit to 100%
                    history["network"].pop(0)
                    history["network"].append(net_percent)
                
                # Processes
                num_processes = len(psutil.pids())
                
                # Top 3 processes by CPU usage
                top_processes = []
                for proc in sorted(psutil.process_iter(['pid', 'name', 'cpu_percent']), 
                                 key=lambda p: p.info['cpu_percent'] if p.info['cpu_percent'] is not None else 0, 
                                 reverse=True)[:3]:
                    try:
                        if proc.info['cpu_percent'] > 0:
                            top_processes.append(f"{proc.info['name'][:15]:<15} - {proc.info['cpu_percent']:>5.1f}%")
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        pass
                
                # Temperatures (if available)
                temp_info = ""
                try:
                    temps = psutil.sensors_temperatures()
                    if temps:
                        for name, entries in temps.items():
                            for entry in entries:
                                temp_info += f"{name}: {entry.current}°C | "
                                break  # only the first temperature per sensor
                except:
                    pass
                
                # Update GUI (in the main thread)
                self.roothwmn.after(10, self.update_gui, current_time, 
                               uptime_days, uptime_hours, uptime_minutes,
                               cpu_percent, cpu_count_physical, cpu_count_logical, 
                               cpu_freq_current, cpu_freq_min, cpu_freq_max,
                               ram_percent, ram_used, ram_total, ram_available, ram_cached,
                               disk_percent, disk_used, disk_total, disk_read_mb, disk_write_mb,
                               num_processes, top_processes, temp_info, history)
                
                # Update GPU (if available)
                if gpu_available:
                    try:
                        gpus = GPUtil.getGPUs()
                        if gpus:
                            gpu = gpus[0]  # Use the first GPU
                            gpu_percent = gpu.load * 100
                            gpu_mem_percent = (gpu.memoryUsed / gpu.memoryTotal) * 100
                            gpu_mem_used = gpu.memoryUsed
                            gpu_mem_total = gpu.memoryTotal
                            gpu_temp = gpu.temperature
                            
                            # Add data to history
                            history["gpu"].pop(0)
                            history["gpu"].append(gpu_percent)
                            
                            self.roothwmn.after(10, self.update_gpu_gui, 
                                           gpu_percent, gpu_mem_percent, 
                                           gpu_mem_used, gpu_mem_total, 
                                           gpu.name, gpu_temp, history["gpu"])
                    except Exception as e:
                        print(f"Error updating GPU information: {e}")
                else:
                    # Update Network GUI if we don't have GPU
                    self.roothwmn.after(10, self.update_network_gui, 
                                   self.network_speed["download"], 
                                   self.network_speed["upload"], 
                                   history["network"])
                
                time.sleep(0.5)  # Update every 0.5 seconds
        
        def update_history_bars(self, history_bars, history_data, color):
            # Update history bars
            for i, value in enumerate(history_data):
                # Calculate relative height (0.1 - 1.0) based on percentage (0-100)
                height = max(0.1, value / 100)
                # Update bar height and color
                alpha = int(min(255, value * 2.55))  # 0-255 based on value
                bar_color = color  # base color with alpha
                history_bars[i].place(relheight=height, relwidth=1.0)
        
        def update_gui(self, current_time, uptime_days, uptime_hours, uptime_minutes,
                      cpu_percent, cpu_count_physical, cpu_count_logical, 
                      cpu_freq_current, cpu_freq_min, cpu_freq_max,
                      ram_percent, ram_used, ram_total, ram_available, ram_cached,
                      disk_percent, disk_used, disk_total, disk_read_mb, disk_write_mb,
                      num_processes, top_processes, temp_info, history):
            # Update time and uptime
            self.time_label.config(text=f"{current_time}")
            uptime_text = f"Uptime: "
            if uptime_days > 0:
                uptime_text += f"{uptime_days}d "
            uptime_text += f"{uptime_hours}h {uptime_minutes}m"
            self.uptime_label.config(text=uptime_text)
            
            # Update processes and temperature
            self.processes_label.config(text=f"Processes: {num_processes}")
            if temp_info:
                self.temp_label.config(text=temp_info)
            
            # Update top processes
            if top_processes:
                self.processes_info.config(text="\n".join(top_processes))
            
            # Update CPU
            self.cpu_card["value"].config(text=f"{cpu_percent:.1f}%")
            self.cpu_card["progress"]["value"] = cpu_percent
            self.cpu_card["info"].config(text=f"Physical: {cpu_count_physical} cores | Logical: {cpu_count_logical} threads")
            
            # Format for CPU frequency
            freq_text = f"Frequency: {cpu_freq_current:.0f} MHz" if isinstance(cpu_freq_current, (int, float)) else f"Frequency: {cpu_freq_current}"
            if isinstance(cpu_freq_min, (int, float)) and isinstance(cpu_freq_max, (int, float)):
                self.cpu_card["extra"].config(text=f"Min: {cpu_freq_min:.0f} MHz | Max: {cpu_freq_max:.0f} MHz")
            
            self.cpu_card["detail"].config(text=freq_text)
            
            # Update CPU history bars
            self.update_history_bars(self.cpu_card["history"], history["cpu"], self.colors["cpu"])
            
            # Update RAM
            self.ram_card["value"].config(text=f"{ram_percent:.1f}%")
            self.ram_card["progress"]["value"] = ram_percent
            self.ram_card["info"].config(text=f"Used: {ram_used:.2f} GB of {ram_total:.2f} GB")
            self.ram_card["detail"].config(text=f"Available: {ram_available:.2f} GB")
            self.ram_card["extra"].config(text=f"Cache: {ram_cached:.2f} GB")
            
            # Update RAM history bars
            self.update_history_bars(self.ram_card["history"], history["ram"], self.colors["ram"])
            
            # Update Disk
            self.disk_card["value"].config(text=f"{disk_percent:.1f}%")
            self.disk_card["progress"]["value"] = disk_percent
            self.disk_card["info"].config(text=f"Used: {disk_used:.2f} GB of {disk_total:.2f} GB")
            self.disk_card["detail"].config(text=f"Available: {disk_total - disk_used:.2f} GB")
            self.disk_card["extra"].config(text=f"I/O: {disk_read_mb:.1f} MB read | {disk_write_mb:.1f} MB written")
            
            # Update Disk history bars
            self.update_history_bars(self.disk_card["history"], history["disk"], self.colors["disk"])
        
        def update_gpu_gui(self, gpu_percent, gpu_mem_percent, gpu_mem_used, gpu_mem_total, gpu_name, gpu_temp, history_data):
            if gpu_available:
                self.gpu_card["value"].config(text=f"{gpu_percent:.1f}%")
                self.gpu_card["progress"]["value"] = gpu_percent
                self.gpu_card["info"].config(text=f"{gpu_name}")
                self.gpu_card["detail"].config(text=f"Memory: {gpu_mem_used:.0f}/{gpu_mem_total:.0f} MB ({gpu_mem_percent:.1f}%)")
                self.gpu_card["extra"].config(text=f"Temperature: {gpu_temp}°C")
                
                # Update GPU history bars
                self.update_history_bars(self.gpu_card["history"], history_data, self.colors["gpu"])
        
        def update_network_gui(self, download_speed, upload_speed, history_data):
            if not gpu_available:
                # Calculate a relative percentage for the progress bar
                # Assume 10 MB/s = 100%
                download_percent = min(download_speed / 10000 * 100, 100)
                
                self.network_card["value"].config(text=f"{download_percent:.1f}%")
                self.network_card["progress"]["value"] = download_percent
                
                # Format units of measurement
                if download_speed > 1024:
                    download_text = f"{download_speed/1024:.2f} MB/s"
                else:
                    download_text = f"{download_speed:.2f} KB/s"
                    
                if upload_speed > 1024:
                    upload_text = f"{upload_speed/1024:.2f} MB/s"
                else:
                    upload_text = f"{upload_speed:.2f} KB/s"
                
                self.network_card["info"].config(text=f"Download: {download_text}")
                self.network_card["detail"].config(text=f"Upload: {upload_text}")
                
                # Packet information
                try:
                    net_stats = psutil.net_io_counters()
                    self.network_card["extra"].config(text=f"Packets: {net_stats.packets_recv} received | {net_stats.packets_sent} sent")
                except:
                    pass
                
                # Update Network history bars
                self.update_history_bars(self.network_card["history"], history_data, self.colors["gpu"])
        
        def on_closing(self):
            self.running = False
            self.roothwmn.destroy()

    def main():
        roothwmn = tk.Tk()
        app = CyberpunkSystemMonitor(roothwmn)
        roothwmn.mainloop()

    if __name__ == "__main__":
        main()
        
if fetchervar == 1995:
    import os
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    import socket
    import random
    import configparser
     
    class SetupWizard(tk.Tk):
        def __init__(self):
            super().__init__()
     
            self.title("Repair Setup - Fetcher")
            self.geometry("500x400")
            self.resizable(False, False)
     
            self.steps = []
            self.current_step = 0
     
            self.container = ttk.Frame(self)
            self.container.pack(fill="both", expand=True)
     
            self.create_steps()
            self.show_step(0)
     
            self.navigation_frame = ttk.Frame(self)
            self.navigation_frame.pack(side="bottom", fill="x")
     
            self.back_button = ttk.Button(self.navigation_frame, text="Back", command=self.back)
            self.next_button = ttk.Button(self.navigation_frame, text="Next", command=self.next)
            self.finish_button = ttk.Button(self.navigation_frame, text="Finish", command=self.finish, state="disabled")
     
            self.back_button.pack(side="left", padx=(10, 0), pady=10)
            self.finish_button.pack(side="right", padx=(0, 10), pady=10)
            self.next_button.pack(side="right", padx=(0, 10), pady=10)
     
            self.update_buttons()
     
        def create_steps(self):
            # Step 1: Welcome
            frame1 = ttk.Frame(self.container)
            label1 = ttk.Label(frame1, text="Welcome to the Repair Setup for Multiapp.exe", font=("Arial", 14))
            label1.pack(pady=20)
            self.steps.append(frame1)
     
            # Step 2: Accept Terms and Conditions
            frame2 = ttk.Frame(self.container)
            label2 = ttk.Label(frame2, text="Please read and accept the terms and conditions to continue.", font=("Arial", 12))
            label2.pack(pady=10)
     
            terms_frame = ttk.Frame(frame2)
            terms_frame.pack(fill="both", expand=True, pady=(0, 10))
     
            self.terms_text = tk.Text(terms_frame, wrap="word", width=60, height=10)
            self.terms_text.insert("1.0", "End-User License Agreement (EULA) for Multiapp.exe\n\n"
                                          "This End-User License Agreement (EULA) is a legal agreement "
                                          "between you and Tudor Marmureanu.\n\n"
                                          "This software repair program is provided 'as-is' and without "
                                          "warranty of any kind. By using this software, you agree to the "
                                          "terms and conditions outlined in this agreement.\n\n"
                                          "1. GRANT OF LICENSE. This EULA grants you the following rights: "
                                          "You may use this software to repair the Multiapp.exe program.\n"
                                          "2. DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS.\n"
                                          "   - Maintenance of Copyright Notices. You must not remove or alter any copyright "
                                          "notices on any copies of the software.\n"
                                          "   - Distribution. You may not distribute copies of the software to third parties.\n"
                                          "   - Prohibition on Reverse Engineering, Decompilation, and Disassembly. You may not "
                                          "reverse engineer, decompile, or disassemble the software.\n\n"
                                          "Tudor Marmureanu reserves all rights not expressly granted to you in this EULA.\n\n"
                                          "If you do not agree to these terms, do not install or use this software.")
            self.terms_text.config(state="disabled")  # Make the text read-only
            self.terms_text.pack(side="left", fill="both", expand=True)
     
            scrollbar = ttk.Scrollbar(terms_frame, command=self.terms_text.yview)
            scrollbar.pack(side="right", fill="y")
            self.terms_text.config(yscrollcommand=scrollbar.set)
     
            self.terms_var = tk.BooleanVar()
            terms_check = ttk.Checkbutton(frame2, text="I accept the terms and conditions", variable=self.terms_var)
            terms_check.pack(pady=10)
            self.steps.append(frame2)
     
            # Step 3: Choose Installation Directory
            frame3 = ttk.Frame(self.container)
            label3 = ttk.Label(frame3, text="Choose the installation directory (Multiapp).", font=("Arial", 12))
            label3.pack(pady=20)
            self.directory_var = tk.StringVar()
            directory_entry = ttk.Entry(frame3, textvariable=self.directory_var, width=40)
            directory_entry.pack(pady=5)
            browse_button = ttk.Button(frame3, text="Browse...", command=self.browse_directory)
            browse_button.pack(pady=5)
            self.steps.append(frame3)
     
            # Step 4: Validation Window
            frame4 = ttk.Frame(self.container)
            label4 = ttk.Label(frame4, text="Serial number validation", font=("Arial", 18, "bold"))
            label4.pack(pady=20)
     
            validation_frame = ttk.Frame(frame4)
            validation_frame.pack(expand=True)
     
            self.entry_vars = [tk.StringVar() for _ in range(5)]
            self.entries = []
            for i in range(5):
                entry = ttk.Entry(validation_frame, textvariable=self.entry_vars[i], width=8)  # Adjusted width to 5
                entry.grid(row=0, column=2 * i)
                self.entries.append(entry)
                if i < 4:
                    dash_label = ttk.Label(validation_frame, text="-")
                    dash_label.grid(row=0, column=2 * i + 1)
     
            self.steps.append(frame4)
     
            # Step 5: Installation Progress
            frame5 = ttk.Frame(self.container)
            label5 = ttk.Label(frame5, text="Running Driver...", font=("Arial", 14))
            label5.pack(pady=20)
            self.progress = ttk.Progressbar(frame5, orient="horizontal", length=300, mode="determinate")
            self.progress.pack(pady=10)
            self.steps.append(frame5)
     
        def show_step(self, step):
            for frame in self.steps:
                frame.pack_forget()
            self.steps[step].pack(fill="both", expand=True)
     
        def next(self):
            if self.current_step == 1 and not self.terms_var.get():
                messagebox.showwarning("Warning", "You must accept the terms and conditions to continue.")
                return
            if self.current_step == 2 and not self.directory_var.get():
                messagebox.showwarning("Warning", "Please choose an installation directory.")
                return
            if self.current_step == 3 and not self.validate_entries():
                messagebox.showwarning("Warning", "Validation failed. Please enter valid serial number.")
                return
     
            if self.current_step < len(self.steps) - 1:
                self.current_step += 1
                self.show_step(self.current_step)
                self.update_buttons()
     
        def back(self):
            if self.current_step > 0:
                self.current_step -= 1
                self.show_step(self.current_step)
                self.update_buttons()

        def create_accounts_file(self):
            installation_directory = self.directory_var.get()
            if not installation_directory:
                return
            
            accounts_file_path = os.path.join(installation_directory, "Accounts.txt")
            
            accounts_data = """|___user___|            |___password___|

    user            nopass
    it              copy (+- product_key)
    passgen         passgen
    quiz            test
    pausemanager    pauze (+- product_key)
    taskmanager     terminator
    launcher        launcher
    hardware        lite
    eventviewer     eventviewer

    --------------------------------------------
    terminal        terminal (+ product_key)
    passgenV2     	passgenV2 (+ product_key)
    system         	realtime (+ product_key)
    screenrec      	screenrec (+ product_key)
    zipmanager     	zipmngr (+ product_key)
    comparator     	comparator (+ product_key)
    convertorpdf   	toword (+ product_key)
    textreplace    	textfind (+ product_key)
    pdftools      	enjoyit (+ product_key)
    bandmonitoring 	networking (+ product_key)
    cryptoV2      	securitate (+ product_key)
    chatbot        	aichatbot (+ product_key)
    notepad        	notepad (+ product_key)
    paint          	paint (+ product_key)
    zippass        	wordsmith (+ product_key)
    backupmanager   	backupmngr (+ product_key)
    renamemanager  	renamer (+ product_key)
    kbmanager      	knowladgebase (+ product_key)
    kbretro         kbretro (+ product_key)
    password       	manager (+ product_key)
    junk           	manager (+ product_key)
    whiteboard     	presentation (+ product_key)
    contact        	manager (+ product_key)
    check          	devices (+ product_key)
    excel           lite (+ product_key)
    reader          office (+ product_key)
    fetcher         repair (+ product_key)
    shell           integrator (+ product_key)
    sql             editor (+ product_key)
    ide             pycharm (+ product_key)
    diagram         canvas (+ product_key)
    commander		total (+ product_key)
    calendar        calendar (+ product_key)
    alert           monitor (+ product_key)
        """

            with open(accounts_file_path, "w") as accounts_file:
                accounts_file.write(accounts_data.strip())  # Scrie datele în fișier

     
        def finish(self):
            # Your existing code for handling 'Finish' button clicks goes here
            self.log_messages()
            self.create_accounts_file()
            messagebox.showinfo("Info", "Installation completed successfully!")
            self.quit()
     
        def browse_directory(self):
            directory = filedialog.askdirectory()
            if directory:
                if not os.path.exists(os.path.join(directory, "Multiapp.exe")):
                    messagebox.showerror("Error", "Multiapp.exe not found in the selected directory.")
                    self.directory_var.set("")
                else:
                    self.directory_var.set(directory)
     
        def install_application(self):
            self.progress["value"] = 0
            self.back_button.config(state="disabled")
            self.next_button.config(state="disabled")
            self.simulate_progress()
     
        def simulate_progress(self):
            current_value = self.progress["value"]
            if current_value < 100:
                # Generăm o valoare aleatorie între 1 și 10 pentru progres
                next_value = current_value + random.randint(1, 20)
                self.progress["value"] = min(next_value, 100)  # Limităm la 100%
                self.after(900, self.simulate_progress)  # Programăm următoarea actualizare
            else:
                self.finish_button.config(state="normal")  # Activați butonul Finish
                self.back_button.config(state="normal")    # Activați butonul Back
     
     
        def validate_entries(self):
            expected_values_sets = [
                ["R46BX", "JHR2J", "PG7ER", "24QFG", "MWKVR"]
            ]
            for expected_values in expected_values_sets:
                valid = True
                for entry_var, expected in zip(self.entry_vars, expected_values):
                    if entry_var.get() != expected:
                        valid = False
                        break
                if valid:
                    return True
            return False
     
     
        def update_buttons(self):
            if self.current_step == 0:
                self.back_button.config(state="disabled")
            else:
                self.back_button.config(state="normal")
     
            if self.current_step == len(self.steps) - 1:
                self.next_button.config(state="disabled")
                self.install_application()  # Start the progress simulation
            else:
                self.next_button.config(state="normal")
                self.finish_button.config(state="disabled")
     
     
        def log_messages(self):
            messages = [
                "11002: TEXT ERROR",
                "11004: Assembly media failed",
                "11005: Running instance",
                "11009: mopad.ini running...",
                "11010: Active patch",
                "11011: Service redirection to the core",
                "11013: Data sent",
                "11014: Matching Packages",
                "11025: Assembly #-N#",
                "11027: None",
                "11028: None",
                "11029: None",
                "11030: None",
                "11031: None",
                "11032: None",
                "11033: None",
                "11034: None",
                "11035: None",
                "11036: None",
                "11037: None",
                "11038: None",
                "11039: None",
                "11040: None",
                "11041: None",
                "11042: Assembly media running...",
                "11043: Product repairing...",
                "11044: Configparser active",
                "11045: Logging successfully",
                "11056: SUCCES",
                " ",
                "DETAILES:",
                "11082: Check port connectivity - sesion 1",
                "Port: 80 open",
                "Port: 443 open",
                "11083: Check port connectivity - sesion 2",
                "Port: 21 open",
                "Port: 22 open",
                "Port: 53 close (#managed_for_this_session#: ID 3)",
                "11088: Data integrity verified",
                "11092: Configuration file updated",
                "11191: User session terminated",
                " ",
                "ENCRYPTED HEX LOG VIEW:",
                "1A SD 8U 3E 7C 91 F0 D2",
                "B5 SD 8U 9B 6A 56 CF D8 37",
                "7C SD 8U A1 B0 62 8D F0 D2",
                "F0 SD 8U 3E 84 56 CF 9B 6A",
                "3E SD 8U 7C 91 A1 B0 D8 37",
                "5F SD 8U 2A 7B E4 F9 C3",
                "A8 SD 8U 6D 3C 1F B2 9E",
                "D1 SD 8U 8E 47 F6 A9 2B",
                "7E SD 8U BC 53 DA 61 9F",
                "32 SD 8U 9D 4A 78 CE E1",
                "Timeout",
                "F5 SD 8U B8 A2 6D 1E C7",
                "8B SD 8U 37 9F E4 5C A1",
                "6E SD 8U D9 24 5A F3 81",
                "-#-",
                "-#-",
                "A7 SD 8U 12 C6 73 9F BD",
                "-#-",
                "2F SD 8U 7D 56 18 E9 A4",
                "NA",
                "NA",
                "NA",
                "FF FF FF FF FF FF FF FF"
            ]
     
            # Write messages to RepairLog.txt
            with open("RepairLog.txt", "w") as file:
                for message in messages:
                    file.write(message + "\n")
     
            def create_default_ini_file(file_path):
                if not os.path.exists(file_path):
                    mopad_ini_content = """
    [Run]
    mate = mate-terminal -x sh -c "python3 {}; exec bash"
    gnome = gnome-terminal -- sh -c "python3 {}; exec bash"
    kde = konsole --hold -e "python3 {}"
    xterm = xterm -hold -e "python3 {}"
    windows = start cmd /K python {}
    mac = open -a Terminal ./python3 {}
     
    [Terminal]
    mate = mate-terminal
    gnome = gnome-terminal
    kde = konsole
    xterm = xterm
    windows = start cmd
    mac = open -a Terminal ./
     
    [Interpreter]
    mate = mate-terminal -x "python3"
    gnome = gnome-terminal -- "python3"
    kde = konsole -e python3
    xterm = xterm python3
    windows = start cmd /K python
    mac = open -a Terminal ./python3
     
    [System]
    system = windows
     
    [Password]
    password = 
            """
                    with open(file_path, 'w') as config_file:
                        config_file.write(mopad_ini_content)
     
            # Verifică și creează fișierul ini implicit dacă nu există
            create_default_ini_file('mopad.ini')
     
            # Continuă cu citirea și procesarea configurației din fișierul ini
            config = configparser.ConfigParser()
            config.read('mopad.ini')
     
     
    def check_internet_connection():
        try:
            socket.create_connection(("www.google.com", 80))
            return True
        except OSError:
            return False
     
    if __name__ == "__main__":
        if check_internet_connection():
            app = SetupWizard()
            app.mainloop()
        else:
            messagebox.showerror("Error", "No internet connection detected. Please check your connection and try again.")
            exit()

if shellvar == 1996:
    import os
    import sys
    import socket
    import time
    import random
    import subprocess
    from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                                 QPushButton, QLineEdit, QTextEdit, QMessageBox)
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    # Commands and simulated messages
    messages = {
        "init": "The precondition has been initialized.",
        "powercli Multiapp.exe -t":"On",
        "getscan register mov eax, eay: shell True":"",
        "getscan register mov eax, eay: shell False":"",
        "getscan register mov ebx, eby: shell True":"",
        "getscan register mov ebx, eby: shell False":"",
        "getscan register mov ecx, ecy: shell True":"",
        "getscan register mov ecx, ecy: shell False":"",
        "getscan register add eax, eay: shell True":"",
        "getscan register add eax, eay: shell False":"",
        "getscan register add ebx, eby: shell True":"",
        "getscan register add ebx, eby: shell False":"",
        "getscan register add ecx, ecy: shell True":"",
        "getscan register add ecx, ecy: shell False":"",
        "getscan register div eax, eay: shell True":"",
        "getscan register div eax, eay: shell False":"",
        "getscan register div ebx, eby: shell True":"",
        "getscan register div ebx, eby: shell False":"",
        "getscan register div ecx, ecy: shell True":"",
        "getscan register div ecx, ecy: shell False":"",
        "1/0,12": "Register OK.",
        "0/0,8": "Register OK.",
        "1/0,12": "None",
        "1/0,8": "None",
        "0/0,12": "None",
        "0/0,8": "None",
        "0/0,12": "None",
        "1/0,8": "None",
        "start,1/0/0": "eax=1;\neay=0;",
        "start,1/1/0": "eax=1;\neay=1;",
        "start,1/1/0": "eax=1;\neay=1;",
        "start,0/1/0": "eax=0;\neay=1;",
        "restart_service": "The service has been restarted.",
        "X/1,0": "256 Bytes",
        "X/1,1": "16 Bytes",
        "X/0,1": "8 Bytes",
        "X/0,0": "None",
        "CLI/1/0/0,t": "Positive_Response()",
        "cfg,0/0/1":"Session terminated.",
        "cfg,0/1/1":"Session restarted.",
        "cfg,1/0/1":"Error: No edx value.",
        "cfg,1/1/1":"Error: Failed configuration.",
        "launch_multiapp": "Launching Multiapp.exe..."
    }

    app = QApplication(sys.argv)

    file_path = os.getcwd()

    def create_accounts_file():
        installation_directory = os.getcwd()
        if not installation_directory:
            return
            
        accounts_file_path = os.path.join(installation_directory, "Accounts.txt")
            
        accounts_data = """|___user___|            |___password___|

    user            nopass
    it              copy (+- product_key)
    passgen         passgen
    quiz            test
    pausemanager    pauze (+- product_key)
    taskmanager     terminator
    launcher        launcher
    hardware        lite
   eventviewer      eventviewer

    --------------------------------------------
    terminal        terminal (+ product_key)
    passgenV2     	passgenV2 (+ product_key)
    system         	realtime (+ product_key)
    screenrec      	screenrec (+ product_key)
    zipmanager     	zipmngr (+ product_key)
    comparator     	comparator (+ product_key)
    convertorpdf   	toword (+ product_key)
    textreplace    	textfind (+ product_key)
    pdftools      	enjoyit (+ product_key)
    bandmonitoring 	networking (+ product_key)
    cryptoV2      	securitate (+ product_key)
    chatbot        	aichatbot (+ product_key)
    notepad        	notepad (+ product_key)
    paint          	paint (+ product_key)
    zippass        	wordsmith (+ product_key)
    backupmanager   	backupmngr (+ product_key)
    renamemanager  	renamer (+ product_key)
    kbmanager      	knowladgebase (+ product_key)
    kbretro         kbretro (+ product_key)
    password       	manager (+ product_key)
    junk           	manager (+ product_key)
    whiteboard     	presentation (+ product_key)
    contact        	manager (+ product_key)
    check          	devices (+ product_key)
    excel           lite (+ product_key)
    reader          office (+ product_key)
    fetcher         repair (+ product_key)
    shell           integrator (+ product_key)
    sql             editor (+ product_key)
    ide             pycharm (+ product_key)
    diagram         canvas (+ product_Key)
    commander		total (+ product_key)
    calendar        calendar (+ product_key)
    alert           monitor (+ product_key)
        """

        with open(accounts_file_path, "w") as accounts_file:
            accounts_file.write(accounts_data.strip())  # Scrie datele în fișier

    create_accounts_file()

    # Display error as a popup window using PyQt5
    def show_error(title, message):
        error_box = QMessageBox()
        error_box.setIcon(QMessageBox.Critical)
        error_box.setWindowTitle(title)
        error_box.setText(message)
        error_box.exec_()
        sys.exit(1)  # Close application after showing error

    # Check internet connection
    def check_internet():
        try:
            socket.create_connection(("www.google.com", 80), timeout=5)
            return True
        except OSError:
            show_error("Error", "You are not connected to the internet.")
            return False
    '''
    # Check if 'Multiapp.exe' exists in the same folder
    def check_file():
        if os.path.isfile("Multiapp.exe"):
            return True
        else:
            show_error("Error", "'Multiapp.exe' file not found in the same folder.")
            return False
    '''

    # Save each output to log.txt
    def save_to_log(command, response):
        with open("log.txt", "a") as log:
            log.write(f"Command: {command}\nResponse: {response}\n---\n")

    # Process command and save to log
    def process_command(command):
        if command in messages:
            response = messages[command]
            if command == "launch_multiapp":  # Launch Multiapp.exe
                try:
                    subprocess.Popen(["Multiapp.exe"], shell=True)  # Start the executable
                except Exception as e:
                    response = f"Failed to launch Multiapp.exe: {str(e)}"
        else:
            response = "Unknown command. Please try again."
        save_to_log(command, response)
        return response

    # Simulate commands in command line
    def simulate_command_cli():
        while True:
            command = input("Enter a command: ")
            response = process_command(command)

            # Introduce a random delay between 1 and 3 seconds
            time.sleep(random.randint(1, 3))

            print(f"Response: {response}")

    # GUI application class
    class CommandSimulatorApp(QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle("Shell Integrator")
            self.setGeometry(100, 100, 400, 300)

            self.central_widget = QWidget()
            self.setCentralWidget(self.central_widget)

            self.layout = QVBoxLayout()
            self.central_widget.setLayout(self.layout)

            self.command_input = QLineEdit(self)
            self.command_input.setPlaceholderText("Enter a command...")
            self.command_input.returnPressed.connect(self.submit_command)  # Connect Enter key
            self.layout.addWidget(self.command_input)

            self.submit_button = QPushButton("Submit", self)
            self.submit_button.clicked.connect(self.submit_command)
            self.layout.addWidget(self.submit_button)

            self.response_display = QTextEdit(self)
            self.response_display.setReadOnly(True)
            self.layout.addWidget(self.response_display)

        def submit_command(self):
            command = self.command_input.text()
            response = process_command(command)

            # Introduce a random delay between 1 and 3 seconds
            time.sleep(random.randint(1, 3))

            self.response_display.append(f"Command: {command}\nResponse: {response}\n")
            self.command_input.clear()

    # CLI mode function
    def run_cli_mode():
        simulate_command_cli()

    # GUI mode function
    def run_gui_mode():
        window = CommandSimulatorApp()
        window.show()
        sys.exit(app.exec_())

    # Main function
    def main():
        # Initial checks
        if not check_internet(): # or not check_file()
            sys.exit(1)  # Close the application if any check fails

        # Ask user to choose mode
        mode = input("Choose mode: Enter '1' for Command Line or '2' for GUI: ")
        if mode == '1':
            run_cli_mode()
        elif mode == '2':
            run_gui_mode()
        else:
            print("Invalid choice. Please restart the application and choose 1 or 2.")

    if __name__ == "__main__":
        main()
        
if w95var == 1997:
    #import tkinter as tk
    #from tkinter import messagebox, filedialog
    #import time
    #import platform
    #import psutil
    #import os
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    def check_and_create_counter():
        pass
    
    def run_instance_checker():
        class Windows95Simulator:
            def __init__(self, root_inst):
                self.root_inst = root_inst
                self.root_inst.title("Virtual Instance Checker")
                self.root_inst.geometry("1024x768")
                self.root_inst.configure(bg='#008080')
                self.is_fullscreen = False  # Variabilă pentru a urmări starea fullscreen
                
                # Obținem dimensiunile ecranului
                screen_width = self.root_inst.winfo_screenwidth()
                screen_height = self.root_inst.winfo_screenheight()
                
                # Dimensiunile ferestrei
                window_width = 1024
                window_height = 768
                
                # Calculăm poziția pentru centrul ecranului
                position_top = int((screen_height / 2) - (window_height / 2))
                position_right = int((screen_width / 2) - (window_width / 2))
                
                # Setăm geometria ferestrei (dimensiuni și poziție)
                self.root_inst.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')
                
                # Background image (desktop wallpaper)
                self.desktop_bg = tk.Label(self.root_inst, bg='#008080', width=1024, height=768)
                self.desktop_bg.place(x=0, y=0)  # Plasare pe fundal
                
                # Taskbar
                self.taskbar = tk.Frame(self.root_inst, bg='gray', height=30)
                self.taskbar.pack(side='bottom', fill='x')
                
                # Start button
                self.start_button = tk.Button(self.taskbar, text='Start', width=10, height=2, bg='#8c8c8c', fg='white', font=("Fixedsys"), command=self.toggle_start_menu)
                self.start_button.pack(side='left')
                
                # Clock
                self.clock_label = tk.Label(self.taskbar, bg='gray', fg='white', font=("Fixedsys"))
                self.clock_label.pack(side='right', padx=10)
                self.update_clock()
                
                # Start menu
                self.start_menu = tk.Frame(self.root_inst, bg='lightgray', width=200, height=300)
                self.start_menu.place(x=0, y=728, anchor='sw')
                self.start_menu_visible = False
                
                # Meniu Start cu submeniuri
                self.apps_frame = tk.Frame(self.start_menu, bg='lightgray')
                self.apps_frame.pack(fill='both', expand=True)
                
                self.create_start_menu()
                
                self.start_menu.lower()
                
                # Taskbar running apps
                self.running_apps = {}
                
            def create_activation_window(self, window):
                import os
                from tkinter import messagebox
                window.title("Activation Wizard")  # Titlul ferestrei
                window.geometry("400x200")
                window.configure(bg="#c9c9c9")
                # Mesaj
                label = tk.Label(window, text="Enter your product key:", font=("Fixedsys"), bg="#c9c9c9")
                label.pack(pady=10)
                # Câmp de introducere a cheii
                product_key_entry = tk.Entry(window, font=("Fixedsys"), width=30, bd=5)
                product_key_entry.pack(pady=5)
                # Butonul de activare (inițial dezactivat)
                activate_button = tk.Button(
                    window, text="Activate", font=("Fixedsys"), state=tk.DISABLED, bd=5, bg="#c9c9c9", 
                    command=lambda: activate_product()
                )
                activate_button.pack(pady=5)
                # Butonul "Activate later" -> elimină aplicația din taskbar
                later_button = tk.Button(
                    window, text="Activate later", font=("Fixedsys"), bd=5, bg="#c9c9c9", 
                    command=lambda: self.close_app("Product Activation", window)
                )
                later_button.pack(pady=5)
                # Funcție pentru activare
                def activate_product():
                    product_key = product_key_entry.get()
                    valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
                    FOLDER_NAME = "Serial"
                    FILE_NAME = "product_key.lic95"
                    
                    if not os.path.exists(FOLDER_NAME):
                        try:
                            os.makedirs(FOLDER_NAME)
                        except:
                            pass
                            
                    if product_key == valid_key:
                        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                        # Verificăm dacă fișierul există deja
                        if not os.path.exists(file_path):
                            with open(file_path, "w") as file:
                                file.write(valid_key)
                        messagebox.showinfo("Activation Successful", "Product has been activated successfully.")
                        self.close_app("Product Activation", window)  # Închide corect aplicația
                    else:
                        messagebox.showerror("Activation Failed", "Invalid product key. Please try again.")
                        
                # Funcție pentru validarea cheii în timp real
                def validate_key(event):
                    if product_key_entry.get() == "R46BX-JHR2J-PG7ER-24QFG-MWKVR":
                        activate_button.config(state=tk.NORMAL)  # Activează butonul dacă cheia este corectă
                    else:
                        activate_button.config(state=tk.DISABLED)  # Dezactivează butonul dacă cheia e greșită
                product_key_entry.bind("<KeyRelease>", validate_key)  # Verifică validitatea în timp real

            def activate_product(self, product_key, window):
                import os
                from tkinter import messagebox
                
                FOLDER_NAME = "Serial"
                FILE_NAME = "product_key.lic95"
                
                if not os.path.exists(FOLDER_NAME):
                    try:
                        os.makedirs(FOLDER_NAME)
                    except:
                        pass
                        
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
                
                # Verifică dacă fișierul există deja
                try:
                    with open(file_path, "r") as file:
                        existing_key = file.read().strip()
                        if existing_key == valid_key:
                            messagebox.showinfo("Activation", "Product is already activated!")
                            window.destroy()
                            return
                except FileNotFoundError:
                    pass  # Fișierul nu există, deci putem continua activarea
                
                # Salvează cheia de produs
                with open(file_path, "w") as file:
                    file.write(valid_key)
                
                messagebox.showinfo("Activation", "Product activated successfully!")
                window.destroy()

            def shutdown(self):
                self.root_inst.destroy()  # Închide aplicația
            
            def soundwav(self):
                import winsound
                winsound.Beep(500, 200)
                
            def beeps(self):
                import winsound
                beep_sounds = [
                (500, 200),  # Sunet 1: 500 Hz, 200 ms
                (700, 150),  # Sunet 2: 700 Hz, 150 ms
                (900, 100),  # Sunet 3: 900 Hz, 100 ms
                (600, 300)   # Sunet 4: 600 Hz, 300 ms
                ]
                sound = random.choice(beep_sounds)
                winsound.Beep(sound[0], sound[1])
            
            def create_start_menu(self):
                self.activation_button = tk.Button(self.apps_frame, text='Product Activation', font=("Fixedsys"), command=lambda: self.open_app("Product Activation"))
                self.activation_button.pack(fill='x')
                
                self.notepad_button = tk.Button(self.apps_frame, text='Notepad', font=("Fixedsys"), command=lambda: self.open_app("Notepad"))
                self.notepad_button.pack(fill='x')
                
                self.about_button = tk.Button(self.apps_frame, text='About Window', font=("Fixedsys"), command=lambda: self.open_app("About Window"))
                self.about_button.pack(fill='x')
                
                # Butonul Fullscreen în meniul Start
                self.fullscreen_button = tk.Button(self.apps_frame, text='Fullscreen', font=("Fixedsys"), command=self.toggle_fullscreen)
                self.fullscreen_button.pack(fill='x')
                
                # Add new SQL Explorer button
                self.sql_explorer_button = tk.Button(self.apps_frame, text='SQL Explorer', font=("Fixedsys"), command=self.open_sql_explorer)
                self.sql_explorer_button.pack(fill='x')
                
                # Buton de Shutdown
                self.shutdown_button = tk.Button(self.apps_frame, text='Shutdown', font=("Fixedsys"), command=self.shutdown)
                self.shutdown_button.pack(fill='x')
                
                self.sound_button = tk.Button(self.apps_frame, text='Sound', font=("Fixedsys"), command=self.soundwav)
                self.sound_button.pack(fill='x')
                
                self.sound1_button = tk.Button(self.apps_frame, text='Random Sound', font=("Fixedsys"), command=self.beeps)
                self.sound1_button.pack(fill='x')
            
            def toggle_start_menu(self):
                if self.start_menu_visible:
                    self.start_menu.lower()
                else:
                    self.start_menu.lift()
                self.start_menu_visible = not self.start_menu_visible
            
            def open_app(self, app_name):
                if app_name in self.running_apps:
                    return
                
                window = tk.Toplevel(self.root_inst)
                window.title(app_name)
                window.geometry("600x400")
                window.protocol("WM_DELETE_WINDOW", lambda: self.close_app(app_name, window))
                
                if app_name == "Notepad":
                    self.create_notepad(window)
                elif app_name == "About Window":
                    self.create_about_window(window)
                    
                elif app_name == "Product Activation":
                    self.create_activation_window(window)
                
                taskbar_button = tk.Button(self.taskbar, text=app_name, font=("Fixedsys"), command=lambda: self.toggle_app_visibility(app_name, window), bg='darkgray', fg='white', height=2)
                taskbar_button.pack(side='left')
                
                self.running_apps[app_name] = {'window': window, 'button': taskbar_button}
                
                self.start_menu.lower()
                self.start_menu_visible = False
            
            def close_app(self, app_name, window):
                window.destroy()
                self.running_apps[app_name]['button'].destroy()
                del self.running_apps[app_name]
            
            def toggle_app_visibility(self, app_name, window):
                if window.state() == "normal":
                    window.withdraw()
                else:
                    window.deiconify()
            
            def update_clock(self):
                current_time = time.strftime('%H:%M:%S')
                self.clock_label.config(text=current_time, font=("Fixedsys"))
                self.root_inst.after(1000, self.update_clock)
            
            def toggle_fullscreen(self):
                self.is_fullscreen = not self.is_fullscreen
                if self.is_fullscreen:
                    self.root_inst.attributes('-fullscreen', True)
                else:
                    self.root_inst.attributes('-fullscreen', False)
            
            def create_notepad(self, window):
                text_area = tk.Text(window, font=("Fixedsys"))
                text_area.pack(fill='both', expand=True)
                
                # Adăugăm un tag pentru culoarea gri
                text_area.tag_configure("placeholder", foreground="#c7c7c7")
                
                # Textul prestabilit care va apărea la început
                placeholder_text = "This instance helps you check if the system requirements of the computer running Multiapp Professional are compatible with the recommended minimum requirements. Click on the About Window button in the Start Menu to perform this check. To continue booting into Multiapp Professional, click on the Shutdown button in the Start Menu. For Multiapp to function, it must be activated using a product key. This can be done from the Product Activation section."
                text_area.insert(tk.END, placeholder_text)
                
                # Aplicăm tag-ul gri pe întregul text prestabilit
                text_area.tag_add("placeholder", "1.0", "end")
                
                # Funcția pentru a șterge textul prestabilit când utilizatorul începe să scrie
                def on_focus_in(event):
                    if text_area.get("1.0", tk.END).strip() == placeholder_text:
                        text_area.delete("1.0", tk.END)
                
                # Funcția pentru a șterge textul prestabilit când utilizatorul pune cursorul
                def on_key_press(event):
                    if text_area.get("1.0", tk.END).strip() == placeholder_text:
                        text_area.delete("1.0", tk.END)

                # Legăm evenimentele la funcțiile corespunzătoare
                text_area.bind("<FocusIn>", on_focus_in)  # Când fereastra primește focus
                text_area.bind("<KeyPress>", on_key_press)  # Când utilizatorul apasă o tastă
                
                # Adăugăm un meniu pentru a salva și deschide fișiere
                menu_bar = tk.Menu(window)
                file_menu = tk.Menu(menu_bar, tearoff=0)
                file_menu.add_command(label='Save', command=lambda: self.save_file(text_area))
                file_menu.add_command(label='Open', command=lambda: self.open_file(text_area))
                menu_bar.add_cascade(label='File', menu=file_menu)
                window.config(menu=menu_bar)
            def open_sql_explorer(self):
                # Close the start menu
                self.start_menu.lower()
                self.start_menu_visible = False
                
                # Create SQL Explorer window directly
                sql_window = tk.Toplevel(self.root_inst)
                
                # Import required modules for SQL Explorer
                import sqlite3
                import os
                
                class Win95SQLViewer:
                    def __init__(self, root):
                        self.root = root
                        self.root.title("SQL Explorer")
                        self.root.geometry("800x600")
                        
                        # Win95 color palette
                        self.colors = {
                            "bg_main": "#c0c0c0",         # Classic Win95 gray background
                            "bg_window": "#ffffff",        # Window background
                            "text": "#000000",             # Black text
                            "button_face": "#c0c0c0",      # Button face color
                            "button_shadow": "#808080",    # Button shadow
                            "button_highlight": "#ffffff", # Button highlight
                            "button_text": "#000000",      # Button text
                            "title_bg": "#000080",         # Title bar background (navy blue)
                            "title_text": "#ffffff",       # Title bar text (white)
                            "border": "#808080"            # Border color
                        }
                        
                        self.root.configure(bg=self.colors["bg_main"])
                        self.connection = None
                        self.current_table = None
                        
                        # Configure styles
                        self.setup_styles()
                        
                        # Create interface
                        self.create_widgets()
                        self.create_menu()
                    
                    def setup_styles(self):
                        # Set app font to match Win95 style
                        self.default_font = ("MS Sans Serif", 9)
                        self.root.option_add("*Font", self.default_font)
                        
                        style = ttk.Style()
                        
                        # Configure treeview style
                        style.configure(
                            "Treeview",
                            background=self.colors["bg_window"],
                            foreground=self.colors["text"],
                            fieldbackground=self.colors["bg_window"],
                            borderwidth=1,
                            relief=tk.SUNKEN
                        )
                        
                        # Configure treeview heading
                        style.configure(
                            "Treeview.Heading",
                            background=self.colors["button_face"],
                            foreground=self.colors["text"],
                            relief=tk.RAISED,
                            borderwidth=2,
                            font=self.default_font
                        )
                        
                        # Configure scrollbar
                        style.configure(
                            "TScrollbar",
                            background=self.colors["button_face"],
                            troughcolor=self.colors["bg_window"],
                            borderwidth=2,
                            relief=tk.RAISED,
                            arrowsize=13
                        )
                        
                        # Configure combobox
                        style.configure(
                            "TCombobox",
                            background=self.colors["bg_window"],
                            fieldbackground=self.colors["bg_window"],
                            selectbackground=self.colors["title_bg"],
                            selectforeground=self.colors["title_text"]
                        )
                    
                    def create_menu(self):
                        # Create classic Win95 menu style
                        menubar = tk.Menu(self.root, bg=self.colors["bg_main"], fg=self.colors["text"],
                                        activebackground=self.colors["title_bg"],
                                        activeforeground=self.colors["title_text"],
                                        relief=tk.RAISED, bd=1)
                        self.root.config(menu=menubar)
                        
                        # File menu
                        file_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_main"],
                                            fg=self.colors["text"],
                                            activebackground=self.colors["title_bg"],
                                            activeforeground=self.colors["title_text"], bd=1)
                        file_menu.add_command(label="Open Database...", command=self.open_database)
                        file_menu.add_separator()
                        file_menu.add_command(label="Exit", command=self.root.destroy)
                        menubar.add_cascade(label="File", menu=file_menu)
                        
                        # Edit menu
                        edit_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_main"],
                                        fg=self.colors["text"],
                                        activebackground=self.colors["title_bg"],
                                        activeforeground=self.colors["title_text"], bd=1)
                        edit_menu.add_command(label="Refresh", command=self.refresh_tables)
                        edit_menu.add_command(label="Execute Query", command=self.execute_query)
                        menubar.add_cascade(label="Edit", menu=edit_menu)
                    
                    def create_widgets(self):
                        # Add title bar-like frame at top
                        title_frame = tk.Frame(self.root, bg=self.colors["title_bg"], height=22)
                        title_frame.pack(fill=tk.X, padx=3, pady=(3,0))
                        
                        title_label = tk.Label(
                            title_frame,
                            text="SQL Explorer",
                            bg=self.colors["title_bg"],
                            fg=self.colors["title_text"],
                            font=("MS Sans Serif", 9, "bold"),
                            padx=5,
                            pady=2
                        )
                        title_label.pack(side=tk.LEFT)
                        
                        # Main window frame (inset look)
                        main_frame = tk.Frame(
                            self.root, 
                            bg=self.colors["bg_main"],
                            bd=2,
                            relief=tk.RAISED
                        )
                        main_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
                        
                        # Toolbar frame
                        toolbar = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=0)
                        toolbar.pack(fill=tk.X, pady=(2, 5), padx=2)
                        
                        # Table selection frame
                        control_frame = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=0)
                        control_frame.pack(fill=tk.X, pady=(0, 5), padx=5)
                        
                        # Table label
                        table_label = tk.Label(
                            control_frame,
                            text="Tables:",
                            bg=self.colors["bg_main"],
                            fg=self.colors["text"]
                        )
                        table_label.pack(side=tk.LEFT, padx=(0, 5))
                        
                        # Table dropdown with Win95 style
                        self.table_combo = ttk.Combobox(
                            control_frame,
                            state="readonly",
                            width=30
                        )
                        self.table_combo.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
                        self.table_combo.bind("<<ComboboxSelected>>", self.load_table)
                        
                        # Refresh button
                        refresh_button = self.create_win95_button(
                            control_frame, 
                            text="Refresh",
                            command=self.refresh_tables
                        )
                        refresh_button.pack(side=tk.RIGHT, padx=2)
                        
                        # Query frame
                        query_frame = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=0)
                        query_frame.pack(fill=tk.X, pady=(0, 5), padx=5)
                        
                        # Query label
                        query_label = tk.Label(
                            query_frame,
                            text="SQL Query:",
                            bg=self.colors["bg_main"],
                            fg=self.colors["text"]
                        )
                        query_label.pack(side=tk.LEFT, padx=(0, 5))
                        
                        # Query text entry (sunken, like Win95)
                        self.query_entry = tk.Entry(
                            query_frame,
                            bg=self.colors["bg_window"],
                            fg=self.colors["text"],
                            bd=2,
                            relief=tk.SUNKEN,
                            insertbackground=self.colors["text"],
                            font=("Courier New", 10)
                        )
                        self.query_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
                        
                        # Execute button
                        execute_button = self.create_win95_button(
                            query_frame, 
                            text="Execute",
                            command=self.execute_query
                        )
                        execute_button.pack(side=tk.RIGHT, padx=2)
                        
                        # Frame for treeview
                        table_frame = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=2, relief=tk.SUNKEN)
                        table_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))
                        
                        # Create treeview with scrollbars
                        self.tree = ttk.Treeview(table_frame)
                        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                        
                        # Vertical scrollbar
                        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
                        vsb.pack(side=tk.RIGHT, fill=tk.Y)
                        self.tree.configure(yscrollcommand=vsb.set)
                        
                        # Horizontal scrollbar
                        hsb = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
                        hsb.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=(0, 5))
                        self.tree.configure(xscrollcommand=hsb.set)
                        
                        # Status bar
                        self.status_var = tk.StringVar()
                        self.status_var.set("Ready")
                        
                        # Status bar with Win95 inset look
                        status_frame = tk.Frame(self.root, bd=2, relief=tk.SUNKEN)
                        status_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=3, pady=3)
                        
                        self.status_bar = tk.Label(
                            status_frame,
                            textvariable=self.status_var,
                            bg=self.colors["bg_main"],
                            fg=self.colors["text"],
                            anchor=tk.W,
                            bd=1,
                            padx=5,
                            pady=2
                        )
                        self.status_bar.pack(fill=tk.X)
                    
                    def create_win95_button(self, parent, text, command):
                        """Create a button with typical Windows 95 appearance"""
                        button_frame = tk.Frame(parent, bd=2, relief=tk.RAISED)
                        
                        button = tk.Button(
                            button_frame,
                            text=text,
                            bg=self.colors["button_face"],
                            fg=self.colors["button_text"],
                            activebackground=self.colors["button_face"],
                            activeforeground=self.colors["button_text"],
                            bd=2,
                            width=10,
                            command=command,
                            relief=tk.RAISED,
                            padx=6,
                            pady=1,
                            font=self.default_font
                        )
                        button.pack(padx=1, pady=1)
                        
                        # Windows 95 button press effect
                        button.bind("<ButtonPress-1>", lambda e: button_frame.config(relief=tk.SUNKEN))
                        button.bind("<ButtonRelease-1>", lambda e: button_frame.config(relief=tk.RAISED))
                        
                        return button_frame
                    
                    def open_database(self):
                        file_path = filedialog.askopenfilename(
                            title="Open Database",
                            filetypes=[("SQLite Files", "*.db *.sqlite *.sqlite3"), ("All Files", "*.*")]
                        )
                        
                        if file_path:
                            try:
                                if self.connection:
                                    self.connection.close()
                                
                                self.connection = sqlite3.connect(file_path)
                                self.refresh_tables()
                                self.status_var.set(f"Database: {os.path.basename(file_path)}")
                                messagebox.showinfo("Success", "Database opened successfully!")
                            except sqlite3.Error as e:
                                messagebox.showerror("Error", f"Could not open database: {e}")
                                self.status_var.set("Error opening database.")
                    
                    def refresh_tables(self):
                        if not self.connection:
                            messagebox.showwarning("Warning", "No database is open!")
                            return
                        
                        try:
                            cursor = self.connection.cursor()
                            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                            tables = cursor.fetchall()
                            
                            self.table_combo['values'] = [table[0] for table in tables]
                            if tables:
                                self.table_combo.current(0)
                                self.load_table(None)
                            else:
                                messagebox.showinfo("Info", "No tables found in this database.")
                                self.clear_tree()
                        except sqlite3.Error as e:
                            messagebox.showerror("Error", f"Could not load tables: {e}")
                    
                    def load_table(self, event):
                        if not self.connection:
                            return
                        
                        selected_table = self.table_combo.get()
                        if not selected_table:
                            return
                        
                        self.current_table = selected_table
                        self.query_entry.delete(0, tk.END)
                        self.query_entry.insert(0, f"SELECT * FROM {selected_table}")
                        
                        try:
                            cursor = self.connection.cursor()
                            cursor.execute(f"PRAGMA table_info({selected_table})")
                            columns = cursor.fetchall()
                            
                            cursor.execute(f"SELECT * FROM {selected_table} LIMIT 1000")
                            rows = cursor.fetchall()
                            
                            self.display_data(columns, rows)
                            self.status_var.set(f"Table: {selected_table} | {len(rows)} records")
                        except sqlite3.Error as e:
                            messagebox.showerror("Error", f"Could not load table: {e}")
                    
                    def execute_query(self):
                        if not self.connection:
                            messagebox.showwarning("Warning", "No database is open!")
                            return
                        
                        query = self.query_entry.get().strip()
                        if not query:
                            messagebox.showwarning("Warning", "Enter a valid query!")
                            return
                        
                        try:
                            cursor = self.connection.cursor()
                            cursor.execute(query)
                            
                            if query.upper().startswith(("SELECT", "PRAGMA")):
                                # Read query - display results
                                columns = [description[0] for description in cursor.description]
                                rows = cursor.fetchall()
                                
                                self.display_data_from_query(columns, rows)
                                self.status_var.set(f"Query executed: {len(rows)} results")
                            else:
                                # Modification query - confirm transaction
                                self.connection.commit()
                                affected = cursor.rowcount
                                messagebox.showinfo("Success", f"Query executed successfully! Rows affected: {affected}")
                                
                                # Refresh current table if exists
                                if self.current_table:
                                    self.load_table(None)
                                
                                self.status_var.set(f"Query executed: {affected} rows affected")
                        except sqlite3.Error as e:
                            messagebox.showerror("Error", f"Error executing query: {e}")
                    
                    def display_data(self, columns, rows):
                        self.clear_tree()
                        
                        # Configure treeview columns
                        column_names = [col[1] for col in columns]
                        
                        self.tree["columns"] = column_names
                        
                        # Hide default column
                        self.tree.column("#0", width=0, stretch=tk.NO)
                        
                        # Configure each column
                        for name in column_names:
                            self.tree.column(name, anchor=tk.W, width=150)
                            self.tree.heading(name, text=name, anchor=tk.W)
                        
                        # Add data
                        for i, row in enumerate(rows):
                            values = [str(val) if val is not None else "NULL" for val in row]
                            self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
                        
                        # Alternate row colors (classic Win95 style)
                        self.tree.tag_configure('even', background=self.colors["bg_window"])
                        self.tree.tag_configure('odd', background="#ececec")  # Light gray for alternating rows
                    
                    def display_data_from_query(self, column_names, rows):
                        self.clear_tree()
                        
                        self.tree["columns"] = column_names
                        
                        # Hide default column
                        self.tree.column("#0", width=0, stretch=tk.NO)
                        
                        # Configure each column
                        for name in column_names:
                            self.tree.column(name, anchor=tk.W, width=150)
                            self.tree.heading(name, text=name, anchor=tk.W)
                        
                        # Add data
                        for i, row in enumerate(rows):
                            values = [str(val) if val is not None else "NULL" for val in row]
                            self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
                        
                        # Alternate row colors
                        self.tree.tag_configure('even', background=self.colors["bg_window"])
                        self.tree.tag_configure('odd', background="#ececec")
                    
                    def clear_tree(self):
                        for item in self.tree.get_children():
                            self.tree.delete(item)
                        
                        for col in self.tree["columns"]:
                            self.tree.heading(col, text="")
                        
                        self.tree["columns"] = []
                
                # Make sure ttk is imported
                from tkinter import ttk
                
                # Create the SQL viewer instance and pass the toplevel window
                sql_app = Win95SQLViewer(sql_window)
                
                # Register in taskbar
                taskbar_button = tk.Button(self.taskbar, text="SQL Explorer", font=("Fixedsys"), 
                                         command=lambda: self.toggle_app_visibility("SQL Explorer", sql_window), 
                                         bg='darkgray', fg='white', height=2)
                taskbar_button.pack(side='left')
                
                # Add to running apps dictionary
                self.running_apps["SQL Explorer"] = {'window': sql_window, 'button': taskbar_button}
                
                # Configure window close event
                sql_window.protocol("WM_DELETE_WINDOW", lambda: self.close_app("SQL Explorer", sql_window))
            
            def save_file(self, text_area):
                file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
                if file_path:
                    with open(file_path, "w") as file:
                        file.write(text_area.get("1.0", tk.END))
            
            def open_file(self, text_area):
                file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
                if file_path:
                    with open(file_path, "r") as file:
                        text_area.delete("1.0", tk.END)
                        text_area.insert("1.0", file.read())
            
            def create_about_window(self, window):
                sys_info = platform.uname()
                system_version = sys_info.system
                processor_info = platform.processor()
                
                # Specificațiile minime
                min_os = "Windows 10 (x64)"
                min_processor_speed = 1  # GHz
                min_ram = 4  # GB
                min_disk_space = 300  # MB
                
                # Obținem informațiile sistemului
                os_version = sys_info.release
                ram = psutil.virtual_memory().total / (1024 ** 3)  # RAM în GB
                processor_speed = float(processor_info.split()[2].split('GHz')[0])  # extragem valoarea GHz
                is_x64 = sys_info.machine in ["x86_64", "AMD64"]  # Verificăm dacă este sistem x64 (AMD64 sau x86_64)
                
                # Verificăm dacă sistemul îndeplinește cerințele minime
                meets_requirements = True
                requirements_message = "Meets minimum requirements"
                
                if system_version != "Windows" or not is_x64:
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: OS is not Windows x64."
                
                # Verificăm dacă versiunea este 10 sau mai mare
                major_version = int(os_version.split('.')[0])
                if major_version < 10:
                    meets_requirements = False
                    requirements_message = f"Does not meet minimum requirements: OS version is older than Windows 10 (Detected: Windows {major_version})."
                
                if processor_speed < min_processor_speed:
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: Processor speed is too low."
                
                # Verificăm RAM-ul
                if ram < min_ram:
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: RAM is too low."
                
                # Verificăm dacă există suficient spațiu pe disc
                if system_version == "Windows":
                    disk_space = psutil.disk_usage('/').free / (1024 ** 2)  # spațiu liber în MB
                    if disk_space < min_disk_space:
                        meets_requirements = False
                        requirements_message = "Does not meet minimum requirements: Insufficient disk space."
                
                window.configure(bg='#c9c9c9')
                
                # Creăm layout-ul pentru fereastra de 'About'
                frame = tk.Frame(window, bg='#c9c9c9')
                frame.pack(padx=10, pady=10)

                # Specificațiile minime
                min_specs = tk.Label(frame, text=f"Minimum Requirements:\nOS: {min_os}\nProcessor: {min_processor_speed} GHz\nRAM: {min_ram} GB\nDisk space: {min_disk_space} MB free", font=("Fixedsys", 12), bg='#c9c9c9')
                min_specs.grid(row=0, column=0, padx=10, pady=10, sticky='w')
                
                # Specificațiile curente
                current_specs = tk.Label(frame, text=f"Your System:\nOS: {system_version} {os_version} {sys_info.machine}\nProcessor: {processor_speed} GHz\nRAM: {ram:.2f} GB\nDisk space: {disk_space:.2f} MB free", font=("Fixedsys", 12), bg='#c9c9c9')
                current_specs.grid(row=0, column=1, padx=10, pady=10, sticky='w')
                
                # Mesajul de cerințe
                color = "green" if meets_requirements else "red"
                result_label = tk.Label(window, text=requirements_message, font=("Fixedsys", 14), fg=color, bg='#c9c9c9')
                result_label.pack(pady=10)

        if __name__ == '__main__':
            root_inst = tk.Tk()
            app = Windows95Simulator(root_inst)
            root_inst.mainloop()

    run_instance_checker()
    
if sqllvar == 22222:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    import sqlite3
    import os
    
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class DarkThemeSQLViewer(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("SQL Explorer")
            self.geometry("900x700")
            
            # Culori pentru tema întunecată
            self.colors = {
                "bg_main": "#121212",          # Fundal principal
                "bg_secondary": "#1A1A1A",     # Fundal secundar
                "bg_input": "#252525",         # Fundal pentru elemente interactive
                "text_primary": "#E0E0E0",     # Text principal
                "text_secondary": "#AAAAAA",   # Text secundar
                "accent": "#9C27B0",           # Accent violet închis
                "accent_hover": "#BB86FC",     # Accent violet deschis pentru hover
                "warning": "#F44336",          # Culoare avertisment
                "success": "#4CAF50",          # Culoare succes
                "border": "#333333"            # Culoare bordură
            }
            
            self.configure(bg=self.colors["bg_main"])
            self.connection = None
            self.current_table = None
            
            # Configurare stiluri ttk
            self.setup_styles()
            
            # Creare interfață
            self.create_widgets()
            self.create_menu()
        
        def setup_styles(self):
            style = ttk.Style()
            
            # Stil butoane
            style.configure(
                "TButton",
                background=self.colors["bg_input"],
                foreground=self.colors["text_primary"],
                borderwidth=0,
                relief=tk.FLAT,
                font=("Segoe UI", 10),
                padding=(10, 5)
            )
            
            # Stil dropdown
            style.configure(
                "TCombobox",
                fieldbackground=self.colors["bg_input"],
                background=self.colors["bg_input"],
                foreground=self.colors["text_primary"],
                arrowcolor=self.colors["accent"],
                borderwidth=0,
                relief=tk.FLAT
            )
            
            # Stil scrollbar
            style.configure(
                "TScrollbar",
                background=self.colors["bg_input"],
                troughcolor=self.colors["bg_secondary"],
                arrowcolor=self.colors["accent"],
                borderwidth=0,
                relief=tk.FLAT
            )
            
            # Stil tabel (treeview)
            style.configure(
                "Treeview",
                background=self.colors["bg_input"],
                foreground=self.colors["text_primary"],
                rowheight=25,
                borderwidth=0,
                relief=tk.FLAT,
                fieldbackground=self.colors["bg_input"]
            )
            
            # Stil antet tabel
            style.configure(
                "Treeview.Heading",
                background=self.colors["bg_secondary"],
                foreground=self.colors["accent"],
                relief=tk.FLAT,
                borderwidth=0,
                font=("Segoe UI", 10, "bold")
            )
            
            # Stil selecție în tabel
            style.map("Treeview",
                background=[("selected", self.colors["accent"])],
                foreground=[("selected", self.colors["text_primary"])]
            )
            
        def create_menu(self):
            menubar = tk.Menu(self, bg=self.colors["bg_secondary"], fg=self.colors["text_primary"],
                              activebackground=self.colors["accent"],
                              activeforeground=self.colors["text_primary"], bd=0)
            self.config(menu=menubar)
            
            file_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_secondary"],
                                fg=self.colors["text_primary"], 
                                activebackground=self.colors["accent"],
                                activeforeground=self.colors["text_primary"], bd=0)
            file_menu.add_command(label="Open database", command=self.open_database)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.quit)
            menubar.add_cascade(label="File", menu=file_menu)
            
            edit_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_secondary"],
                               fg=self.colors["text_primary"], 
                               activebackground=self.colors["accent"],
                               activeforeground=self.colors["text_primary"], bd=0)
            edit_menu.add_command(label="Refresh", command=self.refresh_tables)
            edit_menu.add_command(label="Execute query", command=self.execute_query)
            menubar.add_cascade(label="Edit", menu=edit_menu)
            
        def create_widgets(self):
            # Cadru principal
            main_frame = tk.Frame(self, bg=self.colors["bg_main"])
            main_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=12)
            
            # Cadru pentru controale superioare
            control_frame = tk.Frame(main_frame, bg=self.colors["bg_secondary"], pady=12, padx=12)
            control_frame.pack(fill=tk.X, pady=(0, 12))
            
            # Etichetă stilizată pentru tabele
            table_label = tk.Label(
                control_frame,
                text="TABELE",
                bg=self.colors["bg_secondary"],
                fg=self.colors["accent"],
                font=("Segoe UI", 10, "bold")
            )
            table_label.pack(side=tk.LEFT, padx=(0, 12))
            
            # Dropdown pentru tabele
            self.table_combo = ttk.Combobox(
                control_frame,
                state="readonly",
                font=("Segoe UI", 10),
                width=30
            )
            self.table_combo.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.table_combo.bind("<<ComboboxSelected>>", self.load_table)
            
            # Buton de reîmprospătare
            refresh_button = tk.Button(
                control_frame,
                text="↻",
                bg=self.colors["bg_input"],
                fg=self.colors["accent"],
                font=("Segoe UI", 12, "bold"),
                bd=0,
                padx=8,
                pady=0,
                activebackground=self.colors["accent_hover"],
                activeforeground=self.colors["text_primary"],
                cursor="hand2",
                command=self.refresh_tables
            )
            refresh_button.pack(side=tk.RIGHT)
            
            # Cadru pentru interogări
            query_frame = tk.Frame(main_frame, bg=self.colors["bg_secondary"], pady=12, padx=12)
            query_frame.pack(fill=tk.X, pady=(0, 12))
            
            # Etichetă pentru interogări
            query_label = tk.Label(
                query_frame,
                text="SQL QUERY",
                bg=self.colors["bg_secondary"],
                fg=self.colors["accent"],
                font=("Segoe UI", 10, "bold")
            )
            query_label.pack(side=tk.LEFT, padx=(0, 12))
            
            # Intrare pentru interogări
            self.query_entry = tk.Entry(
                query_frame,
                font=("Consolas", 11),
                bg=self.colors["bg_input"],
                fg=self.colors["text_primary"],
                insertbackground=self.colors["accent"],  # Culoare cursor
                bd=0,
                highlightthickness=1,
                highlightbackground=self.colors["border"],
                highlightcolor=self.colors["accent"]
            )
            self.query_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 12))
            
            # Buton pentru executare
            execute_button = tk.Button(
                query_frame,
                text="EXECUTE",
                bg=self.colors["accent"],
                fg=self.colors["text_primary"],
                font=("Segoe UI", 9, "bold"),
                bd=0,
                padx=15,
                pady=5,
                activebackground=self.colors["accent_hover"],
                activeforeground=self.colors["text_primary"],
                cursor="hand2",
                command=self.execute_query
            )
            execute_button.pack(side=tk.RIGHT)
            
            # Cadru pentru tabel
            table_container = tk.Frame(main_frame, bg=self.colors["bg_secondary"], bd=0)
            table_container.pack(fill=tk.BOTH, expand=True)
            
            # Treeview pentru afișarea datelor
            self.tree = ttk.Treeview(table_container)
            self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Scrollbar vertical
            vsb = ttk.Scrollbar(table_container, orient="vertical", command=self.tree.yview)
            vsb.pack(side=tk.RIGHT, fill=tk.Y)
            self.tree.configure(yscrollcommand=vsb.set)
            
            # Scrollbar orizontal
            hsb = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
            hsb.pack(side=tk.BOTTOM, fill=tk.X, pady=(5, 0))
            self.tree.configure(xscrollcommand=hsb.set)
            
            # Bară de stare
            self.status_var = tk.StringVar()
            self.status_var.set("No database is open.")
            
            status_line = tk.Frame(self, bg=self.colors["accent"], height=2)
            status_line.pack(side=tk.BOTTOM, fill=tk.X)
            
            self.status_bar = tk.Label(
                self,
                textvariable=self.status_var,
                bg=self.colors["bg_main"],
                fg=self.colors["text_secondary"],
                font=("Segoe UI", 9),
                anchor=tk.W,
                padx=12,
                pady=6
            )
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
            
        def open_database(self):
            file_path = filedialog.askopenfilename(
                title="Select the SQLite Database",
                filetypes=[("SQLite File", "*.db *.sqlite *.sqlite3"), ("Toate fișierele", "*.*")]
            )
            
            if file_path:
                try:
                    if self.connection:
                        self.connection.close()
                    
                    self.connection = sqlite3.connect(file_path)
                    self.refresh_tables()
                    self.status_var.set(f"Database: {os.path.basename(file_path)}")
                    messagebox.showinfo("Succes", "The database was successfully opened!")
                except sqlite3.Error as e:
                    messagebox.showerror("Error", f"The database could not be opened: {e}")
                    self.status_var.set("Error opening the database.")
        
        def refresh_tables(self):
            if not self.connection:
                messagebox.showwarning("Warning", "No database is open!")
                return
            
            try:
                cursor = self.connection.cursor()
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = cursor.fetchall()
                
                self.table_combo['values'] = [table[0] for table in tables]
                if tables:
                    self.table_combo.current(0)
                    self.load_table(None)
                else:
                    messagebox.showinfo("Info", "No tables were found in this database.")
                    self.clear_tree()
            except sqlite3.Error as e:
                messagebox.showerror("Error", f"The tables could not be loaded: {e}")
        
        def load_table(self, event):
            if not self.connection:
                return
            
            selected_table = self.table_combo.get()
            if not selected_table:
                return
            
            self.current_table = selected_table
            self.query_entry.delete(0, tk.END)
            self.query_entry.insert(0, f"SELECT * FROM {selected_table}")
            
            try:
                cursor = self.connection.cursor()
                cursor.execute(f"PRAGMA table_info({selected_table})")
                columns = cursor.fetchall()
                
                cursor.execute(f"SELECT * FROM {selected_table} LIMIT 1000")
                rows = cursor.fetchall()
                
                self.display_data(columns, rows)
                self.status_var.set(f"Tabel: {selected_table} | {len(rows)} înregistrări")
            except sqlite3.Error as e:
                messagebox.showerror("Eroare", f"Nu s-a putut încărca tabelul: {e}")
        
        def execute_query(self):
            if not self.connection:
                messagebox.showwarning("Warning", "No database is open!")
                return
            
            query = self.query_entry.get().strip()
            if not query:
                messagebox.showwarning("Warning", "Enter a valid query!")
                return
            
            try:
                cursor = self.connection.cursor()
                cursor.execute(query)
                
                if query.upper().startswith(("SELECT", "PRAGMA")):
                    # Interogare de citire - afișare rezultate
                    columns = [description[0] for description in cursor.description]
                    rows = cursor.fetchall()
                    
                    self.display_data_from_query(columns, rows)
                    self.status_var.set(f"Executed query: {len(rows)} results")
                else:
                    # Interogare de modificare - confirmare tranzacție
                    self.connection.commit()
                    affected = cursor.rowcount
                    messagebox.showinfo("Succes", f"Query executed successfully! Rows affected: {affected}")
                    
                    # Reîmprospătare tabel curent dacă există
                    if self.current_table:
                        self.load_table(None)
                    
                    self.status_var.set(f"Executed query: {affected} rows affected")
            except sqlite3.Error as e:
                messagebox.showerror("Eroare", f"Error executing query: {e}")
        
        def display_data(self, columns, rows):
            self.clear_tree()
            
            # Configurare coloane în treeview
            column_names = [col[1] for col in columns]  # Nume coloane
            
            # Corectie: Folosim coloane standard fără # în id-uri
            self.tree["columns"] = column_names
            
            # Ascunde prima coloană implicită (care nu este folosită)
            self.tree.column("#0", width=0, stretch=tk.NO)
            
            # Configurare fiecare coloană după nume
            for name in column_names:
                self.tree.column(name, anchor=tk.W, width=150)
                self.tree.heading(name, text=name, anchor=tk.W)
            
            # Adăugare date
            for i, row in enumerate(rows):
                values = [str(val) if val is not None else "NULL" for val in row]
                self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
            
            # Alternarea culorilor rândurilor
            self.tree.tag_configure('even', background=self.colors["bg_input"])
            self.tree.tag_configure('odd', background=self.colors["bg_secondary"])
        
        def display_data_from_query(self, column_names, rows):
            self.clear_tree()
            
            # Corectie: Folosim direct numele coloanelor fără ID-uri suplimentare
            self.tree["columns"] = column_names
            
            # Ascunde prima coloană implicită (care nu este folosită)
            self.tree.column("#0", width=0, stretch=tk.NO)
            
            # Configurare fiecare coloană după nume
            for name in column_names:
                self.tree.column(name, anchor=tk.W, width=150)
                self.tree.heading(name, text=name, anchor=tk.W)
            
            # Adăugare date
            for i, row in enumerate(rows):
                values = [str(val) if val is not None else "NULL" for val in row]
                self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
            
            # Alternarea culorilor rândurilor
            self.tree.tag_configure('even', background=self.colors["bg_input"])
            self.tree.tag_configure('odd', background=self.colors["bg_secondary"])
        
        def clear_tree(self):
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            for col in self.tree["columns"]:
                self.tree.heading(col, text="")
            
            self.tree["columns"] = []

    # Adaugă efect de hover pentru butoane
    def on_enter(e):
        if isinstance(e.widget, tk.Button):
            e.widget['background'] = e.widget.master.colors["accent_hover"]

    def on_leave(e, original_bg):
        if isinstance(e.widget, tk.Button):
            e.widget['background'] = original_bg

    if __name__ == "__main__":
        import os
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
        import sqlite3
        
        app = DarkThemeSQLViewer()
        
        # Adaugă efecte de hover pentru butoane (opțional)
        for widget in app.winfo_children():
            if isinstance(widget, tk.Frame):
                for child in widget.winfo_children():
                    if isinstance(child, tk.Button):
                        original_bg = child['background']
                        child.bind("<Enter>", on_enter)
                        child.bind("<Leave>", lambda e, bg=original_bg: on_leave(e, bg))
        
        app.mainloop()

if diagramvar == 2345432:
    import pygame
    import pygame.gfxdraw
    import sys
    import math
    from enum import Enum
    import random
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    # Initialize Pygame
    pygame.init()

    # Screen configuration
    WIDTH, HEIGHT = 1300, 850
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Diagram Editor")

    # Colors
    WHITE = (255, 255, 255)
    BLACK = (20, 20, 20)
    GRAY = (128, 128, 128)
    LIGHT_GRAY = (220, 220, 220)
    DARK_GRAY = (60, 60, 60)
    BLUE = (41, 128, 185)
    LIGHT_BLUE = (52, 152, 219)
    GREEN = (46, 204, 113)
    RED = (231, 76, 60)
    YELLOW = (241, 196, 15)
    PURPLE = (155, 89, 182)
    ORANGE = (230, 126, 34)
    TURQUOISE = (26, 188, 156)

    # Modern UI colors
    BACKGROUND = (245, 246, 250)
    SIDEBAR_BG = (32, 34, 37)
    BUTTON_IDLE = (47, 49, 54)
    BUTTON_HOVER = (67, 70, 77)
    BUTTON_ACTIVE = (88, 101, 242)
    TEXT_COLOR = (255, 255, 255)
    ACCENT_COLOR = (88, 101, 242)
    SECONDARY_ACCENT = (114, 137, 218)
    GRID_COLOR = (230, 230, 230)

    # Canvas settings
    CANVAS_X, CANVAS_Y = 250, 20
    CANVAS_WIDTH, CANVAS_HEIGHT = 1030, 700
    GRID_SIZE = 20

    # Fonts
    pygame.font.init()
    FONT_REGULAR = pygame.font.Font(None, 24)
    FONT_BOLD = pygame.font.Font(None, 28)
    FONT_SMALL = pygame.font.Font(None, 20)
    FONT_LARGE = pygame.font.Font(None, 32)

    # Connection points for shapes
    class ConnectionPoint:
        def __init__(self, parent, rel_x, rel_y):
            self.parent = parent
            self.rel_x = rel_x  # Relative position (0-1)
            self.rel_y = rel_y
            self.connections = []  # List of connections to other points
        
        @property
        def abs_pos(self):
            # Get absolute position based on parent shape
            return (self.parent.rect.x + int(self.rel_x * self.parent.rect.width),
                    self.parent.rect.y + int(self.rel_y * self.parent.rect.height))
        
        def draw(self, surface, selected=False):
            x, y = self.abs_pos
            radius = 5 if selected else 3
            color = ACCENT_COLOR if selected else SECONDARY_ACCENT
            
            pygame.draw.circle(surface, color, (x, y), radius)
            
        def is_clicked(self, pos):
            x, y = self.abs_pos
            click_x, click_y = pos
            # Check if the position is within 10 pixels of the connection point
            return math.sqrt((click_x - x) ** 2 + (click_y - y) ** 2) <= 10

    class Connection:
        def __init__(self, start_point, end_point):
            self.start_point = start_point
            self.end_point = end_point
            self.selected = False
            self.style = "direct"  # Can be "direct", "orthogonal", or "curved"
            self.color = BLACK
            self.line_width = 2
            self.arrow_end = True
            self.label = ""
            
        def draw(self, surface):
            start_pos = self.start_point.abs_pos
            end_pos = self.end_point.abs_pos
            
            # Draw different connection styles
            if self.style == "direct":
                # Draw direct line
                self._draw_direct_line(surface, start_pos, end_pos)
            elif self.style == "orthogonal":
                # Draw orthogonal line (Manhattan distance)
                self._draw_orthogonal_line(surface, start_pos, end_pos)
            elif self.style == "curved":
                # Draw curved line
                self._draw_curved_line(surface, start_pos, end_pos)
            
            # Draw selection indicator if selected
            if self.selected:
                pygame.draw.line(surface, ACCENT_COLOR, start_pos, end_pos, 
                               self.line_width + 2)
            
            # Draw arrow if needed
            if self.arrow_end:
                self._draw_arrow(surface, start_pos, end_pos)
            
            # Draw label if exists
            if self.label:
                self._draw_label(surface, start_pos, end_pos)
                
        def _draw_direct_line(self, surface, start_pos, end_pos):
            pygame.draw.line(surface, self.color, start_pos, end_pos, self.line_width)
        
        def _draw_orthogonal_line(self, surface, start_pos, end_pos):
            sx, sy = start_pos
            ex, ey = end_pos
            
            # Calculate midpoint
            midx = (sx + ex) / 2
            
            # Draw three line segments
            pygame.draw.line(surface, self.color, (sx, sy), (midx, sy), self.line_width)
            pygame.draw.line(surface, self.color, (midx, sy), (midx, ey), self.line_width)
            pygame.draw.line(surface, self.color, (midx, ey), (ex, ey), self.line_width)
        
        def _draw_curved_line(self, surface, start_pos, end_pos):
            sx, sy = start_pos
            ex, ey = end_pos
            
            # Calculate control points for Bezier curve
            # Horizontal distance between points
            dx = abs(ex - sx)
            # Control points are offset by 40% of dx
            cp1 = (sx + 0.4 * dx, sy)
            cp2 = (ex - 0.4 * dx, ey)
            
            # Draw curve using a series of short lines (approximation)
            points = []
            for t in range(0, 101, 5):  # Divide into 20 segments
                t /= 100.0
                # Cubic Bezier formula
                x = (1-t)**3 * sx + 3*(1-t)**2*t * cp1[0] + 3*(1-t)*t**2 * cp2[0] + t**3 * ex
                y = (1-t)**3 * sy + 3*(1-t)**2*t * cp1[1] + 3*(1-t)*t**2 * cp2[1] + t**3 * ey
                points.append((x, y))
            
            if len(points) > 1:
                pygame.draw.lines(surface, self.color, False, points, self.line_width)
        
        def _draw_arrow(self, surface, start_pos, end_pos):
            sx, sy = start_pos
            ex, ey = end_pos
            
            # Calculate angle of the line
            angle = math.atan2(ey - sy, ex - sx)
            
            # Length of the arrow head
            arrow_length = 12
            
            # Calculate coordinates for arrowhead
            arrow1_x = ex - arrow_length * math.cos(angle - math.pi/6)
            arrow1_y = ey - arrow_length * math.sin(angle - math.pi/6)
            arrow2_x = ex - arrow_length * math.cos(angle + math.pi/6)
            arrow2_y = ey - arrow_length * math.sin(angle + math.pi/6)
            
            # Draw arrowhead
            pygame.draw.polygon(surface, self.color, [(ex, ey), 
                                                    (arrow1_x, arrow1_y), 
                                                    (arrow2_x, arrow2_y)])
        
        def _draw_label(self, surface, start_pos, end_pos):
            # Calculate position for label (midpoint of line)
            mx = (start_pos[0] + end_pos[0]) // 2
            my = (start_pos[1] + end_pos[1]) // 2
            
            # Render text
            text_surface = FONT_SMALL.render(self.label, True, BLACK)
            
            # Create background for text
            text_rect = text_surface.get_rect(center=(mx, my))
            bg_rect = text_rect.inflate(10, 6)
            
            # Draw background and text
            pygame.draw.rect(surface, WHITE, bg_rect)
            pygame.draw.rect(surface, LIGHT_GRAY, bg_rect, 1)
            surface.blit(text_surface, text_rect)
        
        def is_clicked(self, pos):
            sx, sy = self.start_point.abs_pos
            ex, ey = self.end_point.abs_pos
            click_x, click_y = pos
            
            # For simplicity, check if click is near the line
            # Calculate distance from point to line
            line_length = math.sqrt((ex - sx) ** 2 + (ey - sy) ** 2)
            if line_length == 0:
                return False
            
            # Calculate closest point on line
            t = max(0, min(1, ((click_x - sx) * (ex - sx) + (click_y - sy) * (ey - sy)) / (line_length ** 2)))
            proj_x = sx + t * (ex - sx)
            proj_y = sy + t * (ey - sy)
            
            # Calculate distance to closest point
            dist = math.sqrt((click_x - proj_x) ** 2 + (click_y - proj_y) ** 2)
            
            # Check if distance is within threshold
            threshold = 8  # Pixels
            return dist <= threshold and 0 <= t <= 1

    class ShapeType(Enum):
        RECTANGLE = "rectangle"
        ELLIPSE = "ellipse"
        DIAMOND = "diamond"
        ROUNDED_RECT = "rounded_rect"
        PARALLELOGRAM = "parallelogram"
        CYLINDER = "cylinder"
        DOCUMENT = "document"
        CLOUD = "cloud"
        HEXAGON = "hexagon"

    class Shape:
        def __init__(self, shape_type, rect, color=BLACK, fill_color=WHITE, text=""):
            self.type = shape_type
            self.rect = rect.copy()
            self.color = color
            self.fill_color = fill_color
            self.text = text
            self.selected = False
            self.connection_points = self._create_connection_points()
            self.locked = False
            self.line_width = 2
            self.font = FONT_REGULAR
            self.id = random.randint(10000, 99999)  # Unique identifier
            
        def _create_connection_points(self):
            # Create 8 connection points around the shape
            points = []
            positions = [
                (0.5, 0),    # Top center
                (1, 0.5),    # Right center
                (0.5, 1),    # Bottom center
                (0, 0.5),    # Left center
                (0, 0),      # Top left
                (1, 0),      # Top right
                (1, 1),      # Bottom right
                (0, 1)       # Bottom left
            ]
            
            for rel_x, rel_y in positions:
                points.append(ConnectionPoint(self, rel_x, rel_y))
            
            return points
        
        def draw(self, surface):
            # Draw the specific shape
            if self.type == ShapeType.RECTANGLE:
                self._draw_rectangle(surface)
            elif self.type == ShapeType.ELLIPSE:
                self._draw_ellipse(surface)
            elif self.type == ShapeType.DIAMOND:
                self._draw_diamond(surface)
            elif self.type == ShapeType.ROUNDED_RECT:
                self._draw_rounded_rect(surface)
            elif self.type == ShapeType.PARALLELOGRAM:
                self._draw_parallelogram(surface)
            elif self.type == ShapeType.CYLINDER:
                self._draw_cylinder(surface)
            elif self.type == ShapeType.DOCUMENT:
                self._draw_document(surface)
            elif self.type == ShapeType.CLOUD:
                self._draw_cloud(surface)
            elif self.type == ShapeType.HEXAGON:
                self._draw_hexagon(surface)
            
            # Draw text
            if self.text:
                self._draw_text(surface)
            
            # Draw selection border
            if self.selected:
                pygame.draw.rect(surface, ACCENT_COLOR, self.rect, 2)
                
                # Draw resize handles at corners
                handle_size = 6
                handles = [
                    (self.rect.left, self.rect.top),
                    (self.rect.right, self.rect.top),
                    (self.rect.right, self.rect.bottom),
                    (self.rect.left, self.rect.bottom)
                ]
                
                for x, y in handles:
                    pygame.draw.rect(surface, ACCENT_COLOR, 
                                   (x - handle_size//2, y - handle_size//2, handle_size, handle_size))
                
                # Draw connection points only when selected
                for point in self.connection_points:
                    point.draw(surface)
            
            # Draw lock indicator if locked
            if self.locked:
                lock_pos = (self.rect.right - 15, self.rect.top + 15)
                pygame.draw.circle(surface, LIGHT_GRAY, lock_pos, 10)
                pygame.draw.circle(surface, BLACK, lock_pos, 10, 1)
                pygame.draw.rect(surface, BLACK, (lock_pos[0]-3, lock_pos[1]-6, 6, 8))
                pygame.draw.circle(surface, BLACK, (lock_pos[0], lock_pos[1]-3), 2)
        
        def _draw_rectangle(self, surface):
            pygame.draw.rect(surface, self.fill_color, self.rect)
            pygame.draw.rect(surface, self.color, self.rect, self.line_width)
        
        def _draw_ellipse(self, surface):
            pygame.draw.ellipse(surface, self.fill_color, self.rect)
            pygame.draw.ellipse(surface, self.color, self.rect, self.line_width)
        
        def _draw_diamond(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            
            points = [
                (x + w//2, y),         # Top
                (x + w, y + h//2),     # Right
                (x + w//2, y + h),     # Bottom
                (x, y + h//2)          # Left
            ]
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.polygon(surface, self.color, points, self.line_width)
        
        def _draw_rounded_rect(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            radius = min(15, w//4, h//4)  # Rounded corner radius
            
            # Draw filled rounded rectangle
            pygame.draw.rect(surface, self.fill_color, (x+radius, y, w-2*radius, h))
            pygame.draw.rect(surface, self.fill_color, (x, y+radius, w, h-2*radius))
            
            # Draw the four corners
            pygame.draw.circle(surface, self.fill_color, (x+radius, y+radius), radius)
            pygame.draw.circle(surface, self.fill_color, (x+w-radius, y+radius), radius)
            pygame.draw.circle(surface, self.fill_color, (x+radius, y+h-radius), radius)
            pygame.draw.circle(surface, self.fill_color, (x+w-radius, y+h-radius), radius)
            
            # Draw outline
            # Top edge
            pygame.draw.line(surface, self.color, (x+radius, y), (x+w-radius, y), self.line_width)
            # Right edge
            pygame.draw.line(surface, self.color, (x+w, y+radius), (x+w, y+h-radius), self.line_width)
            # Bottom edge
            pygame.draw.line(surface, self.color, (x+radius, y+h), (x+w-radius, y+h), self.line_width)
            # Left edge
            pygame.draw.line(surface, self.color, (x, y+radius), (x, y+h-radius), self.line_width)
            
            # Draw the four corners
            pygame.draw.arc(surface, self.color, (x, y, radius*2, radius*2), math.pi, 3*math.pi/2, self.line_width)
            pygame.draw.arc(surface, self.color, (x+w-radius*2, y, radius*2, radius*2), 3*math.pi/2, 2*math.pi, self.line_width)
            pygame.draw.arc(surface, self.color, (x, y+h-radius*2, radius*2, radius*2), math.pi/2, math.pi, self.line_width)
            pygame.draw.arc(surface, self.color, (x+w-radius*2, y+h-radius*2, radius*2, radius*2), 0, math.pi/2, self.line_width)
        
        def _draw_parallelogram(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            offset = min(w//4, 20)  # Slant amount
            
            points = [
                (x + offset, y),       # Top left
                (x + w, y),            # Top right
                (x + w - offset, y + h),  # Bottom right
                (x, y + h)             # Bottom left
            ]
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.polygon(surface, self.color, points, self.line_width)
        
        def _draw_cylinder(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            ellipse_height = min(h//4, 15)
            
            # Draw body rectangle
            pygame.draw.rect(surface, self.fill_color, (x, y + ellipse_height//2, w, h - ellipse_height))
            pygame.draw.rect(surface, self.color, (x, y + ellipse_height//2, w, h - ellipse_height), self.line_width)
            
            # Draw top ellipse
            top_rect = pygame.Rect(x, y, w, ellipse_height)
            pygame.draw.ellipse(surface, self.fill_color, top_rect)
            pygame.draw.ellipse(surface, self.color, top_rect, self.line_width)
            
            # Draw bottom ellipse
            bottom_rect = pygame.Rect(x, y + h - ellipse_height, w, ellipse_height)
            pygame.draw.ellipse(surface, self.fill_color, bottom_rect)
            pygame.draw.ellipse(surface, self.color, bottom_rect, self.line_width)
        
        def _draw_document(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            wave_height = min(h//6, 15)
            
            # Main rectangle
            pygame.draw.rect(surface, self.fill_color, (x, y, w, h - wave_height))
            pygame.draw.rect(surface, self.color, (x, y, w, h - wave_height), self.line_width)
            
            # Bottom wavy part
            points = [(x, y + h - wave_height)]
            steps = 4
            step_width = w / steps
            
            for i in range(1, steps + 1):
                if i % 2 == 1:  # Odd step, goes down
                    points.append((x + i * step_width, y + h))
                else:  # Even step, goes up
                    points.append((x + i * step_width, y + h - wave_height))
            
            # Connect back to rectangle
            points.append((x + w, y + h - wave_height))
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.lines(surface, self.color, False, points, self.line_width)
        
        def _draw_cloud(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            
            # Draw cloud as a series of overlapping circles
            circles = [
                (x + w // 4, y + h // 3, min(w, h) // 3),
                (x + w // 2, y + h // 4, min(w, h) // 4),
                (x + 3 * w // 4, y + h // 3, min(w, h) // 3),
                (x + w // 5, y + 2 * h // 3, min(w, h) // 4),
                (x + w // 2, y + 3 * h // 4, min(w, h) // 3),
                (x + 3 * w // 4, y + 2 * h // 3, min(w, h) // 4)
            ]
            
            # Draw filled circles
            for cx, cy, r in circles:
                pygame.draw.circle(surface, self.fill_color, (cx, cy), r)
            
            # Draw outlines
            for cx, cy, r in circles:
                pygame.draw.circle(surface, self.color, (cx, cy), r, self.line_width)
        
        def _draw_hexagon(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            
            points = [
                (x + w//4, y),                # Top left
                (x + 3*w//4, y),              # Top right
                (x + w, y + h//2),            # Right
                (x + 3*w//4, y + h),          # Bottom right
                (x + w//4, y + h),            # Bottom left
                (x, y + h//2)                 # Left
            ]
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.polygon(surface, self.color, points, self.line_width)
        
        def _draw_text(self, surface):
            # Render text with wrapping
            lines = self._wrap_text()
            
            # Calculate total height of text
            line_height = self.font.get_height()
            total_height = line_height * len(lines)
            
            # Start position for first line (centered vertically)
            start_y = self.rect.y + (self.rect.height - total_height) // 2
            
            # Draw each line
            for i, line in enumerate(lines):
                text_surface = self.font.render(line, True, BLACK)
                text_rect = text_surface.get_rect(centerx=self.rect.centerx, y=start_y + i * line_height)
                surface.blit(text_surface, text_rect)
        
        def _wrap_text(self):
            # Split text into lines to fit width
            max_width = self.rect.width - 20  # Margin
            words = self.text.split()
            lines = []
            current_line = []
            
            for word in words:
                # Try adding the word to the current line
                test_line = ' '.join(current_line + [word])
                width, _ = self.font.size(test_line)
                
                if width <= max_width or not current_line:
                    current_line.append(word)
                else:
                    lines.append(' '.join(current_line))
                    current_line = [word]
            
            # Add the last line
            if current_line:
                lines.append(' '.join(current_line))
            
            return lines
        
        def contains_point(self, point):
            return self.rect.collidepoint(point)
        
        def get_connection_point_at(self, pos):
            for point in self.connection_points:
                if point.is_clicked(pos):
                    return point
            return None
        
        def move(self, dx, dy):
            if not self.locked:
                self.rect.x += dx
                self.rect.y += dy
        
        def resize(self, corner, dx, dy):
            if self.locked:
                return
                
            x, y = self.rect.topleft
            w, h = self.rect.size
            
            # Minimum size constraints
            MIN_SIZE = 30
            
            # Resize based on which corner is being dragged
            if corner == "topleft":
                new_x = x + dx
                new_y = y + dy
                new_w = w - dx
                new_h = h - dy
            elif corner == "topright":
                new_x = x
                new_y = y + dy
                new_w = w + dx
                new_h = h - dy
            elif corner == "bottomright":
                new_x = x
                new_y = y
                new_w = w + dx
                new_h = h + dy
            elif corner == "bottomleft":
                new_x = x + dx
                new_y = y
                new_w = w - dx
                new_h = h + dy
            
            # Apply constraints
            if new_w < MIN_SIZE:
                if corner in ["topleft", "bottomleft"]:
                    new_x = x + w - MIN_SIZE
                new_w = MIN_SIZE
            
            if new_h < MIN_SIZE:
                if corner in ["topleft", "topright"]:
                    new_y = y + h - MIN_SIZE
                new_h = MIN_SIZE
            
            # Update rectangle
            self.rect = pygame.Rect(new_x, new_y, new_w, new_h)

    class DiagramEditor:
        def __init__(self):
            # App states
            self.shapes = []
            self.connections = []
            self.current_tool = "select"
            self.current_shape_type = ShapeType.RECTANGLE
            self.current_color = BLACK
            self.current_fill_color = WHITE
            self.current_connection_style = "direct"
            
            # Selection and creation states
            self.selected_shape = None
            self.selected_connection = None
            self.selected_connection_point = None
            self.temp_connection_start = None
            self.is_moving = False
            self.is_resizing = False
            self.resize_corner = ""
            self.creation_start_pos = None
            self.mouse_pos = (0, 0)
            self.last_mouse_pos = (0, 0)
            self.double_click_time = 0
            self.show_grid = True
            
            # Text editing states
            self.text_input_active = False
            self.current_text = ""
            self.text_input_rect = pygame.Rect(CANVAS_X, HEIGHT - 40, 400, 30)
            
            # Toolbar and menu buttons
            self.buttons = self._create_buttons()
            self.shape_buttons = self._create_shape_buttons()
            self.color_buttons = self._create_color_buttons()
            self.connection_buttons = self._create_connection_buttons()
            
            # Create the canvas surface
            self.canvas = pygame.Surface((CANVAS_WIDTH, CANVAS_HEIGHT))
            self.canvas.fill(WHITE)
            
            # Undo/Redo History
            self.history = []
            self.history_position = -1
            self.save_state()  # Save initial empty state
        
        def _create_buttons(self):
            buttons = {
                "select": {"rect": pygame.Rect(20, 70, 160, 40), "text": "Select", "active": True},
                "create": {"rect": pygame.Rect(20, 120, 160, 40), "text": "Create Shape", "active": False},
                "connect": {"rect": pygame.Rect(20, 170, 160, 40), "text": "Connect", "active": False},
                "text": {"rect": pygame.Rect(20, 220, 160, 40), "text": "Add Text", "active": False},
                "delete": {"rect": pygame.Rect(20, 270, 160, 40), "text": "Delete", "active": False},
                "grid": {"rect": pygame.Rect(20, 320, 160, 40), "text": "Toggle Grid", "active": self.show_grid},
                "undo": {"rect": pygame.Rect(20, HEIGHT - 140, 75, 40), "text": "Undo", "active": False},
                "redo": {"rect": pygame.Rect(105, HEIGHT - 140, 75, 40), "text": "Redo", "active": False},
                "clear": {"rect": pygame.Rect(20, HEIGHT - 90, 160, 40), "text": "Clear All", "active": False},
                "save": {"rect": pygame.Rect(20, HEIGHT - 40, 160, 40), "text": "Save Diagram", "active": False}
            }
            return buttons
        
        def _create_shape_buttons(self):
            buttons = {}
            shape_types = [
                (ShapeType.RECTANGLE, "Rectangle"),
                (ShapeType.ELLIPSE, "Ellipse"),
                (ShapeType.DIAMOND, "Diamond"),
                (ShapeType.ROUNDED_RECT, "Rounded Rect"),
                (ShapeType.PARALLELOGRAM, "Parallelogram"),
                (ShapeType.CYLINDER, "Cylinder"),
                (ShapeType.DOCUMENT, "Document"),
                (ShapeType.HEXAGON, "Hexagon"),
            ]
            
            y_pos = 370
            for shape_type, name in shape_types:
                buttons[shape_type] = {
                    "rect": pygame.Rect(20, y_pos, 160, 30),
                    "text": name,
                    "active": shape_type == self.current_shape_type
                }
                y_pos += 35
            
            return buttons
        
        def _create_color_buttons(self):
            colors = [
                (BLACK, "Black"),
                (BLUE, "Blue"),
                (GREEN, "Green"),
                (RED, "Red"),
                (PURPLE, "Purple"),
                (ORANGE, "Orange")
            ]
            
            fill_colors = [
                (WHITE, "White"),
                (LIGHT_BLUE, "Light Blue"),
                (TURQUOISE, "Turquoise"),
                (YELLOW, "Yellow"),
                (LIGHT_GRAY, "Light Gray")
            ]
            
            buttons = {}
            
            # Outline color buttons
            x_pos = 200
            y_pos = HEIGHT - 80
            for color, name in colors:
                buttons[color] = {
                    "rect": pygame.Rect(x_pos, y_pos, 30, 30),
                    "color": color,
                    "text": "",
                    "type": "outline"
                }
                x_pos += 40
            
            # Fill color buttons
            x_pos = 200
            y_pos = HEIGHT - 40
            for color, name in fill_colors:
                buttons[color] = {
                    "rect": pygame.Rect(x_pos, y_pos, 30, 30),
                    "color": color,
                    "text": "",
                    "type": "fill"
                }
                x_pos += 40
            
            return buttons
        
        def _create_connection_buttons(self):
            buttons = {
                "direct": {"rect": pygame.Rect(460, HEIGHT - 80, 100, 30), "text": "Direct", "active": True},
                "orthogonal": {"rect": pygame.Rect(570, HEIGHT - 80, 100, 30), "text": "Orthogonal", "active": False},
                "curved": {"rect": pygame.Rect(680, HEIGHT - 80, 100, 30), "text": "Curved", "active": False},
                "arrow": {"rect": pygame.Rect(460, HEIGHT - 40, 100, 30), "text": "Toggle Arrow", "active": True},
                "label": {"rect": pygame.Rect(570, HEIGHT - 40, 100, 30), "text": "Add Label", "active": False}
            }
            return buttons
        
        def save_state(self):
            # Capture the current state for undo/redo
            state = {
                "shapes": [self._serialize_shape(shape) for shape in self.shapes],
                "connections": [self._serialize_connection(conn) for conn in self.connections]
            }
            
            # If we're not at the end of the history, truncate
            if self.history_position < len(self.history) - 1:
                self.history = self.history[:self.history_position + 1]
            
            self.history.append(state)
            self.history_position = len(self.history) - 1
            
            # Enable/disable undo/redo buttons
            self.buttons["undo"]["active"] = self.history_position > 0
            self.buttons["redo"]["active"] = self.history_position < len(self.history) - 1
        
        def _serialize_shape(self, shape):
            # Convert shape to serializable dictionary
            return {
                "type": shape.type.value,
                "rect": (shape.rect.x, shape.rect.y, shape.rect.width, shape.rect.height),
                "color": shape.color,
                "fill_color": shape.fill_color,
                "text": shape.text,
                "locked": shape.locked,
                "id": shape.id
            }
        
        def _serialize_connection(self, conn):
            # Convert connection to serializable dictionary
            return {
                "start_shape_id": conn.start_point.parent.id,
                "start_point_index": conn.start_point.parent.connection_points.index(conn.start_point),
                "end_shape_id": conn.end_point.parent.id,
                "end_point_index": conn.end_point.parent.connection_points.index(conn.end_point),
                "style": conn.style,
                "color": conn.color,
                "line_width": conn.line_width,
                "arrow_end": conn.arrow_end,
                "label": conn.label
            }
        
        def restore_state(self, state_idx):
            if 0 <= state_idx < len(self.history):
                # Load the state at the given index
                state = self.history[state_idx]
                
                # Clear current state
                self.shapes = []
                self.connections = []
                self.selected_shape = None
                self.selected_connection = None
                
                # Restore shapes first
                shape_map = {}  # Maps shape IDs to restored shapes
                for shape_data in state["shapes"]:
                    shape_type = ShapeType(shape_data["type"])
                    rect = pygame.Rect(*shape_data["rect"])
                    
                    shape = Shape(shape_type, rect, 
                                 color=shape_data["color"],
                                 fill_color=shape_data["fill_color"],
                                 text=shape_data["text"])
                    shape.locked = shape_data["locked"]
                    shape.id = shape_data["id"]
                    
                    self.shapes.append(shape)
                    shape_map[shape.id] = shape
                
                # Restore connections
                for conn_data in state["connections"]:
                    # Find the referenced shapes
                    start_shape = shape_map.get(conn_data["start_shape_id"])
                    end_shape = shape_map.get(conn_data["end_shape_id"])
                    
                    if start_shape and end_shape:
                        # Get the connection points
                        start_point = start_shape.connection_points[conn_data["start_point_index"]]
                        end_point = end_shape.connection_points[conn_data["end_point_index"]]
                        
                        # Create the connection
                        conn = Connection(start_point, end_point)
                        conn.style = conn_data["style"]
                        conn.color = conn_data["color"]
                        conn.line_width = conn_data["line_width"]
                        conn.arrow_end = conn_data["arrow_end"]
                        conn.label = conn_data["label"]
                        
                        self.connections.append(conn)
                
                self.history_position = state_idx
                
                # Update undo/redo buttons
                self.buttons["undo"]["active"] = self.history_position > 0
                self.buttons["redo"]["active"] = self.history_position < len(self.history) - 1
        
        def undo(self):
            if self.history_position > 0:
                self.restore_state(self.history_position - 1)
        
        def redo(self):
            if self.history_position < len(self.history) - 1:
                self.restore_state(self.history_position + 1)
        
        def draw(self, surface):
            # Draw the sidebar
            pygame.draw.rect(surface, SIDEBAR_BG, (0, 0, CANVAS_X, HEIGHT))
            
            # Draw title
            title_text = FONT_LARGE.render("Diagram Editor", True, WHITE)
            surface.blit(title_text, (20, 20))
            
            # Draw buttons
            for button_id, button in self.buttons.items():
                color = BUTTON_ACTIVE if button["active"] else BUTTON_IDLE
                pygame.draw.rect(surface, color, button["rect"], border_radius=5)
                
                text = FONT_REGULAR.render(button["text"], True, WHITE)
                text_rect = text.get_rect(center=button["rect"].center)
                surface.blit(text, text_rect)
            
            # Draw shape buttons if create tool is active
            if self.current_tool == "create":
                shape_title = FONT_BOLD.render("Shape Types:", True, WHITE)
                surface.blit(shape_title, (20, 340))
                
                for shape_type, button in self.shape_buttons.items():
                    color = BUTTON_ACTIVE if button["active"] else BUTTON_IDLE
                    pygame.draw.rect(surface, color, button["rect"], border_radius=3)
                    
                    text = FONT_SMALL.render(button["text"], True, WHITE)
                    text_rect = text.get_rect(center=button["rect"].center)
                    surface.blit(text, text_rect)
            
            # Draw color picker section
            color_title = FONT_BOLD.render("Colors:", True, PURPLE)
            surface.blit(color_title, (200, HEIGHT - 110))
            
            for color, button in self.color_buttons.items():
                border_color = ACCENT_COLOR if (button["type"] == "outline" and color == self.current_color) or \
                                              (button["type"] == "fill" and color == self.current_fill_color) else DARK_GRAY
                
                pygame.draw.rect(surface, button["color"], button["rect"])
                pygame.draw.rect(surface, border_color, button["rect"], 2)
            
            # Draw connection style buttons if connect tool is active
            if self.current_tool == "connect":
                conn_title = FONT_BOLD.render("Connection Style:", True, WHITE)
                surface.blit(conn_title, (460, HEIGHT - 110))
                
                for style, button in self.connection_buttons.items():
                    color = BUTTON_ACTIVE if button["active"] else BUTTON_IDLE
                    pygame.draw.rect(surface, color, button["rect"], border_radius=3)
                    
                    text = FONT_SMALL.render(button["text"], True, WHITE)
                    text_rect = text.get_rect(center=button["rect"].center)
                    surface.blit(text, text_rect)
            
            # Draw canvas background
            pygame.draw.rect(surface, WHITE, (CANVAS_X, CANVAS_Y, CANVAS_WIDTH, CANVAS_HEIGHT))
            
            # Draw grid if enabled
            if self.show_grid:
                for x in range(CANVAS_X, CANVAS_X + CANVAS_WIDTH + 1, GRID_SIZE):
                    pygame.draw.line(surface, GRID_COLOR, (x, CANVAS_Y), (x, CANVAS_Y + CANVAS_HEIGHT))
                for y in range(CANVAS_Y, CANVAS_Y + CANVAS_HEIGHT + 1, GRID_SIZE):
                    pygame.draw.line(surface, GRID_COLOR, (CANVAS_X, y), (CANVAS_X + CANVAS_WIDTH, y))
            
            # Draw connections
            for conn in self.connections:
                conn.draw(surface)
            
            # Draw shapes
            for shape in self.shapes:
                shape.draw(surface)
            
            # Draw temporary connection line if creating a connection
            if self.temp_connection_start and self.current_tool == "connect":
                start_pos = self.temp_connection_start.abs_pos
                # Draw line to mouse position
                pygame.draw.line(surface, ACCENT_COLOR, start_pos, self.mouse_pos, 2)
                
                # Draw a little circle at mouse pos
                pygame.draw.circle(surface, ACCENT_COLOR, self.mouse_pos, 5, 2)
            
            # Draw shape preview while creating
            if self.creation_start_pos and self.current_tool == "create":
                preview_rect = self._get_rect_from_points(self.creation_start_pos, self.mouse_pos)
                
                # Draw different shape previews based on current shape type
                if self.current_shape_type == ShapeType.RECTANGLE:
                    pygame.draw.rect(surface, self.current_fill_color, preview_rect)
                    pygame.draw.rect(surface, self.current_color, preview_rect, 2)
                
                elif self.current_shape_type == ShapeType.ELLIPSE:
                    pygame.draw.ellipse(surface, self.current_fill_color, preview_rect)
                    pygame.draw.ellipse(surface, self.current_color, preview_rect, 2)
                
                # For other shapes, just draw a rectangle outline as placeholder
                else:
                    pygame.draw.rect(surface, self.current_color, preview_rect, 1)
            
            # Draw text input box if active
            if self.text_input_active:
                pygame.draw.rect(surface, WHITE, self.text_input_rect)
                pygame.draw.rect(surface, BLACK, self.text_input_rect, 2)
                
                text_surface = FONT_REGULAR.render(self.current_text, True, BLACK)
                surface.blit(text_surface, (self.text_input_rect.x + 5, self.text_input_rect.y + 5))
        
        def handle_event(self, event):
            self.mouse_pos = pygame.mouse.get_pos()
            
            if event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Left click
                    # Check for double click
                    current_time = pygame.time.get_ticks()
                    is_double_click = current_time - self.double_click_time < 300
                    self.double_click_time = current_time
                    
                    self._handle_mouse_down(is_double_click)
                
            elif event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:  # Left button release
                    self._handle_mouse_up()
            
            elif event.type == pygame.MOUSEMOTION:
                self._handle_mouse_motion(event.rel)
            
            elif event.type == pygame.KEYDOWN:
                self._handle_key_down(event)
        
        def _handle_mouse_down(self, is_double_click):
            # Check if clicked on a button in the sidebar
            for button_id, button in self.buttons.items():
                if button["rect"].collidepoint(self.mouse_pos):
                    self._handle_button_click(button_id)
                    return
            
            # Check if clicked on a shape button
            if self.current_tool == "create":
                for shape_type, button in self.shape_buttons.items():
                    if button["rect"].collidepoint(self.mouse_pos):
                        # Set current shape type
                        self.current_shape_type = shape_type
                        # Update buttons
                        for st, btn in self.shape_buttons.items():
                            btn["active"] = (st == shape_type)
                        return
            
            # Check if clicked on a color button
            for color, button in self.color_buttons.items():
                if button["rect"].collidepoint(self.mouse_pos):
                    if button["type"] == "outline":
                        self.current_color = color
                    elif button["type"] == "fill":
                        self.current_fill_color = color
                    return
            
            # Check if clicked on a connection style button
            if self.current_tool == "connect":
                for style, button in self.connection_buttons.items():
                    if button["rect"].collidepoint(self.mouse_pos):
                        if style in ["direct", "orthogonal", "curved"]:
                            # Set connection style
                            self.current_connection_style = style
                            # Update buttons
                            for s, btn in self.connection_buttons.items():
                                if s in ["direct", "orthogonal", "curved"]:
                                    btn["active"] = (s == style)
                        elif style == "arrow":
                            # Toggle arrow setting
                            button["active"] = not button["active"]
                        elif style == "label" and self.selected_connection:
                            # Prompt for label
                            self.text_input_active = True
                            self.current_text = self.selected_connection.label
                        return
            
            # Handle actions within the canvas
            if self._is_point_on_canvas(self.mouse_pos):
                # Reset text input
                self.text_input_active = False
                
                # Different handling based on current tool
                if self.current_tool == "select":
                    self._handle_select_tool_click(is_double_click)
                
                elif self.current_tool == "create":
                    # Start shape creation
                    self.creation_start_pos = self.mouse_pos
                
                elif self.current_tool == "connect":
                    self._handle_connect_tool_click()
                
                elif self.current_tool == "text" and self.selected_shape:
                    # Start text input for selected shape
                    self.text_input_active = True
                    self.current_text = self.selected_shape.text
                
                elif self.current_tool == "delete":
                    self._handle_delete_tool_click()
        
        def _handle_select_tool_click(self, is_double_click):
            # First, check if clicking on a connection point of the selected shape
            if self.selected_shape:
                for point in self.selected_shape.connection_points:
                    if point.is_clicked(self.mouse_pos):
                        self.selected_connection_point = point
                        return
            
            # Next, check if clicking on a resize handle of selected shape
            if self.selected_shape and self.selected_shape.selected and not self.selected_shape.locked:
                corner = self._get_resize_corner_at_pos(self.mouse_pos)
                if corner:
                    self.is_resizing = True
                    self.resize_corner = corner
                    return
            
            # Check if a connection was clicked
            for conn in self.connections:
                if conn.is_clicked(self.mouse_pos):
                    self._select_connection(conn)
                    return
            
            # Check if a shape was clicked (in reverse order to handle overlap)
            for shape in reversed(self.shapes):
                if shape.contains_point(self.mouse_pos):
                    if is_double_click and self.current_tool == "select" and shape == self.selected_shape:
                        # Double-click on selected shape - edit text
                        self.text_input_active = True
                        self.current_text = shape.text
                    else:
                        # Single-click - select and potentially move
                        self._select_shape(shape)
                        self.is_moving = True
                    return
            
            # If clicked on empty space, deselect everything
            self._deselect_all()
        
        def _handle_connect_tool_click(self):
            # Check if clicking on a connection point
            for shape in self.shapes:
                conn_point = shape.get_connection_point_at(self.mouse_pos)
                if conn_point:
                    if not self.temp_connection_start:
                        # Start new connection
                        self.temp_connection_start = conn_point
                    else:
                        # Complete connection
                        if conn_point != self.temp_connection_start:
                            new_conn = Connection(self.temp_connection_start, conn_point)
                            new_conn.style = self.current_connection_style
                            new_conn.arrow_end = self.connection_buttons["arrow"]["active"]
                            
                            self.connections.append(new_conn)
                            self._select_connection(new_conn)
                            
                            # Save state for undo/redo
                            self.save_state()
                        
                        # Reset temporary connection
                        self.temp_connection_start = None
                    return
            
            # If clicked on empty space, cancel connection
            self.temp_connection_start = None
        
        def _handle_delete_tool_click(self):
            # Check if a connection was clicked
            for i, conn in enumerate(self.connections):
                if conn.is_clicked(self.mouse_pos):
                    del self.connections[i]
                    self._deselect_all()
                    self.save_state()
                    return
            
            # Check if a shape was clicked
            for i, shape in enumerate(self.shapes):
                if shape.contains_point(self.mouse_pos):
                    # Delete shape and any connections to it
                    self.connections = [c for c in self.connections 
                                       if c.start_point.parent != shape and c.end_point.parent != shape]
                    del self.shapes[i]
                    self._deselect_all()
                    self.save_state()
                    return
        
        def _handle_mouse_up(self):
            # Finish moving or resizing
            if (self.is_moving or self.is_resizing) and self.selected_shape:
                # Save state for undo/redo
                self.save_state()
            
            self.is_moving = False
            self.is_resizing = False
            self.selected_connection_point = None
            
            # Finish creating shape
            if self.creation_start_pos and self.current_tool == "create":
                rect = self._get_rect_from_points(self.creation_start_pos, self.mouse_pos)
                
                # Only create shapes with minimum size
                if rect.width > 10 and rect.height > 10:
                    shape = Shape(self.current_shape_type, rect, 
                                 color=self.current_color, 
                                 fill_color=self.current_fill_color)
                    self.shapes.append(shape)
                    self._select_shape(shape)
                    
                    # Save state for undo/redo
                    self.save_state()
                
                self.creation_start_pos = None
        
        def _handle_mouse_motion(self, rel):
            dx, dy = rel
            
            # Handle shape moving
            if self.is_moving and self.selected_shape and not self.selected_shape.locked:
                self.selected_shape.move(dx, dy)
            
            # Handle shape resizing
            elif self.is_resizing and self.selected_shape and not self.selected_shape.locked:
                self.selected_shape.resize(self.resize_corner, dx, dy)
        
        def _handle_key_down(self, event):
            # Handle text input
            if self.text_input_active:
                if event.key == pygame.K_RETURN:
                    # Confirm text input
                    if self.selected_shape:
                        self.selected_shape.text = self.current_text
                    elif self.selected_connection:
                        self.selected_connection.label = self.current_text
                    
                    self.text_input_active = False
                    # Save state for undo/redo
                    self.save_state()
                
                elif event.key == pygame.K_ESCAPE:
                    # Cancel text input
                    self.text_input_active = False
                
                elif event.key == pygame.K_BACKSPACE:
                    # Handle backspace
                    self.current_text = self.current_text[:-1]
                
                else:
                    # Add character to text if printable
                    if event.unicode and ord(event.unicode) >= 32:
                        self.current_text += event.unicode
            
            else:
                # Handle other keyboard shortcuts
                if event.key == pygame.K_DELETE and self.current_tool == "select":
                    if self.selected_shape:
                        # Delete selected shape
                        self.shapes.remove(self.selected_shape)
                        # Delete associated connections
                        self.connections = [c for c in self.connections 
                                           if c.start_point.parent != self.selected_shape 
                                           and c.end_point.parent != self.selected_shape]
                        self._deselect_all()
                        self.save_state()
                    
                    elif self.selected_connection:
                        # Delete selected connection
                        self.connections.remove(self.selected_connection)
                        self._deselect_all()
                        self.save_state()
                
                elif event.key == pygame.K_l and self.selected_shape:
                    # Toggle lock on selected shape
                    self.selected_shape.locked = not self.selected_shape.locked
                    self.save_state()
                
                elif event.key == pygame.K_z and event.mod & pygame.KMOD_CTRL:
                    # Undo
                    self.undo()
                
                elif event.key == pygame.K_y and event.mod & pygame.KMOD_CTRL:
                    # Redo
                    self.redo()
                
                elif event.key == pygame.K_g:
                    # Toggle grid
                    self.show_grid = not self.show_grid
                    self.buttons["grid"]["active"] = self.show_grid
        
        def _handle_button_click(self, button_id):
            # Handle toolbar button clicks
            if button_id in ["select", "create", "connect", "text", "delete"]:
                # Set current tool
                self.current_tool = button_id
                
                # Update button states
                for tool, button in self.buttons.items():
                    if tool in ["select", "create", "connect", "text", "delete"]:
                        button["active"] = (tool == button_id)
            
            elif button_id == "grid":
                # Toggle grid
                self.show_grid = not self.show_grid
                self.buttons["grid"]["active"] = self.show_grid
            
            elif button_id == "clear":
                # Clear all shapes and connections
                self.shapes = []
                self.connections = []
                self._deselect_all()
                self.save_state()
            
            elif button_id == "undo":
                self.undo()
            
            elif button_id == "redo":
                self.redo()
            
            elif button_id == "save":
                # Save functionality would go here
                # For now, just print a message
                print("Save functionality not implemented yet")
        
        def _select_shape(self, shape):
            # Deselect current shape and connection
            self._deselect_all()
            
            # Select new shape
            shape.selected = True
            self.selected_shape = shape
        
        def _select_connection(self, connection):
            # Deselect current shape and connection
            self._deselect_all()
            
            # Select new connection
            connection.selected = True
            self.selected_connection = connection
        
        def _deselect_all(self):
            # Deselect any selected shape
            if self.selected_shape:
                self.selected_shape.selected = False
                self.selected_shape = None
            
            # Deselect any selected connection
            if self.selected_connection:
                self.selected_connection.selected = False
                self.selected_connection = None
        
        def _is_point_on_canvas(self, point):
            x, y = point
            return (CANVAS_X <= x <= CANVAS_X + CANVAS_WIDTH and 
                    CANVAS_Y <= y <= CANVAS_Y + CANVAS_HEIGHT)
        
        def _get_rect_from_points(self, start_pos, end_pos):
            x1, y1 = start_pos
            x2, y2 = end_pos
            
            # Ensure x1,y1 is the top-left and x2,y2 is the bottom-right
            left = min(x1, x2)
            top = min(y1, y2)
            width = abs(x2 - x1)
            height = abs(y2 - y1)
            
            # Snap to grid if enabled
            if self.show_grid:
                left = CANVAS_X + round((left - CANVAS_X) / GRID_SIZE) * GRID_SIZE
                top = CANVAS_Y + round((top - CANVAS_Y) / GRID_SIZE) * GRID_SIZE
                width = round(width / GRID_SIZE) * GRID_SIZE
                height = round(height / GRID_SIZE) * GRID_SIZE
            
            return pygame.Rect(left, top, width, height)
        
        def _get_resize_corner_at_pos(self, pos):
            # Check if pos is on one of the resize handles
            if not self.selected_shape:
                return None
            
            rect = self.selected_shape.rect
            mx, my = pos
            handle_size = 8  # Half-size of handle hitbox
            
            # Check each corner
            if abs(mx - rect.left) <= handle_size and abs(my - rect.top) <= handle_size:
                return "topleft"
            elif abs(mx - rect.right) <= handle_size and abs(my - rect.top) <= handle_size:
                return "topright"
            elif abs(mx - rect.right) <= handle_size and abs(my - rect.bottom) <= handle_size:
                return "bottomright"
            elif abs(mx - rect.left) <= handle_size and abs(my - rect.bottom) <= handle_size:
                return "bottomleft"
            
            return None

    def main():
        clock = pygame.time.Clock()
        editor = DiagramEditor()
        
        running = True
        while running:
            # Process events
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type in [pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION, pygame.KEYDOWN]:
                    editor.handle_event(event)
            
            # Clear the screen
            screen.fill(BACKGROUND)
            
            # Draw the editor
            editor.draw(screen)
            
            # Update the display
            pygame.display.flip()
            
            # Cap the frame rate
            clock.tick(60)
        
        pygame.quit()
        sys.exit()

    if __name__ == "__main__":
        main()
        
if termadm == 6745:
    import os
    import sys
    import platform
    import psutil
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    import threading
    import time
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon80 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon80)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class RetroHackerExplorer:
        def __init__(self, rootscrtscrt):
            self.rootscrtscrt = rootscrtscrt
            self.rootscrtscrt.title("System Explorer")
            self.rootscrtscrt.geometry("1000x700")
            self.rootscrtscrt.configure(bg="#000000")
            
            # Define color scheme
            self.colors = {
                "bg": "#000000", # Black background
                "text": "#00FF00", # Green text
                "highlight": "#00FFFF", # Cyan highlights
                "dark": "#003300", # Dark green for panels
                "frame": "#001100", # Very dark green for frames
                "selected": "#6272a4"
            }
            
            # Apply a custom style
            self.style = ttk.Style()
            self.style.theme_use('default')
            self.style.configure('TFrame', background=self.colors["bg"])
            self.style.configure('TButton', 
                                 background=self.colors["dark"], 
                                 foreground=self.colors["text"],
                                 borderwidth=2,
                                 relief=tk.RIDGE)
            self.style.map('TButton', 
                           background=[('active', self.colors["highlight"])],
                           foreground=[('active', self.colors["bg"])])
            self.style.configure('TLabel', 
                                 background=self.colors["bg"], 
                                 foreground=self.colors["text"])
            self.style.configure('TTreeview', 
                                 background=self.colors["bg"], 
                                 foreground=self.colors["text"],
                                 fieldbackground=self.colors["bg"])
            self.style.map('TTreeview', 
                           background=[('selected', self.colors["dark"])],
                           foreground=[('selected', self.colors["highlight"])])
            
            # Create main frame
            self.main_frame = ttk.Frame(self.rootscrtscrt)
            self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Title with "hacker-style" animation
            self.title_frame = ttk.Frame(self.main_frame)
            self.title_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.title_label = tk.Label(self.title_frame, 
                                       text="SYSTEM EXPLORER", 
                                       font=("Courier New", 18, "bold"),
                                       bg=self.colors["bg"], 
                                       fg=self.colors["highlight"])
            self.title_label.pack(side=tk.LEFT, padx=5)
            
            # System info panel
            self.sys_frame = tk.Frame(self.main_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.sys_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.sys_title = tk.Label(self.sys_frame, 
                                     text="[ SYSTEM INFORMATION ]", 
                                     font=("Courier New", 12, "bold"),
                                     bg=self.colors["frame"], 
                                     fg=self.colors["highlight"])
            self.sys_title.pack(anchor=tk.W, padx=5, pady=2)
            
            self.sys_info = tk.Text(self.sys_frame, 
                                   height=6, 
                                   font=("Courier New", 10),
                                   bg=self.colors["dark"], 
                                   fg=self.colors["text"],
                                   insertbackground=self.colors["highlight"])
            self.sys_info.pack(fill=tk.X, padx=5, pady=5)
            
            # Split main area into two panels
            self.content_frame = ttk.Frame(self.main_frame)
            self.content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Left panel for file explorer
            self.explorer_frame = tk.Frame(self.content_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.explorer_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            self.explorer_title = tk.Label(self.explorer_frame, 
                                          text="[ FILE EXPLORER ]", 
                                          font=("Courier New", 12, "bold"),
                                          bg=self.colors["frame"], 
                                          fg=self.colors["highlight"])
            self.explorer_title.pack(anchor=tk.W, padx=5, pady=2)
            
            # Path entry
            self.path_frame = tk.Frame(self.explorer_frame, bg=self.colors["frame"])
            self.path_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.path_label = tk.Label(self.path_frame, 
                                      text="PATH:", 
                                      font=("Courier New", 10),
                                      bg=self.colors["frame"], 
                                      fg=self.colors["text"])
            self.path_label.pack(side=tk.LEFT, padx=2)
            
            self.path_var = tk.StringVar()
            self.path_entry = tk.Entry(self.path_frame, 
                                      textvariable=self.path_var,
                                      font=("Courier New", 10),
                                      bg=self.colors["dark"], 
                                      fg=self.colors["text"],
                                      insertbackground=self.colors["highlight"])
            self.path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            self.go_button = tk.Button(self.path_frame, 
                                      text="GO", 
                                      font=("Courier New", 10, "bold"),
                                      bg=self.colors["dark"], 
                                      fg=self.colors["text"],
                                      activebackground=self.colors["highlight"],
                                      activeforeground=self.colors["bg"],
                                      command=self.navigate_to_path)
            self.go_button.pack(side=tk.LEFT, padx=2)
            
            # Aplicare stil pentru Treeview
            style = ttk.Style()
            style.configure("Treeview", 
                background=self.colors["dark"], 
                foreground=self.colors["text"], 
                fieldbackground=self.colors["dark"],
                rowheight=25
            )
            style.map("Treeview", 
                background=[("selected", self.colors["selected"])],
                foreground=[("selected", "#ffffff")]
            )
            style.configure("Treeview.Heading", 
                background=self.colors["bg"], 
                foreground=self.colors["text"], 
                font=("Arial", 10, "bold")
            )

            # File tree
            self.tree_frame = tk.Frame(self.explorer_frame, bg=self.colors["dark"])
            self.tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

            self.tree_scroll = tk.Scrollbar(self.tree_frame)
            self.tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

            self.file_tree = ttk.Treeview(self.tree_frame, style="Treeview")
            self.file_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.tree_scroll.config(command=self.file_tree.yview)
            self.file_tree.config(yscrollcommand=self.tree_scroll.set)

            self.file_tree["columns"] = ("size", "modified", "type")
            self.file_tree.column("#0", width=200, minwidth=150)
            self.file_tree.column("size", width=100, minwidth=50)
            self.file_tree.column("modified", width=150, minwidth=100)
            self.file_tree.column("type", width=100, minwidth=50)

            self.file_tree.heading("#0", text="Name")
            self.file_tree.heading("size", text="Size")
            self.file_tree.heading("modified", text="Modified")
            self.file_tree.heading("type", text="Type")

            self.file_tree.bind("<Double-1>", self.on_tree_double_click)

            
            # Right panel for system monitoring
            self.monitor_frame = tk.Frame(self.content_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.monitor_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            self.monitor_title = tk.Label(self.monitor_frame, 
                                         text="[ SYSTEM MONITOR ]", 
                                         font=("Courier New", 12, "bold"),
                                         bg=self.colors["frame"], 
                                         fg=self.colors["highlight"])
            self.monitor_title.pack(anchor=tk.W, padx=5, pady=2)
            
            # CPU usage
            self.cpu_frame = tk.Frame(self.monitor_frame, bg=self.colors["frame"])
            self.cpu_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.cpu_label = tk.Label(self.cpu_frame, 
                                     text="CPU:", 
                                     font=("Courier New", 10),
                                     bg=self.colors["frame"], 
                                     fg=self.colors["text"],
                                     width=10, anchor=tk.W)
            self.cpu_label.pack(side=tk.LEFT, padx=2)
            
            self.cpu_canvas = tk.Canvas(self.cpu_frame, 
                                       height=20, 
                                       bg=self.colors["dark"],
                                       highlightbackground=self.colors["dark"])
            self.cpu_canvas.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            # Memory usage
            self.mem_frame = tk.Frame(self.monitor_frame, bg=self.colors["frame"])
            self.mem_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.mem_label = tk.Label(self.mem_frame, 
                                     text="MEMORY:", 
                                     font=("Courier New", 10),
                                     bg=self.colors["frame"], 
                                     fg=self.colors["text"],
                                     width=10, anchor=tk.W)
            self.mem_label.pack(side=tk.LEFT, padx=2)
            
            self.mem_canvas = tk.Canvas(self.mem_frame, 
                                       height=20, 
                                       bg=self.colors["dark"],
                                       highlightbackground=self.colors["dark"])
            self.mem_canvas.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            # Disk usage
            self.disk_frame = tk.Frame(self.monitor_frame, bg=self.colors["frame"])
            self.disk_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.disk_label = tk.Label(self.disk_frame, 
                                      text="DISK:", 
                                      font=("Courier New", 10),
                                      bg=self.colors["frame"], 
                                      fg=self.colors["text"],
                                      width=10, anchor=tk.W)
            self.disk_label.pack(side=tk.LEFT, padx=2)
            
            self.disk_canvas = tk.Canvas(self.disk_frame, 
                                        height=20, 
                                        bg=self.colors["dark"],
                                        highlightbackground=self.colors["dark"])
            self.disk_canvas.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            # Process list
            self.process_title = tk.Label(self.monitor_frame, 
                                         text="[ RUNNING PROCESSES ]", 
                                         font=("Courier New", 10, "bold"),
                                         bg=self.colors["frame"], 
                                         fg=self.colors["text"])
            self.process_title.pack(anchor=tk.W, padx=5, pady=2)
            
            self.process_frame = tk.Frame(self.monitor_frame, bg=self.colors["dark"])
            self.process_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            self.process_scroll = tk.Scrollbar(self.process_frame, bg=self.colors["dark"])
            self.process_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            
            self.process_list = tk.Listbox(self.process_frame, 
                                          font=("Courier New", 9),
                                          bg=self.colors["dark"], 
                                          fg=self.colors["text"],
                                          selectbackground=self.colors["frame"],
                                          selectforeground=self.colors["highlight"])
            self.process_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            self.process_scroll.config(command=self.process_list.yview)
            self.process_list.config(yscrollcommand=self.process_scroll.set)
            
            # Console output at the bottom
            self.console_frame = tk.Frame(self.main_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.console_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.console_title = tk.Label(self.console_frame, 
                                         text="[ CONSOLE ]", 
                                         font=("Courier New", 10, "bold"),
                                         bg=self.colors["frame"], 
                                         fg=self.colors["text"])
            self.console_title.pack(anchor=tk.W, padx=5, pady=2)
            
            self.console = tk.Text(self.console_frame, 
                                  height=4, 
                                  font=("Courier New", 9),
                                  bg=self.colors["dark"], 
                                  fg=self.colors["text"],
                                  insertbackground=self.colors["highlight"])
            self.console.pack(fill=tk.X, padx=5, pady=5)
            
            # Status bar
            self.status_bar = tk.Label(self.rootscrtscrt, 
                                      text="SYSTEM: ONLINE | STATUS: READY", 
                                      font=("Courier New", 9),
                                      bg=self.colors["bg"], 
                                      fg=self.colors["highlight"],
                                      bd=1, relief=tk.SUNKEN, anchor=tk.W)
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
            
            # Initialize with current directory
            self.current_path = os.getcwd()
            self.path_var.set(self.current_path)
            
            # Start update threads
            self.stop_threads = False
            self.update_system_info()
            self.update_file_explorer()
            
            # Start monitor update thread
            self.monitor_thread = threading.Thread(target=self.update_monitor)
            self.monitor_thread.daemon = True
            self.monitor_thread.start()
            
            # Start title animation
            self.animate_title()
        
        def animate_title(self):
            """Animate the title with a hacker-style effect"""
            text = self.title_label.cget("text")
            if "█" in text:
                # Remove cursor
                self.title_label.config(text=text.replace("█", ""))
            else:
                # Add cursor
                self.title_label.config(text=text + "█")
            self.rootscrtscrt.after(500, self.animate_title)
        
        def update_system_info(self):
            """Update system information"""
            self.sys_info.config(state=tk.NORMAL)
            self.sys_info.delete(1.0, tk.END)
            
            uname = platform.uname()
            cpu_info = f"CPU: {platform.processor()}"
            if len(cpu_info) > 60:
                cpu_info = cpu_info[:57] + "..."
                
            info_text = (
                f"OS: {uname.system} {uname.release} ({uname.version})\n"
                f"NODE: {uname.node}\n"
                f"{cpu_info}\n"
                f"TOTAL RAM: {round(psutil.virtual_memory().total / (1024**3), 2)} GB\n"
                f"PYTHON: {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\n"
                f"TIME: {time.strftime('%Y-%m-%d %H:%M:%S')}"
            )
            
            self.sys_info.insert(tk.END, info_text)
            self.sys_info.config(state=tk.DISABLED)
            
            # Log system info to console
            self.console_log("System information updated")
        
        def console_log(self, message):
            """Log message to console with timestamp"""
            timestamp = time.strftime("[%H:%M:%S]")
            self.console.config(state=tk.NORMAL)
            self.console.insert(tk.END, f"{timestamp} {message}\n")
            self.console.see(tk.END)
            self.console.config(state=tk.DISABLED)
        
        def update_file_explorer(self):
            """Update file explorer with current path contents"""
            self.file_tree.delete(*self.file_tree.get_children())
            
            try:
                # Set current path
                self.current_path = self.path_var.get()
                
                # List directory contents
                items = os.listdir(self.current_path)
                
                # Add parent directory entry
                parent_id = self.file_tree.insert("", "end", text="..", values=("", "", "Parent Dir"))
                
                # Add directories first
                for item in sorted([x for x in items if os.path.isdir(os.path.join(self.current_path, x))]):
                    try:
                        path = os.path.join(self.current_path, item)
                        stats = os.stat(path)
                        modified = time.strftime("%Y-%m-%d %H:%M", time.localtime(stats.st_mtime))
                        self.file_tree.insert("", "end", text=item, values=("", modified, "Directory"))
                    except Exception as e:
                        self.file_tree.insert("", "end", text=item, values=("", "", f"Error: {str(e)[:20]}"))
                
                # Then add files
                for item in sorted([x for x in items if os.path.isfile(os.path.join(self.current_path, x))]):
                    try:
                        path = os.path.join(self.current_path, item)
                        stats = os.stat(path)
                        size = self.format_size(stats.st_size)
                        modified = time.strftime("%Y-%m-%d %H:%M", time.localtime(stats.st_mtime))
                        file_type = os.path.splitext(item)[1][1:].upper() if os.path.splitext(item)[1] else "File"
                        self.file_tree.insert("", "end", text=item, values=(size, modified, file_type))
                    except Exception as e:
                        self.file_tree.insert("", "end", text=item, values=("", "", f"Error: {str(e)[:20]}"))
                
                self.console_log(f"Navigated to: {self.current_path}")
                self.status_bar.config(text=f"CURRENT PATH: {self.current_path}")
                
            except Exception as e:
                self.console_log(f"Error accessing path: {str(e)}")
                messagebox.showerror("Access Error", f"Cannot access path: {str(e)}")
                # Revert to previous path
                self.path_var.set(self.current_path)
        
        def format_size(self, size):
            """Format file size in human-readable format"""
            for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
                if size < 1024:
                    return f"{size:.1f} {unit}"
                size /= 1024
            return f"{size:.1f} PB"
        
        def navigate_to_path(self):
            """Navigate to the path entered in the path entry"""
            path = self.path_var.get()
            if os.path.exists(path) and os.path.isdir(path):
                self.current_path = path
                self.update_file_explorer()
            else:
                messagebox.showerror("Invalid Path", "The specified path does not exist or is not a directory")
                self.path_var.set(self.current_path)
        
        def on_tree_double_click(self, event):
            """Handle double click on file tree"""
            item = self.file_tree.selection()[0]
            item_text = self.file_tree.item(item, "text")
            
            if item_text == "..":
                # Navigate to parent directory
                parent_path = os.path.dirname(self.current_path)
                self.path_var.set(parent_path)
                self.navigate_to_path()
            else:
                # Get full path
                full_path = os.path.join(self.current_path, item_text)
                
                if os.path.isdir(full_path):
                    # Navigate to directory
                    self.path_var.set(full_path)
                    self.navigate_to_path()
                else:
                    # Display file info
                    stats = os.stat(full_path)
                    file_info = (
                        f"FILE: {item_text}\n"
                        f"PATH: {full_path}\n"
                        f"SIZE: {self.format_size(stats.st_size)}\n"
                        f"CREATED: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(stats.st_ctime))}\n"
                        f"MODIFIED: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(stats.st_mtime))}\n"
                        f"ACCESSED: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(stats.st_atime))}"
                    )
                    self.console_log(f"Selected file: {full_path}")
                    messagebox.showinfo("File Information", file_info)
        
        def update_monitor(self):
            """Update system monitor continuously"""
            while not self.stop_threads:
                try:
                    # Update CPU usage
                    cpu_percent = psutil.cpu_percent()
                    self.cpu_canvas.delete("all")
                    width = self.cpu_canvas.winfo_width()
                    bar_width = int(width * cpu_percent / 100)
                    self.cpu_canvas.create_rectangle(0, 0, bar_width, 20, 
                                                   fill=self.get_color_for_percent(cpu_percent), 
                                                   outline="")
                    self.cpu_canvas.create_text(width/2, 10, 
                                              text=f"{cpu_percent}%", 
                                              fill=self.colors["text"])
                    
                    # Update Memory usage
                    mem = psutil.virtual_memory()
                    mem_percent = mem.percent
                    self.mem_canvas.delete("all")
                    width = self.mem_canvas.winfo_width()
                    bar_width = int(width * mem_percent / 100)
                    self.mem_canvas.create_rectangle(0, 0, bar_width, 20, 
                                                   fill=self.get_color_for_percent(mem_percent), 
                                                   outline="")
                    self.mem_canvas.create_text(width/2, 10, 
                                              text=f"{mem_percent}% ({self.format_size(mem.used)}/{self.format_size(mem.total)})", 
                                              fill=self.colors["text"])
                    
                    # Update Disk usage
                    disk = psutil.disk_usage('/')
                    disk_percent = disk.percent
                    self.disk_canvas.delete("all")
                    width = self.disk_canvas.winfo_width()
                    bar_width = int(width * disk_percent / 100)
                    self.disk_canvas.create_rectangle(0, 0, bar_width, 20, 
                                                    fill=self.get_color_for_percent(disk_percent), 
                                                    outline="")
                    self.disk_canvas.create_text(width/2, 10, 
                                               text=f"{disk_percent}% ({self.format_size(disk.used)}/{self.format_size(disk.total)})", 
                                               fill=self.colors["text"])
                    
                    # Update process list (every 5 seconds to avoid performance impact)
                    if int(time.time()) % 5 == 0:
                        self.update_process_list()
                    
                    time.sleep(1)
                except Exception as e:
                    self.console_log(f"Monitor error: {str(e)}")
                    time.sleep(5) # Wait longer on error
        
        def get_color_for_percent(self, percent):
            """Get color based on percentage (green to yellow to red)"""
            if percent < 50:
                # Green to Yellow (0-50%)
                r = int(255 * percent / 50)
                g = 255
                b = 0
            else:
                # Yellow to Red (50-100%)
                r = 255
                g = int(255 * (100 - percent) / 50)
                b = 0
            return f"#{r:02x}{g:02x}{b:02x}"
        
        def update_process_list(self):
            """Update the process list"""
            self.process_list.delete(0, tk.END)
            
            try:
                # Get process information
                processes = []
                for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                    try:
                        pinfo = proc.info
                        processes.append((
                            pinfo['pid'],
                            pinfo['name'],
                            pinfo['cpu_percent'],
                            pinfo['memory_percent']
                        ))
                    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                        pass
                
                # Sort by CPU usage and display top processes
                for pid, name, cpu, mem in sorted(processes, key=lambda x: x[2], reverse=True)[:20]:
                    self.process_list.insert(tk.END, f"{pid:5} | {name[:20]:20} | CPU: {cpu:5.1f}% | MEM: {mem:5.1f}%")
            except Exception as e:
                self.console_log(f"Process list error: {str(e)}")
        
        def on_close(self):
            """Handle window close event"""
            self.stop_threads = True
            self.rootscrtscrt.destroy()

    def main():
        rootscrtscrt = tk.Tk()
        app = RetroHackerExplorer(rootscrtscrt)
        rootscrtscrt.protocol("WM_DELETE_WINDOW", app.on_close)
        rootscrtscrt.mainloop()

    if __name__ == "__main__":
        main()
        
if commandervar == 88888888:
    import os
    import shutil
    import tkinter as tk
    from tkinter import ttk, messagebox, simpledialog
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon61 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon61)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class RetroFileManagerApp:
        def __init__(self, rootcomm):
            self.rootcomm = rootcomm
            self.rootcomm.title("Commander - File Manager")
            self.rootcomm.geometry("1000x600")
            
            # Definim culorile Windows 95
            self.bg_color = "#C0C0C0"  # Gri deschis specific Windows 95
            self.text_color = "#000000"  # Negru
            self.button_color = "#C0C0C0"  # Gri pentru butoane
            self.highlight_color = "#000080"  # Albastru închis pentru selecție
            self.button_shadow = "#808080"  # Gri închis pentru umbră butoane
            self.button_highlight = "#FFFFFF"  # Alb pentru highlight butoane
            
            # Configurăm rootcomm
            self.rootcomm.configure(bg=self.bg_color)
            
            # Creăm un stil pentru elemente
            self.create_retro_style()
            
            # Creăm frame-ul principal
            self.main_frame = tk.Frame(rootcomm, bg=self.bg_color, relief="raised", bd=2)
            self.main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Bara de titlu cu logo Windows 95
            self.title_bar = tk.Frame(self.main_frame, bg="#000080", height=20)
            self.title_bar.pack(fill=tk.X)
            self.title_label = tk.Label(self.title_bar, text="RetroCommander - File Manager", 
                                        bg="#000080", fg="white", font=("Arial", 10, "bold"))
            self.title_label.pack(side=tk.LEFT, padx=5)
            
            # Bara de meniu
            self.menu_bar = tk.Frame(self.main_frame, bg=self.bg_color, relief="raised", bd=1)
            self.menu_bar.pack(fill=tk.X)
            
            # Butoane de meniu
            menu_buttons = ["File", "Edit", "View", "Options", "Help"]
            for btn_text in menu_buttons:
                btn = tk.Button(self.menu_bar, text=btn_text, bg=self.bg_color, relief="flat",
                                borderwidth=1, font=("Arial", 9), pady=1)
                btn.pack(side=tk.LEFT, padx=2)
            
            # Creăm panoul împărțit
            self.paned_window = tk.PanedWindow(self.main_frame, orient=tk.HORIZONTAL, 
                                               bg=self.bg_color, sashwidth=4, relief="sunken")
            self.paned_window.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Panoul stâng
            self.left_frame = tk.Frame(self.paned_window, bg=self.bg_color, relief="sunken", bd=2)
            self.paned_window.add(self.left_frame, width=400)
            
            # Panoul drept
            self.right_frame = tk.Frame(self.paned_window, bg=self.bg_color, relief="sunken", bd=2)
            self.paned_window.add(self.right_frame, width=400)
            
            # Configurăm fiecare panou
            self.setup_panel(self.left_frame, "left")
            self.setup_panel(self.right_frame, "right")
            
            # Căile curente pentru fiecare panou
            self.paths = {
                "left": os.path.expanduser("~"),
                "right": os.path.expanduser("~")
            }
            
            # Panoul activ (implicit: stâng)
            self.active_panel = "left"
            self.highlight_active_panel()
            
            # Bara de instrumente de jos cu scurtături
            self.setup_toolbar()
            
            # Asocieri de taste
            self.setup_keybindings()
            
            # Încărcarea inițială a directoarelor
            self.refresh_panels()
        
        def create_retro_style(self):
            # Stilizare pentru Windows 95
            style = ttk.Style()
            style.theme_use('clam')
            
            # Stilizare pentru Treeview
            style.configure("Treeview", 
                            background="white",
                            foreground="black",
                            fieldbackground="white",
                            borderwidth=1)
            style.map("Treeview", 
                     background=[('selected', '#000080')])
            
            # Stilizare pentru entrye-uri
            style.configure("TEntry", 
                            fieldbackground="white", 
                            borderwidth=2)
            
            # Stilizare pentru butoane
            style.configure("Retro.TButton", 
                        font=("Arial", 9, "bold"),
                        borderwidth=2,
                        relief="raised")
            
            # Stilizare pentru frame-uri
            style.configure("TFrame", background=self.bg_color)
        
        def setup_panel(self, frame, side):
            # Frame pentru calea curentă
            path_frame = tk.Frame(frame, bg=self.bg_color)
            path_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # Label pentru cale
            path_label = tk.Label(path_frame, text="Path:", bg=self.bg_color)
            path_label.pack(side=tk.LEFT, padx=5)
            
            # Entry pentru cale
            self.path_vars = self.path_vars if hasattr(self, 'path_vars') else {}
            self.path_vars[side] = tk.StringVar()
            
            path_entry = tk.Entry(path_frame, textvariable=self.path_vars[side], 
                                  relief="sunken", bd=2, bg="white")
            path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
            path_entry.bind("<Return>", lambda e, s=side: self.navigate_to_path(s))
            
            # Buton Go
            go_button = tk.Button(path_frame, text="Go", bg=self.button_color,
                                 relief="raised", bd=2, command=lambda s=side: self.navigate_to_path(s))
            go_button.pack(side=tk.RIGHT, padx=5)
            
            # Frame pentru Treeview
            self.tree_frames = self.tree_frames if hasattr(self, 'tree_frames') else {}
            self.tree_frames[side] = tk.Frame(frame, bg=self.bg_color, relief="sunken", bd=2)
            self.tree_frames[side].pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Treeview cu scrollbar
            self.trees = self.trees if hasattr(self, 'trees') else {}
            
            # Scrollbar
            tree_scroll = tk.Scrollbar(self.tree_frames[side], relief="raised", bd=2)
            tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Treeview pentru fișiere
            self.trees[side] = ttk.Treeview(self.tree_frames[side], 
                                           columns=("name", "size", "modified"),
                                           show="headings",
                                           yscrollcommand=tree_scroll.set)
            
            tree_scroll.config(command=self.trees[side].yview)
            
            # Configurăm coloanele
            self.trees[side].heading("name", text="Name")
            self.trees[side].heading("size", text="Size")
            self.trees[side].heading("modified", text="Modified")
            
            self.trees[side].column("name", width=200)
            self.trees[side].column("size", width=100)
            self.trees[side].column("modified", width=150)
            
            self.trees[side].pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Asociem evenimente
            self.trees[side].bind("<Double-1>", lambda e, s=side: self.on_item_double_click(s))
            self.trees[side].bind("<ButtonRelease-1>", lambda e, s=side: self.on_item_click(s))
        
        def setup_toolbar(self):
            # Frame pentru bara de instrumente
            toolbar_frame = tk.Frame(self.main_frame, bg=self.bg_color, relief="raised", bd=2)
            toolbar_frame.pack(fill=tk.X, pady=5)
            
            # Butoane pentru funcții
            buttons = [
                ("F1 Help", self.show_help),
                ("F2 Rename", self.rename_item),
                ("F3 View", self.view_item),
                ("F4 Edit", self.edit_item),
                ("F5 Copy", self.copy_item),
                ("F6 Move", self.move_item),
                ("F7 MkDir", self.make_directory),
                ("F8 Delete", self.delete_item),
                ("F10 Quit", self.quit_app)
            ]
            
            # Creăm butoanele cu stil Windows 95
            for text, command in buttons:
                btn = tk.Button(toolbar_frame, text=text, command=command,
                               bg=self.button_color, bd=3, relief="raised",
                               font=("Arial", 9, "bold"), width=8)
                btn.pack(side=tk.LEFT, padx=3, pady=3)
        
        def setup_keybindings(self):
            self.rootcomm.bind("<F1>", lambda e: self.show_help())
            self.rootcomm.bind("<F2>", lambda e: self.rename_item())
            self.rootcomm.bind("<F3>", lambda e: self.view_item())
            self.rootcomm.bind("<F4>", lambda e: self.edit_item())
            self.rootcomm.bind("<F5>", lambda e: self.copy_item())
            self.rootcomm.bind("<F6>", lambda e: self.move_item())
            self.rootcomm.bind("<F7>", lambda e: self.make_directory())
            self.rootcomm.bind("<F8>", lambda e: self.delete_item())
            self.rootcomm.bind("<F10>", lambda e: self.quit_app())
            self.rootcomm.bind("<Tab>", lambda e: self.toggle_active_panel())
        
        def toggle_active_panel(self):
            self.active_panel = "right" if self.active_panel == "left" else "left"
            self.highlight_active_panel()
        
        def highlight_active_panel(self):
            for side in ["left", "right"]:
                if side == self.active_panel:
                    self.tree_frames[side].configure(relief="groove", bd=3)
                else:
                    self.tree_frames[side].configure(relief="sunken", bd=2)
        
        def navigate_to_path(self, side):
            path = self.path_vars[side].get()
            if os.path.exists(path) and os.path.isdir(path):
                self.paths[side] = path
                self.refresh_panel(side)
            else:
                self.show_error_dialog("Error", f"Invalid path: {path}")
        
        def load_directory(self, side, path):
            self.trees[side].delete(*self.trees[side].get_children())
            
            # Adăugăm elementul pentru directorul părinte
            if path != os.path.dirname(path):
                self.trees[side].insert("", "end", values=("..", "", ""), tags=("parent",))
            
            try:
                items = os.listdir(path)
                
                # Adăugăm mai întâi directoarele
                for item in sorted(items):
                    item_path = os.path.join(path, item)
                    if os.path.isdir(item_path):
                        size = ""
                        try:
                            modified = os.path.getmtime(item_path)
                            modified_str = tk.Tcl().call('clock', 'format', int(modified), '-format', '%Y-%m-%d %H:%M')
                        except:
                            modified_str = ""
                        
                        self.trees[side].insert("", "end", values=(item + "/", size, modified_str), tags=("dir",))
                
                # Apoi adăugăm fișierele
                for item in sorted(items):
                    item_path = os.path.join(path, item)
                    if os.path.isfile(item_path):
                        try:
                            size = self.format_size(os.path.getsize(item_path))
                            modified = os.path.getmtime(item_path)
                            modified_str = tk.Tcl().call('clock', 'format', int(modified), '-format', '%Y-%m-%d %H:%M')
                        except:
                            size = ""
                            modified_str = ""
                        
                        self.trees[side].insert("", "end", values=(item, size, modified_str), tags=("file",))
                        
            except PermissionError:
                self.show_error_dialog("Error", f"Permission denied: {path}")
            except Exception as e:
                self.show_error_dialog("Error", f"Error loading directory: {str(e)}")
        
        def show_error_dialog(self, title, message):
            dialog = tk.Toplevel(self.rootcomm)
            dialog.title(title)
            dialog.geometry("300x150")
            dialog.configure(bg=self.bg_color)
            dialog.transient(self.rootcomm)
            dialog.grab_set()
            
            icon_label = tk.Label(dialog, text="X", font=("Arial", 24), fg="red", bg=self.bg_color)
            icon_label.pack(pady=(10, 5))
            
            message_label = tk.Label(dialog, text=message, wraplength=250, bg=self.bg_color)
            message_label.pack(pady=5)
            
            btn_frame = tk.Frame(dialog, bg=self.bg_color)
            btn_frame.pack(pady=10)
            
            ok_button = tk.Button(btn_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=dialog.destroy)
            ok_button.pack()
        
        def format_size(self, size):
            for unit in ["B", "KB", "MB", "GB", "TB"]:
                if size < 1024.0:
                    return f"{size:.2f} {unit}"
                size /= 1024.0
            return f"{size:.2f} TB"
        
        def refresh_panel(self, side):
            self.path_vars[side].set(self.paths[side])
            self.load_directory(side, self.paths[side])
        
        def refresh_panels(self):
            for side in ["left", "right"]:
                self.refresh_panel(side)
        
        def on_item_double_click(self, side):
            selected = self.trees[side].focus()
            if not selected:
                return
                
            values = self.trees[side].item(selected, "values")
            if not values:
                return
                
            name = values[0]
            
            if name == "..":
                # Mergem un director mai sus
                self.paths[side] = os.path.dirname(self.paths[side])
            elif name.endswith("/"):
                # Intrăm în director
                name = name[:-1]  # Eliminăm slash-ul final
                new_path = os.path.join(self.paths[side], name)
                if os.path.exists(new_path) and os.path.isdir(new_path):
                    self.paths[side] = new_path
            else:
                # Deschidem fișierul (în acest caz doar vizualizare)
                self.view_item()
                return
                
            self.refresh_panel(side)
        
        def on_item_click(self, side):
            self.active_panel = side
            self.highlight_active_panel()
        
        def get_selected_item(self):
            side = self.active_panel
            selected = self.trees[side].focus()
            if not selected:
                return None, None
                
            values = self.trees[side].item(selected, "values")
            if not values:
                return None, None
                
            name = values[0]
            if name == "..":
                return None, None
                
            if name.endswith("/"):
                name = name[:-1]  # Eliminăm slash-ul final
                
            path = os.path.join(self.paths[side], name)
            return name, path
        
        def get_inactive_panel_path(self):
            inactive = "right" if self.active_panel == "left" else "left"
            return self.paths[inactive]
        
        # Funcții pentru acțiuni
        def show_help(self):
            help_text = """
            RetroCommander File Manager Help
            --------------------------------
            F1: Help - Show this help screen
            F2: Rename - Rename selected file/folder
            F3: View - View selected file
            F4: Edit - Edit selected file
            F5: Copy - Copy to other panel
            F6: Move - Move to other panel
            F7: MkDir - Create new directory
            F8: Delete - Delete selected file/folder
            F10: Quit - Exit application
            Tab: Switch active panel
            """
            
            # Creăm o fereastră de ajutor în stil Windows 95
            help_window = tk.Toplevel(self.rootcomm)
            help_window.title("Help")
            help_window.geometry("400x350")
            help_window.configure(bg=self.bg_color)
            help_window.transient(self.rootcomm)
            
            # Titlu
            title_frame = tk.Frame(help_window, bg="#000080", height=20)
            title_frame.pack(fill=tk.X)
            title_label = tk.Label(title_frame, text="RetroCommander Help", 
                                  bg="#000080", fg="white", font=("Arial", 10, "bold"))
            title_label.pack(side=tk.LEFT, padx=5)
            
            # Conținut
            content_frame = tk.Frame(help_window, bg=self.bg_color, relief="sunken", bd=2)
            content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            help_label = tk.Label(content_frame, text=help_text, justify=tk.LEFT, 
                                 bg="white", relief="sunken", bd=2, padx=10, pady=10)
            help_label.pack(fill=tk.BOTH, expand=True)
            
            # Buton OK
            button_frame = tk.Frame(help_window, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            ok_button = tk.Button(button_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=help_window.destroy)
            ok_button.pack()
        
        def rename_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
            
            # Dialog pentru redenumire în stil Windows 95
            rename_dialog = tk.Toplevel(self.rootcomm)
            rename_dialog.title("Rename")
            rename_dialog.geometry("300x120")
            rename_dialog.configure(bg=self.bg_color)
            rename_dialog.transient(self.rootcomm)
            rename_dialog.grab_set()
            
            tk.Label(rename_dialog, text="Enter new name:", bg=self.bg_color).pack(pady=(10, 5))
            
            new_name_var = tk.StringVar(value=name)
            entry = tk.Entry(rename_dialog, textvariable=new_name_var, width=40, 
                            relief="sunken", bd=2, bg="white")
            entry.pack(padx=10, pady=5)
            entry.select_range(0, tk.END)
            entry.focus_set()
            
            button_frame = tk.Frame(rename_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            def do_rename():
                new_name = new_name_var.get()
                if new_name and new_name != name:
                    try:
                        new_path = os.path.join(os.path.dirname(path), new_name)
                        os.rename(path, new_path)
                        self.refresh_panels()
                        rename_dialog.destroy()
                    except Exception as e:
                        self.show_error_dialog("Error", f"Cannot rename: {str(e)}")
                else:
                    rename_dialog.destroy()
            
            ok_button = tk.Button(button_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=do_rename)
            ok_button.pack(side=tk.LEFT, padx=5)
            
            cancel_button = tk.Button(button_frame, text="Cancel", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=rename_dialog.destroy)
            cancel_button.pack(side=tk.LEFT, padx=5)
            
            entry.bind("<Return>", lambda e: do_rename())
        
        def view_item(self):
            name, path = self.get_selected_item()
            if not path or not os.path.isfile(path):
                return
                
            try:
                # Fereastră simplă pentru vizualizare fișiere în stil Windows 95
                viewer = tk.Toplevel(self.rootcomm)
                viewer.title(f"View: {name}")
                viewer.geometry("700x500")
                viewer.configure(bg=self.bg_color)
                
                # Bara de titlu
                title_frame = tk.Frame(viewer, bg="#000080", height=20)
                title_frame.pack(fill=tk.X)
                title_label = tk.Label(title_frame, text=f"View: {name}", 
                                      bg="#000080", fg="white", font=("Arial", 10, "bold"))
                title_label.pack(side=tk.LEFT, padx=5)
                
                # Conținut
                content_frame = tk.Frame(viewer, bg=self.bg_color, padx=5, pady=5)
                content_frame.pack(fill=tk.BOTH, expand=True)
                
                text = tk.Text(content_frame, wrap=tk.WORD, bg="white", fg="black", 
                              relief="sunken", bd=2, font=("Courier", 10))
                scroll = tk.Scrollbar(content_frame, command=text.yview, relief="raised", bd=2)
                text.configure(yscrollcommand=scroll.set)
                
                text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                scroll.pack(side=tk.RIGHT, fill=tk.Y)
                
                try:
                    with open(path, 'r') as f:
                        content = f.read()
                    text.insert(tk.END, content)
                    text.configure(state='disabled')
                except UnicodeDecodeError:
                    text.insert(tk.END, "Cannot display binary file content.")
                    text.configure(state='disabled')
                    
                # Buton de închidere
                button_frame = tk.Frame(viewer, bg=self.bg_color)
                button_frame.pack(pady=5)
                
                close_button = tk.Button(button_frame, text="Close", width=10, bg=self.button_color,
                                        relief="raised", bd=3, command=viewer.destroy)
                close_button.pack()
                    
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot view file: {str(e)}")
        
        def edit_item(self):
            name, path = self.get_selected_item()
            if not path or not os.path.isfile(path):
                return
                
            try:
                # Fereastră simplă pentru editare fișiere în stil Windows 95
                editor = tk.Toplevel(self.rootcomm)
                editor.title(f"Edit: {name}")
                editor.geometry("700x500")
                editor.configure(bg=self.bg_color)
                
                # Bara de titlu
                title_frame = tk.Frame(editor, bg="#000080", height=20)
                title_frame.pack(fill=tk.X)
                title_label = tk.Label(title_frame, text=f"Edit: {name}", 
                                      bg="#000080", fg="white", font=("Arial", 10, "bold"))
                title_label.pack(side=tk.LEFT, padx=5)
                
                # Conținut
                content_frame = tk.Frame(editor, bg=self.bg_color, padx=5, pady=5)
                content_frame.pack(fill=tk.BOTH, expand=True)
                
                text = tk.Text(content_frame, wrap=tk.WORD, bg="white", fg="black", 
                              relief="sunken", bd=2, font=("Courier", 10))
                scroll = tk.Scrollbar(content_frame, command=text.yview, relief="raised", bd=2)
                text.configure(yscrollcommand=scroll.set)
                
                text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                scroll.pack(side=tk.RIGHT, fill=tk.Y)
                
                try:
                    with open(path, 'r') as f:
                        content = f.read()
                    text.insert(tk.END, content)
                except UnicodeDecodeError:
                    self.show_error_dialog("Error", "Cannot edit binary file.")
                    editor.destroy()
                    return
                    
                def save_file():
                    try:
                        with open(path, 'w') as f:
                            f.write(text.get(1.0, tk.END))
                        self.refresh_panels()
                        editor.destroy()
                    except Exception as e:
                        self.show_error_dialog("Error", f"Cannot save file: {str(e)}")
                
                # Butoane
                button_frame = tk.Frame(editor, bg=self.bg_color)
                button_frame.pack(pady=5)
                
                save_button = tk.Button(button_frame, text="Save", width=10, bg=self.button_color,
                                       relief="raised", bd=3, command=save_file)
                save_button.pack(side=tk.LEFT, padx=5)
                
                cancel_button = tk.Button(button_frame, text="Cancel", width=10, bg=self.button_color,
                                         relief="raised", bd=3, command=editor.destroy)
                cancel_button.pack(side=tk.LEFT, padx=5)
                    
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot edit file: {str(e)}")
        
        def copy_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
                
            target_dir = self.get_inactive_panel_path()
            target_path = os.path.join(target_dir, name)
            
            if os.path.exists(target_path):
                # Dialog de confirmare în stil Windows 95
                confirm_dialog = tk.Toplevel(self.rootcomm)
                confirm_dialog.title("Confirm")
                confirm_dialog.geometry("350x150")
                confirm_dialog.configure(bg=self.bg_color)
                confirm_dialog.transient(self.rootcomm)
                confirm_dialog.grab_set()
                
                icon_label = tk.Label(confirm_dialog, text="?", font=("Arial", 24), fg="blue", bg=self.bg_color)
                icon_label.pack(pady=(10, 5))
                
                message_label = tk.Label(confirm_dialog, 
                                        text=f"{name} already exists. Overwrite?", 
                                        wraplength=300, bg=self.bg_color)
                message_label.pack(pady=5)
                
                button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
                button_frame.pack(pady=10)
                
                result = [False]  # Folosim o listă pentru a stoca rezultatul
                
                def on_yes():
                    result[0] = True
                    confirm_dialog.destroy()
                    
                def on_no():
                    result[0] = False
                    confirm_dialog.destroy()
                
                yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                      relief="raised", bd=3, command=on_yes)
                yes_button.pack(side=tk.LEFT, padx=5)
                
                no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=on_no)
                no_button.pack(side=tk.LEFT, padx=5)
                
                # Așteptăm închiderea dialogului
                self.rootcomm.wait_window(confirm_dialog)
                
                if not result[0]:
                    return
            
            try:
                if os.path.isdir(path):
                    shutil.copytree(path, target_path)
                else:
                    shutil.copy2(path, target_path)
                self.refresh_panels()
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot copy: {str(e)}")
        
        def move_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
                
            target_dir = self.get_inactive_panel_path()
            target_path = os.path.join(target_dir, name)
            
            if os.path.exists(target_path):
                # Dialog de confirmare în stil Windows 95
                confirm_dialog = tk.Toplevel(self.rootcomm)
                confirm_dialog.title("Confirm")
                confirm_dialog.geometry("350x150")
                confirm_dialog.configure(bg=self.bg_color)
                confirm_dialog.transient(self.rootcomm)
                confirm_dialog.grab_set()
                
                icon_label = tk.Label(confirm_dialog, text="?", font=("Arial", 24), fg="blue", bg=self.bg_color)
                icon_label.pack(pady=(10, 5))
                
                message_label = tk.Label(confirm_dialog, 
                                        text=f"{name} already exists. Overwrite?", 
                                        wraplength=300, bg=self.bg_color)
                message_label.pack(pady=5)
                
                button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
                button_frame.pack(pady=10)
                
                result = [False]  # Folosim o listă pentru a stoca rezultatul
                
                def on_yes():
                    result[0] = True
                    confirm_dialog.destroy()
                    
                def on_no():
                    result[0] = False
                    confirm_dialog.destroy()
                
                yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                      relief="raised", bd=3, command=on_yes)
                yes_button.pack(side=tk.LEFT, padx=5)
                
                no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=on_no)
                no_button.pack(side=tk.LEFT, padx=5)
                
                # Așteptăm închiderea dialogului
                self.rootcomm.wait_window(confirm_dialog)
                
                if not result[0]:
                    return
            
            try:
                shutil.move(path, target_path)
                self.refresh_panels()
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot move: {str(e)}")
        
        def make_directory(self):
            side = self.active_panel
            
            # Dialog pentru nume director în stil Windows 95
            mkdir_dialog = tk.Toplevel(self.rootcomm)
            mkdir_dialog.title("Create Directory")
            mkdir_dialog.geometry("300x120")
            mkdir_dialog.configure(bg=self.bg_color)
            mkdir_dialog.transient(self.rootcomm)
            mkdir_dialog.grab_set()
            
            tk.Label(mkdir_dialog, text="Enter directory name:", bg=self.bg_color).pack(pady=(10, 5))
            
            dir_name_var = tk.StringVar()
            entry = tk.Entry(mkdir_dialog, textvariable=dir_name_var, width=40, 
                            relief="sunken", bd=2, bg="white")
            entry.pack(padx=10, pady=5)
            entry.focus_set()
            
            button_frame = tk.Frame(mkdir_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            def do_mkdir():
                dir_name = dir_name_var.get()
                if dir_name:
                    try:
                        new_dir = os.path.join(self.paths[side], dir_name)
                        os.mkdir(new_dir)
                        self.refresh_panels()
                        mkdir_dialog.destroy()
                    except Exception as e:
                        self.show_error_dialog("Error", f"Cannot create directory: {str(e)}")
                else:
                    mkdir_dialog.destroy()
            
            ok_button = tk.Button(button_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=do_mkdir)
            ok_button.pack(side=tk.LEFT, padx=5)
            
            cancel_button = tk.Button(button_frame, text="Cancel", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=mkdir_dialog.destroy)
            cancel_button.pack(side=tk.LEFT, padx=5)
            
            entry.bind("<Return>", lambda e: do_mkdir())
        
        def delete_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
                
            # Dialog de confirmare în stil Windows 95
            confirm_dialog = tk.Toplevel(self.rootcomm)
            confirm_dialog.title("Confirm Delete")
            confirm_dialog.geometry("350x150")
            confirm_dialog.configure(bg=self.bg_color)
            confirm_dialog.transient(self.rootcomm)
            confirm_dialog.grab_set()
            
            icon_label = tk.Label(confirm_dialog, text="!", font=("Arial", 24), fg="red", bg=self.bg_color)
            icon_label.pack(pady=(10, 5))
            
            is_dir = os.path.isdir(path)
            message = f"Are you sure you want to delete this {'directory' if is_dir else 'file'}?\n{name}"
            
            message_label = tk.Label(confirm_dialog, text=message, wraplength=300, bg=self.bg_color)
            message_label.pack(pady=5)
            
            button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            def do_delete():
                try:
                    if is_dir:
                        shutil.rmtree(path)
                    else:
                        os.remove(path)
                    self.refresh_panels()
                    confirm_dialog.destroy()
                except Exception as e:
                    self.show_error_dialog("Error", f"Cannot delete: {str(e)}")
                    confirm_dialog.destroy()
            
            yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                  relief="raised", bd=3, command=do_delete)
            yes_button.pack(side=tk.LEFT, padx=5)
            
            no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=confirm_dialog.destroy)
            no_button.pack(side=tk.LEFT, padx=5)
        
        def quit_app(self):
            # Dialog de confirmare în stil Windows 95
            confirm_dialog = tk.Toplevel(self.rootcomm)
            confirm_dialog.title("Confirm Exit")
            confirm_dialog.geometry("300x150")
            confirm_dialog.configure(bg=self.bg_color)
            confirm_dialog.transient(self.rootcomm)
            confirm_dialog.grab_set()
            
            icon_label = tk.Label(confirm_dialog, text="?", font=("Arial", 24), fg="blue", bg=self.bg_color)
            icon_label.pack(pady=(10, 5))
            
            message_label = tk.Label(confirm_dialog, text="Are you sure you want to exit?", 
                                    wraplength=250, bg=self.bg_color)
            message_label.pack(pady=5)
            
            button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                  relief="raised", bd=3, command=self.rootcomm.destroy)
            yes_button.pack(side=tk.LEFT, padx=5)
            
            no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=confirm_dialog.destroy)
            no_button.pack(side=tk.LEFT, padx=5)


    # Funcția principală pentru a rula aplicația
    def main():
        rootcomm = tk.Tk()
        app = RetroFileManagerApp(rootcomm)
        rootcomm.mainloop()

    if __name__ == "__main__":
        main()

if calendarvar == 999000:
    import tkinter as tk
    from tkinter import ttk, simpledialog, messagebox
    import datetime
    from datetime import datetime, timedelta
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon61 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon61)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class Win95CalendarApp:
        def __init__(self, rootCalendar):
            self.rootCalendar = rootCalendar
            self.rootCalendar.title("Calendar")
            self.rootCalendar.geometry("640x480")
            self.rootCalendar.configure(bg="#c0c0c0")
            
            # Set Windows 95 style colors
            self.win95_bg = "#c0c0c0"
            self.win95_button = "#c0c0c0"
            self.win95_shadow = "#808080"
            self.win95_highlight = "#ffffff"
            self.win95_text = "#000000"
            self.calendar_bg = "#e0e0e0"  # Lighter color for the calendar table
            
            # Date variables
            self.current_date = datetime.now()
            self.year = self.current_date.year
            self.month = self.current_date.month
            
            # List of month names
            self.month_names = [
                "", "January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
            ]
            
            # List of day names
            self.day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            
            # Events dictionary
            self.events = {}
            
            # Load saved events
            self.load_events()
            
            # Create interface
            self.create_widgets()
            
        def create_3d_frame(self, parent, **kwargs):
            """Create a 3D frame with Windows 95 style"""
            frame = tk.Frame(parent, bg=self.win95_bg, bd=2, relief="raised", **kwargs)
            return frame
            
        def create_win95_button(self, parent, text, command, **kwargs):
            """Create a Windows 95 style button"""
            button = tk.Button(
                parent, 
                text=text, 
                command=command, 
                bg=self.win95_button,
                fg=self.win95_text,
                relief="raised",
                bd=2,
                font=("Arial", 8),
                **kwargs
            )
            return button
            
        def create_widgets(self):
            # Main frame
            main_frame = self.create_3d_frame(self.rootCalendar)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Title bar
            title_bar = tk.Frame(main_frame, bg="#000080", height=22)
            title_bar.pack(fill=tk.X)
            
            title_text = tk.Label(
                title_bar, 
                text="Calendar - Retro Style", 
                fg="white", 
                bg="#000080",
                font=("Arial", 8, "bold")
            )
            title_text.pack(side=tk.LEFT, padx=5)
            
            # X button
            close_button = tk.Button(
                title_bar, 
                text="X", 
                bg="#c0c0c0",
                fg="#000000",
                width=2,
                relief="raised",
                bd=1,
                command=self.rootCalendar.destroy
            )
            close_button.pack(side=tk.RIGHT)
            
            # Calendar control frame
            control_frame = self.create_3d_frame(main_frame)
            control_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # Navigation buttons
            prev_button = self.create_win95_button(control_frame, "< Previous", self.prev_month)
            prev_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            next_button = self.create_win95_button(control_frame, "Next >", self.next_month)
            next_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Label for current month and year
            self.month_year_label = tk.Label(
                control_frame, 
                text="",
                font=("Arial", 10, "bold"),
                bg=self.win95_bg
            )
            self.month_year_label.pack(side=tk.LEFT, padx=30, pady=5)
            
            # Frame for displaying the calendar grid
            calendar_frame = self.create_3d_frame(main_frame)
            calendar_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Week day names
            for i, day in enumerate(self.day_names):
                day_label = tk.Label(
                    calendar_frame, 
                    text=day,
                    font=("Arial", 8, "bold"),
                    width=9,
                    height=1,
                    bg="#d3d3d3",
                    bd=1,
                    relief="sunken"
                )
                day_label.grid(row=0, column=i, sticky="nsew", padx=1, pady=1)
            
            # Create grid of cells for days
            self.day_cells = []
            for row in range(6):
                row_cells = []
                for col in range(7):
                    cell = tk.Button(
                        calendar_frame,
                        text="",
                        font=("Arial", 8),
                        bg=self.calendar_bg,  # Lighter background color
                        relief="raised",
                        bd=1,
                        width=9,
                        height=4,
                        justify="left",
                        anchor="nw"
                    )
                    cell.grid(row=row+1, column=col, sticky="nsew", padx=1, pady=1)
                    row_cells.append(cell)
                self.day_cells.append(row_cells)
            
            # Configure grid for resolution
            for i in range(7):
                calendar_frame.columnconfigure(i, weight=1)
            for i in range(7):
                calendar_frame.rowconfigure(i, weight=1)
                
            # Status bar frame
            status_frame = tk.Frame(main_frame, bg=self.win95_bg, bd=1, relief="sunken")
            status_frame.pack(fill=tk.X, side=tk.BOTTOM)
            
            status_label = tk.Label(
                status_frame, 
                text="Ready", 
                bg=self.win95_bg,
                font=("Arial", 8),
                anchor="w"
            )
            status_label.pack(side=tk.LEFT, padx=5)
            
            # Update calendar
            self.update_calendar()
            
        def get_month_calendar(self, year, month):
            """Generate calendar for specified month and year"""
            # First day of the month
            first_day = datetime(year, month, 1)
            
            # Weekday for the first day (0 = Monday, 6 = Sunday in ISO format)
            # first_weekday will be between 0-6, where 0 is Monday
            first_weekday = first_day.weekday()
            
            # Number of days in current month
            if month == 12:
                last_day = datetime(year + 1, 1, 1) - timedelta(days=1)
            else:
                last_day = datetime(year, month + 1, 1) - timedelta(days=1)
            days_in_month = last_day.day
            
            # Build calendar as a matrix
            cal = []
            week = [0] * 7  # Initialize with 7 zeros
            
            # Fill previous days with zeros
            for i in range(first_weekday):
                week[i] = 0
                
            day = 1
            for i in range(first_weekday, 7):
                if day <= days_in_month:
                    week[i] = day
                    day += 1
                else:
                    week[i] = 0
                    
            cal.append(week)
            
            # Continue with the rest of the weeks
            while day <= days_in_month:
                week = [0] * 7
                for i in range(7):
                    if day <= days_in_month:
                        week[i] = day
                        day += 1
                    else:
                        week[i] = 0
                cal.append(week)
                
            return cal
            
        def update_calendar(self):
            # Update month and year label
            month_name = self.month_names[self.month]
            self.month_year_label.config(text=f"{month_name} {self.year}")
            
            # Get calendar for current month
            cal = self.get_month_calendar(self.year, self.month)
            
            # Reset all cells
            for row in self.day_cells:
                for cell in row:
                    cell.config(
                        text="",
                        bg=self.calendar_bg,
                        command=lambda: None
                    )
            
            # Fill cells with dates
            for week_idx, week in enumerate(cal):
                for day_idx, day in enumerate(week):
                    if day != 0:
                        # Determine if day has events
                        date_obj = datetime(self.year, self.month, day)
                        date_str = date_obj.strftime("%Y-%m-%d")
                        has_events = date_str in self.events and len(self.events[date_str]) > 0
                        
                        # Text for cell
                        cell_text = f"{day}"
                        if has_events:
                            cell_text += f"\n[{len(self.events[date_str])} events]"
                        
                        # Configure cell
                        self.day_cells[week_idx][day_idx].config(
                            text=cell_text,
                            bg="#d3d3d3" if has_events else self.calendar_bg,
                            command=lambda d=day, m=self.month, y=self.year: 
                                   self.day_click(d, m, y)
                        )
        
        def day_click(self, day, month, year):
            """Handler for clicking on a day in the calendar"""
            date_obj = datetime(year, month, day)
            date_str = date_obj.strftime("%Y-%m-%d")
            date_display = f"{day} {self.month_names[month]} {year}"
            
            # Create window for viewing/adding events
            events_window = tk.Toplevel(self.rootCalendar)
            events_window.title(f"Events - {date_display}")
            events_window.geometry("400x300")
            events_window.configure(bg=self.win95_bg)
            
            # Title bar
            title_bar = tk.Frame(events_window, bg="#000080", height=22)
            title_bar.pack(fill=tk.X)
            
            title_text = tk.Label(
                title_bar, 
                text=f"Events - {date_display}",
                fg="white", 
                bg="#000080",
                font=("Arial", 8, "bold")
            )
            title_text.pack(side=tk.LEFT, padx=5)
            
            # Close button
            close_button = tk.Button(
                title_bar, 
                text="X", 
                bg="#c0c0c0",
                width=2,
                relief="raised",
                bd=1,
                command=events_window.destroy
            )
            close_button.pack(side=tk.RIGHT)
            
            # Main frame
            main_frame = tk.Frame(events_window, bg=self.win95_bg, bd=2, relief="raised")
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Listbox with events
            events_label = tk.Label(
                main_frame, 
                text="Events:", 
                bg=self.win95_bg,
                font=("Arial", 8, "bold"),
                anchor="w"
            )
            events_label.pack(fill=tk.X, padx=5, pady=5)
            
            events_frame = tk.Frame(main_frame, bg="white", bd=1, relief="sunken")
            events_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            events_listbox = tk.Listbox(
                events_frame,
                font=("Arial", 8),
                bg="white",
                selectmode=tk.SINGLE
            )
            events_listbox.pack(fill=tk.BOTH, expand=True)
            
            # Action buttons
            buttons_frame = tk.Frame(main_frame, bg=self.win95_bg)
            buttons_frame.pack(fill=tk.X, pady=5)
            
            add_button = self.create_win95_button(
                buttons_frame, 
                "Add event", 
                lambda: self.add_event(date_str, events_listbox, events_window)
            )
            add_button.pack(side=tk.LEFT, padx=5)
            
            delete_button = self.create_win95_button(
                buttons_frame, 
                "Delete event", 
                lambda: self.delete_event(date_str, events_listbox)
            )
            delete_button.pack(side=tk.LEFT, padx=5)
            
            close_button = self.create_win95_button(
                buttons_frame, 
                "Close", 
                events_window.destroy
            )
            close_button.pack(side=tk.RIGHT, padx=5)
            
            # Populate listbox with existing events
            if date_str in self.events:
                for event in self.events[date_str]:
                    events_listbox.insert(tk.END, event)
        
        def add_event(self, date_str, listbox, parent_window):
            """Add an event for the specified date"""
            event = simpledialog.askstring(
                "Add event",
                "Enter event description:",
                parent=parent_window
            )
            
            if event:
                if date_str not in self.events:
                    self.events[date_str] = []
                
                self.events[date_str].append(event)
                listbox.insert(tk.END, event)
                self.update_calendar()
                self.save_events()  # Save events after adding
        
        def delete_event(self, date_str, listbox):
            """Delete the selected event"""
            selected = listbox.curselection()
            
            if selected:
                index = selected[0]
                if date_str in self.events and index < len(self.events[date_str]):
                    listbox.delete(index)
                    del self.events[date_str][index]
                    self.update_calendar()
                    self.save_events()  # Save events after deleting
            else:
                messagebox.showinfo(
                    "Warning",
                    "Select an event to delete."
                )
        
        def prev_month(self):
            """Navigate to previous month"""
            if self.month > 1:
                self.month -= 1
            else:
                self.month = 12
                self.year -= 1
            self.update_calendar()
        
        def next_month(self):
            """Navigate to next month"""
            if self.month < 12:
                self.month += 1
            else:
                self.month = 1
                self.year += 1
            self.update_calendar()
        
        def save_events(self):
            """Save events to a JSON file"""
            with open("calendar_events.json", "w") as file:
                json.dump(self.events, file)
        
        def load_events(self):
            """Load events from a JSON file"""
            try:
                if os.path.exists("calendar_events.json"):
                    with open("calendar_events.json", "r") as file:
                        self.events = json.load(file)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load events: {str(e)}")
                self.events = {}


    if __name__ == "__main__":
        rootCalendar = tk.Tk()
        app = Win95CalendarApp(rootCalendar)
        rootCalendar.iconbitmap("calendar.ico") if os.path.exists("calendar.ico") else None
        rootCalendar.mainloop()
        
if allmonitorvar == 999001:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon61 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon61)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    
    import tkinter as tk
    from tkinter import ttk, messagebox
    import psutil
    import platform
    import threading
    import time
    from datetime import datetime
    import subprocess
    import re
    import sys

    class HardwareMonitorApplication:
        def __init__(self, rootAllMonitorAllMonitor):
            self.rootAllMonitorAllMonitor = rootAllMonitorAllMonitor
            self.rootAllMonitorAllMonitor.title("Hardware Monitor")
            self.rootAllMonitorAllMonitor.geometry("800x600")
            
            # Variabilă pentru tema curentă
            self.current_theme = "win95"  # Implicit "win95", alternativ "modern"
            
            # Buton pentru schimbarea temei - adăugat la începutul inițializării
            self.theme_button = tk.Button(
                rootAllMonitorAllMonitor, 
                text="Toggle Theme", 
                command=self.toggle_theme,
                relief="raised",
                bd=2
            )
            self.theme_button.pack(anchor="ne", padx=10, pady=5)
            
            # Configurare temă Win95 inițială
            self.configure_win95_theme()
            
            # Alert threshold variables
            self.thresholds = {
                "cpu": 80,  # CPU usage percentage
                "memory": 80,  # Memory usage percentage
                "disk": 90,  # Disk usage percentage
                "temperature": 80,  # Temperature in Celsius
                "gpu": 80  # GPU usage percentage
            }
            
            # Create tabs
            self.tab_control = ttk.Notebook(rootAllMonitorAllMonitor)
            
            self.tab_summary = ttk.Frame(self.tab_control)
            self.tab_cpu = ttk.Frame(self.tab_control)
            self.tab_memory = ttk.Frame(self.tab_control)
            self.tab_disk = ttk.Frame(self.tab_control)
            self.tab_network = ttk.Frame(self.tab_control)
            self.tab_alerts = ttk.Frame(self.tab_control)
            
            self.tab_control.add(self.tab_summary, text="System Summary")
            self.tab_control.add(self.tab_cpu, text="CPU")
            self.tab_control.add(self.tab_memory, text="Memory")
            self.tab_control.add(self.tab_disk, text="Disk")
            self.tab_control.add(self.tab_network, text="Network")
            self.tab_control.add(self.tab_alerts, text="Alerts")
            
            # Check if GPU is available and create GPU tab if it is
            self.has_gpu = self.check_gpu_available()
            if self.has_gpu:
                self.tab_gpu = ttk.Frame(self.tab_control)
                self.tab_control.add(self.tab_gpu, text="GPU")
            
            self.tab_control.pack(expand=1, fill="both")
            
            # Initialize tabs
            self.initialize_summary_tab()
            self.initialize_cpu_tab()
            self.initialize_memory_tab()
            self.initialize_disk_tab()
            self.initialize_network_tab()
            self.initialize_alerts_tab()
            
            # Initialize GPU tab if available
            if self.has_gpu:
                self.initialize_gpu_tab()
            
            # Alert log
            self.alert_log = []
            
            # Start data update thread
            self.running = True
            self.update_thread = threading.Thread(target=self.update_data)
            self.update_thread.daemon = True
            self.update_thread.start()
        
        def check_gpu_available(self):
            """Verifică dacă există un GPU detectabil în sistem"""
            try:
                if platform.system() == "Windows":
                    # Windows - Încercăm să folosim NVIDIA-SMI
                    try:
                        subprocess.check_output(["nvidia-smi"])
                        self.gpu_type = "nvidia"
                        return True
                    except (subprocess.SubprocessError, FileNotFoundError):
                        # Încercăm AMD
                        try:
                            subprocess.check_output(["rocm-smi"])
                            self.gpu_type = "amd"
                            return True
                        except (subprocess.SubprocessError, FileNotFoundError):
                            pass
                elif platform.system() == "Linux":
                    # Linux - Verificăm fișierele de dispozitiv
                    try:
                        # Căutăm GPU NVIDIA
                        if subprocess.call("which nvidia-smi > /dev/null 2>&1", shell=True) == 0:
                            self.gpu_type = "nvidia"
                            return True
                        # Căutăm GPU AMD
                        elif subprocess.call("which rocm-smi > /dev/null 2>&1", shell=True) == 0:
                            self.gpu_type = "amd"
                            return True
                        else:
                            # Încercăm să verificăm direct dispozitivele
                            lspci_output = subprocess.check_output("lspci | grep -E 'VGA|3D|Display'", shell=True).decode('utf-8')
                            if "NVIDIA" in lspci_output:
                                self.gpu_type = "nvidia"
                                return True
                            elif "AMD" in lspci_output or "ATI" in lspci_output:
                                self.gpu_type = "amd"
                                return True
                    except:
                        pass
                elif platform.system() == "Darwin":  # macOS
                    # Pe macOS verificăm informațiile sistemului
                    try:
                        system_profiler = subprocess.check_output(["system_profiler", "SPDisplaysDataType"]).decode('utf-8')
                        if "NVIDIA" in system_profiler:
                            self.gpu_type = "nvidia"
                            return True
                        elif "AMD" in system_profiler:
                            self.gpu_type = "amd"
                            return True
                        else:
                            # MacOS are întotdeauna un GPU, dar poate fi integrat
                            self.gpu_type = "integrated"
                            return True
                    except:
                        pass
            except Exception as e:
                print(f"Error checking GPU: {e}")
            
            return False
        
        def toggle_theme(self):
            """Comută între temele disponibile"""
            if self.current_theme == "win95":
                self.configure_modern_theme()
                self.current_theme = "modern"
                self.theme_button.config(text="Switch to Win95 Theme")
                self.rootAllMonitorAllMonitor.title("Modern Hardware Monitor")
            else:
                self.configure_win95_theme()
                self.current_theme = "win95"
                self.theme_button.config(text="Switch to Modern Theme")
                self.rootAllMonitorAllMonitor.title("Windows 95 Hardware Monitor")
        
        def configure_win95_theme(self):
            """Configurează aspectul temei Windows 95"""
            # Configure Windows 95 style colors and fonts
            bg_color = "#c0c0c0"  # Classic Win95 gray
            button_color = "#c0c0c0"
            text_color = "#000000"
            
            self.rootAllMonitorAllMonitor.configure(bg=bg_color)
            
            # Configurare buton de toggle
            self.theme_button.config(
                bg=button_color,
                fg=text_color,
                activebackground="#a0a0a0",
                activeforeground="#000000",
                font=("MS Sans Serif", 9),
                text="Switch to Modern Theme"
            )
            
            # Configure ttk style
            style = ttk.Style()
            style.theme_use('clam')  # Use closest theme to Win95
            
            # Configure fonts
            default_font = ("MS Sans Serif", 9)
            header_font = ("MS Sans Serif", 10, "bold")
            
            # Configure styles
            style.configure("TFrame", background=bg_color)
            style.configure("TLabel", background=bg_color, foreground=text_color, font=default_font)
            style.configure("TButton", background=button_color, foreground=text_color, font=default_font, relief="raised")
            style.configure("TNotebook", background=bg_color, tabmargins=[2, 5, 2, 0])
            style.configure("TNotebook.Tab", background=button_color, foreground=text_color, font=default_font, padding=[10, 2])
            style.configure("TProgressbar", background="#008080", troughcolor="#ffffff")
            style.configure("TLabelframe", background=bg_color, foreground=text_color, font=header_font)
            style.configure("TLabelframe.Label", background=bg_color, foreground=text_color, font=header_font)
            
            # Configure Listbox
            self.listbox_style = {"background": "#ffffff", "foreground": "#000000", "font": default_font, 
                                 "selectbackground": "#000080", "selectforeground": "#ffffff"}
            
            # Update any existing listboxes
            if hasattr(self, 'listbox_log'):
                self.listbox_log.config(**self.listbox_style)
        
        def configure_modern_theme(self):
            """Configurează aspectul temei moderne cu accente neon"""
            # Culori pentru tema modernă
            bg_color = "#121212"  # Fundal aproape negru
            darker_bg = "#0a0a0a"  # Fundal mai închis pentru contraste
            text_color = "#ffffff"  # Text alb
            accent_cyan = "#00ffff"  # Cyan neon
            accent_purple = "#cc00ff"  # Purple neon
            accent_green = "#00ff8c"  # Verde neon
            
            self.rootAllMonitorAllMonitor.configure(bg=bg_color)
            
            # Configurare buton de toggle
            self.theme_button.config(
                bg=darker_bg,
                fg=accent_cyan,
                activebackground="#303030",
                activeforeground=accent_purple,
                font=("Segoe UI", 9, "bold"),
                text="Switch to Win95 Theme"
            )
            
            # Configure ttk style
            style = ttk.Style()
            style.theme_use('clam')
            
            # Configure fonts
            default_font = ("Segoe UI", 9)
            header_font = ("Segoe UI", 10, "bold")
            
            # Configure styles
            style.configure("TFrame", background=bg_color)
            style.configure("TLabel", background=bg_color, foreground=text_color, font=default_font)
            style.configure("TButton", font=default_font)
            style.map("TButton", 
                      background=[("active", darker_bg), ("!active", bg_color)],
                      foreground=[("active", accent_cyan), ("!active", accent_purple)])
            
            # Notebook și tab-uri
            style.configure("TNotebook", background=darker_bg, tabmargins=[2, 5, 2, 0])
            style.configure("TNotebook.Tab", 
                            background=darker_bg, 
                            foreground=text_color, 
                            font=default_font, 
                            padding=[10, 2])
            style.map("TNotebook.Tab", 
                      background=[("selected", bg_color), ("active", "#303030")],
                      foreground=[("selected", accent_cyan), ("active", accent_purple)])
            
            # Progress bar
            style.configure("TProgressbar", 
                            background=accent_green,  # Bara de progres verde neon
                            troughcolor=darker_bg)    # Fundal mai închis
            
            # Frame-uri
            style.configure("TLabelframe", 
                            background=bg_color, 
                            foreground=accent_cyan, 
                            font=header_font)
            style.configure("TLabelframe.Label", 
                            background=bg_color, 
                            foreground=accent_cyan, 
                            font=header_font)
            
            # Configure Listbox
            self.listbox_style = {
                "background": darker_bg, 
                "foreground": text_color, 
                "font": default_font,
                "selectbackground": accent_purple, 
                "selectforeground": "#ffffff"
            }
            
            # Update any existing listboxes
            if hasattr(self, 'listbox_log'):
                self.listbox_log.config(**self.listbox_style)
        
        def initialize_summary_tab(self):
            # System information frame
            frame_info = ttk.LabelFrame(self.tab_summary, text="System Information")
            frame_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # System details
            system_os = platform.system() + " " + platform.version()
            processor = platform.processor()
            
            ttk.Label(frame_info, text=f"Operating System: {system_os}").pack(anchor="w", padx=10, pady=5)
            ttk.Label(frame_info, text=f"Processor: {processor}").pack(anchor="w", padx=10, pady=5)
            
            # Add GPU info if available
            if self.has_gpu:
                gpu_info = self.get_gpu_info()
                ttk.Label(frame_info, text=f"GPU: {gpu_info}").pack(anchor="w", padx=10, pady=5)
            
            # Main metrics frame
            frame_metrics = ttk.LabelFrame(self.tab_summary, text="Main Metrics")
            frame_metrics.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Metric labels
            self.label_cpu = ttk.Label(frame_metrics, text="CPU Usage: Loading...")
            self.label_cpu.pack(anchor="w", padx=10, pady=5)
            
            self.label_memory = ttk.Label(frame_metrics, text="Memory Usage: Loading...")
            self.label_memory.pack(anchor="w", padx=10, pady=5)
            
            self.label_disk = ttk.Label(frame_metrics, text="Disk Usage: Loading...")
            self.label_disk.pack(anchor="w", padx=10, pady=5)
            
            # Add GPU usage label if available
            if self.has_gpu:
                self.label_gpu = ttk.Label(frame_metrics, text="GPU Usage: Loading...")
                self.label_gpu.pack(anchor="w", padx=10, pady=5)
            
            # Detected problems frame
            self.frame_problems = ttk.LabelFrame(self.tab_summary, text="Detected Problems")
            self.frame_problems.pack(fill="both", expand=1, padx=10, pady=10)
            
            self.label_no_problems = ttk.Label(self.frame_problems, text="No problems detected")
            self.label_no_problems.pack(anchor="w", padx=10, pady=5)
        
        def initialize_cpu_tab(self):
            # CPU information frame
            frame_cpu_info = ttk.LabelFrame(self.tab_cpu, text="CPU Information")
            frame_cpu_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # CPU details
            physical_cores = psutil.cpu_count(logical=False)
            logical_cores = psutil.cpu_count(logical=True)
            
            ttk.Label(frame_cpu_info, text=f"Physical cores: {physical_cores}").pack(anchor="w", padx=10, pady=5)
            ttk.Label(frame_cpu_info, text=f"Logical cores: {logical_cores}").pack(anchor="w", padx=10, pady=5)
            
            # CPU usage frame
            frame_cpu_usage = ttk.LabelFrame(self.tab_cpu, text="CPU Usage")
            frame_cpu_usage.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Usage labels
            self.label_cpu_usage = ttk.Label(frame_cpu_usage, text="Total usage: Loading...")
            self.label_cpu_usage.pack(anchor="w", padx=10, pady=5)
            
            # CPU usage progress bar
            ttk.Label(frame_cpu_usage, text="Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_cpu = ttk.Progressbar(frame_cpu_usage, orient="horizontal", length=700, mode="determinate")
            self.progress_cpu.pack(padx=10, pady=5)
            
            # CPU frequency frame
            frame_cpu_freq = ttk.LabelFrame(self.tab_cpu, text="CPU Frequency")
            frame_cpu_freq.pack(fill="both", expand=1, padx=10, pady=10)
            
            self.label_cpu_freq = ttk.Label(frame_cpu_freq, text="Current frequency: Loading...")
            self.label_cpu_freq.pack(anchor="w", padx=10, pady=5)
        
        def initialize_memory_tab(self):
            # Memory information frame
            frame_memory_info = ttk.LabelFrame(self.tab_memory, text="Memory Information")
            frame_memory_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get memory information
            mem = psutil.virtual_memory()
            total_mem = round(mem.total / (1024 ** 3), 2)
            
            ttk.Label(frame_memory_info, text=f"Total memory: {total_mem} GB").pack(anchor="w", padx=10, pady=5)
            
            # Memory usage frame
            frame_memory_usage = ttk.LabelFrame(self.tab_memory, text="Memory Usage")
            frame_memory_usage.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Usage label
            self.label_memory_usage = ttk.Label(frame_memory_usage, text="Usage: Loading...")
            self.label_memory_usage.pack(anchor="w", padx=10, pady=5)
            
            # Memory usage progress bar
            ttk.Label(frame_memory_usage, text="Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_memory = ttk.Progressbar(frame_memory_usage, orient="horizontal", length=700, mode="determinate")
            self.progress_memory.pack(padx=10, pady=5)
            
            # Swap frame
            frame_swap = ttk.LabelFrame(self.tab_memory, text="Swap Memory")
            frame_swap.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Swap information
            swap = psutil.swap_memory()
            total_swap = round(swap.total / (1024 ** 3), 2)
            
            ttk.Label(frame_swap, text=f"Total swap: {total_swap} GB").pack(anchor="w", padx=10, pady=5)
            
            self.label_swap_usage = ttk.Label(frame_swap, text="Swap usage: Loading...")
            self.label_swap_usage.pack(anchor="w", padx=10, pady=5)
            
            # Swap usage progress bar
            ttk.Label(frame_swap, text="Swap usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_swap = ttk.Progressbar(frame_swap, orient="horizontal", length=700, mode="determinate")
            self.progress_swap.pack(padx=10, pady=5)
        
        def initialize_disk_tab(self):
            frame_disk_info = ttk.LabelFrame(self.tab_disk, text="Disk Information")
            frame_disk_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get partition information
            partitions = psutil.disk_partitions()
            
            # Container for partition progress bars
            self.frame_partitions = ttk.Frame(frame_disk_info)
            self.frame_partitions.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Dictionary to store labels and progress bars
            self.disk_labels = {}
            self.disk_progress = {}
            
            # Add information for each partition
            for partition in partitions:
                try:
                    usage = psutil.disk_usage(partition.mountpoint)
                    usage_percent = usage.percent
                    
                    # Frame for this partition
                    frame_partition = ttk.Frame(self.frame_partitions)
                    frame_partition.pack(fill="x", pady=5)
                    
                    # Partition information
                    total_gb = round(usage.total / (1024 ** 3), 2)
                    used_gb = round(usage.used / (1024 ** 3), 2)
                    free_gb = round(usage.free / (1024 ** 3), 2)
                    
                    info_text = f"Partition: {partition.mountpoint} | Total: {total_gb} GB | Used: {used_gb} GB | Free: {free_gb} GB | Usage: {usage_percent}%"
                    label = ttk.Label(frame_partition, text=info_text)
                    label.pack(anchor="w")
                    
                    # Progress bar for usage
                    progress = ttk.Progressbar(frame_partition, orient="horizontal", length=700, mode="determinate")
                    progress["value"] = usage_percent
                    progress.pack(pady=2)
                    
                    # Save references for later updates
                    self.disk_labels[partition.mountpoint] = label
                    self.disk_progress[partition.mountpoint] = progress
                    
                except (PermissionError, FileNotFoundError):
                    # Ignore partitions we can't access
                    pass
            
            # IO information frame
            frame_io = ttk.LabelFrame(self.tab_disk, text="Disk IO Activity")
            frame_io.pack(fill="both", expand=1, padx=10, pady=10)
            
            # IO labels
            self.label_disk_read = ttk.Label(frame_io, text="Read speed: Loading...")
            self.label_disk_read.pack(anchor="w", padx=10, pady=5)
            
            self.label_disk_write = ttk.Label(frame_io, text="Write speed: Loading...")
            self.label_disk_write.pack(anchor="w", padx=10, pady=5)
        
        def initialize_network_tab(self):
            frame_network_info = ttk.LabelFrame(self.tab_network, text="Network Information")
            frame_network_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get network interfaces
            interfaces = psutil.net_if_addrs()
            
            # Add information for each interface
            for interface, addresses in interfaces.items():
                # Create frame for this interface
                frame_interface = ttk.LabelFrame(frame_network_info, text=f"Interface: {interface}")
                frame_interface.pack(fill="x", padx=10, pady=5)
                
                # Add address information
                for address in addresses:
                    if address.family == 2:  # IPv4
                        ttk.Label(frame_interface, text=f"IPv4: {address.address}").pack(anchor="w", padx=10, pady=2)
                    elif address.family == 23:  # IPv6
                        ttk.Label(frame_interface, text=f"IPv6: {address.address}").pack(anchor="w", padx=10, pady=2)
                    elif address.family == 17:  # MAC
                        ttk.Label(frame_interface, text=f"MAC: {address.address}").pack(anchor="w", padx=10, pady=2)
            
            # Traffic frame
            frame_traffic = ttk.LabelFrame(self.tab_network, text="Network Traffic")
            frame_traffic.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Traffic labels
            self.label_download = ttk.Label(frame_traffic, text="Download: Loading...")
            self.label_download.pack(anchor="w", padx=10, pady=5)
            
            self.label_upload = ttk.Label(frame_traffic, text="Upload: Loading...")
            self.label_upload.pack(anchor="w", padx=10, pady=5)
            
            # Previous network traffic statistics
            self.bytes_sent_previous = psutil.net_io_counters().bytes_sent
            self.bytes_recv_previous = psutil.net_io_counters().bytes_recv
            self.timestamp_previous = time.time()
        
        def initialize_gpu_tab(self):
            """Inițializează tab-ul GPU dacă este disponibil"""
            frame_gpu_info = ttk.LabelFrame(self.tab_gpu, text="GPU Information")
            frame_gpu_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get GPU information
            gpu_info = self.get_gpu_info()
            ttk.Label(frame_gpu_info, text=f"GPU: {gpu_info}").pack(anchor="w", padx=10, pady=5)
            
            # GPU usage frame
            frame_gpu_usage = ttk.LabelFrame(self.tab_gpu, text="GPU Usage")
            frame_gpu_usage.pack(fill="both", expand=1, padx=10, pady=10)
            
            # GPU usage label
            self.label_gpu_usage = ttk.Label(frame_gpu_usage, text="Usage: Loading...")
            self.label_gpu_usage.pack(anchor="w", padx=10, pady=5)
            
            # GPU usage progress bar
            ttk.Label(frame_gpu_usage, text="Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_gpu = ttk.Progressbar(frame_gpu_usage, orient="horizontal", length=700, mode="determinate")
            self.progress_gpu.pack(padx=10, pady=5)
            
            # GPU memory frame
            frame_gpu_memory = ttk.LabelFrame(self.tab_gpu, text="GPU Memory")
            frame_gpu_memory.pack(fill="both", expand=1, padx=10, pady=10)
            
            # GPU memory label
            self.label_gpu_memory = ttk.Label(frame_gpu_memory, text="Memory: Loading...")
            self.label_gpu_memory.pack(anchor="w", padx=10, pady=5)
            
            # GPU memory progress bar
            ttk.Label(frame_gpu_memory, text="Memory Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_gpu_memory = ttk.Progressbar(frame_gpu_memory, orient="horizontal", length=700, mode="determinate")
            self.progress_gpu_memory.pack(padx=10, pady=5)
            
            # GPU temperature frame
            frame_gpu_temp = ttk.LabelFrame(self.tab_gpu, text="GPU Temperature")
            frame_gpu_temp.pack(fill="both", expand=1, padx=10, pady=10)
            
            # GPU temperature label
            self.label_gpu_temp = ttk.Label(frame_gpu_temp, text="Temperature: Loading...")
            self.label_gpu_temp.pack(anchor="w", padx=10, pady=5)
            
            # GPU temperature progress bar
            ttk.Label(frame_gpu_temp, text="Temperature:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_gpu_temp = ttk.Progressbar(frame_gpu_temp, orient="horizontal", length=700, mode="determinate")
            self.progress_gpu_temp.pack(padx=10, pady=5)
        
        def get_gpu_info(self):
            """Obține informații despre GPU-ul instalat"""
            if not self.has_gpu:
                return "No GPU detected"
            
            try:
                if self.gpu_type == "nvidia":
                    result = subprocess.check_output(["nvidia-smi", "--query-gpu=name", "--format=csv,noheader"]).decode('utf-8').strip()
                    return result
                elif self.gpu_type == "amd":
                    result = subprocess.check_output(["rocm-smi", "--showproductname"]).decode('utf-8')
                    return result.split("\n")[1].strip() if len(result.split("\n")) > 1 else "AMD GPU"
                elif self.gpu_type == "integrated":
                    if platform.system() == "Darwin":  # macOS
                        try:
                            system_profiler = subprocess.check_output(["system_profiler", "SPDisplaysDataType"]).decode('utf-8')
                            for line in system_profiler.split("\n"):
                                if "Chipset Model:" in line:
                                    return line.split("Chipset Model:")[1].strip()
                        except:
                            pass
                    return "Integrated GPU"
            except Exception as e:
                print(f"Error getting GPU info: {e}")
                return "GPU detected but info unavailable"
        
        def get_gpu_usage(self):
            """Obține utilizarea GPU-ului"""
            if not self.has_gpu:
                return 0, 0, 0  # Usage, Memory usage, Temperature
            
            try:
                if self.gpu_type == "nvidia":
                    # NVIDIA-SMI pentru obținerea utilizării
                    result = subprocess.check_output([
                        "nvidia-smi",
                        "--query-gpu=utilization.gpu,memory.used,memory.total,temperature.gpu",
                        "--format=csv,noheader,nounits"
                    ]).decode('utf-8').strip()
                    
                    values = result.split(", ")
                    if len(values) >= 4:
                        gpu_usage = float(values[0])
                        gpu_memory_used = float(values[1])
                        gpu_memory_total = float(values[2])
                        gpu_memory_usage = (gpu_memory_used / gpu_memory_total) * 100 if gpu_memory_total > 0 else 0
                        gpu_temp = float(values[3])
                        return gpu_usage, gpu_memory_usage, gpu_temp
                    
                elif self.gpu_type == "amd":
                    # Pentru AMD, folosim rocm-smi
                    result = subprocess.check_output(["rocm-smi", "--showuse", "--showmemuse", "--showtemp"]).decode('utf-8')
                    
                    # Analizăm rezultatul pentru a extrage valorile
                    gpu_usage = 0
                    gpu_memory_usage = 0
                    gpu_temp = 0
                    
                    for line in result.split("\n"):
                        if "GPU use" in line:
                            usage_match = re.search(r"(\d+)%", line)
                            if usage_match:
                                gpu_usage = float(usage_match.group(1))
                        elif "Memory use" in line:
                            memory_match = re.search(r"(\d+)%", line)
                            if memory_match:
                                gpu_memory_usage = float(memory_match.group(1))
                        elif "Temperature" in line:
                            temp_match = re.search(r"(\d+\.\d+)C", line)
                            if temp_match:
                                gpu_temp = float(temp_match.group(1))
                    
                    return gpu_usage, gpu_memory_usage, gpu_temp
                    
                elif self.gpu_type == "integrated":
                    # For integrated GPUs on macOS, try to get system info
                    if platform.system() == "Darwin":
                        try:
                            # On macOS we can't get exact GPU usage for integrated GPUs
                            # Estimate based on system statistics
                            # This is just an approximation
                            cpu_percent = psutil.cpu_percent()
                            gpu_usage = cpu_percent * 0.5  # Rough estimation
                            gpu_memory_usage = 50  # Default value as we can't measure accurately
                            gpu_temp = 50  # Default value as we can't measure accurately
                            return gpu_usage, gpu_memory_usage, gpu_temp
                        except:
                            pass
                    # Default values if no specific method works
                    return 0, 0, 0
                    
            except Exception as e:
                print(f"Error getting GPU usage: {e}")
                return 0, 0, 0

        def initialize_alerts_tab(self):
            """Initialize the alerts configuration tab"""
            # Create main frame
            frame_alerts = ttk.Frame(self.tab_alerts)
            frame_alerts.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Thresholds configuration frame
            frame_thresholds = ttk.LabelFrame(frame_alerts, text="Alert Thresholds")
            frame_thresholds.pack(fill="x", expand=0, padx=10, pady=10)
            
            # CPU threshold
            frame_cpu = ttk.Frame(frame_thresholds)
            frame_cpu.pack(fill="x", pady=5)
            
            ttk.Label(frame_cpu, text="CPU Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            self.cpu_threshold_var = tk.StringVar(value=str(self.thresholds["cpu"]))
            self.cpu_threshold_entry = ttk.Entry(frame_cpu, textvariable=self.cpu_threshold_var, width=10)
            self.cpu_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # Memory threshold
            frame_memory = ttk.Frame(frame_thresholds)
            frame_memory.pack(fill="x", pady=5)
            
            ttk.Label(frame_memory, text="Memory Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            self.memory_threshold_var = tk.StringVar(value=str(self.thresholds["memory"]))
            self.memory_threshold_entry = ttk.Entry(frame_memory, textvariable=self.memory_threshold_var, width=10)
            self.memory_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # Disk threshold
            frame_disk = ttk.Frame(frame_thresholds)
            frame_disk.pack(fill="x", pady=5)
            
            ttk.Label(frame_disk, text="Disk Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            self.disk_threshold_var = tk.StringVar(value=str(self.thresholds["disk"]))
            self.disk_threshold_entry = ttk.Entry(frame_disk, textvariable=self.disk_threshold_var, width=10)
            self.disk_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # GPU threshold
            if self.has_gpu:
                frame_gpu = ttk.Frame(frame_thresholds)
                frame_gpu.pack(fill="x", pady=5)
                
                ttk.Label(frame_gpu, text="GPU Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
                self.gpu_threshold_var = tk.StringVar(value=str(self.thresholds["gpu"]))
                self.gpu_threshold_entry = ttk.Entry(frame_gpu, textvariable=self.gpu_threshold_var, width=10)
                self.gpu_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
                
                # Temperature threshold
                frame_temp = ttk.Frame(frame_thresholds)
                frame_temp.pack(fill="x", pady=5)
                
                ttk.Label(frame_temp, text="GPU Temperature (°C)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
                self.temp_threshold_var = tk.StringVar(value=str(self.thresholds["temperature"]))
                self.temp_threshold_entry = ttk.Entry(frame_temp, textvariable=self.temp_threshold_var, width=10)
                self.temp_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # Button to save thresholds
            save_button = ttk.Button(frame_thresholds, text="Save Thresholds", 
                                   command=self.save_thresholds)
            save_button.pack(pady=10)
            
            # Alerts log frame
            frame_log = ttk.LabelFrame(frame_alerts, text="Alerts Log")
            frame_log.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Create listbox with scrollbar
            scrollbar = ttk.Scrollbar(frame_log)
            scrollbar.pack(side="right", fill="y")
            
            self.listbox_log = tk.Listbox(frame_log, height=10, width=100, 
                                         yscrollcommand=scrollbar.set, 
                                         **self.listbox_style)
            self.listbox_log.pack(side="left", fill="both", expand=1, padx=5, pady=5)
            
            scrollbar.config(command=self.listbox_log.yview)
            
            # Add some initial log entries
            self.listbox_log.insert(tk.END, "Alert system initialized")
            self.listbox_log.insert(tk.END, f"Current time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.listbox_log.insert(tk.END, "No alerts detected yet")
        
        def save_thresholds(self):
            """Save the threshold values from the input fields"""
            try:
                # Try to convert values to float
                cpu_val = float(self.cpu_threshold_var.get())
                memory_val = float(self.memory_threshold_var.get())
                disk_val = float(self.disk_threshold_var.get())
                
                # Validate values are within range
                if not (0 <= cpu_val <= 100):
                    raise ValueError("CPU threshold must be between 0 and 100")
                if not (0 <= memory_val <= 100):
                    raise ValueError("Memory threshold must be between 0 and 100")
                if not (0 <= disk_val <= 100):
                    raise ValueError("Disk threshold must be between 0 and 100")
                
                # Update thresholds
                self.thresholds["cpu"] = cpu_val
                self.thresholds["memory"] = memory_val
                self.thresholds["disk"] = disk_val
                
                if self.has_gpu:
                    gpu_val = float(self.gpu_threshold_var.get())
                    temp_val = float(self.temp_threshold_var.get())
                    
                    if not (0 <= gpu_val <= 100):
                        raise ValueError("GPU threshold must be between 0 and 100")
                    if not (0 <= temp_val <= 100):
                        raise ValueError("Temperature threshold must be between 0 and 100")
                    
                    self.thresholds["gpu"] = gpu_val
                    self.thresholds["temperature"] = temp_val
                
                # Add log entry
                log_entry = f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - Thresholds updated"
                self.listbox_log.insert(0, log_entry)
                
                # Show confirmation
                messagebox.showinfo("Thresholds", "Alert thresholds saved successfully")
            
            except ValueError as e:
                # Show error message
                messagebox.showerror("Input Error", str(e))
            except Exception as e:
                # Show error message
                messagebox.showerror("Error", f"Failed to save thresholds: {str(e)}")
        
        def add_alert(self, message):
            """Add an alert to the log"""
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_entry = f"{timestamp} - {message}"
            
            # Add to internal alert log
            self.alert_log.append(log_entry)
            
            # Add to listbox
            self.listbox_log.insert(0, log_entry)
            
            # Show popup
            #messagebox.showwarning("Alert", message)
        
        def update_data(self):
            """Update all system data in a background thread"""
            # Initialize previous disk IO stats
            disk_io_prev = psutil.disk_io_counters()
            prev_time = time.time()
            
            while self.running:
                try:
                    # Update CPU data
                    cpu_percent = psutil.cpu_percent()
                    
                    # Get CPU frequency
                    try:
                        cpu_freq = psutil.cpu_freq()
                        if cpu_freq:
                            cpu_freq_text = f"Current frequency: {cpu_freq.current:.2f} MHz"
                        else:
                            cpu_freq_text = "CPU frequency not available"
                    except:
                        cpu_freq_text = "CPU frequency not available"
                    
                    # Update memory data
                    mem = psutil.virtual_memory()
                    swap = psutil.swap_memory()
                    
                    # Update disk data
                    partitions = psutil.disk_partitions()
                    
                    # Update disk IO
                    current_time = time.time()
                    time_diff = current_time - prev_time
                    
                    if time_diff > 0:
                        disk_io = psutil.disk_io_counters()
                        
                        # Calculate read/write speeds
                        read_bytes = disk_io.read_bytes - disk_io_prev.read_bytes
                        write_bytes = disk_io.write_bytes - disk_io_prev.write_bytes
                        
                        read_speed = round(read_bytes / time_diff / (1024 * 1024), 2)  # MB/s
                        write_speed = round(write_bytes / time_diff / (1024 * 1024), 2)  # MB/s
                        
                        # Update previous values
                        disk_io_prev = disk_io
                        prev_time = current_time
                    else:
                        read_speed = write_speed = 0
                    
                    # Update network data
                    net_io = psutil.net_io_counters()
                    
                    # Calculate network speeds
                    current_time = time.time()
                    time_diff = current_time - self.timestamp_previous
                    
                    if time_diff > 0:
                        bytes_sent = net_io.bytes_sent - self.bytes_sent_previous
                        bytes_recv = net_io.bytes_recv - self.bytes_recv_previous
                        
                        upload_speed = round(bytes_sent / time_diff / 1024, 2)  # KB/s
                        download_speed = round(bytes_recv / time_diff / 1024, 2)  # KB/s
                        
                        # Update previous values
                        self.bytes_sent_previous = net_io.bytes_sent
                        self.bytes_recv_previous = net_io.bytes_recv
                        self.timestamp_previous = current_time
                    else:
                        upload_speed = download_speed = 0
                    
                    # Update GPU data if available
                    if self.has_gpu:
                        gpu_usage, gpu_memory, gpu_temp = self.get_gpu_usage()
                    
                    # Update GUI in the main thread
                    self.rootAllMonitorAllMonitor.after(0, lambda: self.update_ui(
                        cpu_percent, cpu_freq_text, 
                        mem, swap, 
                        partitions, 
                        read_speed, write_speed,
                        upload_speed, download_speed,
                        gpu_usage, gpu_memory, gpu_temp if self.has_gpu else 0
                    ))
                    
                    # Check for alerts
                    self.check_alerts(
                        cpu_percent, 
                        mem.percent, 
                        partitions,
                        gpu_usage, gpu_temp if self.has_gpu else 0
                    )
                    
                    # Sleep for a short time
                    time.sleep(1)
                    
                except Exception as e:
                    print(f"Error updating data: {e}")
                    time.sleep(2)
        
        def check_alerts(self, cpu_percent, memory_percent, partitions, gpu_percent=0, gpu_temp=0):
            """Check for threshold alerts"""
            problem_detected = False
            problems_text = []
            
            # CPU check
            if cpu_percent > self.thresholds["cpu"]:
                problem_detected = True
                message = f"CPU usage is high: {cpu_percent:.1f}% (threshold: {self.thresholds['cpu']}%)"
                problems_text.append(message)
                
                # Add to alert log if not already alerted recently
                if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                    self.add_alert(message)
            
            # Memory check
            if memory_percent > self.thresholds["memory"]:
                problem_detected = True
                message = f"Memory usage is high: {memory_percent:.1f}% (threshold: {self.thresholds['memory']}%)"
                problems_text.append(message)
                
                # Add to alert log if not already alerted recently
                if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                    self.add_alert(message)
            
            # Disk check
            for partition in partitions:
                try:
                    usage = psutil.disk_usage(partition.mountpoint)
                    if usage.percent > self.thresholds["disk"]:
                        problem_detected = True
                        message = f"Disk usage on {partition.mountpoint} is high: {usage.percent:.1f}% (threshold: {self.thresholds['disk']}%)"
                        problems_text.append(message)
                        
                        # Add to alert log if not already alerted recently
                        if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                            self.add_alert(message)
                except:
                    pass
            
            # GPU checks
            if self.has_gpu:
                if gpu_percent > self.thresholds["gpu"]:
                    problem_detected = True
                    message = f"GPU usage is high: {gpu_percent:.1f}% (threshold: {self.thresholds['gpu']}%)"
                    problems_text.append(message)
                    
                    # Add to alert log if not already alerted recently
                    if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                        self.add_alert(message)
                
                if gpu_temp > self.thresholds["temperature"]:
                    problem_detected = True
                    message = f"GPU temperature is high: {gpu_temp:.1f}°C (threshold: {self.thresholds['temperature']}°C)"
                    problems_text.append(message)
                    
                    # Add to alert log if not already alerted recently
                    if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                        self.add_alert(message)
            
            # Update the problems frame
            def update_problems():
                # Remove all widgets
                for widget in self.frame_problems.winfo_children():
                    widget.destroy()
                
                if problem_detected:
                    # Add each problem as a label
                    for problem in problems_text:
                        ttk.Label(self.frame_problems, text=problem, foreground="red").pack(anchor="w", padx=10, pady=2)
                else:
                    ttk.Label(self.frame_problems, text="No problems detected").pack(anchor="w", padx=10, pady=5)
            
            # Update in main thread
            self.rootAllMonitorAllMonitor.after(0, update_problems)
        
        def update_ui(self, cpu_percent, cpu_freq_text, mem, swap, partitions, read_speed, write_speed, 
                     upload_speed, download_speed, gpu_usage=0, gpu_memory=0, gpu_temp=0):
            """Update the UI with new data"""
            try:
                # Update CPU data
                self.label_cpu.config(text=f"CPU Usage: {cpu_percent:.1f}%")
                self.label_cpu_usage.config(text=f"Total usage: {cpu_percent:.1f}%")
                self.progress_cpu["value"] = cpu_percent
                self.label_cpu_freq.config(text=cpu_freq_text)
                
                # Update memory data
                used_mem = round(mem.used / (1024 ** 3), 2)
                total_mem = round(mem.total / (1024 ** 3), 2)
                
                self.label_memory.config(text=f"Memory Usage: {mem.percent:.1f}% ({used_mem} GB / {total_mem} GB)")
                self.label_memory_usage.config(text=f"Usage: {mem.percent:.1f}% ({used_mem} GB / {total_mem} GB)")
                self.progress_memory["value"] = mem.percent
                
                # Update swap data
                used_swap = round(swap.used / (1024 ** 3), 2)
                total_swap = round(swap.total / (1024 ** 3), 2)
                swap_percent = swap.percent if swap.total > 0 else 0
                
                self.label_swap_usage.config(text=f"Swap usage: {swap_percent:.1f}% ({used_swap} GB / {total_swap} GB)")
                self.progress_swap["value"] = swap_percent
                
                # Update disk data
                # Update the first partition in the summary tab
                try:
                    main_partition = partitions[0]
                    usage = psutil.disk_usage(main_partition.mountpoint)
                    used_disk = round(usage.used / (1024 ** 3), 2)
                    total_disk = round(usage.total / (1024 ** 3), 2)
                    
                    self.label_disk.config(text=f"Disk Usage: {usage.percent:.1f}% ({used_disk} GB / {total_disk} GB)")
                except:
                    self.label_disk.config(text="Disk Usage: Not available")
                
                # Update all partition details
                for partition in partitions:
                    try:
                        if partition.mountpoint in self.disk_labels:
                            usage = psutil.disk_usage(partition.mountpoint)
                            usage_percent = usage.percent
                            total_gb = round(usage.total / (1024 ** 3), 2)
                            used_gb = round(usage.used / (1024 ** 3), 2)
                            free_gb = round(usage.free / (1024 ** 3), 2)
                            
                            info_text = f"Partition: {partition.mountpoint} | Total: {total_gb} GB | Used: {used_gb} GB | Free: {free_gb} GB | Usage: {usage_percent}%"
                            self.disk_labels[partition.mountpoint].config(text=info_text)
                            self.disk_progress[partition.mountpoint]["value"] = usage_percent
                    except:
                        pass
                
                # Update disk IO
                self.label_disk_read.config(text=f"Read speed: {read_speed} MB/s")
                self.label_disk_write.config(text=f"Write speed: {write_speed} MB/s")
                
                # Update network data
                self.label_download.config(text=f"Download: {download_speed} KB/s")
                self.label_upload.config(text=f"Upload: {upload_speed} KB/s")
                
                # Update GPU data if available
                if self.has_gpu:
                    self.label_gpu.config(text=f"GPU Usage: {gpu_usage:.1f}%")
                    self.label_gpu_usage.config(text=f"Usage: {gpu_usage:.1f}%")
                    self.progress_gpu["value"] = gpu_usage
                    
                    self.label_gpu_memory.config(text=f"Memory: {gpu_memory:.1f}%")
                    self.progress_gpu_memory["value"] = gpu_memory
                    
                    self.label_gpu_temp.config(text=f"Temperature: {gpu_temp:.1f}°C")
                    self.progress_gpu_temp["value"] = gpu_temp
            
            except Exception as e:
                print(f"Error updating UI: {e}")
        
        def on_closing(self):
            """Handle application closing"""
            self.running = False
            time.sleep(0.5)  # Wait for thread to finish
            self.rootAllMonitorAllMonitor.destroy()

    def main():
        rootAllMonitor = tk.Tk()
        app = HardwareMonitorApplication(rootAllMonitor)
        rootAllMonitor.protocol("WM_DELETE_WINDOW", app.on_closing)
        rootAllMonitor.mainloop()

    if __name__ == "__main__":
        main()

if assemblyvar == 333333333:
    from tkinter import font
    
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon61 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon61)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class RetroDebugger:
        def __init__(self, rootasm):
            self.rootasm = rootasm
            self.rootasm.title("Registry x64 Debugger")
            # Full screen și fără bordură
            self.rootasm.attributes('-fullscreen', True)
            self.rootasm.overrideredirect(True)  # Elimină bara de titlu
            
            # Culori de interfață
            self.bg_color = "#000080"  # Albastru închis
            self.text_color = "#FFFFFF"  # Alb
            self.highlight_color = "#FFFF00"  # Galben pentru evidențiere
            self.header_color = "#00FFFF"  # Cyan pentru header
            self.changed_color = "#FF0000"  # Roșu pentru valorile modificate
            
            # Font Roboto Bold pentru toate elementele
            self.font = font.Font(family="Roboto", size=12, weight="bold")
            self.small_font = font.Font(family="Roboto", size=10, weight="bold")
            self.header_font = font.Font(family="Roboto", size=14, weight="bold")
            
            # Configurare rootasm
            self.rootasm.configure(bg=self.bg_color)
            
            # Variabile pentru stare
            self.selected_register = 0
            self.editing_mode = False
            self.edit_value = ""
            
            # Definirea registrilor
            self.registers = {
                "EAX": "0000FFFF",
                "EBX": "00000000",
                "ECX": "AAAAAAAA",
                "EDX": "00001234",
                "ESI": "BBBB0000",
                "EDI": "CCCC0000",
                "EBP": "FFFF0000",
                "ESP": "EEEE1111",
                "CS": "0008",
                "DS": "0010",
                "ES": "0010",
                "SS": "0018",
                "IP": "7C00"
            }
            
            # Istoricul valorilor pentru a marca schimbările
            self.prev_registers = self.registers.copy()
            
            # Inițializarea memoriei hex (32 rânduri x 16 bytes)
            self.memory = {}
            base_addr = 0x7C00  # Adresa de start tipică pentru boot
            for i in range(32):
                addr = base_addr + (i * 16)
                self.memory[addr] = [0 for _ in range(16)]  # Inițial toate zero
            
            # Flag pentru oprirea thread-ului de actualizare
            self.stop_thread = False
            
            # Crearea cadrelor principale
            self.main_frame = tk.Frame(self.rootasm, bg=self.bg_color)
            self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Crearea header-ului
            self.header_frame = tk.Frame(self.main_frame, bg=self.bg_color)
            self.header_frame.pack(fill=tk.X, pady=(5, 15))
            
            self.title_label = tk.Label(
                self.header_frame, 
                text="x64 Debug Monitor v0.2",
                font=self.header_font,
                fg=self.header_color,
                bg=self.bg_color
            )
            self.title_label.pack(side=tk.LEFT)
            
            # Crearea conținutului pe două coloane
            self.content_frame = tk.Frame(self.main_frame, bg=self.bg_color)
            self.content_frame.pack(fill=tk.BOTH, expand=True)
            
            # Cadru pentru registri (partea stângă)
            self.registers_frame = tk.Frame(self.content_frame, bg=self.bg_color, width=400)
            self.registers_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=(0, 20))
            
            # Cadru pentru memoria hex (partea dreaptă)
            self.memory_frame = tk.Frame(self.content_frame, bg=self.bg_color)
            self.memory_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
            
            # Crearea footer-ului
            self.footer_frame = tk.Frame(self.main_frame, bg=self.bg_color)
            self.footer_frame.pack(fill=tk.X, side=tk.BOTTOM, pady=(15, 5))
            
            self.footer_label = tk.Label(
                self.footer_frame, 
                text="↑↓: Select Register   Enter: Edit Value   ESC: Exit   F5: Run/Stop   F11: Toggle Fullscreen",
                font=self.small_font,
                fg=self.text_color,
                bg=self.bg_color
            )
            self.footer_label.pack(side=tk.LEFT)
            
            # Adăugarea evenimentelor de tastatură
            self.rootasm.bind("<Up>", self.move_up)
            self.rootasm.bind("<Down>", self.move_down)
            self.rootasm.bind("<Return>", self.toggle_edit_mode)
            self.rootasm.bind("<Escape>", self.cancel_or_exit)
            self.rootasm.bind("<F5>", self.toggle_run)
            self.rootasm.bind("<KeyPress>", self.handle_key)
            self.rootasm.bind("<F11>", self.toggle_fullscreen)  # Adăugare pentru a ieși din fullscreen
            
            # Flag pentru rularea simulării
            self.is_running = False
            
            # Randomizare memorie inițială
            self.randomize_memory()
            
            # Afișarea registrilor și memoriei
            self.update_display()
            
            # Pornirea thread-ului pentru actualizarea memoriei
            self.updater_thread = threading.Thread(target=self.memory_updater)
            self.updater_thread.daemon = True
            self.updater_thread.start()
        
        def randomize_memory(self):
            """Metoda pentru inițializarea aleatorie a memoriei"""
            for addr in self.memory:
                self.memory[addr] = [random.randint(0, 255) for _ in range(16)]
        
        def update_display(self):
            # Actualizare registri
            self.update_registers_display()
            
            # Actualizare memorie
            self.update_memory_display()
        
        def update_registers_display(self):
            # Ștergerea afișării registrilor anteriori
            for widget in self.registers_frame.winfo_children():
                widget.destroy()
            
            # Titlul registrilor
            reg_title = tk.Label(
                self.registers_frame,
                text="CPU Registers",
                font=self.header_font,
                fg=self.header_color,
                bg=self.bg_color
            )
            reg_title.pack(anchor=tk.W, pady=(0, 20))
            
            # Separator
            separator = tk.Frame(self.registers_frame, height=2, bg=self.text_color)
            separator.pack(fill=tk.X, pady=(0, 20))
            
            # Afișarea fiecărui registru
            for i, (reg_name, reg_value) in enumerate(self.registers.items()):
                # Evidențiere registru selectat
                frame_bg = self.highlight_color if i == self.selected_register else self.bg_color
                text_fg = self.bg_color if i == self.selected_register else self.text_color
                
                # Cadru pentru fiecare rând
                reg_frame = tk.Frame(self.registers_frame, bg=frame_bg)
                reg_frame.pack(fill=tk.X, pady=2)
                
                # Numele registrului
                name_label = tk.Label(
                    reg_frame,
                    text=f"{reg_name}:",
                    font=self.font,
                    fg=text_fg,  # Culoarea textului se schimbă pentru cel selectat
                    bg=frame_bg,
                    width=6,
                    anchor=tk.W
                )
                name_label.pack(side=tk.LEFT, padx=(20, 10))
                
                # Valoarea registrului
                value_text = reg_value
                if self.editing_mode and i == self.selected_register:
                    value_text = self.edit_value + "_"
                
                # Verifică dacă valoarea s-a schimbat
                value_fg = text_fg  # Implicit, culoarea textului depinde de selecție
                if not (i == self.selected_register) and reg_name in self.prev_registers and reg_value != self.prev_registers[reg_name]:
                    value_fg = self.changed_color  # Roșu pentru valorile modificate
                
                value_label = tk.Label(
                    reg_frame,
                    text=value_text,
                    font=self.font,
                    fg=value_fg,
                    bg=frame_bg,
                    anchor=tk.W
                )
                value_label.pack(side=tk.LEFT)
        
        def update_memory_display(self):
            # Ștergerea afișării memoriei anterioare
            for widget in self.memory_frame.winfo_children():
                widget.destroy()
            
            # Titlul memoriei
            mem_title = tk.Label(
                self.memory_frame,
                text="Memory Dump",
                font=self.header_font,
                fg=self.header_color,
                bg=self.bg_color
            )
            mem_title.pack(anchor=tk.W, pady=(0, 20))
            
            # Separator
            separator = tk.Frame(self.memory_frame, height=2, bg=self.text_color)
            separator.pack(fill=tk.X, pady=(0, 20))
            
            # Header pentru memoria hex
            header_frame = tk.Frame(self.memory_frame, bg=self.bg_color)
            header_frame.pack(fill=tk.X)
            
            addr_header = tk.Label(
                header_frame,
                text="Address",
                font=self.small_font,
                fg=self.header_color,
                bg=self.bg_color,
                width=10,
                anchor=tk.W
            )
            addr_header.pack(side=tk.LEFT, padx=(0, 10))
            
            # Header pentru bytes
            for i in range(16):
                byte_header = tk.Label(
                    header_frame,
                    text=f"{i:02X}",
                    font=self.small_font,
                    fg=self.header_color,
                    bg=self.bg_color,
                    width=2,
                    anchor=tk.CENTER
                )
                byte_header.pack(side=tk.LEFT, padx=1)
            
            # Afișarea fiecărui rând de memorie
            mem_canvas = tk.Canvas(self.memory_frame, bg=self.bg_color, highlightthickness=0)
            mem_canvas.pack(fill=tk.BOTH, expand=True)
            
            # Frame în canvas pentru a permite scrolling
            mem_inner_frame = tk.Frame(mem_canvas, bg=self.bg_color)
            mem_canvas.create_window((0, 0), window=mem_inner_frame, anchor=tk.NW)
            
            for i, addr in enumerate(sorted(self.memory.keys())):
                row_frame = tk.Frame(mem_inner_frame, bg=self.bg_color)
                row_frame.pack(fill=tk.X, pady=1)
                
                # Adresa
                addr_label = tk.Label(
                    row_frame,
                    text=f"{addr:08X}",
                    font=self.small_font,
                    fg=self.text_color,
                    bg=self.bg_color,
                    width=10,
                    anchor=tk.W
                )
                addr_label.pack(side=tk.LEFT, padx=(0, 10))
                
                # Bytes - cu posibilitatea de a evidenția bytes modificați recent
                for i, byte in enumerate(self.memory[addr]):
                    # Aleatoriu, unele valori apar evidențiate (simulând o modificare recentă)
                    highlight = random.random() < 0.05 and self.is_running  # 5% șansă de evidențiere când rulează
                    fg_color = self.changed_color if highlight else self.text_color
                    
                    byte_label = tk.Label(
                        row_frame,
                        text=f"{byte:02X}",
                        font=self.small_font,
                        fg=fg_color,
                        bg=self.bg_color,
                        width=2,
                        anchor=tk.CENTER
                    )
                    byte_label.pack(side=tk.LEFT, padx=1)
        
        def move_up(self, event):
            if self.editing_mode:
                return
            
            if self.selected_register > 0:
                self.selected_register -= 1
                self.update_registers_display()
        
        def move_down(self, event):
            if self.editing_mode:
                return
            
            if self.selected_register < len(self.registers) - 1:
                self.selected_register += 1
                self.update_registers_display()
        
        def toggle_edit_mode(self, event):
            reg_name = list(self.registers.keys())[self.selected_register]
            
            if self.editing_mode:
                # Salvează valoarea editată
                if self.is_valid_hex(self.edit_value):
                    padded_value = self.edit_value.zfill(len(self.registers[reg_name]))
                    self.prev_registers[reg_name] = self.registers[reg_name]
                    self.registers[reg_name] = padded_value.upper()
                self.editing_mode = False
            else:
                # Începe editarea
                self.editing_mode = True
                self.edit_value = ""
            
            self.update_registers_display()
        
        def cancel_or_exit(self, event):
            if self.editing_mode:
                self.editing_mode = False
                self.edit_value = ""
                self.update_registers_display()
            else:
                # Oprim thread-ul înainte de a ieși
                self.stop_thread = True
                self.rootasm.destroy()
                
        def toggle_fullscreen(self, event):
            # Pentru a ieși din fullscreen
            is_fullscreen = self.rootasm.attributes('-fullscreen')
            self.rootasm.attributes('-fullscreen', not is_fullscreen)
            if is_fullscreen:
                self.rootasm.overrideredirect(False)  # Readuce bara de titlu
            else:
                self.rootasm.overrideredirect(True)  # Elimină bara de titlu
        
        def toggle_run(self, event):
            self.is_running = not self.is_running
            status = "Running" if self.is_running else "Stopped"
            self.footer_label.config(text=f"↑↓: Select Register   Enter: Edit Value   ESC: Exit   F5: Run/Stop   F11: Toggle Fullscreen   [Status: {status}]")
        
        def is_valid_hex(self, value):
            try:
                int(value, 16)
                return True
            except ValueError:
                return False
        
        def handle_key(self, event):
            if not self.editing_mode:
                return
                
            key = event.char.upper()
            
            # Verifică dacă tasta apăsată este un caracter hexazecimal
            if key in "0123456789ABCDEF":
                reg_name = list(self.registers.keys())[self.selected_register]
                max_length = len(self.registers[reg_name])
                
                if len(self.edit_value) < max_length:
                    self.edit_value += key
                    self.update_registers_display()
            # Backspace
            elif event.keysym == "BackSpace" and self.edit_value:
                self.edit_value = self.edit_value[:-1]
                self.update_registers_display()
        
        def memory_updater(self):
            try:
                while not self.stop_thread:
                    if self.is_running:
                        # Simularea modificării aleatorii a registrilor
                        reg_keys = list(self.registers.keys())
                        reg_to_update = random.choice(reg_keys)
                        
                        # Salvăm vechea valoare
                        self.prev_registers[reg_to_update] = self.registers[reg_to_update]
                        
                        # Generăm o nouă valoare
                        if reg_to_update in ["CS", "DS", "ES", "SS", "IP"]:
                            # Registri de 16 biți
                            new_value = f"{random.randint(0, 0xFFFF):04X}"
                        else:
                            # Registri de 32 biți
                            new_value = f"{random.randint(0, 0xFFFFFFFF):08X}"
                        
                        self.registers[reg_to_update] = new_value
                        
                        # Actualizăm memoria hexazecimală aleator - mai multe locații simultan
                        num_changes = random.randint(3, 8)  # Modificăm între 3 și 8 bytes simultan
                        for _ in range(num_changes):
                            mem_addr = random.choice(list(self.memory.keys()))
                            byte_pos = random.randint(0, 15)
                            self.memory[mem_addr][byte_pos] = random.randint(0, 255)
                        
                        # Actualizăm afișajul în thread-ul principal
                        self.rootasm.after(0, self.update_display)
                        
                    # Interval aleator de actualizare între 0.1 și 0.8 secunde
                    time.sleep(random.uniform(0.1, 0.8))
            except Exception as e:
                print(f"Error in updater thread: {e}")

    if __name__ == "__main__":
        rootasm = tk.Tk()
        app = RetroDebugger(rootasm)
        rootasm.mainloop()

if eventvval == 44445555:
    class Windows95EventViewer:
        def __init__(self, rooteventv):
            self.rooteventv = rooteventv
            self.rooteventv.title("Event Viewer")
            self.rooteventv.geometry("800x600")
            
            # Setări pentru tema Windows 95
            self.configure_win95_theme()
            
            # Variabile pentru filtrare
            self.filter_type = tk.StringVar(value="All")
            self.filter_source = tk.StringVar(value="All")
            self.filter_period = tk.StringVar(value="All")
            
            # Creare interfață
            self.create_menu()
            self.create_toolbar()
            self.create_main_frame()
            self.create_status_bar()
            
            # Inițializare date
            self.events = []
            self.load_events()
            
            # Pornire monitorizare în fundal
            self.monitoring = True
            self.monitor_thread = threading.Thread(target=self.monitor_events)
            self.monitor_thread.daemon = True
            self.monitor_thread.start()
        
        def configure_win95_theme(self):
            # Setează culorile temei Windows 95
            bg_color = "#c0c0c0"  # Gri deschis pentru fundal
            button_color = "#c0c0c0"  # Gri pentru butoane
            text_color = "#000000"  # Negru pentru text
            
            self.rooteventv.configure(bg=bg_color)
            
            # Creează stiluri pentru temă
            style = ttk.Style()
            
            # Configurare font sistem Windows 95
            default_font = font.nametofont("TkDefaultFont")
            default_font.configure(family="Roboto", size=9)
            
            # Configurare stil butoane și alte elemente
            style.configure("W95.TButton", 
                          background=button_color, 
                          foreground=text_color,
                          relief="raised",
                          font=("Roboto", 9))
            
            style.configure("W95.TFrame", background=bg_color)
            style.configure("W95.TLabel", background=bg_color, foreground=text_color)
            style.configure("W95.TCheckbutton", background=bg_color, foreground=text_color)
            
            # Configurare stil pentru listbox și treeview
            style.configure("W95.Treeview", 
                          background="white", 
                          foreground=text_color,
                          fieldbackground="white",
                          borderwidth=1,
                          relief="sunken",
                          font=("Roboto", 9))
            
            style.configure("W95.Treeview.Heading", 
                          background=button_color, 
                          foreground=text_color,
                          relief="raised",
                          font=("Roboto", 9, "bold"))
        
        def create_menu(self):
            # Creare bară de meniu în stil Windows 95
            menu_bar = tk.Menu(self.rooteventv, bg="#c0c0c0", fg="black", relief="raised", borderwidth=1)
            
            # Meniu Fișier
            file_menu = tk.Menu(menu_bar, tearoff=0, bg="#c0c0c0", fg="black")
            file_menu.add_command(label="Save events", command=self.save_events)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rooteventv.quit)
            menu_bar.add_cascade(label="File", menu=file_menu)
            
            # Meniu Vizualizare
            view_menu = tk.Menu(menu_bar, tearoff=0, bg="#c0c0c0", fg="black")
            view_menu.add_command(label="Refresh", command=self.refresh_events)
            view_menu.add_separator()
            view_menu.add_command(label="Filter", command=self.show_filter_dialog)
            menu_bar.add_cascade(label="View", menu=view_menu)
            
            # Meniu Ajutor
            help_menu = tk.Menu(menu_bar, tearoff=0, bg="#c0c0c0", fg="black")
            help_menu.add_command(label="About", command=self.show_about)
            menu_bar.add_cascade(label="Help", menu=help_menu)
            
            self.rooteventv.config(menu=menu_bar)
        
        def create_toolbar(self):
            # Creare bară de unelte în stil Windows 95
            toolbar_frame = tk.Frame(self.rooteventv, bg="#c0c0c0", bd=1, relief="raised")
            toolbar_frame.pack(side=tk.TOP, fill=tk.X)
            
            # Butoane pentru bara de unelte
            refresh_button = ttk.Button(toolbar_frame, text="Refresh", style="W95.TButton", 
                                       command=self.refresh_events)
            refresh_button.pack(side=tk.LEFT, padx=2, pady=2)
            
            filter_button = ttk.Button(toolbar_frame, text="Filter", style="W95.TButton", 
                                      command=self.show_filter_dialog)
            filter_button.pack(side=tk.LEFT, padx=2, pady=2)
            
            # Separator
            separator = ttk.Separator(toolbar_frame, orient="vertical")
            separator.pack(side=tk.LEFT, padx=5, pady=2, fill="y")
            
            # Tipuri de evenimente cu checkbox-uri
            error_var = tk.IntVar(value=1)
            warning_var = tk.IntVar(value=1)
            info_var = tk.IntVar(value=1)
            
            self.filter_vars = {
                "Error": error_var,
                "Warning": warning_var,
                "Information": info_var
            }
            
            error_cb = ttk.Checkbutton(toolbar_frame, text="Errors", variable=error_var, 
                                      style="W95.TCheckbutton", command=self.apply_filters)
            error_cb.pack(side=tk.LEFT, padx=2, pady=2)
            
            warning_cb = ttk.Checkbutton(toolbar_frame, text="Warnings", variable=warning_var, 
                                        style="W95.TCheckbutton", command=self.apply_filters)
            warning_cb.pack(side=tk.LEFT, padx=2, pady=2)
            
            info_cb = ttk.Checkbutton(toolbar_frame, text="Informations", variable=info_var, 
                                     style="W95.TCheckbutton", command=self.apply_filters)
            info_cb.pack(side=tk.LEFT, padx=2, pady=2)
        
        def create_main_frame(self):
            # Creare frame principal cu lista de evenimente
            main_frame = ttk.Frame(self.rooteventv, style="W95.TFrame")
            main_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Creare treeview pentru evenimente
            columns = ("Type", "Date", "Source", "ID", "Description")
            self.tree = ttk.Treeview(main_frame, columns=columns, show="headings", style="W95.Treeview")
            
            # Configurare coloane
            self.tree.heading("Type", text="Type")
            self.tree.heading("Date", text="Date & Time")
            self.tree.heading("Source", text="Source")
            self.tree.heading("ID", text="Event ID")
            self.tree.heading("Description", text="Description")
            
            self.tree.column("Type", width=80, anchor=tk.W)
            self.tree.column("Date", width=150, anchor=tk.W)
            self.tree.column("Source", width=100, anchor=tk.W)
            self.tree.column("ID", width=80, anchor=tk.CENTER)
            self.tree.column("Description", width=350, anchor=tk.W)
            
            # Adăugare scrollbar
            scrollbar_y = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
            self.tree.configure(yscrollcommand=scrollbar_y.set)
            
            # Aranjare elemente
            self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Setare acțiune pentru dublu click
            self.tree.bind("<Double-1>", self.show_event_details)
        
        def create_status_bar(self):
            # Creare bară de stare în stil Windows 95
            self.status_bar = tk.Frame(self.rooteventv, bg="#c0c0c0", bd=1, relief="sunken")
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
            
            # Text pentru bară de stare
            self.status_text = tk.Label(self.status_bar, text="Ready", bg="#c0c0c0", anchor=tk.W, padx=5, pady=2)
            self.status_text.pack(side=tk.LEFT, fill=tk.X)
            
            # Indicator număr evenimente
            self.event_count = tk.Label(self.status_bar, text="Events: 0", bg="#c0c0c0", padx=5, pady=2)
            self.event_count.pack(side=tk.RIGHT)
        
        def load_events(self):
            """Încarcă evenimentele din jurnalele de sistem"""
            self.status_text.config(text="Loading events...")
            self.rooteventv.update()
            
            # Curățare evenimente existente
            self.events = []
            self.tree.delete(*self.tree.get_children())
            
            try:
                os_name = platform.system()
                
                if os_name == "Windows":
                    # Pentru Windows folosim wevtutil sau PowerShell
                    self.load_windows_events()
                elif os_name == "Linux":
                    # Pentru Linux folosim journalctl
                    self.load_linux_events()
                elif os_name == "Darwin":
                    # Pentru macOS folosim log command
                    self.load_macos_events()
                else:
                    messagebox.showerror("Error", f"The operating system {os_name} is not supported.")
                    return
                
                # Aplicare filtre și actualizare interfață
                self.apply_filters()
                self.status_text.config(text="Ready")
            
            except Exception as e:
                messagebox.showerror("Error", f"Unable to load events: {str(e)}")
                self.status_text.config(text="Error loading events")
        
        def load_windows_events(self):
            """Încarcă evenimentele din Event Viewer din Windows"""
            try:
                # Încercăm mai întâi PowerShell pentru mai multe detalii
                command = 'powershell "Get-WinEvent -LogName Application, System -MaxEvents 100 | Select-Object TimeCreated, LevelDisplayName, ProviderName, Id, Message | ConvertTo-Csv -NoTypeInformation"'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if len(lines) > 1:  # Verificăm dacă avem date (prima linie este header)
                        import csv
                        from io import StringIO
                        
                        # Parsare CSV
                        reader = csv.DictReader(StringIO(result.stdout))
                        for row in reader:
                            event_type = row.get('LevelDisplayName', '').strip()
                            # Mapare tipuri de evenimente
                            if event_type.lower() == 'error':
                                event_type = 'Error'
                            elif event_type.lower() == 'warning':
                                event_type = 'Warning'
                            elif event_type.lower() == 'information':
                                event_type = 'Information'
                            
                            timestamp = row.get('TimeCreated', '')
                            source = row.get('ProviderName', '')
                            event_id = row.get('Id', '')
                            description = row.get('Message', '')
                            
                            if description and len(description) > 100:
                                description = description[:100] + "..."
                            
                            self.events.append({
                                'type': event_type,
                                'date': timestamp,
                                'source': source,
                                'id': event_id,
                                'description': description,
                                'details': row.get('Message', '')
                            })
                    else:
                        # Fallback la metoda wevtutil pentru sisteme Windows mai vechi
                        self.load_windows_events_legacy()
                else:
                    # Fallback la metoda wevtutil pentru sisteme Windows mai vechi
                    self.load_windows_events_legacy()
                    
            except Exception as e:
                messagebox.showerror("Error", f"Could not load Windows events: {str(e)}")
        
        def load_windows_events_legacy(self):
            """Metodă alternativă pentru încărcarea evenimentelor din Windows"""
            try:
                command = 'wevtutil qe System /c:20 /rd:true /f:text'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    events_text = result.stdout
                    event_blocks = events_text.split("\n\n")
                    
                    for block in event_blocks:
                        if not block.strip():
                            continue
                        
                        lines = block.strip().split("\n")
                        event_data = {}
                        
                        for line in lines:
                            if ": " in line:
                                key, value = line.split(": ", 1)
                                event_data[key.strip()] = value.strip()
                        
                        # Extragere informații
                        event_type = "Information"  # Valoare implicită
                        if "Level" in event_data:
                            level = event_data["Level"].lower()
                            if "error" in level:
                                event_type = "Error"
                            elif "warn" in level:
                                event_type = "Warning"
                        
                        timestamp = event_data.get("Date", "")
                        source = event_data.get("Provider Name", "")
                        event_id = event_data.get("Event ID", "")
                        description = event_data.get("Description", "")
                        
                        if description and len(description) > 100:
                            description = description[:100] + "..."
                        
                        self.events.append({
                            'type': event_type,
                            'date': timestamp,
                            'source': source,
                            'id': event_id,
                            'description': description,
                            'details': event_data.get("Description", "")
                        })
                else:
                    raise Exception("Failed command: " + result.stderr)
                    
            except Exception as e:
                messagebox.showerror("Error", f"Could not load Windows events (legacy): {str(e)}")
        
        def load_linux_events(self):
            """Încarcă evenimentele din jurnalele Linux"""
            try:
                # Verificăm dacă avem acces la journalctl
                command = 'journalctl -n 100 --no-pager -o json'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    # Parsare JSON pentru fiecare linie
                    import json
                    for line in result.stdout.strip().split('\n'):
                        if not line.strip():
                            continue
                        
                        try:
                            log_entry = json.loads(line)
                            
                            # Determinare tip eveniment
                            priority = int(log_entry.get('PRIORITY', 6))
                            event_type = "Information"
                            if priority <= 3:
                                event_type = "Error"
                            elif priority == 4:
                                event_type = "Warning"
                            
                            # Formatare timestamp
                            timestamp = log_entry.get('__REALTIME_TIMESTAMP', '')
                            if timestamp:
                                timestamp = datetime.datetime.fromtimestamp(int(timestamp) / 1000000).strftime('%Y-%m-%d %H:%M:%S')
                            
                            source = log_entry.get('SYSLOG_IDENTIFIER', log_entry.get('_COMM', ''))
                            message = log_entry.get('MESSAGE', '')
                            
                            if message and len(message) > 100:
                                short_message = message[:100] + "..."
                            else:
                                short_message = message
                            
                            self.events.append({
                                'type': event_type,
                                'date': timestamp,
                                'source': source,
                                'id': log_entry.get('_PID', ''),
                                'description': short_message,
                                'details': message
                            })
                            
                        except json.JSONDecodeError:
                            continue
                else:
                    # Fallback la /var/log
                    self.load_linux_events_legacy()
                    
            except Exception as e:
                messagebox.showerror("Error", f"Unable to load Linux events: {str(e)}")
        
        def load_linux_events_legacy(self):
            """Metodă alternativă pentru încărcarea evenimentelor din Linux folosind fișiere de log"""
            try:
                log_files = ['/var/log/syslog', '/var/log/messages']
                
                for log_file in log_files:
                    if os.path.exists(log_file):
                        with open(log_file, 'r', errors='ignore') as f:
                            lines = f.readlines()[-100:]  # Ultimele 100 de linii
                            
                            for line in lines:
                                line = line.strip()
                                if not line:
                                    continue
                                
                                # Încercare de parsare
                                parts = line.split(' ', 5)
                                if len(parts) >= 6:
                                    date_str = ' '.join(parts[:3])
                                    host = parts[3]
                                    source = parts[4].rstrip(':')
                                    message = parts[5]
                                    
                                    # Determinare tip eveniment
                                    event_type = "Information"
                                    if any(err in line.lower() for err in ['error', 'err', 'fail', 'critical']):
                                        event_type = "Error"
                                    elif any(warn in line.lower() for warn in ['warn', 'alert']):
                                        event_type = "Warning"
                                    
                                    if message and len(message) > 100:
                                        short_message = message[:100] + "..."
                                    else:
                                        short_message = message
                                    
                                    self.events.append({
                                        'type': event_type,
                                        'date': date_str,
                                        'source': source,
                                        'id': '',
                                        'description': short_message,
                                        'details': message
                                    })
            except Exception as e:
                messagebox.showerror("Error", f"Unable to load Linux events (legacy): {str(e)}")
        
        def load_macos_events(self):
            """Încarcă evenimentele din jurnalele macOS"""
            try:
                # Folosim utilitarul log din macOS
                command = 'log show --style compact --last 1h'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    
                    for line in lines:
                        if not line.strip():
                            continue
                        
                        # Încercare de parsare linie log macOS
                        match = re.match(r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d+).*\[(.*):(\d+)\] (.*)', line)
                        if match:
                            timestamp, source, pid, message = match.groups()
                            
                            # Determinare tip eveniment
                            event_type = "Information"
                            if any(err in line.lower() for err in ['error', 'err', 'fail', 'critical']):
                                event_type = "Error"
                            elif any(warn in line.lower() for warn in ['warn', 'alert']):
                                event_type = "Warning"
                            
                            if message and len(message) > 100:
                                short_message = message[:100] + "..."
                            else:
                                short_message = message
                            
                            self.events.append({
                                'type': event_type,
                                'date': timestamp,
                                'source': source,
                                'id': pid,
                                'description': short_message,
                                'details': message
                            })
                        else:
                            # Încercare alternativă de parsare
                            parts = line.split(' ', 5)
                            if len(parts) >= 6:
                                date_str = ' '.join(parts[:2])
                                source = parts[2]
                                message = parts[5] if len(parts) > 5 else ''
                                
                                # Determinare tip eveniment
                                event_type = "Information"
                                if any(err in line.lower() for err in ['error', 'err', 'fail', 'critical']):
                                    event_type = "Error"
                                elif any(warn in line.lower() for warn in ['warn', 'alert']):
                                    event_type = "Warning"
                                
                                if message and len(message) > 100:
                                    short_message = message[:100] + "..."
                                else:
                                    short_message = message
                                
                                self.events.append({
                                    'type': event_type,
                                    'date': date_str,
                                    'source': source,
                                    'id': '',
                                    'description': short_message,
                                    'details': message
                                })
                else:
                    raise Exception("Failed command: " + result.stderr)
                    
            except Exception as e:
                messagebox.showerror("Error", f"Could not load macOS events: {str(e)}")
        
        def parse_event_date(self, date_str):
            """Parsează string-ul de dată în format datetime"""
            if not date_str:
                return None
                
            # Lista formatelor de dată posibile
            date_formats = [
                '%Y-%m-%d %H:%M:%S',         # Format standard 
                '%Y-%m-%d %H:%M:%S.%f',      # Cu microsecunde
                '%b %d %H:%M:%S %Y',         # Format syslog
                '%Y-%m-%dT%H:%M:%S.%fZ',     # Format ISO
                '%a %b %d %H:%M:%S %Y',      # Format alt syslog
                '%d/%m/%Y %H:%M:%S',         # Format dd/mm/yyyy
                '%m/%d/%Y %H:%M:%S',         # Format mm/dd/yyyy
                '%Y-%m-%dT%H:%M:%S',         # Format ISO fără microsecunde
                '%d %b %Y %H:%M:%S'          # Format zi lună an
            ]
            
            for fmt in date_formats:
                try:
                    return datetime.datetime.strptime(date_str, fmt)
                except ValueError:
                    continue
                    
            return None
        
        def apply_filters(self):
            """Aplică filtrele și actualizează lista de evenimente"""
            # Curățare treeview
            self.tree.delete(*self.tree.get_children())
            
            # Obține filtrele active pentru tipuri de evenimente
            active_types = [tip for tip, var in self.filter_vars.items() if var.get() == 1]
            
            # Obține perioada de filtrat
            now = datetime.datetime.now()
            start_date = None
            
            if self.filter_period.get() == "Last hour":
                start_date = now - datetime.timedelta(hours=1)
            elif self.filter_period.get() == "Last 24 hours":
                start_date = now - datetime.timedelta(days=1)
            elif self.filter_period.get() == "Last week":
                start_date = now - datetime.timedelta(weeks=1)
            
            # Adaugă evenimentele filtrate
            displayed_events = 0
            for event in self.events:
                # Verificare tip eveniment
                if event['type'] not in active_types:
                    continue
                
                # Verificare perioadă (dacă este setată)
                if start_date is not None:
                    event_date = self.parse_event_date(event['date'])
                    # Dacă nu putem parsa data sau este în afara perioadei, sărim peste
                    if event_date is None or event_date < start_date:
                        continue
                
                # Adăugăm evenimentul în treeview
                self.tree.insert("", tk.END, values=(
                    event['type'],
                    event['date'],
                    event['source'],
                    event['id'],
                    event['description']
                ))
                displayed_events += 1
            
            # Actualizare contor și bară de stare
            self.event_count.config(text=f"Events: {displayed_events}")
            
            # Actualizare bară de stare cu informații despre filtre
            filter_info = "Filters: "
            
            # Adaugă informații despre tipurile filtrate
            type_filters = []
            if self.filter_vars["Error"].get() == 1:
                type_filters.append("Errors")
            if self.filter_vars["Warning"].get() == 1:
                type_filters.append("Warnings")
            if self.filter_vars["Information"].get() == 1:
                type_filters.append("Informations")
                
            filter_info += ", ".join(type_filters)
            
            # Adaugă informații despre perioada filtrată
            if self.filter_period.get() != "All":
                filter_info += f" | Period: {self.filter_period.get()}"
                
            self.status_text.config(text=filter_info)
        
        def show_event_details(self, event):
            """Afișează detaliile unui eveniment la dublu click"""
            selection = self.tree.selection()
            if not selection:
                return
                
            item_id = selection[0]
            item_values = self.tree.item(item_id, "values")
            
            # Găsește evenimentul complet
            event_details = None
            for event in self.events:
                if (event['type'] == item_values[0] and 
                    event['date'] == item_values[1] and 
                    event['source'] == item_values[2] and 
                    str(event['id']) == str(item_values[3])):
                    event_details = event
                    break
            
            if event_details:
                # Creare fereastră de detalii în stil Windows 95
                details_window = tk.Toplevel(self.rooteventv)
                details_window.title("Event details")
                details_window.geometry("600x400")
                details_window.configure(bg="#c0c0c0")
                
                # Titlu
                title_frame = tk.Frame(details_window, bg="#000080", relief="raised", borderwidth=1)
                title_frame.pack(fill=tk.X, padx=2, pady=2)
                
                title_label = tk.Label(title_frame, text="Event details", fg="white", bg="#000080", font=("Roboto", 10, "bold"))
                title_label.pack(anchor="w", padx=10, pady=5)
                
                # Informații eveniment
                info_frame = tk.Frame(details_window, bg="#c0c0c0", relief="sunken", borderwidth=1)
                info_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                # Grid pentru informații
                info_labels = [
                    ("Type:", event_details['type']),
                    ("Date & Time:", event_details['date']),
                    ("Source:", event_details['source']),
                    ("Event ID:", event_details['id']),
                ]
                
                for i, (label, value) in enumerate(info_labels):
                    tk.Label(info_frame, text=label, bg="#c0c0c0", anchor="w").grid(row=i, column=0, sticky="w", padx=5, pady=2)
                    tk.Label(info_frame, text=value, bg="#c0c0c0", anchor="w").grid(row=i, column=1, sticky="w", padx=5, pady=2)
                
                # Descriere completă
                tk.Label(info_frame, text="Description:", bg="#c0c0c0", anchor="w").grid(row=len(info_labels), column=0, sticky="nw", padx=5, pady=2)
                
                text_frame = tk.Frame(info_frame, bg="white", relief="sunken", borderwidth=1)
                text_frame.grid(row=len(info_labels), column=1, sticky="nsew", padx=5, pady=2)
                info_frame.grid_rowconfigure(len(info_labels), weight=1)
                info_frame.grid_columnconfigure(1, weight=1)
                
                text_widget = scrolledtext.ScrolledText(text_frame, wrap=tk.WORD, bg="white", relief="flat")
                text_widget.pack(fill=tk.BOTH, expand=True, padx=1, pady=1)
                text_widget.insert(tk.END, event_details.get('details', 'No description available'))
                text_widget.configure(state='disabled')  # Facem textul doar pentru citire
                
                # Butoane
                buttons_frame = tk.Frame(details_window, bg="#c0c0c0")
                buttons_frame.pack(fill=tk.X, padx=5, pady=5)
                
                close_button = tk.Button(buttons_frame, text="Close", bg="#c0c0c0", 
                                       command=details_window.destroy)
                close_button.pack(side=tk.RIGHT, padx=5)
        
        def show_filter_dialog(self):
            """Afișează dialogul pentru filtrare avansată"""
            filter_window = tk.Toplevel(self.rooteventv)
            filter_window.title("Event filtering")
            filter_window.geometry("400x300")
            filter_window.configure(bg="#c0c0c0")
            filter_window.resizable(False, False)
            
            # Titlu
            title_frame = tk.Frame(filter_window, bg="#000080", relief="raised", borderwidth=1)
            title_frame.pack(fill=tk.X, padx=2, pady=2)
            
            title_label = tk.Label(title_frame, text="Event filtering", fg="white", bg="#000080", 
                                  font=("MS Sans Serif", 10, "bold"))
            title_label.pack(anchor="w", padx=10, pady=5)
            
            # Conținut
            content_frame = tk.Frame(filter_window, bg="#c0c0c0", relief="sunken", borderwidth=1)
            content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Tipuri de evenimente
            tk.Label(content_frame, text="Event type:", bg="#c0c0c0", anchor="w").grid(row=0, column=0, 
                                                                                          sticky="w", padx=5, pady=10)
            
            # Radiobuttons pentru tipuri
            types_frame = tk.Frame(content_frame, bg="#c0c0c0")
            types_frame.grid(row=0, column=1, sticky="w", padx=5, pady=5)
            
            type_values = ["All", "Error", "Warning", "Information"]
            for i, value in enumerate(type_values):
                rb = tk.Radiobutton(types_frame, text=value, variable=self.filter_type, value=value, 
                                  bg="#c0c0c0")
                rb.grid(row=0, column=i, padx=5)
            
            # Surse
            tk.Label(content_frame, text="Source:", bg="#c0c0c0", anchor="w").grid(row=1, column=0, 
                                                                                 sticky="w", padx=5, pady=10)
            
            # Combobox pentru surse
            sources = ["All"] + sorted(list(set(event['source'] for event in self.events if event['source'])))
            source_combo = ttk.Combobox(content_frame, textvariable=self.filter_source, values=sources, state="readonly")
            source_combo.grid(row=1, column=1, sticky="w", padx=5, pady=5)
            
            # Perioadă
            tk.Label(content_frame, text="Period:", bg="#c0c0c0", anchor="w").grid(row=2, column=0, 
                                                                                    sticky="w", padx=5, pady=10)
            
            # Radiobuttons pentru perioadă
            period_frame = tk.Frame(content_frame, bg="#c0c0c0")
            period_frame.grid(row=2, column=1, sticky="w", padx=5, pady=5)
            
            period_values = ["All", "Last hour", "Last 24 hours", "Last week"]
            for i, value in enumerate(period_values):
                rb = tk.Radiobutton(period_frame, text=value, variable=self.filter_period, value=value, 
                                  bg="#c0c0c0")
                rb.grid(row=i//2, column=i%2, sticky="w", padx=5, pady=2)
            
            # Butoane
            buttons_frame = tk.Frame(filter_window, bg="#c0c0c0")
            buttons_frame.pack(fill=tk.X, padx=5, pady=5)
            
            apply_button = tk.Button(buttons_frame, text="Apply", bg="#c0c0c0", 
                                   command=lambda: [self.apply_filters(), filter_window.destroy()])
            apply_button.pack(side=tk.RIGHT, padx=5)
            
            cancel_button = tk.Button(buttons_frame, text="Cancel", bg="#c0c0c0", 
                                    command=filter_window.destroy)
            cancel_button.pack(side=tk.RIGHT, padx=5)
        
        def refresh_events(self):
            """Reîmprospătează lista de evenimente"""
            self.load_events()
        
        def save_events(self):
            """Salvează evenimentele într-un fișier"""
            from tkinter import filedialog
            
            file_path = filedialog.asksaveasfilename(
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")],
                title="Save events"
            )
            
            if not file_path:
                return
                
            try:
                with open(file_path, 'w', newline='', encoding='utf-8') as f:
                    import csv
                    writer = csv.writer(f)
                    
                    # Scriere header
                    writer.writerow(["Type", "Date & Time", "Source", "ID", "Description"])
                    
                    # Scriere evenimente
                    for item_id in self.tree.get_children():
                        values = self.tree.item(item_id, "values")
                        writer.writerow(values)
                        
                messagebox.showinfo("Full save", f"The events were saved in {file_path}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Unable to save events: {str(e)}")
        
        def show_about(self):
            """Afișează informații despre aplicație"""
            about_window = tk.Toplevel(self.rooteventv)
            about_window.title("About")
            about_window.geometry("350x200")
            about_window.configure(bg="#c0c0c0")
            about_window.resizable(False, False)
            
            # Titlu
            title_frame = tk.Frame(about_window, bg="#000080", relief="raised", borderwidth=1)
            title_frame.pack(fill=tk.X, padx=2, pady=2)
            
            title_label = tk.Label(title_frame, text="About Event Viewer", fg="white", bg="#000080", 
                                  font=("Roboto", 10, "bold"))
            title_label.pack(anchor="w", padx=10, pady=5)
            
            # Conținut
            content_frame = tk.Frame(about_window, bg="#c0c0c0")
            content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Logo placeholder - înlocuim Frame cu Canvas
            logo_canvas = tk.Canvas(content_frame, width=80, height=80, bg="#c0c0c0", bd=0, highlightthickness=0)
            logo_canvas.pack(side=tk.LEFT, padx=10)
            logo_canvas.create_rectangle(10, 10, 70, 70, fill="#ff0000", outline="")
            logo_canvas.create_rectangle(15, 15, 65, 65, fill="#00ff00", outline="")
            logo_canvas.create_rectangle(20, 20, 60, 60, fill="#0000ff", outline="")
            logo_canvas.create_rectangle(25, 25, 55, 55, fill="#ffff00", outline="")
            
            # Informații
            info_frame = tk.Frame(content_frame, bg="#c0c0c0")
            info_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            tk.Label(info_frame, text="Event Viewer", bg="#c0c0c0", 
                    font=("Roboto", 10, "bold")).pack(anchor="w")
            tk.Label(info_frame, text="Version 1.0", bg="#c0c0c0").pack(anchor="w")
            tk.Label(info_frame, text="© 2024", bg="#c0c0c0").pack(anchor="w")
            tk.Label(info_frame, text="Tudor Marmureanu", bg="#c0c0c0").pack(anchor="w")
            tk.Label(info_frame, text="An application for viewing system logs", 
                    bg="#c0c0c0", wraplength=200).pack(anchor="w")
            
            # Buton închidere
            buttons_frame = tk.Frame(about_window, bg="#c0c0c0")
            buttons_frame.pack(fill=tk.X, padx=5, pady=5)
            
            close_button = tk.Button(buttons_frame, text="OK", bg="#c0c0c0", 
                                   command=about_window.destroy)
            close_button.pack(side=tk.RIGHT, padx=5)
        
        def monitor_events(self):
            """Monitorizează evenimente noi în fundal"""
            while self.monitoring:
                # Verifică la fiecare 30 de secunde
                time.sleep(30)
                
                # Implementarea reală ar trebui să verifice doar evenimente noi
                # și să le adauge la lista existentă fără a reîncărca totul
                # Aici este doar un exemplu simplu
                
                # În thread-ul principal avem acces la interfață
                if self.monitoring:  # Verificăm din nou pentru cazul în care aplicația se închide
                    self.rooteventv.after(0, self.check_new_events)
        
        def check_new_events(self):
            """Verifică și adaugă evenimente noi în thread-ul principal"""
            # Aici ar trebui să implementăm o logică pentru a verifica și adăuga doar evenimente noi
            # Pentru exemplu, doar actualizăm statusul
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            self.status_text.config(text=f"Check for new events: {current_time}")
            
            # Puteți implementa logica reală aici
            
            # Resetează statusul după un timp
            self.rooteventv.after(3000, lambda: self.status_text.config(text="Ready"))

    def main():
        rooteventv = tk.Tk()
        app = Windows95EventViewer(rooteventv)
        rooteventv.mainloop()

    if __name__ == "__main__":
        main()
        
if kbbbvar == 5189:
    from tkinter import ttk, font, filedialog, colorchooser, messagebox
    
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    # Verifică și creează folderul Serial dacă nu există
    if not os.path.exists(FOLDER_NAME):
        try:
            os.makedirs(FOLDER_NAME)
            print(f"Folder '{FOLDER_NAME}' created successfully.")
        except Exception as e:
            print(f"Error creating folder '{FOLDER_NAME}': {e}")

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Salvarea cheii în fișier text
            with open(file_path, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Calea completă către fișier în folderul Serial
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            
            # Încărcarea cheii din fișier text
            with open(file_path, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        sys.exit()

    def valkey():
        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")
    image_icon61 = PhotoImage(file = "img/keylogo.png")
    validation.iconphoto(False, image_icon61)

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()

    class Win95KnowledgeBase:
        def __init__(self, rootKBBB):
            self.rootKBBB = rootKBBB
            self.rootKBBB.title("Retro Knowledge Base")
            self.rootKBBB.geometry("800x600")
            
            # Culorile Windows 95
            self.win95_bg = "#c0c0c0"
            self.win95_button = "#c0c0c0"
            self.win95_text_bg = "#ffffff"
            self.win95_text_fg = "#000000"
            self.win95_active = "#000080"
            self.win95_highlight = "#0000ff"
            
            # Fonturi
            self.default_font = font.Font(family="MS Sans Serif", size=10)
            
            # Configurare stil Windows 95
            self.rootKBBB.configure(bg=self.win95_bg)
            
            # Variabile pentru fișierul curent
            self.current_file = None
            self.procedures = {}
            self.current_procedure = None
            
            # Crearea interfeței
            self.create_ui()
            
            # Crearea primei proceduri implicite
            self.new_procedure()
        
        def create_ui(self):
            # Cadru principal
            main_frame = tk.Frame(self.rootKBBB, bg=self.win95_bg, bd=1, relief=tk.RAISED)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Meniu
            self.create_menu()
            
            # Cadru pentru toolbar
            toolbar_frame = tk.Frame(main_frame, bg=self.win95_bg, bd=1, relief=tk.RAISED)
            toolbar_frame.pack(fill=tk.X, padx=2, pady=2)
            
            # Butoane toolbar
            new_btn = tk.Button(toolbar_frame, text="New", bg=self.win95_button, 
                              relief=tk.RAISED, bd=2, font=self.default_font,
                              command=self.new_procedure)
            new_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            save_btn = tk.Button(toolbar_frame, text="Save", bg=self.win95_button, 
                               relief=tk.RAISED, bd=2, font=self.default_font,
                               command=self.save_procedure)
            save_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            bold_btn = tk.Button(toolbar_frame, text="B", bg=self.win95_button, 
                              relief=tk.RAISED, bd=2, font=font.Font(family="MS Sans Serif", size=10, weight="bold"),
                              command=self.toggle_bold)
            bold_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            italic_btn = tk.Button(toolbar_frame, text="I", bg=self.win95_button, 
                                relief=tk.RAISED, bd=2, font=font.Font(family="MS Sans Serif", size=10, slant="italic"),
                                command=self.toggle_italic)
            italic_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            text_color_btn = tk.Button(toolbar_frame, text="Text Color", bg=self.win95_button, 
                                     relief=tk.RAISED, bd=2, font=self.default_font,
                                     command=self.choose_text_color)
            text_color_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            bg_color_btn = tk.Button(toolbar_frame, text="BG Color", bg=self.win95_button, 
                                   relief=tk.RAISED, bd=2, font=self.default_font,
                                   command=self.choose_bg_color)
            bg_color_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            # Combobox pentru mărime font
            font_size_label = tk.Label(toolbar_frame, text="Font:", bg=self.win95_bg, font=self.default_font)
            font_size_label.pack(side=tk.LEFT, padx=2, pady=2)
            
            self.font_size_var = tk.StringVar(value="10")
            font_sizes = ["8", "9", "10", "11", "12", "14", "16", "18", "20", "22", "24", "26", "28", "36", "48", "72"]
            self.font_size_combo = ttk.Combobox(toolbar_frame, textvariable=self.font_size_var, values=font_sizes, width=3)
            self.font_size_combo.pack(side=tk.LEFT, padx=2, pady=2)
            self.font_size_combo.bind("<<ComboboxSelected>>", self.change_font_size)
            
            # Cadru pentru conținut
            content_frame = tk.Frame(main_frame, bg=self.win95_bg)
            content_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # Cadru stânga pentru lista de proceduri
            left_frame = tk.Frame(content_frame, bg=self.win95_bg, bd=1, relief=tk.SUNKEN, width=200)
            left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=2, pady=2)
            left_frame.pack_propagate(False)
            
            # Lista de proceduri
            procedure_label = tk.Label(left_frame, text="Procedures:", bg=self.win95_bg, font=self.default_font)
            procedure_label.pack(anchor=tk.W, padx=5, pady=5)
            
            self.procedure_listbox = tk.Listbox(left_frame, bg=self.win95_text_bg, relief=tk.SUNKEN, bd=2,
                                             selectbackground=self.win95_active, font=self.default_font)
            self.procedure_listbox.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            self.procedure_listbox.bind("<<ListboxSelect>>", self.load_selected_procedure)
            
            # Cadru pentru adăugarea unei noi proceduri
            add_procedure_frame = tk.Frame(left_frame, bg=self.win95_bg)
            add_procedure_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.new_procedure_name = tk.Entry(add_procedure_frame, bg=self.win95_text_bg, 
                                            relief=tk.SUNKEN, bd=2, font=self.default_font)
            self.new_procedure_name.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 2))
            
            add_btn = tk.Button(add_procedure_frame, text="+", bg=self.win95_button, 
                              relief=tk.RAISED, bd=2, font=self.default_font,
                              command=self.add_new_procedure)
            add_btn.pack(side=tk.RIGHT)
            
            # Cadru dreapta pentru editor text
            right_frame = tk.Frame(content_frame, bg=self.win95_bg, bd=1, relief=tk.SUNKEN)
            right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # Titlu procedură
            title_frame = tk.Frame(right_frame, bg=self.win95_bg)
            title_frame.pack(fill=tk.X, padx=5, pady=5)
            
            title_label = tk.Label(title_frame, text="Title:", bg=self.win95_bg, font=self.default_font)
            title_label.pack(side=tk.LEFT, padx=(0, 5))
            
            self.title_entry = tk.Entry(title_frame, bg=self.win95_text_bg, 
                                     relief=tk.SUNKEN, bd=2, font=self.default_font)
            self.title_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            # Editor text
            self.text_editor = tk.Text(right_frame, bg=self.win95_text_bg, fg=self.win95_text_fg,
                                    relief=tk.SUNKEN, bd=2, font=self.default_font,
                                    wrap=tk.WORD, undo=True)
            self.text_editor.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Scrollbar pentru editor
            scrollbar = tk.Scrollbar(self.text_editor, command=self.text_editor.yview)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.text_editor.config(yscrollcommand=scrollbar.set)
            
            # Status bar
            self.status_bar = tk.Label(main_frame, text="Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W,
                                    font=font.Font(family="MS Sans Serif", size=8), bg=self.win95_bg)
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        def create_menu(self):
            menubar = tk.Menu(self.rootKBBB)
            
            # Meniu Fișier
            file_menu = tk.Menu(menubar, tearoff=0)
            file_menu.add_command(label="New", command=self.new_kb)
            file_menu.add_command(label="Open", command=self.open_kb)
            file_menu.add_command(label="Save", command=self.save_kb)
            file_menu.add_command(label="Save as", command=self.save_kb_as)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootKBBB.quit)
            menubar.add_cascade(label="File", menu=file_menu)
            
            # Meniu Editare
            edit_menu = tk.Menu(menubar, tearoff=0)
            edit_menu.add_command(label="Cut", command=lambda: self.text_editor.event_generate("<<Cut>>"))
            edit_menu.add_command(label="Copy", command=lambda: self.text_editor.event_generate("<<Copy>>"))
            edit_menu.add_command(label="Paste", command=lambda: self.text_editor.event_generate("<<Paste>>"))
            edit_menu.add_separator()
            edit_menu.add_command(label="Bold", command=self.toggle_bold)
            edit_menu.add_command(label="Italic", command=self.toggle_italic)
            edit_menu.add_command(label="Text color", command=self.choose_text_color)
            edit_menu.add_command(label="BG color", command=self.choose_bg_color)
            menubar.add_cascade(label="Edit", menu=edit_menu)
            
            # Meniu Ajutor
            help_menu = tk.Menu(menubar, tearoff=0)
            help_menu.add_command(label="About", command=self.show_about)
            menubar.add_cascade(label="Help", menu=help_menu)
            
            self.rootKBBB.config(menu=menubar)
        
        def add_tag_with_config(self, tag_name, **kwargs):
            """Adaugă un tag cu configurație pentru formatare text"""
            self.text_editor.tag_configure(tag_name, **kwargs)
        
        def toggle_tag(self, tag_name):
            """Comută un tag la selecția curentă"""
            try:
                # Verifică dacă există text selectat
                selected_text = self.text_editor.tag_ranges(tk.SEL)
                if selected_text:
                    start, end = selected_text
                    # Verifică dacă tag-ul există deja în selecție
                    tags = self.text_editor.tag_names(start)
                    if tag_name in tags:
                        self.text_editor.tag_remove(tag_name, start, end)
                    else:
                        self.text_editor.tag_add(tag_name, start, end)
                else:
                    self.status_bar.config(text="Select text to apply formatting.")
            except:
                self.status_bar.config(text="Error applying formatting.")
        
        def toggle_bold(self):
            """Comută textul îngroșat"""
            bold_font = font.Font(family="MS Sans Serif", size=int(self.font_size_var.get()), weight="bold")
            self.add_tag_with_config("bold", font=bold_font)
            self.toggle_tag("bold")
        
        def toggle_italic(self):
            """Comută textul înclinat"""
            italic_font = font.Font(family="MS Sans Serif", size=int(self.font_size_var.get()), slant="italic")
            self.add_tag_with_config("italic", font=italic_font)
            self.toggle_tag("italic")
        
        def choose_text_color(self):
            """Alege culoarea textului"""
            color = colorchooser.askcolor(title="Choose text color.")[1]
            if color:
                self.add_tag_with_config(f"color_{color}", foreground=color)
                self.toggle_tag(f"color_{color}")
        
        def choose_bg_color(self):
            """Alege culoarea de fundal"""
            color = colorchooser.askcolor(title="Choose background color.")[1]
            if color:
                self.add_tag_with_config(f"bg_{color}", background=color)
                self.toggle_tag(f"bg_{color}")
        
        def change_font_size(self, event=None):
            """Schimbă dimensiunea fontului"""
            try:
                size = int(self.font_size_var.get())
                size_font = font.Font(family="MS Sans Serif", size=size)
                tag_name = f"size_{size}"
                self.add_tag_with_config(tag_name, font=size_font)
                
                # Aplică tag-ul la selecție
                selected_text = self.text_editor.tag_ranges(tk.SEL)
                if selected_text:
                    start, end = selected_text
                    # Elimină alte tag-uri de dimensiune
                    for tag in self.text_editor.tag_names(start):
                        if tag.startswith("size_"):
                            self.text_editor.tag_remove(tag, start, end)
                    # Adaugă noul tag
                    self.text_editor.tag_add(tag_name, start, end)
                else:
                    self.status_bar.config(text="Select text to change font size.")
            except:
                self.status_bar.config(text="Error changing font size.")
        
        def new_procedure(self):
            """Creează o nouă procedură"""
            self.current_procedure = f"Procedure {len(self.procedures) + 1}"
            self.procedures[self.current_procedure] = {
                "title": self.current_procedure,
                "content": "",
                "tags": []
            }
            self.update_procedure_list()
            self.clear_editor()
            self.title_entry.insert(0, self.current_procedure)
        
        def add_new_procedure(self):
            """Adaugă o nouă procedură din câmpul de intrare"""
            name = self.new_procedure_name.get().strip()
            if name:
                self.current_procedure = name
                self.procedures[name] = {
                    "title": name,
                    "content": "",
                    "tags": []
                }
                self.update_procedure_list()
                self.clear_editor()
                self.title_entry.insert(0, name)
                self.new_procedure_name.delete(0, tk.END)
            else:
                self.status_bar.config(text="Enter a name for the new procedure.")
        
        def update_procedure_list(self):
            """Actualizează lista de proceduri"""
            self.procedure_listbox.delete(0, tk.END)
            for proc in self.procedures:
                self.procedure_listbox.insert(tk.END, proc)
            # Selectează procedura curentă
            if self.current_procedure:
                for i, proc in enumerate(self.procedures):
                    if proc == self.current_procedure:
                        self.procedure_listbox.selection_set(i)
                        break
        
        def load_selected_procedure(self, event=None):
            """Încarcă procedura selectată"""
            selection = self.procedure_listbox.curselection()
            if selection:
                index = selection[0]
                procedure_name = self.procedure_listbox.get(index)
                
                # Salvează procedura curentă înainte de a o schimba
                if self.current_procedure:
                    self.save_procedure()
                
                # Încarcă noua procedură
                self.current_procedure = procedure_name
                self.load_procedure(procedure_name)
        
        def load_procedure(self, procedure_name):
            """Încarcă o procedură în editor"""
            if procedure_name in self.procedures:
                procedure = self.procedures[procedure_name]
                
                # Curăță editorul
                self.clear_editor()
                
                # Setează titlul
                self.title_entry.insert(0, procedure["title"])
                
                # Setează conținutul
                self.text_editor.insert("1.0", procedure["content"])
                
                # Aplică tag-urile
                for tag_info in procedure["tags"]:
                    tag_name = tag_info["name"]
                    start = tag_info["start"]
                    end = tag_info["end"]
                    config = tag_info["config"]
                    
                    # Creează tag-ul cu configurația sa
                    self.text_editor.tag_configure(tag_name, **config)
                    
                    # Aplică tag-ul
                    self.text_editor.tag_add(tag_name, start, end)
                
                self.status_bar.config(text=f"Procedure '{procedure_name}' loaded")
        
        def save_procedure(self):
            """Salvează procedura curentă"""
            if self.current_procedure:
                # Actualizează titlul
                new_title = self.title_entry.get().strip()
                if new_title and new_title != self.current_procedure:
                    # Dacă titlul s-a schimbat, trebuie să redenumim procedura
                    procedure_data = self.procedures[self.current_procedure]
                    del self.procedures[self.current_procedure]
                    self.current_procedure = new_title
                    self.procedures[new_title] = procedure_data
                
                # Salvează conținutul
                content = self.text_editor.get("1.0", tk.END)
                self.procedures[self.current_procedure]["content"] = content
                self.procedures[self.current_procedure]["title"] = new_title
                
                # Salvează tag-urile
                tags = []
                for tag_name in self.text_editor.tag_names():
                    if tag_name == "sel":  # Ignoră tag-ul de selecție
                        continue
                    
                    # Obține configurația tag-ului
                    config = {}
                    for key in ["font", "foreground", "background"]:
                        value = self.text_editor.tag_cget(tag_name, key)
                        if value:
                            config[key] = value
                    
                    # Obține toate intervalele care au acest tag
                    ranges = self.text_editor.tag_ranges(tag_name)
                    for i in range(0, len(ranges), 2):
                        start = ranges[i]
                        end = ranges[i + 1]
                        tags.append({
                            "name": tag_name,
                            "start": str(start),
                            "end": str(end),
                            "config": config
                        })
                
                self.procedures[self.current_procedure]["tags"] = tags
                
                self.update_procedure_list()
                self.status_bar.config(text=f"Procedure '{self.current_procedure}' saved")
        
        def clear_editor(self):
            """Curăță editorul"""
            self.text_editor.delete("1.0", tk.END)
            self.title_entry.delete(0, tk.END)
            
            # Elimină toate tag-urile
            for tag in self.text_editor.tag_names():
                if tag != "sel":  # Păstrează tag-ul de selecție
                    self.text_editor.tag_delete(tag)
        
        def new_kb(self):
            """Creează o nouă bază de cunoștințe"""
            if self.procedures and messagebox.askyesno("Saving", "Do you want to save the current knowledge base before creating a new one?"):
                self.save_kb()
            
            self.procedures = {}
            self.current_procedure = None
            self.current_file = None
            self.update_procedure_list()
            self.clear_editor()
            self.new_procedure()
            self.status_bar.config(text="Nouă bază de cunoștințe creată")
        
        def open_kb(self):
            """Deschide o bază de cunoștințe"""
            if self.procedures and messagebox.askyesno("Saving", "Do you want to save the current knowledge base before creating a new one?"):
                self.save_kb()
            
            file_path = filedialog.askopenfilename(
                defaultextension=".kb95",
                filetypes=[("Knowledge Base for Multiapp 95", "*.kb95"), ("All files", "*.*")]
            )
            
            if file_path:
                try:
                    with open(file_path, "r", encoding="utf-8") as file:
                        data = json.load(file)
                        self.procedures = data.get("procedures", {})
                        self.current_file = file_path
                        
                        # Încarcă prima procedură dacă există
                        if self.procedures:
                            self.current_procedure = list(self.procedures.keys())[0]
                            self.update_procedure_list()
                            self.load_procedure(self.current_procedure)
                        else:
                            self.new_procedure()
                        
                        self.status_bar.config(text=f"Knowledge base '{os.path.basename(file_path)}' open")
                except Exception as e:
                    messagebox.showerror("Error", f"The file could not be opened: {str(e)}")
        
        def save_kb(self):
            """Salvează baza de cunoștințe"""
            if self.current_procedure:
                self.save_procedure()
            
            if self.current_file:
                self.save_kb_to_file(self.current_file)
            else:
                self.save_kb_as()
        
        def save_kb_as(self):
            """Salvează baza de cunoștințe ca un nou fișier"""
            if self.current_procedure:
                self.save_procedure()
            
            file_path = filedialog.asksaveasfilename(
                defaultextension=".kb95",
                filetypes=[("Knowledge Base for Multiapp 95", "*.kb95"), ("All files", "*.*")]
            )
            
            if file_path:
                self.save_kb_to_file(file_path)
                self.current_file = file_path
        
        def save_kb_to_file(self, file_path):
            """Salvează baza de cunoștințe în fișier"""
            try:
                data = {
                    "procedures": self.procedures
                }
                
                with open(file_path, "w", encoding="utf-8") as file:
                    json.dump(data, file, ensure_ascii=False, indent=2)
                
                self.status_bar.config(text=f"Knowledge base saved in '{os.path.basename(file_path)}'")
            except Exception as e:
                messagebox.showerror("Error", f"The file could not be saved: {str(e)}")
        
        def show_about(self):
            """Afișează informații despre aplicație"""
            messagebox.showinfo(
                "About Knowledge Base",
                "Version 1.0\n\n"
                "A knowledge/procedure management system."
            )

    if __name__ == "__main__":
        rootKBBB = tk.Tk()
        app = Win95KnowledgeBase(rootKBBB)
        rootKBBB.mainloop()