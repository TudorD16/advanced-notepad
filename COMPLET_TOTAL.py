import zipfile
import json
import tkinter as tk
from tkinter import PhotoImage
from tkinter import filedialog, messagebox, ttk, Scrollbar
from tkinter.filedialog import askopenfilename, asksaveasfilename
import math
import pyperclip
import random
import shutil
import os
import subprocess
import tkinter.messagebox as MB
import datetime
import platform
from tkinter.ttk import Progressbar, Scrollbar
from getmac import getmac
from tkinter.messagebox import showinfo
import socket,sys,threading,time
from tkinter import *
# Importuri standard
import argparse
import difflib
import mimetypes
import filecmp
import pandas as pd
import numpy as np
from tkinter import scrolledtext
from tkinter import filedialog as fd
from tkinter import messagebox as mb
import os.path
from aspose.words import Document
import aspose.words as aw
import dearpygui.dearpygui as dpg
from cpuinfo import get_cpu_info
import GPUtil
import psutil
import humanize
#from datetime import datetime
from multiprocessing import Process
from threading import Thread
import pyautogui
import threading
import cv2
import numpy as np
import xml.etree.ElementTree as ET

# Importuri pentru interfața grafică
try:
    from tkinter import *
    from tkinter.filedialog import askopenfilename, askdirectory
    from tkinter.simpledialog import askstring
    from tkinter.messagebox import showerror
    from tkinter import font
    from tkinter import ttk
    from tkinter.ttk import Treeview
except ImportError:    # Python 2 fallback
    from Tkinter import *
    from tkFileDialog import askopenfilename, askdirectory
    from tkSimpleDialog import askstring
    from tkMessageBox import showerror
    from tkFont import Font
    import ttk
    from ttk import Treeview
    
import getpass

def check_database():
    """Check Config folder and mark_init.inst95 file"""
    config_dir = "Config"
    config_file = os.path.join(config_dir, "mark_init.inst95")
    
    # Create Config directory if it doesn't exist
    if not os.path.exists(config_dir):
        try:
            os.makedirs(config_dir)
        except:
            show_config_error()
            return False
    
    # Check if mark_init.inst95 exists and contains "True"
    if os.path.exists(config_file):
        try:
            with open(config_file, "r") as f:
                content = f.read().strip()
                if content == "True":
                    #print("pass")
                    return False  # Don't run installer
                else:
                    show_config_error()
                    return False
        except:
            pass
    
    return True  # Run installer

def show_config_error():
    """Show Windows 95 style error dialog"""
    error_root = tk.Tk()
    error_root.title("Multiapp 95 Professional Setup")
    error_root.geometry("400x150")
    error_root.configure(bg='#c0c0c0')
    error_root.resizable(False, False)
    error_root.overrideredirect(True)
    
    # Center the error window
    error_root.update_idletasks()
    x = (error_root.winfo_screenwidth() // 2) - (400 // 2)
    y = (error_root.winfo_screenheight() // 2) - (150 // 2)
    error_root.geometry(f"400x170+{x}+{y}")
    
    # Main frame
    main_frame = tk.Frame(error_root, bg='#c0c0c0', relief='raised', bd=2)
    main_frame.pack(fill='both', expand=True, padx=2, pady=2)
    
    # Header
    header_frame = tk.Frame(main_frame, bg='#000080', height=30)
    header_frame.pack(fill='x')
    header_frame.pack_propagate(False)
    
    title_label = tk.Label(header_frame, text="Multiapp 95 Professional Setup - Error", bg='#000080', fg='white', 
                          font=('MS Sans Serif', 10, 'bold'))
    title_label.pack(anchor='w', padx=10, pady=5)
    
    # Content
    content_frame = tk.Frame(main_frame, bg='#c0c0c0')
    content_frame.pack(fill='both', expand=True, padx=20, pady=15)
    
    # Error icon and message
    msg_frame = tk.Frame(content_frame, bg='#c0c0c0')
    msg_frame.pack(expand=True)
    
    # Error icon (using text)
    icon_label = tk.Label(msg_frame, text="!", bg='#c0c0c0', fg='red', 
                         font=('MS Sans Serif', 24))
    icon_label.pack(side='left', padx=(0, 15))
    
    # Error message
    error_msg = tk.Label(msg_frame, text="Cannot create configuration for Multiapp 95 Professional.\n\nSetup cannot continue due to\ninsufficient permissions or corrupted files.", 
                        bg='#c0c0c0', font=('MS Sans Serif', 9), justify='left')
    error_msg.pack(side='left')
    
    # Button
    button_frame = tk.Frame(main_frame, bg='#c0c0c0')
    button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
    
    ok_button = tk.Button(button_frame, text='OK', command=error_root.destroy,
                         width=10, height=1, font=('MS Sans Serif', 8))
    ok_button.pack(side='right', padx=5)
    
    # Bind ESC to close
    error_root.bind('<Escape>', lambda e: error_root.destroy())
    
    error_root.mainloop()

def write_completion_flag():
    """Write completion flag to Config/mark_init.inst95"""
    config_dir = "Config"
    config_file = os.path.join(config_dir, "mark_init.inst95")
    
    try:
        # Ensure Config directory exists
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
        
        # Write True to mark_init.inst95
        with open(config_file, "w") as f:
            f.write("True")
    except:
        pass

class Windows95Installer:
    def __init__(self):
        self.root9955 = tk.Tk()
        self.root9955.title("Multiapp 95 Professional Setup")
        self.root9955.geometry("640x480")
        self.root9955.configure(bg='#c0c0c0')
        self.root9955.resizable(False, False)
        
        # Remove title bar
        self.root9955.overrideredirect(True)
        
        # Center the window
        self.center_window()
        
        # Fullscreen state
        self.is_fullscreen = False
        self.normal_geometry = "640x480"
        
        # Get actual system info
        self.actual_user = getpass.getuser()
        self.actual_computer = socket.gethostname()
        
        # Variables with actual system values
        self.current_step = 0
        self.progress_value = 0
        self.user_name = tk.StringVar(value=self.actual_user)
        self.computer_name = tk.StringVar(value=self.actual_computer)
        self.workgroup = tk.StringVar(value="WORKGROUP")
        self.timezone = tk.StringVar(value="(GMT-08:00) Pacific Time (US & Canada)")
        
        # Create main frame
        self.main_frame = tk.Frame(self.root9955, bg='#c0c0c0', relief='raised', bd=2)
        self.main_frame.pack(fill='both', expand=True, padx=2, pady=2)
        
        # Start installation
        self.show_welcome_screen()
        
        # Bind escape key to toggle fullscreen
        self.root9955.bind('<Escape>', self.toggle_fullscreen)
        
    def EXITO(self):
        sys.exit(0)
    
    def show_product_activation(self):
        """Show Windows 95 style product activation as part of the installation flow"""
        self.clear_frame()
        self.create_header("Multiapp 95 Professional", "Product Activation")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=10)
        self.create_key_logo(content_frame)
        
        # Instruction
        instruction = tk.Label(content_frame, text="Please enter your 25-character Product Key:", 
                             bg='#c0c0c0', font=('MS Sans Serif', 9))
        instruction.pack(anchor='w', pady=(0, 15))
        
        # Create entry fields for product key
        entry_frame = tk.Frame(content_frame, bg='#c0c0c0')
        entry_frame.pack(pady=10)
        
        # Create variables for each entry field
        self.key_vars = [tk.StringVar() for _ in range(5)]
        self.key_entries = []
        
        # Function to handle auto-movement to next field
        def on_entry_change(index, event=None):
            value = self.key_vars[index].get().upper()
            self.key_vars[index].set(value)  # Convert to uppercase
            
            if len(value) >= 5 and index < 4:
                # Move to next field
                self.key_entries[index+1].focus()
                self.key_entries[index+1].select_range(0, 0)  # Place cursor at start
            
            # Keep entry limited to 5 chars
            if len(value) > 5:
                self.key_vars[index].set(value[:5])
        
        # Create 5 entry fields
        for i in range(5):
            entry = tk.Entry(entry_frame, textvariable=self.key_vars[i], font=('MS Sans Serif', 10, 'bold'),
                           width=6, justify='center')
            entry.pack(side='left')
            self.key_entries.append(entry)
            
            # Configure callback for each entry
            self.key_vars[i].trace_add("write", lambda name, index, mode, i=i: on_entry_change(i))
            
            # Add binding to handle keys
            entry.bind('<KeyRelease>', lambda event, i=i: on_entry_change(i, event))
            
            # Add dash except after the last entry
            if i < 4:
                dash_label = tk.Label(entry_frame, text="-", bg='#c0c0c0', font=('MS Sans Serif', 10, 'bold'))
                dash_label.pack(side='left', padx=2)
        
        # Status message
        self.status_var = tk.StringVar()
        status_label = tk.Label(content_frame, textvariable=self.status_var, bg='#c0c0c0', 
                              font=('MS Sans Serif', 8), fg='#800000')
        status_label.pack(pady=10)
        
        # Example key hint
        hint_label = tk.Label(content_frame, text="Example format: XXXXX-XXXXX-XXXXX-XXXXX-XXXXX", 
                            bg='#c0c0c0', font=('MS Sans Serif', 8), fg='#808080')
        hint_label.pack(pady=(0, 10))
        
        # Create buttons
        self.create_buttons([
            {'text': '< Back', 'command': self.show_license_agreement, 'side': 'right'},
            {'text': 'Next >', 'command': self.validate_and_continue, 'side': 'right'},
            {'text': 'Exit', 'command': self.EXITO, 'side': 'right'}
        ])
        
        # Set focus to the first entry field
        self.key_entries[0].focus()

    def validate_and_continue(self):
        """Validate product key and continue if valid"""
        # Combine all parts
        entered_key = "-".join([var.get().upper() for var in self.key_vars])
        valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        
        if entered_key == valid_key:
            # Key is valid - create folder and file
            if not os.path.exists(FOLDER_NAME):
                try:
                    os.makedirs(FOLDER_NAME)
                except:
                    self.status_var.set("Error: Could not create serial folder.")
                    return
            
            # Write key to file
            try:
                with open(os.path.join(FOLDER_NAME, FILE_NAME), 'w') as f:
                    f.write(entered_key)
                
                # Continue to the next screen
                self.show_user_info()
                
            except:
                self.status_var.set("Error: Could not write product key file.")
        else:
            self.status_var.set("Invalid product key. Please check and try again.")
            
            # Show error dialog
            self.show_activation_error()

    def show_activation_error(self):
        """Show Windows 95 style error dialog for activation"""
        error_root = tk.Toplevel(self.root9955)
        error_root.title("Multiapp 95 Professional Setup")
        error_root.geometry("400x180")
        error_root.configure(bg='#c0c0c0')
        error_root.resizable(False, False)
        error_root.overrideredirect(True)
        
        # Center the error window
        error_root.update_idletasks()
        x = (error_root.winfo_screenwidth() // 2) - (400 // 2)
        y = (error_root.winfo_screenheight() // 2) - (180 // 2)
        error_root.geometry(f"400x180+{x}+{y}")
        
        # Main frame
        main_frame = tk.Frame(error_root, bg='#c0c0c0', relief='raised', bd=2)
        main_frame.pack(fill='both', expand=True, padx=2, pady=2)
        
        # Header
        header_frame = tk.Frame(main_frame, bg='#000080', height=30)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        title_label = tk.Label(header_frame, text="Multiapp 95 Professional Setup - Activation Error", bg='#000080', fg='white', 
                              font=('MS Sans Serif', 10, 'bold'))
        title_label.pack(anchor='w', padx=10, pady=5)
        
        # Content
        content_frame = tk.Frame(main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=15)
        
        # Error icon and message
        msg_frame = tk.Frame(content_frame, bg='#c0c0c0')
        msg_frame.pack(expand=True)
        
        # Error icon (using text)
        icon_label = tk.Label(msg_frame, text="X", bg='#c0c0c0', fg='red', 
                             font=('MS Sans Serif', 24, 'bold'))
        icon_label.pack(side='left', padx=(0, 15))
        
        # Error message
        error_msg = tk.Label(msg_frame, text="The product key you entered is invalid.\n\nPlease check your product key and try again.", 
                            bg='#c0c0c0', font=('MS Sans Serif', 9), justify='left')
        error_msg.pack(side='left')
        
        # Button
        button_frame = tk.Frame(main_frame, bg='#c0c0c0')
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
        
        ok_button = tk.Button(button_frame, text='OK', command=error_root.destroy,
                             width=10, height=1, font=('MS Sans Serif', 8))
        ok_button.pack(side='right', padx=5)
        
        # Bind ESC to close
        error_root.bind('<Escape>', lambda e: error_root.destroy())
    
    def create_logo(self, parent_frame):
        """Create a 3D retro PC logo similar to Windows 95 style"""
        logo_canvas = tk.Canvas(parent_frame, width=120, height=100, bg='#c0c0c0', 
                               highlightthickness=0)
        logo_canvas.pack(side='right', anchor='ne', padx=(0, 20), pady=10)
        
        # Draw PC case (tower) - 3D effect
        # Main front face
        logo_canvas.create_rectangle(20, 25, 50, 75, fill='#e0e0e0', outline='#808080', width=1)
        # Top face (3D)
        logo_canvas.create_polygon(20, 25, 25, 20, 55, 20, 50, 25, fill='#f0f0f0', outline='#808080')
        # Right face (3D)
        logo_canvas.create_polygon(50, 25, 55, 20, 55, 70, 50, 75, fill='#d0d0d0', outline='#808080')
        
        # Draw floppy drive slot
        logo_canvas.create_rectangle(25, 30, 45, 35, fill='#404040', outline='#202020')
        
        # Draw CD-ROM drive
        logo_canvas.create_rectangle(25, 40, 45, 45, fill='#606060', outline='#404040')
        logo_canvas.create_rectangle(42, 41, 44, 44, fill='#808080', outline='#606060')
        
        # Draw power button
        logo_canvas.create_oval(40, 50, 45, 55, fill='#ff4040', outline='#cc0000')
        
        # Draw some ventilation lines
        for i in range(3):
            y = 60 + i * 3
            logo_canvas.create_line(25, y, 45, y, fill='#a0a0a0', width=1)
        
        # Draw monitor
        # Monitor base/stand
        logo_canvas.create_rectangle(65, 70, 85, 75, fill='#c0c0c0', outline='#808080')
        # Monitor screen (3D)
        logo_canvas.create_rectangle(60, 30, 90, 60, fill='#f0f0f0', outline='#808080', width=1)
        # Top face
        logo_canvas.create_polygon(60, 30, 65, 25, 95, 25, 90, 30, fill='#ffffff', outline='#808080')
        # Right face
        logo_canvas.create_polygon(90, 30, 95, 25, 95, 55, 90, 60, fill='#e0e0e0', outline='#808080')
        
        # Draw screen content (blue desktop)
        logo_canvas.create_rectangle(65, 35, 85, 55, fill='#008080', outline='#008080')
        
        # Draw small window on screen
        logo_canvas.create_rectangle(68, 38, 80, 48, fill='#c0c0c0', outline='#808080')
        logo_canvas.create_rectangle(68, 38, 80, 42, fill='#000080', outline='#000080')
        
        # Draw keyboard (simple 3D)
        logo_canvas.create_rectangle(55, 78, 95, 88, fill='#f0f0f0', outline='#808080')
        logo_canvas.create_polygon(55, 78, 60, 73, 100, 73, 95, 78, fill='#ffffff', outline='#808080')
        logo_canvas.create_polygon(95, 78, 100, 73, 100, 83, 95, 88, fill='#e0e0e0', outline='#808080')
        
        # Draw some keys
        for x in range(4):
            for y in range(2):
                kx = 58 + x * 8
                ky = 80 + y * 3
                logo_canvas.create_rectangle(kx, ky, kx+5, ky+2, fill='#e8e8e8', outline='#c0c0c0')
        # Remove the line: installer.run()
    
    def show_validation_error(self, error_type):
        """Show Windows 95 style validation error dialog"""
        error_root = tk.Tk()
        error_root.title("Multiapp 95 Professional Setup")
        error_root.geometry("450x180")
        error_root.configure(bg='#c0c0c0')
        error_root.resizable(False, False)
        error_root.overrideredirect(True)
        
        # Center the error window
        error_root.update_idletasks()
        x = (error_root.winfo_screenwidth() // 2) - (450 // 2)
        y = (error_root.winfo_screenheight() // 2) - (180 // 2)
        error_root.geometry(f"450x200+{x}+{y}")
        
        # Main frame
        main_frame = tk.Frame(error_root, bg='#c0c0c0', relief='raised', bd=2)
        main_frame.pack(fill='both', expand=True, padx=2, pady=2)
        
        # Header
        header_frame = tk.Frame(main_frame, bg='#000080', height=30)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        title_label = tk.Label(header_frame, text="Multiapp 95 Professional Setup - Validation Error", bg='#000080', fg='white', 
                              font=('MS Sans Serif', 10, 'bold'))
        title_label.pack(anchor='w', padx=10, pady=5)
        
        # Content
        content_frame = tk.Frame(main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=15)
        
        # Error icon and message
        msg_frame = tk.Frame(content_frame, bg='#c0c0c0')
        msg_frame.pack(expand=True)
        
        # Error icon
        icon_label = tk.Label(msg_frame, text="X", bg='#c0c0c0', fg='red', 
                             font=('MS Sans Serif', 24))
        icon_label.pack(side='left', padx=(0, 15))
        
        # Error message based on type
        if error_type == "user":
            error_text = f"Invalid user name!\n\nThe entered user name does not match\nthe current system user: {self.actual_user}\n\nPlease enter the correct user name."
        else:  # computer
            error_text = f"Invalid computer name!\n\nThe entered computer name does not match\nthe current system name: {self.actual_computer}\n\nPlease enter the correct computer name."
        
        error_msg = tk.Label(msg_frame, text=error_text, 
                            bg='#c0c0c0', font=('MS Sans Serif', 9), justify='left')
        error_msg.pack(side='left')
        
        # Button
        button_frame = tk.Frame(main_frame, bg='#c0c0c0')
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
        
        ok_button = tk.Button(button_frame, text='OK', command=error_root.destroy,
                             width=10, height=1, font=('MS Sans Serif', 8))
        ok_button.pack(side='right', padx=5)
        
        # Bind ESC to close
        error_root.bind('<Escape>', lambda e: error_root.destroy())
        
        error_root.mainloop()
    
    def validate_and_continue_from_user_info(self):
        entered_user = self.user_name.get().strip()
        if entered_user != self.actual_user:
            self.show_validation_error("user")
            return
        self.show_computer_name()
        
    def validate_and_continue_from_computer_name(self):
        entered_computer = self.computer_name.get().strip()
        if entered_computer != self.actual_computer:
            self.show_validation_error("computer")
            return
        self.show_components()
    
    def toggle_fullscreen(self, event=None):
        """Toggle between fullscreen and windowed mode"""
        if self.is_fullscreen:
            # Exit fullscreen - restore to exact original state
            self.root9955.state('normal')  # First normalize the window
            self.root9955.geometry(self.normal_geometry)  # Restore size
            self.center_window()  # Center it
            self.is_fullscreen = False
        else:
            # Enter fullscreen - save current state and maximize without title bar
            self.normal_geometry = self.root9955.geometry()
            # Get screen dimensions
            screen_width = self.root9955.winfo_screenwidth()
            screen_height = self.root9955.winfo_screenheight()
            # Set to full screen size without title bar
            self.root9955.geometry(f"{screen_width}x{screen_height}+0+0")
            self.is_fullscreen = True
    
    def center_window(self):
        self.root9955.update_idletasks()
        x = (self.root9955.winfo_screenwidth() // 2) - (640 // 2)
        y = (self.root9955.winfo_screenheight() // 2) - (480 // 2)
        self.root9955.geometry(f"640x480+{x}+{y}")
    
    def clear_frame(self):
        for widget in self.main_frame.winfo_children():
            widget.destroy()
    
    def create_header(self, title, subtitle=""):
        header_frame = tk.Frame(self.main_frame, bg='#000080', height=60)
        header_frame.pack(fill='x', pady=(0, 10))
        header_frame.pack_propagate(False)
        
        title_label = tk.Label(header_frame, text=title, bg='#000080', fg='white', 
                              font=('MS Sans Serif', 14, 'bold'))
        title_label.pack(anchor='w', padx=10, pady=(8, 0))
        
        if subtitle:
            subtitle_label = tk.Label(header_frame, text=subtitle, bg='#000080', fg='white', 
                                    font=('MS Sans Serif', 8))
            subtitle_label.pack(anchor='w', padx=10)
    
    def create_buttons(self, buttons_config):
        button_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
        
        for btn_config in buttons_config:
            btn = tk.Button(button_frame, text=btn_config['text'], 
                           command=btn_config['command'],
                           width=10, height=1,
                           font=('MS Sans Serif', 8))
            btn.pack(side=btn_config.get('side', 'right'), padx=5)
    
    def show_welcome_screen(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional Setup", "Welcome to Setup")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=10)
        self.create_logo(content_frame)
        welcome_text = """Welcome to Multiapp 95 Professional Setup.

This Setup program will configure Multiapp 95 Professional on your computer.

• To continue configuring Multiapp 95 Professional, click Next.
• To learn more about Multiapp 95 Professional before continuing, read the after documentation.
• To quit Setup without configuring Multiapp 95 Professional, click Exit.
• Press ESC for full screen or press ESC again for original size."""
        
        text_label = tk.Label(content_frame, text=welcome_text, bg='#c0c0c0', 
                             font=('MS Sans Serif', 9), justify='left')
        text_label.pack(anchor='w')
        
        # Windows 95 logo simulation
        logo_frame = tk.Frame(content_frame, bg='#c0c0c0', width=200, height=100)
        logo_frame.pack(side='right', anchor='ne', padx=20, pady=20)
        logo_frame.pack_propagate(False)
        
        logo_label = tk.Label(logo_frame, text="Multiapp\n95\nProfessional", bg='#c0c0c0', 
                             font=('Arial', 18, 'bold'), fg='#000080')
        logo_label.pack(expand=True)
        
        self.create_buttons([
            {'text': 'Exit', 'command': self.EXITO, 'side': 'right'},
            {'text': 'Next >', 'command': self.show_license_agreement, 'side': 'right'}
        ])
    
    def show_license_agreement(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional", "Software License Agreement")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
        tk.Label(content_frame, text="Please read the following license agreement carefully:",
                bg='#c0c0c0', font=('MS Sans Serif', 9)).pack(anchor='w', pady=(0, 10))
        
        # Create text widget with scrollbar
        text_frame = tk.Frame(content_frame, bg='#c0c0c0')
        text_frame.pack(fill='both', expand=True)
        
        scrollbar = tk.Scrollbar(text_frame)
        scrollbar.pack(side='right', fill='y')
        
        license_text = tk.Text(text_frame, bg='white', fg='black', 
                              font=('MS Sans Serif', 8),
                              yscrollcommand=scrollbar.set, wrap='word')
        
        '''
        license_content = """MULTIAPP 95 PROFESSIONAL SETUP SOFTWARE LICENSE AGREEMENT

IMPORTANT - READ CAREFULLY: This Multiapp 95 Professional Setup End-User License Agreement ("EULA") is a legal agreement between you (either an individual or a single entity) and Retro Computin Division for the Multiapp 95 Professional Setup software product identified above, which includes computer software and may include associated media, printed materials, and "online" or electronic documentation ("SOFTWARE PRODUCT").

By installing, copying, or otherwise using the SOFTWARE PRODUCT, you agree to be bound by the terms of this EULA. If you do not agree to the terms of this EULA, do not install or use the SOFTWARE PRODUCT.

SOFTWARE PRODUCT LICENSE
The SOFTWARE PRODUCT is protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The SOFTWARE PRODUCT is licensed, not sold.

1. GRANT OF LICENSE. This EULA grants you the following rights:
   • Installation and Use. You may install and use one copy of the SOFTWARE PRODUCT on a single computer.
   • Backup Copy. You may also make one copy of the SOFTWARE PRODUCT for backup or archival purposes.

2. DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS.
   • Limitations on Reverse Engineering, Decompilation, and Disassembly. You may not reverse engineer, decompile, or disassemble the SOFTWARE PRODUCT.
   • Separation of Components. The SOFTWARE PRODUCT is licensed as a single product.
   • Rental. You may not rent, lease, or lend the SOFTWARE PRODUCT.
   • Support Services. Microsoft may provide you with support services related to the SOFTWARE PRODUCT.

3. COPYRIGHT. All title and intellectual property rights in and to the SOFTWARE PRODUCT are owned by Retro Computing Division."""
        '''
        license_content = """
Software License for Personal and IT Department Use
Title: Personal Use License for Multiapp.exe

Version: 0.95.0

Date: 20.05.2024

1. Introduction
    • This license sets forth the terms and conditions for the use of Multiapp.exe (hereinafter referred to as "the Software"), which is developed for exclusive personal use within the IT department of any company (hereinafter referred to as "the Company"). The Software shall not be distributed or used outside this department.

2. Definitions
    • Licensor: Tudor Marmureanu, the developer and copyright holder of the Software.
    • Licensee: An employee within the IT department of any Company who is permitted to use the Software in accordance with the terms of this license.
    • Personal Use: Use of the Software solely by the Licensee for activities related to job duties within the IT department of the Company.

3. License Agreement
    • The Licensor grants the Licensee a non-exclusive, non-transferable, and limited license to use the Software in accordance with the terms and conditions set forth in this document.

4. Rights and Restrictions
 4.1 Rights
 The Licensee has the right to:

    • Install and use the Software on a single device owned or controlled by the Company, used within the IT department.
    • Create backup copies of the Software solely for archiving and restoration purposes.
    • Use the Software's own license to activate specific functionalities, but only within the IT department.
 4.2 Restrictions
    • The Licensee is prohibited from:
    • Distributing, selling, sublicensing, renting, or otherwise transferring the Software or its license to any third party.
    • Modifying, decompiling, disassembling, or reverse engineering the Software, except as explicitly permitted by law.
    • Using the Software outside the IT department or for purposes other than those specified in this license.

5. Intellectual Property
    • The Software and all associated rights, including copyrights, patents, trade secrets, and other intellectual property rights, are and shall remain the exclusive property of the Licensor. The Licensee does not obtain any ownership rights to the Software.

6. Limitation of Liability
    • The Software is provided "as is" without any warranties, express or implied. Under no circumstances shall the Licensor be liable for any direct, indirect, incidental, special, or consequential damages resulting from the use or inability to use the Software.

7. Termination of the License
    • This license remains valid until terminated. The Licensor may terminate the license immediately if the Licensee fails to comply with any of the terms of this agreement. Upon termination, the Licensee must cease all use of the Software and destroy all copies.

8. Final Provisions
    • This license constitutes the entire agreement between the parties regarding the use of the Software and supersedes any prior or contemporaneous agreements, whether written or oral. Any modification to this license must be made in writing and signed by both parties.

By using the Software, the Licensee agrees to the terms and conditions of this license.

Tudor Marmureanu
20.05.2024
        """
        license_text.insert('1.0', license_content)
        license_text.config(state='disabled')
        license_text.pack(side='left', fill='both', expand=True)
        
        scrollbar.config(command=license_text.yview)
        
        # Agreement checkbox with all buttons
        agreement_frame = tk.Frame(content_frame, bg='#c0c0c0')
        agreement_frame.pack(fill='x', pady=10)
        
        # Left side - checkbox
        left_frame = tk.Frame(agreement_frame, bg='#c0c0c0')
        left_frame.pack(side='left', fill='x', expand=True)
        
        self.agree_var = tk.BooleanVar()
        agree_check = tk.Checkbutton(left_frame, text="I accept the license agreement", 
                                    variable=self.agree_var, bg='#c0c0c0',
                                    font=('MS Sans Serif', 9),
                                    command=self.toggle_next_button)
        agree_check.pack(anchor='w')
        
        # Right side - buttons
        button_frame = tk.Frame(agreement_frame, bg='#c0c0c0')
        button_frame.pack(side='right')
        
        # Create all buttons in the agreement frame
        self.next_button = tk.Button(button_frame, text='Next >', command=self.show_product_activation,
                                   width=10, height=1, state='disabled',
                                   font=('MS Sans Serif', 8))
        self.next_button.pack(side='right', padx=2)
        
        tk.Button(button_frame, text='Exit', command=self.EXITO,
                 width=10, height=1, font=('MS Sans Serif', 8)).pack(side='right', padx=2)
        
        tk.Button(button_frame, text='< Back', command=self.show_welcome_screen,
                 width=10, height=1, font=('MS Sans Serif', 8)).pack(side='right', padx=2)
    
    def toggle_next_button(self):
        if hasattr(self, 'next_button'):
            if self.agree_var.get():
                self.next_button.config(state='normal')
            else:
                self.next_button.config(state='disabled')
    
    def show_user_info(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional", "User Information")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        self.create_logo(content_frame)
        tk.Label(content_frame, text="Type your name and your company name below:",
                bg='#c0c0c0', font=('MS Sans Serif', 9)).pack(anchor='w', pady=(0, 20))
        
        # Name entry
        name_frame = tk.Frame(content_frame, bg='#c0c0c0')
        name_frame.pack(fill='x', pady=5)
        tk.Label(name_frame, text="Name:", bg='#c0c0c0', 
                font=('MS Sans Serif', 9), width=15).pack(side='left')
        tk.Entry(name_frame, textvariable=self.user_name, 
                font=('MS Sans Serif', 9), width=30).pack(side='left', padx=10)
        
        # Company entry
        company_frame = tk.Frame(content_frame, bg='#c0c0c0')
        company_frame.pack(fill='x', pady=5)
        self.company_name = tk.StringVar(value="")
        tk.Label(company_frame, text="Company:", bg='#c0c0c0', 
                font=('MS Sans Serif', 9), width=15).pack(side='left')
        tk.Entry(company_frame, textvariable=self.company_name, 
                font=('MS Sans Serif', 9), width=30).pack(side='left', padx=10)
        
        self.create_buttons([
            {'text': '< Back', 'command': self.show_product_activation, 'side': 'right'},
            {'text': 'Next >', 'command': self.validate_and_continue_from_user_info, 'side': 'right'},
            {'text': 'Exit', 'command': self.EXITO, 'side': 'right'}
        ])
    
    def create_key_logo(self, parent_frame):
        """Create a pixelated yellow key logo"""
        logo_canvas = tk.Canvas(parent_frame, width=120, height=100, bg='#c0c0c0', 
                               highlightthickness=0)
        logo_canvas.pack(side='right', anchor='ne', padx=(0, 20), pady=10)
        
        # Pixel colors
        key_yellow = '#FFD700'  # Golden yellow
        key_dark = '#B8860B'    # Dark goldenrod
        key_light = '#FFFF00'   # Bright yellow
        key_shadow = '#8B6914'  # Darker shadow
        
        # Pixel size
        pixel_size = 4
        
        # Key head - pixelated circle shape
        # This is a 2D array representing our pixel art
        # 0 = empty, 1 = shadow, 2 = dark, 3 = main color, 4 = highlight
        key_head = [
            [0, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0],
            [0, 0, 2, 2, 3, 3, 3, 2, 2, 0, 0],
            [0, 2, 2, 3, 3, 3, 3, 3, 2, 2, 0],
            [1, 2, 3, 3, 2, 2, 2, 3, 3, 2, 1],
            [2, 3, 3, 2, 0, 0, 0, 2, 3, 3, 2],
            [2, 3, 3, 2, 0, 0, 0, 2, 3, 3, 2],
            [2, 3, 3, 2, 0, 0, 0, 2, 3, 3, 2],
            [1, 2, 3, 3, 2, 2, 2, 3, 3, 2, 1],
            [0, 2, 2, 3, 3, 3, 3, 3, 2, 2, 0],
            [0, 0, 2, 2, 3, 3, 3, 2, 2, 0, 0],
            [0, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0]
        ]
        
        # Key shaft and teeth - pixelated rectangle shape
        key_shaft = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 4, 4, 0, 0],
            [0, 0, 0, 4, 4, 4, 4, 4, 3, 2, 2, 3, 4, 4, 0],
            [0, 0, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2],
            [0, 0, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2],
            [0, 0, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2],
            [0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
        
        # Draw the key head pixels
        for y, row in enumerate(key_head):
            for x, pixel in enumerate(row):
                if pixel != 0:  # If not empty
                    color = key_shadow if pixel == 1 else key_dark if pixel == 2 else key_yellow if pixel == 3 else key_light
                    logo_canvas.create_rectangle(
                        20 + x * pixel_size, 
                        30 + y * pixel_size, 
                        20 + (x+1) * pixel_size, 
                        30 + (y+1) * pixel_size, 
                        fill=color, outline=''
                    )
        
        # Draw the key shaft pixels
        for y, row in enumerate(key_shaft):
            for x, pixel in enumerate(row):
                if pixel != 0:  # If not empty
                    color = key_shadow if pixel == 1 else key_dark if pixel == 2 else key_yellow if pixel == 3 else key_light
                    logo_canvas.create_rectangle(
                        46 + x * pixel_size, 
                        34 + y * pixel_size, 
                        46 + (x+1) * pixel_size, 
                        34 + (y+1) * pixel_size, 
                        fill=color, outline=''
                    )
        
        # Draw "95" text in a pixelated style
        # "9" pixelated
        nine_pixels = [
            [0, 1, 1, 0],
            [1, 0, 0, 1],
            [1, 0, 0, 1],
            [0, 1, 1, 1],
            [0, 0, 0, 1],
            [1, 0, 0, 1],
            [0, 1, 1, 0]
        ]
        
        # "5" pixelated
        five_pixels = [
            [1, 1, 1, 1],
            [1, 0, 0, 0],
            [1, 1, 1, 0],
            [0, 0, 0, 1],
            [0, 0, 0, 1],
            [1, 0, 0, 1],
            [0, 1, 1, 0]
        ]
        
        # Draw pixelated "9"
        for y, row in enumerate(nine_pixels):
            for x, pixel in enumerate(row):
                if pixel == 1:
                    logo_canvas.create_rectangle(
                        32 + x * 2, 
                        42 + y * 2, 
                        32 + (x+1) * 2, 
                        42 + (y+1) * 2, 
                        fill='#800000', outline=''
                    )
        
        # Draw pixelated "5"
        for y, row in enumerate(five_pixels):
            for x, pixel in enumerate(row):
                if pixel == 1:
                    logo_canvas.create_rectangle(
                        41 + x * 2, 
                        42 + y * 2, 
                        41 + (x+1) * 2, 
                        42 + (y+1) * 2, 
                        fill='#800000', outline=''
                    )
        
        # Add pixelated "Product Key" text
        logo_canvas.create_text(65, 75, text="Product Key", fill='#000080', 
                              font=('MS Sans Serif', 8, 'bold'))
        
        return logo_canvas
    
    '''
    def create_key_logo(self, parent_frame):
        """Create a simple yellow key logo"""
        logo_canvas = tk.Canvas(parent_frame, width=120, height=100, bg='#c0c0c0', 
                               highlightthickness=0)
        logo_canvas.pack(side='right', anchor='ne', padx=(0, 20), pady=10)
        
        # Yellow key colors
        key_yellow = '#FFD700'  # Golden yellow
        key_darker = '#DAA520'  # Goldenrod (darker yellow)
        key_highlight = '#FFFF00'  # Bright yellow for highlights
        key_shadow = '#B8860B'  # Dark goldenrod for shadows
        
        # Key dimensions
        key_x = 60  # Center x position
        key_y = 50  # Center y position
        
        # Draw key head (circle with 3D effect)
        logo_canvas.create_oval(30, 35, 60, 65, fill=key_yellow, outline=key_darker, width=1)
        
        # Add 3D effect to key head
        # Highlight on top-left
        logo_canvas.create_arc(31, 36, 59, 64, start=120, extent=120,
                             style='arc', outline=key_highlight, width=2)
        # Shadow on bottom-right
        logo_canvas.create_arc(31, 36, 59, 64, start=300, extent=120,
                             style='arc', outline=key_shadow, width=2)
        
        # Key hole
        logo_canvas.create_oval(40, 45, 50, 55, fill='#A0A0A0', outline=key_darker)
        # Add depth to key hole
        logo_canvas.create_arc(41, 46, 49, 54, start=45, extent=180,
                             style='arc', outline='#707070', width=1)
        
        # Key shaft
        logo_canvas.create_rectangle(60, 45, 100, 55, fill=key_yellow, outline=key_darker, width=1)
        
        # Add 3D effect to key shaft
        # Top highlight
        logo_canvas.create_line(60, 45, 100, 45, fill=key_highlight, width=1)
        # Bottom shadow
        logo_canvas.create_line(60, 55, 100, 55, fill=key_shadow, width=1)
        
        # Key teeth
        # First tooth
        logo_canvas.create_rectangle(75, 45, 80, 40, fill=key_yellow, outline=key_darker, width=1)
        logo_canvas.create_line(75, 40, 80, 40, fill=key_highlight, width=1)  # Top highlight
        logo_canvas.create_line(80, 40, 80, 45, fill=key_shadow, width=1)  # Right shadow
        
        # Second tooth
        logo_canvas.create_rectangle(85, 45, 90, 38, fill=key_yellow, outline=key_darker, width=1)
        logo_canvas.create_line(85, 38, 90, 38, fill=key_highlight, width=1)  # Top highlight
        logo_canvas.create_line(90, 38, 90, 45, fill=key_shadow, width=1)  # Right shadow
        
        # Third tooth
        logo_canvas.create_rectangle(95, 45, 100, 42, fill=key_yellow, outline=key_darker, width=1)
        logo_canvas.create_line(95, 42, 100, 42, fill=key_highlight, width=1)  # Top highlight
        logo_canvas.create_line(100, 42, 100, 45, fill=key_shadow, width=1)  # Right shadow
        
        # Add "95" text to the key head
        logo_canvas.create_text(45, 50, text="95", fill='#800000', 
                               font=('MS Sans Serif', 9, 'bold'))
        
        # Add a shine/glint effect
        logo_canvas.create_oval(33, 40, 36, 43, fill='white', outline='')
        
        # Add "Product Key" text below
        logo_canvas.create_text(65, 75, text="Product Key", fill='#000080', 
                               font=('MS Sans Serif', 8, 'bold'))
        
        return logo_canvas
    '''
    
    def show_computer_name(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional", "Computer Name")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        self.create_logo(content_frame)
        tk.Label(content_frame, text="Enter a computer name and workgroup name:",
                bg='#c0c0c0', font=('MS Sans Serif', 9)).pack(anchor='w', pady=(0, 20))
        
        # Computer name
        comp_frame = tk.Frame(content_frame, bg='#c0c0c0')
        comp_frame.pack(fill='x', pady=5)
        tk.Label(comp_frame, text="Computer name:", bg='#c0c0c0', 
                font=('MS Sans Serif', 9), width=15).pack(side='left')
        tk.Entry(comp_frame, textvariable=self.computer_name, 
                font=('MS Sans Serif', 9), width=30).pack(side='left', padx=10)
        
        # Workgroup
        work_frame = tk.Frame(content_frame, bg='#c0c0c0')
        work_frame.pack(fill='x', pady=5)
        tk.Label(work_frame, text="Workgroup:", bg='#c0c0c0', 
                font=('MS Sans Serif', 9), width=15).pack(side='left')
        tk.Entry(work_frame, textvariable=self.workgroup, 
                font=('MS Sans Serif', 9), width=30).pack(side='left', padx=10)
        
        tk.Label(content_frame, text="\nDescription:", bg='#c0c0c0', 
                font=('MS Sans Serif', 9)).pack(anchor='w', pady=(20, 5))
        tk.Text(content_frame, height=3, width=50, font=('MS Sans Serif', 9)).pack(anchor='w')
        
        self.create_buttons([
            {'text': '< Back', 'command': self.show_user_info, 'side': 'right'},
            {'text': 'Next >', 'command': self.validate_and_continue_from_computer_name, 'side': 'right'},
            {'text': 'Exit', 'command': self.EXITO, 'side': 'right'}
        ])
    
    def show_components(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional Setup", "Select Components")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=10)
        self.create_logo(content_frame)
        tk.Label(content_frame, text="Select the components you want to configure\n(all are pre-installed, informative details are provided regarding the allocation space that is already allocated):",
                bg='#c0c0c0', font=('MS Sans Serif', 9)).pack(anchor='w', pady=(0, 10))
        
        # Components list
        components_frame = tk.Frame(content_frame, bg='white', relief='sunken', bd=2)
        components_frame.pack(fill='both', expand=True, pady=5)
        
        components = [
            ("Shell", True, "6.2 MB"),
            ("Port Communications", True, "3.1 MB"),
            ("Disk Tools", True, "1.8 MB"),
            ("inst95 file format", True, "4.5 MB"),
            ("XFC", False, "2.3 MB"),
            ("Dev Arguments", False, "8.7 MB"),
            ("Local Server", False, "1.2 MB")
        ]
        
        self.component_vars = {}
        for comp, default, size in components:
            comp_frame = tk.Frame(components_frame, bg='white')
            comp_frame.pack(fill='x', padx=5, pady=2)
            
            var = tk.BooleanVar(value=default)
            self.component_vars[comp] = var
            
            tk.Checkbutton(comp_frame, text=comp, variable=var, bg='white',
                          font=('MS Sans Serif', 8)).pack(side='left')
            tk.Label(comp_frame, text=size, bg='white', fg='blue',
                    font=('MS Sans Serif', 8)).pack(side='right')
        
        # Space info
        space_frame = tk.Frame(content_frame, bg='#c0c0c0')
        space_frame.pack(fill='x', pady=10)
        tk.Label(space_frame, text="Minimum space: 200 MB", bg='#c0c0c0',
                font=('MS Sans Serif', 8)).pack(side='left')
        tk.Label(space_frame, text="Preset space: 512 MB", bg='#c0c0c0',
                font=('MS Sans Serif', 8)).pack(side='right')
        
        self.create_buttons([
            {'text': '< Back', 'command': self.show_computer_name, 'side': 'right'},
            {'text': 'Next >', 'command': self.show_startup_disk, 'side': 'right'},
            {'text': 'Exit', 'command': self.EXITO, 'side': 'right'}
        ])
    
    def show_startup_disk(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional Setup", "Startup Disk Configuration")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        self.create_logo(content_frame)
        tk.Label(content_frame, text="Setup can create a Startup Disk Configuration for you. You should create a Startup Disk or USB\nin case you have problems starting Multiapp 95 Professional from your hard disk.",
                bg='#c0c0c0', font=('MS Sans Serif', 9), justify='left').pack(anchor='w', pady=(0, 20))
        
        self.startup_disk_var = tk.StringVar(value="yes")
        tk.Radiobutton(content_frame, text="Yes, I want a USB Boot Configuration (Recommended)", 
                      variable=self.startup_disk_var, value="yes", bg='#c0c0c0',
                      font=('MS Sans Serif', 9)).pack(anchor='w', pady=5)
        tk.Radiobutton(content_frame, text="No, I do not want a USB Boot Configuration", 
                      variable=self.startup_disk_var, value="no", bg='#c0c0c0',
                      font=('MS Sans Serif', 9)).pack(anchor='w', pady=5)
        
        tk.Label(content_frame, text="\nTo create a Startup Disk Configuration, copy the files from Multiapp directory\non USB or another disk after this Setup was closed.\nThere is a chance that running Multiapp directly from a separate medium,\nsuch as a USB stick, may not be feasible.",
                bg='#c0c0c0', font=('MS Sans Serif', 8), fg='#808080').pack(anchor='w', pady=(20, 0))
        
        self.create_buttons([
            {'text': '< Back', 'command': self.show_components, 'side': 'right'},
            {'text': 'Next >', 'command': self.start_copying_files, 'side': 'right'},
            {'text': 'Exit', 'command': self.root9955.destroy, 'side': 'right'}
        ])
    
    def start_copying_files(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional Setup", "Making edits...")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        tk.Label(content_frame, text="Please wait while Setup makes final edits to your allocated space on disk.",
                bg='#c0c0c0', font=('MS Sans Serif', 9)).pack(anchor='w', pady=(0, 20))
        
        # Progress bar
        progress_frame = tk.Frame(content_frame, bg='#c0c0c0')
        progress_frame.pack(fill='x', pady=10)
        
        self.progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=400)
        self.progress_bar.pack()
        
        # Current file label
        self.current_file_label = tk.Label(content_frame, text="Configuring: SYSTEM.DAT", 
                                          bg='#c0c0c0', font=('MS Sans Serif', 8))
        self.current_file_label.pack(pady=(10, 0))
        
        # Estimated time
        self.time_label = tk.Label(content_frame, text="Estimated time remaining: 5 seconds", 
                                  bg='#c0c0c0', font=('MS Sans Serif', 8))
        self.time_label.pack(pady=5)
        
        # Start copying simulation
        self.simulate_file_copying()
        
        # Only show exit button during copying
        button_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
        tk.Button(button_frame, text='Cancel', command=self.EXITO,
                 width=10, height=1, font=('MS Sans Serif', 8)).pack(side='right', padx=5)
    
    def simulate_file_copying(self):
        files = [
            "0x4F9A2C7E", "0xB17E53D1", "0xC0FFEE42", "0xDEADBEEF", "0x9AC3F712",
            "0x1234ABCD", "0xF00DBABE", "0x7E4A91F3", "0xA1B2C3D4", "0x5F9D3E2A",
            "0xCAFEBABE", "0x8D42F6B1", "0xE3F7A91C", "0x0BADF00D", "0x4A9E7C12",
            "0xFACEB00C", "0xBEEFBEEF", "0x9F3C7A2B", "0xD4E5F6A7", "0x1BADC0DE",
            "0x6A7F2E91", "0x0C0FFEE0", "0xAB12EF34", "0x8E7D6C5B", "0xFEEDBEEF"
        ]
        
        def copy_file(index=0):
            if index < len(files):
                progress = (index + 1) / len(files) * 100
                self.progress_bar['value'] = progress
                
                self.current_file_label.config(text=f"Configuring: {files[index]}")
                
                remaining_time = max(0, (len(files) - index - 1) * 0.2)
                if remaining_time > 1:
                    self.time_label.config(text=f"Estimated time remaining: {int(remaining_time)} seconds")
                else:
                    self.time_label.config(text="Almost finished...")
                
                self.root9955.after(200, lambda: copy_file(index + 1))
            else:
                self.show_restart_screen()
        
        copy_file()
    
    def show_restart_screen(self):
        self.clear_frame()
        self.create_header("Multiapp 95 Professional Setup", "Setup Complete")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        self.create_logo(content_frame)
        success_text = """Congratulations! Multiapp 95 Professional has been successfully configured on your computer.

Setup has finished configuring files and making the necessary configuration to your system.

Click Finish to use Multiapp 95 Professional on your computer."""
        
        tk.Label(content_frame, text=success_text, bg='#c0c0c0', 
                font=('MS Sans Serif', 9), justify='left').pack(expand=True)
        
        # Create finish button
        button_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        button_frame.pack(side='bottom', fill='x', padx=10, pady=10)
        tk.Button(button_frame, text='Finish', command=self.simulate_restart,
                 width=10, height=1, font=('MS Sans Serif', 8, 'bold')).pack(side='right', padx=5)
    
    def simulate_restart(self):
        self.clear_frame()
        
        # Black screen with restart message
        restart_frame = tk.Frame(self.main_frame, bg='black')
        restart_frame.pack(fill='both', expand=True)
        
        tk.Label(restart_frame, text="Restarting services...", bg='black', fg='white',
                font=('MS Sans Serif', 12)).pack(expand=True)
        
        # After 2 seconds, show Windows 95 boot screen
        self.root9955.after(2000, self.show_boot_screen)
    
    def show_boot_screen(self):
        self.clear_frame()
        
        # Windows 95 boot screen
        boot_frame = tk.Frame(self.main_frame, bg='#008080')  # Teal background
        boot_frame.pack(fill='both', expand=True)
        
        # Windows 95 logo
        logo_frame = tk.Frame(boot_frame, bg='#008080')
        logo_frame.pack(expand=True)
        
        tk.Label(logo_frame, text="Multiapp 95", bg='#008080', fg='white',
                font=('Arial', 24, 'bold')).pack(pady=(50, 0))
        tk.Label(logo_frame, text="Professional", bg='#008080', fg='white',
                font=('Arial', 32, 'bold')).pack()
        
        tk.Label(logo_frame, text="Starting Multiapp 95 Professional...", bg='#008080', fg='white',
                font=('MS Sans Serif', 10)).pack(pady=(30, 0))
        
        # After 3 seconds, show welcome message and write completion flag
        self.root9955.after(3000, self.show_welcome_to_windows)
    
    def show_welcome_to_windows(self):
        self.clear_frame()
        self.create_header("Welcome to Multiapp 95 Professional!", "Setup is now complete")
        
        content_frame = tk.Frame(self.main_frame, bg='#c0c0c0')
        content_frame.pack(fill='both', expand=True, padx=20, pady=10)
        self.create_logo(content_frame)
        
        # Create a frame for the text with a scrollbar
        text_frame = tk.Frame(content_frame, bg='#c0c0c0')
        text_frame.pack(fill='both', expand=True, pady=5)
        
        # Create a more compact welcome text
        welcome_text = f"""Welcome to Multiapp 95 Professional, {self.user_name.get()}!

    Your software is now ready to use. This Setup will close as soon as you click Close Setup.

    Virtual Instance:
    • Run programs/Shutdown to close Virtual Instance
    • Activate product
    • Check system compatibilities
    • Switch between programs with taskbar

    Settings:
    • User: {self.user_name.get()}
    • Computer: {self.computer_name.get()}
    • Workgroup: {self.workgroup.get()}
    • Hash: ##/##
    • Product ID: 000020250420

    Enjoy using Multiapp 95 Professional!"""
        
        # Use a Text widget instead of Label for better control over display
        text_widget = tk.Text(text_frame, bg='#c0c0c0', 
                            font=('MS Sans Serif', 8), 
                            wrap=tk.WORD, 
                            height=12,
                            width=50,
                            relief='flat',
                            borderwidth=0,
                            highlightthickness=0)
        text_widget.pack(fill='both', expand=True)
        text_widget.insert('1.0', welcome_text)
        text_widget.config(state='disabled')  # Make it read-only
        
        self.create_buttons([
            {'text': 'Close Setup', 'command': self.close_and_complete, 'side': 'right'}
        ])
    
    def close_and_complete(self):
        """Close setup and write completion flag"""
        write_completion_flag()
        self.root9955.destroy()
    
    def run(self):
        self.root9955.mainloop()

if __name__ == "__main__":
    # Check database before running installer
    if check_database():
        installer = Windows95Installer()
        installer.run()
#from tkinter.ttk import *
def startup_services():
    #import tkinter as tk
    #import time
    #import random
    #import os
    
    def update_progress_bar(current_step, total_steps):
        # Calculează progresul ca procent
        progress = int((current_step / total_steps) * 20)  # 20 de caractere pentru bara
        
        # Creează bara de progres cu caractere █ pentru progres și spații pentru restul
        bar = "█" * progress + " " * (20 - progress)
        progress_text = f"[{bar}] {int((current_step / total_steps) * 100)}%"
        
        progress_bar.config(text=progress_text)
        root_srv.update()
    
    def update_boot_messages():
        current_path = os.getcwd()
        messages = [
            f"{current_path}>Multiapp.exe\n",
            "Boot Manager starting...",
            "Configure enviroment... done.",
            "Starting Multiapp Services...",
            "REG-ED Version 7.0",
            "Virtual instance is testing RAM Memory... done.",
            "Loading Multiapp drivers...",
            "Checking file system...",
            "Initializing hardware...",
            "Scanning for disk errors... No errors found.",
            "Configuring network settings...",
            "Loading graphical interface...",
            "Applying system policies...",
            "Finalizing startup...",
            "Multiapp is now starting...\n\n",
            "Welcome to Multiapp Professional! \u00A9 2024 Tudor Marmureanu"
        ]
        
        total_messages = len(messages)
        
        for i, msg in enumerate(messages):
            # Actualizează bara de progres
            update_progress_bar(i + 1, total_messages)
            
            # Actualizează mesajul
            boot_label.config(text=boot_label.cget("text") + "\n" + msg + "_")
            root_srv.update()
            time.sleep(random.uniform(0.2, 3.5))  # Simulează timpul de boot cu intervale aleatorii
            boot_label.config(text=boot_label.cget("text").rstrip("_"))
        
        progress_bar.pack_forget()  # Ascunde bara de progres la final
        root_srv.after(2000, root_srv.destroy)  # Închide fereastra după un scurt delay
    
    # Configurare fereastră principală
    root_srv = tk.Tk()
    root_srv.title("Multiapp 95 Professional Boot")
    root_srv.geometry("850x650")
    root_srv.configure(bg="black")
    root_srv.resizable(False, False)
    root_srv.overrideredirect(True)
    
    # Fă fereastra mereu deasupra altora
    root_srv.attributes("-topmost", True)
    
    # Obține dimensiunile ecranului
    screen_width = root_srv.winfo_screenwidth()
    screen_height = root_srv.winfo_screenheight()
    # Calculează poziția pentru a centra fereastra
    x_position = (screen_width - 850) // 2
    y_position = (screen_height - 650) // 2
    # Aplică poziția calculată
    root_srv.geometry(f"850x650+{x_position}+{y_position}")
    
    # Eticheta pentru mesaje
    boot_label = tk.Label(root_srv, text="", fg="white", bg="black", font=("Fixedsys",12), justify="left", anchor="nw")
    boot_label.pack(padx=20, pady=20, anchor="w")
    
    # Bara de progres ASCII (inițial goală)
    progress_bar = tk.Label(root_srv, text="[                    ] 0%", fg="white", bg="black", font=("Fixedsys",12))
    progress_bar.pack()
    
    # Start automat al bootării
    root_srv.after(1000, update_boot_messages)
    root_srv.mainloop()
    
#startup_services()
# Verificare și creare folder/fișier config
if not os.path.exists("Config"):
    os.makedirs("Config")

if not os.path.exists("Config/config.xml"):
    with open("Config/config.xml", "w") as f:
        f.write('<?xml version="1.0" encoding="UTF-8"?>\n<configuration>\n    <checker_instance>True</checker_instance>\n\n</configuration>')

# Citire valoare din config.xml
tree = ET.parse("Config/config.xml")
root = tree.getroot()
checker_instance = root.find('checker_instance').text == 'True'

# Verificare parametru și rulare funcție
if checker_instance:
    startup_services()

#import tkinter as tk
#from tkinter import messagebox, filedialog
#import time
#import platform
#import psutil
#import os

'''
def check_and_create_counter():
    # Verifică dacă fișierul counter.txt există
    if not os.path.exists('counter.txt'):
        # Dacă nu există, îl creăm și scriem 1 în el
        with open('counter.txt', 'w') as file:
            file.write('1')
        return True  # Funcția trebuie să ruleze
    else:
        # Dacă fișierul există și conține 1, nu mai rulăm funcția
        with open('counter.txt', 'r') as file:
            if file.read().strip() == '1':
                return False  # Nu mai rulăm funcția
        return True
'''
def check_and_create_counter():
    # Asigură-te că folderul Config există
    if not os.path.exists('Config'):
        os.makedirs('Config')
    
    counter_path = os.path.join('Config', 'mark.inst95')
    
    # Verifică dacă fișierul counter.txt există în Config
    if not os.path.exists(counter_path):
        # Dacă nu există, îl creăm și scriem 1 în el
        with open(counter_path, 'w') as file:
            file.write('1')
        return True  # Funcția trebuie să ruleze
    else:
        # Dacă fișierul există și conține 1, nu mai rulăm funcția
        with open(counter_path, 'r') as file:
            if file.read().strip() == '1':
                return False  # Nu mai rulăm funcția
        return True

def run_instance_checker():
    # Verifică dacă trebuie să ruleze funcția
    if not check_and_create_counter():
        #print("Funcția a fost deja rulată o dată. Nu se va mai executa.")
        return
    class Windows95Simulator:
        def __init__(self, root_inst):
            self.root_inst = root_inst
            self.root_inst.title("Virtual Instance Checker")
            self.root_inst.geometry("1024x768")
            self.root_inst.configure(bg='#008080')
            self.is_fullscreen = False  # Variabilă pentru a urmări starea fullscreen
            
            # Obținem dimensiunile ecranului
            screen_width = self.root_inst.winfo_screenwidth()
            screen_height = self.root_inst.winfo_screenheight()
            
            # Dimensiunile ferestrei
            window_width = 1024
            window_height = 768
            
            # Calculăm poziția pentru centrul ecranului
            position_top = int((screen_height / 2) - (window_height / 2))
            position_right = int((screen_width / 2) - (window_width / 2))
            
            # Setăm geometria ferestrei (dimensiuni și poziție)
            self.root_inst.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')
            
            # Background image (desktop wallpaper)
            self.desktop_bg = tk.Label(self.root_inst, bg='#008080', width=1024, height=768)
            self.desktop_bg.place(x=0, y=0)  # Plasare pe fundal
            
            # Taskbar
            self.taskbar = tk.Frame(self.root_inst, bg='gray', height=30)
            self.taskbar.pack(side='bottom', fill='x')
            
            # Start button
            self.start_button = tk.Button(self.taskbar, text='Start', width=10, height=2, bg='#8c8c8c', fg='white', font=("Fixedsys"), command=self.toggle_start_menu)
            self.start_button.pack(side='left')
            
            # Clock
            self.clock_label = tk.Label(self.taskbar, bg='gray', fg='white', font=("Fixedsys"))
            self.clock_label.pack(side='right', padx=10)
            self.update_clock()
            
            # Start menu
            self.start_menu = tk.Frame(self.root_inst, bg='lightgray', width=200, height=300)
            self.start_menu.place(x=0, y=728, anchor='sw')
            self.start_menu_visible = False
            
            # Meniu Start cu submeniuri
            self.apps_frame = tk.Frame(self.start_menu, bg='lightgray')
            self.apps_frame.pack(fill='both', expand=True)
            
            self.create_start_menu()
            
            self.start_menu.lower()
            
            # Taskbar running apps
            self.running_apps = {}
            
        def create_activation_window(self, window):
            window.title("Activation Wizard")  # Titlul ferestrei
            window.geometry("400x200")
            window.configure(bg="#c9c9c9")
            # Mesaj
            label = tk.Label(window, text="Enter your product key:", font=("Fixedsys"), bg="#c9c9c9")
            label.pack(pady=10)
            # Câmp de introducere a cheii
            product_key_entry = tk.Entry(window, font=("Fixedsys"), width=30, bd=5)
            product_key_entry.pack(pady=5)
            # Butonul de activare (inițial dezactivat)
            activate_button = tk.Button(
                window, text="Activate", font=("Fixedsys"), state=tk.DISABLED, bd=5, bg="#c9c9c9", 
                command=lambda: activate_product()
            )
            activate_button.pack(pady=5)
            # Butonul "Activate later" -> elimină aplicația din taskbar
            later_button = tk.Button(
                window, text="Activate later", font=("Fixedsys"), bd=5, bg="#c9c9c9", 
                command=lambda: self.close_app("Product Activation", window)
            )
            later_button.pack(pady=5)
            # Funcție pentru activare
            def activate_product():
                product_key = product_key_entry.get()
                valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
                FOLDER_NAME = "Serial"
                FILE_NAME = "product_key.lic95"
                
                if not os.path.exists(FOLDER_NAME):
                    try:
                        os.makedirs(FOLDER_NAME)
                    except:
                        pass
                        
                if product_key == valid_key:
                    file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                    # Verificăm dacă fișierul există deja
                    if not os.path.exists(file_path):
                        with open(file_path, "w") as file:
                            file.write(valid_key)
                    messagebox.showinfo("Activation Successful", "Product has been activated successfully.")
                    self.close_app("Product Activation", window)  # Închide corect aplicația
                else:
                    messagebox.showerror("Activation Failed", "Invalid product key. Please try again.")
                    
            # Funcție pentru validarea cheii în timp real
            def validate_key(event):
                if product_key_entry.get() == "R46BX-JHR2J-PG7ER-24QFG-MWKVR":
                    activate_button.config(state=tk.NORMAL)  # Activează butonul dacă cheia este corectă
                else:
                    activate_button.config(state=tk.DISABLED)  # Dezactivează butonul dacă cheia e greșită
            product_key_entry.bind("<KeyRelease>", validate_key)  # Verifică validitatea în timp real

        def activate_product(self, product_key, window):            
            FOLDER_NAME = "Serial"
            FILE_NAME = "product_key.lic95"
            
            if not os.path.exists(FOLDER_NAME):
                try:
                    os.makedirs(FOLDER_NAME)
                except:
                    pass
                    
            file_path = os.path.join(FOLDER_NAME, FILE_NAME)
            valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
            
            # Verifică dacă fișierul există deja
            try:
                with open(file_path, "r") as file:
                    existing_key = file.read().strip()
                    if existing_key == valid_key:
                        messagebox.showinfo("Activation", "Product is already activated!")
                        window.destroy()
                        return
            except FileNotFoundError:
                pass  # Fișierul nu există, deci putem continua activarea
            
            # Salvează cheia de produs
            with open(file_path, "w") as file:
                file.write(valid_key)
            
            messagebox.showinfo("Activation", "Product activated successfully!")
            window.destroy()

        def shutdown(self):
            self.root_inst.destroy()  # Închide aplicația
        
        def create_start_menu(self):
            self.activation_button = tk.Button(self.apps_frame, text='Product Activation', font=("Fixedsys"), command=lambda: self.open_app("Product Activation"))
            self.activation_button.pack(fill='x')
            
            self.notepad_button = tk.Button(self.apps_frame, text='Notepad', font=("Fixedsys"), command=lambda: self.open_app("Notepad"))
            self.notepad_button.pack(fill='x')
            
            self.about_button = tk.Button(self.apps_frame, text='About Window', font=("Fixedsys"), command=lambda: self.open_app("About Window"))
            self.about_button.pack(fill='x')
            
            # Butonul Fullscreen în meniul Start
            self.fullscreen_button = tk.Button(self.apps_frame, text='Fullscreen', font=("Fixedsys"), command=self.toggle_fullscreen)
            self.fullscreen_button.pack(fill='x')
            
            # Buton de Shutdown
            self.shutdown_button = tk.Button(self.apps_frame, text='Shutdown', font=("Fixedsys"), command=self.shutdown)
            self.shutdown_button.pack(fill='x')
        
        def toggle_start_menu(self):
            if self.start_menu_visible:
                self.start_menu.lower()
            else:
                self.start_menu.lift()
            self.start_menu_visible = not self.start_menu_visible
        
        def open_app(self, app_name):
            if app_name in self.running_apps:
                return
            
            window = tk.Toplevel(self.root_inst)
            window.title(app_name)
            window.geometry("600x400")
            window.protocol("WM_DELETE_WINDOW", lambda: self.close_app(app_name, window))
            
            if app_name == "Notepad":
                self.create_notepad(window)
            elif app_name == "About Window":
                self.create_about_window(window)
                
            elif app_name == "Product Activation":
                self.create_activation_window(window)
            
            taskbar_button = tk.Button(self.taskbar, text=app_name, font=("Fixedsys"), command=lambda: self.toggle_app_visibility(app_name, window), bg='darkgray', fg='white', height=2)
            taskbar_button.pack(side='left')
            
            self.running_apps[app_name] = {'window': window, 'button': taskbar_button}
            
            self.start_menu.lower()
            self.start_menu_visible = False
        
        def close_app(self, app_name, window):
            window.destroy()
            self.running_apps[app_name]['button'].destroy()
            del self.running_apps[app_name]
        
        def toggle_app_visibility(self, app_name, window):
            if window.state() == "normal":
                window.withdraw()
            else:
                window.deiconify()
        
        def update_clock(self):
            current_time = time.strftime('%H:%M:%S')
            self.clock_label.config(text=current_time, font=("Fixedsys"))
            self.root_inst.after(1000, self.update_clock)
        
        def toggle_fullscreen(self):
            self.is_fullscreen = not self.is_fullscreen
            if self.is_fullscreen:
                self.root_inst.attributes('-fullscreen', True)
            else:
                self.root_inst.attributes('-fullscreen', False)
        
        def create_notepad(self, window):
            text_area = tk.Text(window, font=("Fixedsys"))
            text_area.pack(fill='both', expand=True)
            
            # Adăugăm un tag pentru culoarea gri
            text_area.tag_configure("placeholder", foreground="#c7c7c7")
            
            # Textul prestabilit care va apărea la început
            placeholder_text = "This instance helps you check if the system requirements of the computer running Multiapp Professional are compatible with the recommended minimum requirements. Click on the About Window button in the Start Menu to perform this check. To continue booting into Multiapp Professional, click on the Shutdown button in the Start Menu. For Multiapp to function, it must be activated using a product key. This can be done from the Product Activation section. ##Try w95dist (type this code in USER, without password)##"
            text_area.insert(tk.END, placeholder_text)
            
            # Aplicăm tag-ul gri pe întregul text prestabilit
            text_area.tag_add("placeholder", "1.0", "end")
            
            # Funcția pentru a șterge textul prestabilit când utilizatorul începe să scrie
            def on_focus_in(event):
                if text_area.get("1.0", tk.END).strip() == placeholder_text:
                    text_area.delete("1.0", tk.END)
            
            # Funcția pentru a șterge textul prestabilit când utilizatorul pune cursorul
            def on_key_press(event):
                if text_area.get("1.0", tk.END).strip() == placeholder_text:
                    text_area.delete("1.0", tk.END)

            # Legăm evenimentele la funcțiile corespunzătoare
            text_area.bind("<FocusIn>", on_focus_in)  # Când fereastra primește focus
            text_area.bind("<KeyPress>", on_key_press)  # Când utilizatorul apasă o tastă
            
            # Adăugăm un meniu pentru a salva și deschide fișiere
            menu_bar = tk.Menu(window)
            file_menu = tk.Menu(menu_bar, tearoff=0)
            file_menu.add_command(label='Save', command=lambda: self.save_file(text_area))
            file_menu.add_command(label='Open', command=lambda: self.open_file(text_area))
            menu_bar.add_cascade(label='File', menu=file_menu)
            window.config(menu=menu_bar)
        
        def save_file(self, text_area):
            file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
            if file_path:
                with open(file_path, "w") as file:
                    file.write(text_area.get("1.0", tk.END))
        
        def open_file(self, text_area):
            file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
            if file_path:
                with open(file_path, "r") as file:
                    text_area.delete("1.0", tk.END)
                    text_area.insert("1.0", file.read())
        
        def create_about_window(self, window):
            sys_info = platform.uname()
            system_version = sys_info.system
            processor_info = platform.processor()
            
            # Specificațiile minime
            min_os = "Windows 10 (x64)"
            min_processor_speed = 1  # GHz
            min_ram = 4  # GB
            min_disk_space = 300  # MB
            
            # Obținem informațiile sistemului
            os_version = sys_info.release
            ram = psutil.virtual_memory().total / (1024 ** 3)  # RAM în GB
            processor_speed = float(processor_info.split()[2].split('GHz')[0])  # extragem valoarea GHz
            is_x64 = sys_info.machine in ["x86_64", "AMD64"]  # Verificăm dacă este sistem x64 (AMD64 sau x86_64)
            
            # Verificăm dacă sistemul îndeplinește cerințele minime
            meets_requirements = True
            requirements_message = "Meets minimum requirements"
            
            if system_version != "Windows" or not is_x64:
                meets_requirements = False
                requirements_message = "Does not meet minimum requirements: OS is not Windows x64."
            
            # Verificăm dacă versiunea este 10 sau mai mare
            major_version = int(os_version.split('.')[0])
            if major_version < 10:
                meets_requirements = False
                requirements_message = f"Does not meet minimum requirements: OS version is older than Windows 10 (Detected: Windows {major_version})."
            
            if processor_speed < min_processor_speed:
                meets_requirements = False
                requirements_message = "Does not meet minimum requirements: Processor speed is too low."
            
            # Verificăm RAM-ul
            if ram < min_ram:
                meets_requirements = False
                requirements_message = "Does not meet minimum requirements: RAM is too low."
            
            # Verificăm dacă există suficient spațiu pe disc
            if system_version == "Windows":
                disk_space = psutil.disk_usage('/').free / (1024 ** 2)  # spațiu liber în MB
                if disk_space < min_disk_space:
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: Insufficient disk space."
            
            window.configure(bg='#c9c9c9')
            
            # Creăm layout-ul pentru fereastra de 'About'
            frame = tk.Frame(window, bg='#c9c9c9')
            frame.pack(padx=10, pady=10)

            # Specificațiile minime
            min_specs = tk.Label(frame, text=f"Minimum Requirements:\nOS: {min_os}\nProcessor: {min_processor_speed} GHz\nRAM: {min_ram} GB\nDisk space: {min_disk_space} MB free", font=("Fixedsys", 12), bg='#c9c9c9')
            min_specs.grid(row=0, column=0, padx=10, pady=10, sticky='w')
            
            # Specificațiile curente
            current_specs = tk.Label(frame, text=f"Your System:\nOS: {system_version} {os_version} {sys_info.machine}\nProcessor: {processor_speed} GHz\nRAM: {ram:.2f} GB\nDisk space: {disk_space:.2f} MB free", font=("Fixedsys", 12), bg='#c9c9c9')
            current_specs.grid(row=0, column=1, padx=10, pady=10, sticky='w')
            
            # Mesajul de cerințe
            color = "green" if meets_requirements else "red"
            result_label = tk.Label(window, text=requirements_message, font=("Fixedsys", 14), fg=color, bg='#c9c9c9')
            result_label.pack(pady=10)

    if __name__ == '__main__':
        root_inst = tk.Tk()
        app = Windows95Simulator(root_inst)
        root_inst.mainloop()

# Verificare și creare folder/fișier config
if not os.path.exists("Config"):
    os.makedirs("Config")

if not os.path.exists("Config/config.xml"):
    with open("Config/config.xml", "w") as f:
        f.write('<?xml version="1.0" encoding="UTF-8"?>\n<configuration>\n\n    <checker_instance>True</checker_instance>\n\n    <virtual_instance>True</virtual_instance>\n\n</configuration>')
else:
    # Verifică și adaugă parametrii lipsă
    import xml.etree.ElementTree as ET
    tree = ET.parse("Config/config.xml")
    root = tree.getroot()
    
    modified = False
    if root.find('checker_instance') is None:
        ET.SubElement(root, 'checker_instance').text = 'True'
        modified = True
    if root.find('virtual_instance') is None:
        ET.SubElement(root, 'virtual_instance').text = 'True'
        modified = True
    
    if modified:
        tree.write("Config/config.xml", encoding="utf-8", xml_declaration=True)

# Citire valoare din config.xml
import xml.etree.ElementTree as ET
tree = ET.parse("Config/config.xml")
root = tree.getroot()
checker_element = root.find('checker_instance')
checker_instance = checker_element.text == 'True' if checker_element is not None else False
virtual_element = root.find('virtual_instance')
virtual_instance = virtual_element.text == 'True' if virtual_element is not None else False

# Verificare parametru și rulare funcție
if virtual_instance:
    run_instance_checker()
    
   
def run_reading_pane():
    import webbrowser
    from datetime import datetime

    class MultiappInfoDashboard:
        def __init__(self, rootuserinfo):
            self.rootuserinfo = rootuserinfo
            self.rootuserinfo.title("Multiapp 95 Professional - User Information")
            self.rootuserinfo.geometry("1200x800")
            self.rootuserinfo.configure(bg='#c0c0c0')
            #self.rootuserinfo.overrideredirect(True)
            # Variabile pentru funcționalitatea de drag
            self.start_x = 0
            self.start_y = 0
            
            # Bind evenimente pentru drag pe întreaga fereastră
            self.rootuserinfo.bind('<Button-1>', self.start_drag)
            self.rootuserinfo.bind('<B1-Motion>', self.do_drag)
            
            # Windows 95 style configuration
            self.setup_win95_style()
            
            # Create title bar
            self.create_title_bar()
            
            # Create main container with classic border
            self.main_frame = tk.Frame(rootuserinfo, bg='#c0c0c0', relief='raised', bd=2)
            self.main_frame.pack(fill="both", expand=True, padx=2, pady=2)
            
            # Create menu bar
            self.create_menu_bar()
            
            # Create toolbar
            self.create_toolbar()
            
            # Create main content with classic layout
            self.create_main_content()
            
            # Load overview by default
            self.show_overview()
        
        def start_drag(self, event):
            """Inițiază procesul de drag"""
            self.start_x = event.x
            self.start_y = event.y
        
        def do_drag(self, event):
            """Execută mutarea ferestrei"""
            # Calculează noua poziție
            x = self.rootuserinfo.winfo_x() + event.x - self.start_x
            y = self.rootuserinfo.winfo_y() + event.y - self.start_y
            
            # Mută fereastra
            self.rootuserinfo.geometry(f"+{x}+{y}")
        
        def setup_win95_style(self):
            """Configure Windows 95 style colors and fonts"""
            self.colors = {
                'bg': '#c0c0c0',
                'button': '#c0c0c0',
                'button_active': '#0078d4',
                'text': '#000000',
                'window': '#ffffff',
                'title_bar': '#008080',
                'border_light': '#dfdfdf',
                'border_dark': '#808080',
                'selected': '#0078d4'
            }
            
            # Configure ttk style for Windows 95 look
            style = ttk.Style()
            style.theme_use('clam')
            
            style.configure('Win95.TButton',
                           background='#c0c0c0',
                           foreground='black',
                           borderwidth=2,
                           relief='raised',
                           font=('MS Sans Serif', 8))
            
            style.configure('Win95.TFrame',
                           background='#c0c0c0',
                           borderwidth=2,
                           relief='raised')
        
        def create_win95_button(self, parent, text, command=None, width=None):
            """Create Windows 95 style button"""
            btn = tk.Button(parent, text=text, command=command,
                           bg='#c0c0c0', fg='black',
                           font=('MS Sans Serif', 8),
                           relief='raised', bd=2,
                           activebackground='#e0e0e0',
                           activeforeground='black')
            if width:
                btn.config(width=width)
            return btn
        
        def create_title_bar(self):
            """Create Windows 95 style title bar"""
            title_frame = tk.Frame(self.rootuserinfo, bg='#008080', height=25)
            title_frame.pack(fill='x', side='top')
            title_frame.pack_propagate(False)
            
            # Title text with logo
            title_label = tk.Label(title_frame, text="Multiapp 95 Professional - User Guide", 
                                  bg='#008080', fg='white', 
                                  font=('MS Sans Serif', 8, 'bold'))
            title_label.pack(side='left', padx=5, pady=2)
            
            # Window controls
            controls_frame = tk.Frame(title_frame, bg='#008080')
            controls_frame.pack(side='right', padx=2)
            
            for symbol in ['_', '□', '×']:
                if symbol == '_':
                    # Minimizare fereastră
                    #command = lambda: self.rootuserinfo.iconify()
                    #command = lambda: self.rootuserinfo.withdraw()
                    pass
                elif symbol == '□':
                    # Maximizare/Restaurare fereastră - inline logic
                    #command = lambda: self.rootuserinfo.state('normal') if self.rootuserinfo.state() == 'zoomed' else self.rootuserinfo.state('zoomed')
                    pass
                elif symbol == '×':
                    # Închidere fereastră
                    #command = self.rootuserinfo.quit
                    pass
                else:
                    #command = None
                    pass
                
                btn = tk.Button(controls_frame, text=symbol, bg='#c0c0c0', fg='black', font=('MS Sans Serif', 8, 'bold'), width=3, height=1, bd=1, relief='raised')
                #btn = tk.Button(controls_frame, text=symbol, bg='#c0c0c0', fg='black', font=('MS Sans Serif', 8, 'bold'), width=3, height=1, bd=1, relief='raised', command=command)
                btn.pack(side='left', padx=1)
        
        def create_menu_bar(self):
            """Create Windows 95 style menu bar"""
            menubar = tk.Menu(self.rootuserinfo, bg='#c0c0c0', fg='black', 
                             font=('MS Sans Serif', 8))
            self.rootuserinfo.config(menu=menubar)
            
            # File menu
            file_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0', fg='black',
                               font=('MS Sans Serif', 8))
            file_menu.add_command(label="Print Info", command=self.print_info)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootuserinfo.quit)
            menubar.add_cascade(label="File", menu=file_menu)
            
            # View menu
            view_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0', fg='black',
                               font=('MS Sans Serif', 8))
            view_menu.add_command(label="Overview", command=self.show_overview)
            view_menu.add_command(label="Features", command=self.show_features)
            view_menu.add_command(label="Accounts", command=self.show_accounts)
            view_menu.add_command(label="System Requirements", command=self.show_requirements)
            view_menu.add_command(label="Installation", command=self.show_installation)
            menubar.add_cascade(label="View", menu=view_menu)
            
            # Help menu
            help_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0', fg='black',
                               font=('MS Sans Serif', 8))
            help_menu.add_command(label="Support", command=self.show_support)
            help_menu.add_command(label="About", command=self.show_about)
            menubar.add_cascade(label="Help", menu=help_menu)
        
        def create_toolbar(self):
            """Create Windows 95 style toolbar"""
            toolbar = tk.Frame(self.main_frame, bg='#c0c0c0', relief='raised', bd=1)
            toolbar.pack(fill='x', padx=2, pady=2)
            
            buttons = [
                ("Overview", "Overview", self.show_overview),
                ("Features", "Features", self.show_features),
                ("Accounts", "Accounts", self.show_accounts),
                ("System Req", "System Req", self.show_requirements),
                ("|", "", None),
                ("Install", "Install", self.show_installation),
                ("Help", "Help", self.show_support),
                ("About", "About", self.show_about)
            ]
            
            for icon, tooltip, command in buttons:
                if icon == "|":
                    sep = tk.Frame(toolbar, bg='#808080', width=1, height=20)
                    sep.pack(side='left', padx=2, pady=2)
                else:
                    btn = tk.Button(toolbar, text=icon, command=command,
                                   bg='#c0c0c0', fg='black',
                                   font=('MS Sans Serif', 8),
                                   relief='raised', bd=1,
                                   width=10, height=1)
                    btn.pack(side='left', padx=1, pady=2)
        
        def create_main_content(self):
            """Create main content area"""
            main_container = tk.Frame(self.main_frame, bg='#c0c0c0', relief='sunken', bd=2)
            main_container.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Navigation panel
            self.nav_frame = tk.Frame(main_container, bg='#c0c0c0', width=180, relief='raised', bd=1)
            self.nav_frame.pack(side='left', fill='y', padx=2, pady=2)
            self.nav_frame.pack_propagate(False)
            
            nav_title = tk.Label(self.nav_frame, text="Quick Navigation", 
                                bg='#c0c0c0', fg='black', 
                                font=('MS Sans Serif', 8, 'bold'))
            nav_title.pack(pady=5)
            
            nav_buttons = [
                ("Overview", self.show_overview),
                ("System & Diagnostics", self.show_system_features),
                ("File Management", self.show_file_features),
                ("Security Suite", self.show_security_features),
                ("Office Suite", self.show_office_features),
                ("Development Tools", self.show_dev_features),
                ("AI & Productivity", self.show_ai_features),
                ("Network Features", self.show_network_features),
                ("User Accounts", self.show_accounts),
                ("System Requirements", self.show_requirements),
                ("Installation Guide", self.show_installation)
            ]
            
            for text, command in nav_buttons:
                btn = self.create_win95_button(self.nav_frame, text, command, 20)
                btn.pack(fill='x', padx=5, pady=1)
            
            # Content area
            self.content_frame = tk.Frame(main_container, bg='#ffffff', relief='sunken', bd=2)
            self.content_frame.pack(side='right', fill='both', expand=True, padx=2, pady=2)
        
        def clear_content(self):
            """Clear main content area"""
            for widget in self.content_frame.winfo_children():
                widget.destroy()
        
        def create_scrollable_text(self, parent, content, title=""):
            """Create a scrollable text widget with content"""
            if title:
                header = tk.Label(parent, text=title, 
                                 bg='#ffffff', fg='black',
                                 font=('MS Sans Serif', 14, 'bold'))
                header.pack(anchor='w', padx=10, pady=(10, 5))
            
            # Create scrolled text widget
            text_widget = scrolledtext.ScrolledText(parent, 
                                                   bg='#ffffff', fg='black',
                                                   font=('MS Sans Serif', 9),
                                                   wrap=tk.WORD,
                                                   relief='sunken', bd=2)
            text_widget.pack(fill='both', expand=True, padx=10, pady=5)
            
            # Insert content
            text_widget.insert(tk.END, content)
            text_widget.config(state='disabled')  # Make read-only
            
            return text_widget
        
        def show_overview(self):
            """Show application overview"""
            self.clear_content()
            
            content = """MULTIAPP 95 PROFESSIONAL - IT MANAGEMENT TOOL SUITE

    Multiapp 95 Professional is the ultimate productivity and efficiency suite designed specifically for IT support departments. This revolutionary software combines over 50+ professional tools into a single, powerful executable file.

    WHY CHOOSE MULTIAPP PROFESSIONAL?

    - All-in-one solution with no additional installations required
    - Advanced security features built-in
    - Intuitive interface with retro & modern design
    - Regular updates and continuous improvement
    - Portable application - runs from anywhere

    TECHNOLOGY STACK & ARCHITECTURE

    • Programming Languages: Python and C++
    • Deployment: Precompiled into a single executable file
    • Architecture: x64 (64-bit) Windows applications only
    • Distribution: Single executable file - no installer needed
    • Installation: Portable application with one-time setup

    PROFESSIONAL USE CASES

    • IT Support Departments - Comprehensive diagnostic and task automation
    • System Administrators - Advanced monitoring and management capabilities
    • Developers - Python IDE and database management tools
    • Office Professionals - Office Lite suite and productivity tools
    • Network Engineers - Advanced network analysis and monitoring
    • Security Teams - Encryption and security management tools

    PERFORMANCE BENEFITS

    • Efficiency: 18.8% ~ 20% faster copying compared to traditional methods
    • Optimization: Precompiled paths and direct bit allocation
    • Integration: All tools unified in a single application
    • Resource Management: Optimized memory usage and CPU allocation

    This comprehensive suite streamlines various IT tasks from system monitoring to file management, network diagnostics, development tools, and advanced AI-powered productivity features."""

            self.create_scrollable_text(self.content_frame, content, "Multiapp 95 Professional Overview")
        
        def show_features(self):
            """Show all features categorized"""
            self.clear_content()
            
            # Create notebook for feature categories
            notebook = ttk.Notebook(self.content_frame)
            notebook.pack(fill='both', expand=True, padx=10, pady=10)
            
            categories = [
                ("System & Diagnostics", self.get_system_features()),
                ("File Management", self.get_file_features()),
                ("Security Suite", self.get_security_features()),
                ("Office Suite", self.get_office_features()),
                ("Development Tools", self.get_dev_features()),
                ("AI & Productivity", self.get_ai_features()),
                ("Network Features", self.get_network_features())
            ]
            
            for category_name, content in categories:
                frame = tk.Frame(notebook, bg='#ffffff')
                notebook.add(frame, text=category_name)
                
                text_widget = scrolledtext.ScrolledText(frame, 
                                                       bg='#ffffff', fg='black',
                                                       font=('MS Sans Serif', 9),
                                                       wrap=tk.WORD)
                text_widget.pack(fill='both', expand=True, padx=5, pady=5)
                text_widget.insert(tk.END, content)
                text_widget.config(state='disabled')
        
        def show_system_features(self):
            """Show system and diagnostic features"""
            self.clear_content()
            content = self.get_system_features()
            self.create_scrollable_text(self.content_frame, content, "System & Diagnostics Features")
        
        def show_file_features(self):
            """Show file management features"""
            self.clear_content()
            content = self.get_file_features()
            self.create_scrollable_text(self.content_frame, content, "File Management Pro Features")
        
        def show_security_features(self):
            """Show security features"""
            self.clear_content()
            content = self.get_security_features()
            self.create_scrollable_text(self.content_frame, content, "Security Suite Features")
        
        def show_office_features(self):
            """Show office suite features"""
            self.clear_content()
            content = self.get_office_features()
            self.create_scrollable_text(self.content_frame, content, "Office Suite Lite Features")
        
        def show_dev_features(self):
            """Show development tools"""
            self.clear_content()
            content = self.get_dev_features()
            self.create_scrollable_text(self.content_frame, content, "Development Tools")
        
        def show_ai_features(self):
            """Show AI and productivity features"""
            self.clear_content()
            content = self.get_ai_features()
            self.create_scrollable_text(self.content_frame, content, "AI & Productivity Features")
        
        def show_network_features(self):
            """Show network features"""
            self.clear_content()
            content = self.get_network_features()
            self.create_scrollable_text(self.content_frame, content, "Network & Connectivity Features")
        
        def get_system_features(self):
            return """SYSTEM & DIAGNOSTICS TOOLS

    • System Compatibility Testing
      Built-in hardware verification to ensure optimal performance

    • Hardware Diagnostics & Monitoring
      Real-time system performance tracking and analysis

    • Network Troubleshooting Tools
      Complete network analysis suite for connectivity issues

    • Support IT Process Automation
      Streamlined workflow management for IT tasks

    • Advanced Terminal Emulator
      CMD and Linux (WSL) interface simulation

    • Performance Optimization
      System tuning and enhancement capabilities

    • Alert Monitor
      System alerts based on usage thresholds and performance metrics

    • Event Viewer
      System log analysis (errors, warnings, information)

    • Manual & Automatic Repair Tool
      Self-healing capabilities for Multiapp with comprehensive diagnostics

    • Real-time System Information
      Live performance monitoring with detailed metrics

    • Task Manager
      Process management with memory and network usage tracking

    • Process Viewer
      CPU and GPU usage analysis by core
      
    • Multiapp Dashboard
      For essential informations (if you have the code)"""
        
        def get_file_features(self):
            return """FILE MANAGEMENT PRO TOOLS

    • Smart Backup Tool
      Intelligent data backup for sensitive information

    • Advanced Files & Folders Comparator
      Deep comparison algorithms for file differences

    • ZIP Password Recovery & Maker
      Archive security management with encryption capabilities

    • Intelligent File Organizer
      Automatic file categorization based on type and usage

    • Explorer Mode
      Dynamic local file/folder copying with path saving functionality

    • Copy App
      Network file copying from servers to C:\KIT directory with profiles

    • Rename Utility
      Batch file renaming operations with pattern matching

    • File Archeologist
      File history tools for tracking changes and versions

    • Archive Management
      Comprehensive compression and management for ZIP files

    • File History Tools
      Track and manage file modifications over time
      
    • File Fisher
      Searching files tool
      
    • Recovery Tunnel
      Advanced file recovery tool"""
        
        def get_security_features(self):
            return """SECURITY SUITE TOOLS

    • Military-grade File Encryption
      High-complexity encryption algorithms for sensitive data protection

    • Advanced Password Manager & Generation Tool
      Encrypted password database with secure storage

    • Multi-level Authentication System
      Secure access control with role-based permissions

    • Terminal Access Restrictions
      Security policy-based controls for system access

    • Password Generator Utilities
      Multiple password generation tools with customizable parameters
      - Basic Password Generator (passgen/passgen)
      - Advanced Password Generator V2 (passgenV2/passgenV2)

    • Password Storage and Management
      Secure password vault with encryption (password/manager)

    • File Encryption and Security Tools
      Advanced cryptographic tools (cryptoV2/security)

    • ZIP Password Recovery
      Specialized tools for archive password recovery (zippass/wordsmith)
      
    • Safety Tool
      Designed for avoiding vulnerabilities on your system (safe/checker)"""
        
        def get_office_features(self):
            return """OFFICE SUITE LITE TOOLS

    • Office Document Reader
      View Word, PowerPoint & Excel files without installation

    • Spreadsheet Editor
      Excel-compatible editor with SUM, AVERAGE, MIN, MAX, COUNT, PRODUCT, MEDIAN, CONCAT formula support

    • Document Conversion Tools
      .pdf to .docx support for various document types (convertorpdf/toword)

    • PDF Tools Suite
      - Encryption and security features
      - Image extraction capabilities
      - Page manipulation tools
      - PDF to Word conversion (convertorpdf/toword)
      - Comprehensive PDF manipulation (pdftools/enjoyit)
      
    • PDF Viewer

    • Paint App & Whiteboard
      Digital drawing and diagramming tools

    • Find & Replace Text Tool
      Advanced search and replacement with regex support

    • Contacts Manager
      Contact information database with search capabilities
    """
        
        def get_dev_features(self):
            return """DEVELOPMENT TOOLS

    • Full-featured Python IDE
      Complete development environment with debugging support (ide/pycharm or ide/vscode)

    • Advanced Text Editor
      Notepad++ functionality with syntax highlighting
      
    • Markdown Viewer
      View and edit Markdown files (md/mdviewer)
      
    • SQLite Editor & Reader
      Database management with syntax highlighting and query tools

    • Script Agent
      Script runner for daily tasks and automation
      
    • Multi File Editor
      Configuration file editing for various formats

    • Development Environment Features:
      - Syntax highlighting for multiple languages
      - Project management capabilities"""
        
        def get_ai_features(self):
            return """AI & PRODUCTIVITY TOOLS

    • AI Chatbot
      Virtual assistant with 95% Romanian language support (chatbot/aichatbot)

    • Smart Calendar & Scheduling
      Event management system with intelligent planning (calendar/calendar)

    • Task Manager System
      Comprehensive task management and tracking (taskmanager/terminator)

    • Knowledge Base System
      Built-in documentation platform with search capabilities
      - Standard Knowledge Base (kbmanager/knowladgebase)
      - Retro Knowledge Base (kbretro/kbretro)

    • Account Launcher & Manager
      Unified account management system (launcher/launcher)

    • Workflow Automation
      Process optimization tools for repetitive tasks

    • Q&A Platform
      Interactive help system with contextual assistance

    • Pause Manager for Teams
      Break management system for productivity (pausemanager/pauze)

    • Screen Recorder App
      Capture and recording tools for training and documentation (screenrec/screenrec)

    • Visual Diagram Creator
      Professional diagram tools for flowcharts and process mapping (diagram/beta or mindmap/diagram)

    • Expense Tracker
      Financial tracking with visual diagrams and reporting (expense/tracker)

    • Quiz Creation and Testing
      - Quiz Maker for content creation (quizmaker/quizmaker)
      - Quiz Testing system for evaluation (quiz/test)
      
    • XML Editor
      Configuration file editing capabilities with validation
      
    • Text Search and Replace Utility
      Advanced find and replace with pattern matching (textreplace/textfind)"""
        
        def get_network_features(self):
            return """NETWORK & CONNECTIVITY TOOLS

    • Network Information Display
      Get IP & MAC address information for all network adapters

    • Port Scanner
      Open port detection on network devices with service identification

    • Ping Tool
      Connectivity testing with port discovery and latency analysis

    • Network Console
      Comprehensive monitoring and Wi-Fi password recovery capabilities

    • Network Bandwidth Monitoring
      Real-time usage graphs with VLAN and LAN support (bandmonitoring/networking)

    • Device Status Listener
      Track online/offline status of network devices (check/devices)
      
    • Network traffic monitoring (traffic/network)

    • Advanced Network Diagnostics:
      - Connection quality testing
      - Network performance optimization
      - Bandwidth utilization analysis
      - Network topology discovery
      - Wi-Fi signal strength monitoring
      - Network security scanning"""
        
        def show_accounts(self):
            """Show user accounts information"""
            self.clear_content()
            
            content = """USER ACCOUNTS SYSTEM

    Multiapp 95 Professional uses a comprehensive authentication system with predefined accounts for different functionalities. All accounts are stored in the Accounts.txt file.

    PUBLIC ACCOUNTS (Available to all users):

    BASIC ACCOUNTS:
    • user/nopass - File copying operations only
    • it/copy - Enhanced user functionality (user++)

    SPECIALIZED TOOL ACCOUNTS:
    • chatbot/aichatbot - AI chatbot assistant
    • alert/monitor - Hardware alert monitoring system
    • backupmanager/backupmngr - File backup management
    • calendar/calendar - Calendar display & event planning
    • check/devices - Online device checker
    • comparator/comparator - File comparison tool
    • contact/manager - Contact management system
    • diagram/beta - Diagram creation and editing (beta version)
    • mindmap/diagram - Diagram creation and editing
    • cryptoV2/security - File encryption and security tools
    • eventviewer/eventviewer - System event monitoring
    • excel/lite - Lightweight spreadsheet editor
    • expense/tracker - Expense tracker with diagrams
    • fetcher/repair - Multiapp auto repair utility
    • fisher/file - Searching files tool
    • shell/integrator - Multiapp manual repair utility
    • history/files - File history management tools
    • hardware/lite - Hardware monitoring live kit
    • junk/manager - Junk file management and cleanup
    • kbmanager/knowladgebase - Knowledge base management
    • kbretro/kbretro - Retro knowledge base manager
    • launcher/launcher - Application launcher interface
    • md/mdviewer - Markdown file viewer and editor
    • multifile/editor - Configuration file editing for various formats
    • bandmonitoring/networking - Network bandwidth monitoring
    • notepad/notepad - Advanced text editor
    • reader/office - Office document reader
    • paint/paint - Digital drawing tool
    • passgen/passgen - Password generator utility
    • passgenV2/passgenV2 - Advanced password generator
    • password/manager - Password storage and management
    • pausemanager/pauze - Team break manager
    • convertorpdf/toword - PDF to Word document converter
    • pdftools/enjoyit - Comprehensive PDF manipulation tools
    • pdfviewer/pdfviewer - Simple PDF viewer
    • process/viewer - CPU and GPU process monitoring
    • ide/pycharm - Python integrated development environment
    • ide/vscode - Python integrated development environment
    • quizmaker/quizmaker - Quiz creation and editing tool
    • quiz/test - Quiz testing and evaluation system
    • recovery/tunnel - Advanced file recovery tool
    • renamemanager/renamer - File renaming utility
    • safe/checker - Safety tool for avoiding vulnerabilities on your system
    • screenrec/screenrec - Screen recording application
    • script/agent - Script runner for daily tasks
    • sql/editor - SQLite database editor and query tool
    • system/realtime - Real-time system resource monitoring
    • taskmanager/terminator - Advanced task manager
    • terminal/terminal - Command line terminal interface
    • textreplace/textfind - Text search and replace utility
    • traffic/network - Network traffic monitoring
    • commander/total - Total commander file manager
    • whiteboard/presentation - Whiteboard & presentation tools
    • xml/editor - XML file editor and validator for Config
    • zipmanager/zipmngr - Archive compression and management
    • zippass/wordsmith - ZIP password recovery tool

    DEVELOPER ACCOUNTS:
    • Reserved for development purposes
    • Not accessible to end users
    • Used for system maintenance and updates

    USAGE TIPS:
    1. Each account provides access to specific functionality
    2. Use the launcher/launcher account to manage other accounts
    3. Accounts are case-sensitive
    4. Some accounts may require administrator privileges
    5. Account permissions are automatically managed by the system"""

            self.create_scrollable_text(self.content_frame, content, "User Accounts Guide")
        
        def show_requirements(self):
            """Show system requirements"""
            self.clear_content()
            
            content = """SYSTEM REQUIREMENTS

    IMPORTANT NOTICE:
    This software is designed exclusively for x64 (64-bit) systems

    MINIMUM REQUIREMENTS:
    • Architecture: x64 (64-bit processor required - between 1-2 GHz)
    • Operating System: Windows 10 (build 1903+) or Windows 11
    • Processor: Intel i3 or AMD equivalent (1-2 GHz)
    • RAM: 4GB minimum
    • Storage: 500MB free disk space
    • Permissions: Administrator privileges for full functionality
    • Network: Internet connection for AI features and updates
    • Display: 100% zoom recommended (especially for laptops)

    RECOMMENDED SPECIFICATIONS:
    • Processor: Intel Core i5 or AMD Ryzen 5 (or equivalent)
    • RAM: 8GB recommended or 16GB for heavy development work
    • Storage: SSD for faster file operations
    • Display: 1920x1080 or higher resolution

    BUILT-IN COMPATIBILITY CHECK:
    Multiapp 95 Professional includes an integrated system compatibility checker that verifies your hardware and software configuration automatically - no need to worry about compatibility!

    DISPLAY OPTIMIZATION:
    For optimal display on laptops:
    1. Right-click Multiapp.exe
    2. Select Properties
    3. Choose "Change settings for all users"
    4. Click "Change high DPI settings"
    5. Configure scaling settings as needed

    PERFORMANCE CONSIDERATIONS:
    • SSD storage recommended for faster file operations
    • Dedicated graphics card beneficial for intensive development work
    • Stable internet connection required for AI chatbot functionality
    • Administrator privileges needed for system monitoring features
    • Multiple monitor setup supported for enhanced productivity"""

            self.create_scrollable_text(self.content_frame, content, "System Requirements")
        
        def show_installation(self):
            """Show installation guide"""
            self.clear_content()
            
            content = """INSTALLATION & SETUP GUIDE

    WHAT YOU GET:
    - Single executable file - no installer needed
    - Portable application - run from anywhere
    - All features unlocked immediately
    - No additional dependencies required

    SIMPLE SETUP PROCESS:

    1. DOWNLOAD
       • Download the Multiapp.exe file
       • File size: ~500MB
       • Single executable file

    2. SYSTEM CHECK
       • Ensure your system meets minimum requirements
       • Built-in compatibility checker will verify automatically
       • x64 (64-bit) processor required

    3. DISPLAY CONFIGURATION
       • Configure display settings for optimal viewing
       • Set zoom to 100% for best experience
       • For laptops: Adjust high DPI settings if needed

    4. FIRST RUN
       • Run the application as Administrator (recommended)
       • Log in using provided accounts from the account list
       • Choose appropriate account for your intended use (recommended launcher/launcher or dev mode if you have the code)

    5. OPTIMIZATION (Optional)
       • For optimal display on laptops:
         - Right-click Multiapp.exe → Properties
         - Change settings for all users
         - Change high DPI settings
         - Configure scaling as needed

    CONFIGURATION FILES & STRUCTURE:
    • Accounts.txt - User account information
    • paths.txt - Network or local paths for Copy App
    • profiles.json - Equipment profiles for Copy App
    • ChooseLocationForPause.txt - Pause Manager file location
    • Config folder - XML configuration files for various modules

    FIRST-TIME SETUP CHECKLIST:
    □ Verify system requirements
    □ Run compatibility check
    □ Configure display settings
    □ Preset the config.xml file in Config folder
    □ Test login with basic account (user/nopass)
    □ Explore main features using launcher/launcher account
    □ Configure network paths if needed
    □ Set up backup locations if using backup features

    QUICK START TIPS:
    • Start with the launcher/launcher account to explore all features (or dev mode if you have the code)
    • Preset the config.xml file in Config folder
    • Use the built-in help system for detailed guidance
    • The AI chatbot (chatbot/aichatbot) can assist with questions
    • Each tool has its own specialized account for focused work
    • Administrator privileges recommended for full functionality

    IMPORTANT NOTES:
    • No installation required - runs directly from executable
    • Portable - can be run from USB drive or network location
    • All data stored locally within application directory
    • Internet connection required for AI features and updates
    • Some features may require specific network permissions"""

            self.create_scrollable_text(self.content_frame, content, "Installation & Setup Guide")
        
        def show_support(self):
            """Show support information"""
            self.clear_content()
            
            content = """SUPPORT & DOCUMENTATION

    GET HELP AND SUPPORT:

    BUILT-IN HELP RESOURCES:
    • Knowledge Base: Built-in local documentation platform
    • AI Chatbot: Integrated virtual assistant (chatbot/aichatbot)
    • Read Me First: Essential usage information
    • Equipment Sheets: Software configuration templates for profiles.json and paths.txt (copy app)
    • Multiapp Dashboard: For essential informations (if you have the code)

    OFFICIAL SUPPORT CHANNELS:
    • Developer: Tudor Marmureanu
    • Support Email: support@muap.ro
    • Company: Muap - Retro Computing Division

    REPAIR & MAINTENANCE:

    AUTOMATIC REPAIR (Fetcher):
    Use the Fetcher - Repair Setup feature (fetcher/repair) for automatic error correction and file restoration.

    MANUAL REPAIR (Shell Integrator):
    Use shell/integrator account and execute commands in sequence:
    1. init
    2. powercli Multiapp.exe -t
    3. getscan register mov eax, eay: shell True
    4. 1/0,12
    5. 0/0,8
    6. start,1/0/0
    7. restart_service
    8. X/1,0
    9. X/1,1
    10. CLI/1/0/0,t
    11. cfg,0/0/1 (use 'init' for Windows 10 x64 if this fails)
    12. launch_multiapp

    COMMON SOLUTIONS:

    DISPLAY ISSUES:
    • Adjust DPI settings for high-resolution displays
    • Set zoom to 100% in Windows display settings
    • Update graphics drivers

    PERFORMANCE ISSUES:
    • Run as Administrator for full functionality
    • Close unnecessary background applications
    • Ensure minimum system requirements are met

    NETWORK CONNECTIVITY:
    • Check internet connection for AI chatbot functionality
    • Verify firewall settings for network tools
    • Ensure proper network permissions for file copying

    FILE ACCESS ISSUES:
    • Verify administrator privileges
    • Check file permissions and ownership
    • Ensure adequate disk space for operations

    DOCUMENTATION RESOURCES:
    • Knowledge Base: Built-in local documentation platform
    • Read Me First: Essential usage information
    • Built-in tutorials and guides for each tool
    • Context-sensitive help throughout the application

    ADDITIONAL RESOURCES:
    • Company: Muap - Retro Computing Division
    • Professional IT environments with advanced capabilities
    • Some features may require specific network permissions"""

            self.create_scrollable_text(self.content_frame, content, "Support & Documentation")
        
        def show_about(self):
            """Show about information"""
            self.clear_content()
            
            content = """ABOUT MULTIAPP 95 PROFESSIONAL

    COMPANY INFORMATION:
    • Developer: Tudor Marmureanu
    • Company: Muap - Retro Computing Division
    • Support Email: support@muap.ro
    • Copyright: © 2024 Muap - Retro Computing Division

    APPLICATION DETAILS:
    • Name: Multiapp 95 Professional
    • Version: 0.95.0
    • Application Type: IT Management Tool Suite
    • Architecture: x64 (64-bit) Windows applications only
    • File Size: ~500MB
    • Distribution: Single executable file
    • License: Professional IT environments or Personal usage

    MISSION STATEMENT:
    Multiapp 95 Professional is designed to revolutionize IT workflow management by combining over 50+ professional tools into a single, powerful executable. Our mission is to provide IT support departments, system administrators, developers, and office professionals with an all-in-one solution that enhances productivity and streamlines operations.

    KEY ACHIEVEMENTS:
    • 50+ integrated professional tools
    • 18.8% ~ 20% faster file operations
    • Zero installation requirements
    • Military-grade security features
    • 95% Romanian language support for AI chatbot
    • Comprehensive network analysis capabilities
    • Advanced development environment
    • Real-time system monitoring

    DEVELOPMENT PHILOSOPHY:
    Built with Python and C++, Multiapp 95 Professional represents a modern approach to IT tool consolidation. Every feature has been carefully crafted to provide maximum efficiency while maintaining the familiar Windows 95 aesthetic that IT professionals love.

    PERFORMANCE METRICS:
    • Single executable deployment
    • Optimized memory usage and CPU allocation
    • Precompiled paths for faster operations
    • Direct bit allocation for enhanced performance
    • Resource-efficient multi-tool architecture

    INNOVATION HIGHLIGHTS:
    • Portable application design
    • Built-in compatibility checker
    • Self-healing repair capabilities
    • Advanced AI integration
    • Comprehensive security suite
    • Professional development tools

    RECOGNITION:
    Designed specifically for professional IT environments with advanced network and system management capabilities. Trusted by IT professionals for comprehensive diagnostic and task automation needs.

    GET IN TOUCH:
    For technical support, feature requests, or additional configuration assistance:
    • Use the built-in Knowledge Base system
    • Chat with our integrated AI assistant
    • Contact our support team at support@muap.ro

    Thank you for choosing Multiapp 95 Professional - The ultimate all-in-one productivity and IT management solution!"""

            self.create_scrollable_text(self.content_frame, content, "About Multiapp 95 Professional")
        
        def print_info(self):
            """Print current information"""
            messagebox.showinfo("Print Info", "Print functionality would be implemented here.\nCurrent view can be saved or printed.")
        
        def open_support_link(self):
            """Open support link in browser"""
            webbrowser.open("mailto:support@muap.ro")

    def main():
        rootuserinfo = tk.Tk()
        app = MultiappInfoDashboard(rootuserinfo)
        rootuserinfo.mainloop()

    if __name__ == "__main__":
        main()
    
if not os.path.exists("Config"):
    os.makedirs("Config")

if not os.path.exists("Config/config.xml"):
    with open("Config/config.xml", "w") as f:
        f.write('<?xml version="1.0" encoding="UTF-8"?>\n<configuration>\n\n    <checker_instance>True</checker_instance>\n\n    <virtual_instance>True</virtual_instance>\n\n    <reading_pane>True<reading_pane>\n\n</configuration>')
else:
    # Verifică și adaugă parametrii lipsă
    import xml.etree.ElementTree as ET
    tree = ET.parse("Config/config.xml")
    root = tree.getroot()
    
    modified = False
    if root.find('checker_instance') is None:
        ET.SubElement(root, 'checker_instance').text = 'True'
        modified = True
    if root.find('virtual_instance') is None:
        ET.SubElement(root, 'virtual_instance').text = 'True'
        modified = True
    if root.find('reading_pane') is None:
        ET.SubElement(root, 'reading_pane').text = 'True'
        modified = True
    
    if modified:
        tree.write("Config/config.xml", encoding="utf-8", xml_declaration=True)

# Citire valoare din config.xml
import xml.etree.ElementTree as ET
tree = ET.parse("Config/config.xml")
root = tree.getroot()
checker_element = root.find('checker_instance')
checker_instance = checker_element.text == 'True' if checker_element is not None else False
virtual_element = root.find('virtual_instance')
virtual_instance = virtual_element.text == 'True' if virtual_element is not None else False
reading_element = root.find('reading_pane')
reading_pane = reading_element.text == 'True' if reading_element is not None else False

# Verificare parametru și rulare funcție
if reading_pane:
    run_reading_pane()


show_validation = True
adminT = False
vscodevar = None
c = None
#xx = None
#trmn = None
trmn = None
passfig = None
passfig1 = None
hardvar = None
screenvar = None
zipvar = None
compvar = None
pdfvar = None
pdfviewervar = None
replfindvar = None
testvarr = None
testvarr2 = None
pdfvwvar = None
netwvar = None
crpvar2 = None
aivar = None
notepadvar = None
paintvar = None
Adm1var = None
Adm2var = None
zippassvar = None
bkvar = None
rnvar = None
kbvar = None
passmngrr = None
pausevar = None
taskmngrvar = None
junkvar = None
cmvar = None
wbpvar = None
pingalivevar = None
launchervar = None
launchervar_admin = None
excelvar = None
readervar = None
hardmvar = None
fetchervar = None
shellvar = None
w95var = None
sqllvar = None
diagramvar = None
termadm = None
commandervar = None
calendarvar = None
allmonitorvar = None
eventvval = None
assemblyvar = None
kbbbvar = None
dev_mode = False  # Variabilă pentru modul dezvoltator
proc_varr = None
xmleditorvar = None
MDvar = None
archVar = None
expensevar = None
scrpVar = None
recoveryVarr = None
fishervar = None
muapdash = None
mindmapvar = None
multifilevar = None
safevar = None
trafficvar = None
dosboxvar = None

def on_closing():
    #pass
    messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

def on_enter_press(event):
    login()
    
def toggle_dev_mode(user_type="normal"):
    global dev_mode, combo_users
    dev_mode = not dev_mode
    status_label.config(text=f"Dev Mode: {'ACTIVE' if dev_mode else 'INACTIVE'}", 
                        fg="lime green" if dev_mode else "red")
    
    if dev_mode:
        combo_users.set("")
        if user_type == "tudor":
            # Concatenează toate conturile (normale + Tudor)
            all_users = list(credentials.keys()) + list(tudor_credentials.keys())
            combo_users['values'] = all_users
        else:
            # Doar conturile normale
            combo_users['values'] = list(credentials.keys())
        combo_users.config(state="readonly")
    else:
        combo_users.set("Only for Dev mode")  # Repune textul când se dezactivează
        combo_users.config(state="disabled")

windowlogin = tk.Tk()
windowlogin.protocol("WM_DELETE_WINDOW", on_closing)
windowlogin.title("Login form")
windowlogin.geometry('700x600')
windowlogin.configure(bg='#333333')
windowlogin.resizable(False, False)
#image_icon = PhotoImage(file = "img/coins2.png")
#windowlogin.iconphoto(False, image_icon)
#windowlogin.wm_attributes('-toolwindow', True)  # Pe Windows transformă fereastra într-o fereastră de tip tool

# Dicționar cu toate credențialele
credentials = {
    "AI Chatbot": {"username": "chatbot", "password": "aichatbot"},
    "Alert Monitor": {"username": "alert", "password": "monitor"},
    "Backup Manager": {"username": "backupmanager", "password": "backupmngr"},
    "Calendar": {"username": "calendar", "password": "calendar"},
    "Check Online Devices": {"username": "check", "password": "devices"},
    "Comparator": {"username": "comparator", "password": "comparator"},
    "Contact Manager": {"username": "contact", "password": "manager"},
    "Diagram Editor BETA": {"username": "diagram", "password": "beta"},
    "Diagram Editor": {"username": "mindmap", "password": "diagram"},
    "Encrypting Files": {"username": "cryptoV2", "password": "security"},
    "Event Viewer": {"username": "eventviewer", "password": "eventviewer"},
    "Excel Lite": {"username": "excel", "password": "lite"},
    "Expense Tracker": {"username": "expense", "password": "tracker"},
    "Fetcher Repair": {"username": "fetcher", "password": "repair"},
    "File Archeologist": {"username": "history", "password": "files"},
    "File Fisher": {"username": "fisher", "password": "file"},
    "Hardware Monitor Live Kit": {"username": "hardware", "password": "lite"},
    "IT - full acces for user": {"username": "it", "password": "copy"},
    "Junk File Manager": {"username": "junk", "password": "manager"},
    "Knowledge Base": {"username": "kbmanager", "password": "knowladgebase"},
    "Knowledge Base Retro": {"username": "kbretro", "password": "kbretro"},
    "Launcher": {"username": "launcher", "password": "launcher"},
    "MD Viewer": {"username": "md", "password": "mdviewer"},
    "Multi File Editor": {"username": "multifile", "password": "editor"},
    "Network Monitoring": {"username": "traffic", "password": "network"},
    "Network Band Monitoring": {"username": "bandmonitoring", "password": "networking"},
    "Notepad": {"username": "notepad", "password": "notepad"},
    "Office Reader": {"username": "reader", "password": "office"},
    "Paint": {"username": "paint", "password": "paint"},
    "Password Generator": {"username": "passgen", "password": "passgen"},
    "Password Generator V2": {"username": "passgenV2", "password": "passgenV2"},
    "Password Manager": {"username": "password", "password": "manager"},
    "Pause Manager": {"username": "pausemanager", "password": "pauze"},
    "PDF Convertor to .docx": {"username": "convertorpdf", "password": "toword"},
    "PDF Tools": {"username": "pdftools", "password": "enjoyit"},
    "PDF Viewer": {"username": "pdfviewer", "password": "pdfviewer"},
    "Process Viewer - CPU & GPU": {"username": "process", "password": "viewer"},
    "Python IDE Pycharm Theme": {"username": "ide", "password": "pycharm"},
    "Python IDE VS Code Theme": {"username": "ide", "password": "vscode"},
    "Quiz Maker": {"username": "quizmaker", "password": "quizmaker"},
    "Quiz Test": {"username": "quiz", "password": "test"},
    "Recovery Tunnel": {"username": "recovery", "password": "tunnel"},
    "Rename Manager": {"username": "renamemanager", "password": "renamer"},
    "Safety Tool": {"username": "safe", "password": "checker"},
    "Screen Recorder": {"username": "screenrec", "password": "screenrec"},
    "Script Runner": {"username": "script", "password": "agent"},
    "Shell Integrator": {"username": "shell", "password": "integrator"},
    "SQL Editor": {"username": "sql", "password": "editor"},
    "System Resources": {"username": "system", "password": "realtime"},
    "Task Manager": {"username": "taskmanager", "password": "terminator"},
    "Terminal": {"username": "terminal", "password": "terminal"},
    "Text Replace & Find": {"username": "textreplace", "password": "textfind"},
    "Total Commander": {"username": "commander", "password": "total"},
    "User - copy files": {"username": "user", "password": "nopass"},
    "Whiteboard": {"username": "whiteboard", "password": "presentation"},
    "XML Editor - Config": {"username": "xml", "password": "editor"},
    "Zip Manager": {"username": "zipmanager", "password": "zipmngr"},
    "Zip Password Cracker": {"username": "zippass", "password": "wordsmith"}
}

tudor_credentials = {
    "Tudor it": {"username": "tudor", "password": "fosfataza"},
    "Tudor GUI Creator": {"username": "tudor", "password": "fosfatazaaa"},
    "Tudor Admin Launcher": {"username": "tudor", "password": "adminlauncher"},
    "Tudor VNC": {"username": "tudor", "password": "vnc"},
    "Tudor Explorer": {"username": "tudor", "password": "explorer"},
    "Tudor Assembly": {"username": "tudor", "password": "assembly"},
    "DEVCPP": {"username": "devcpp", "password": ""},
    "FOSFATAZA": {"username": "fosfataza", "password": ""},
    "RFLAGS": {"username": "RFLAGS", "password": ""},
    "DOSBOX": {"username": "dosbox", "password": ""},
    "w95dist": {"username": "w95dist", "password": ""},
}

def python_packages():
    from datetime import datetime

    def check_python_version():
        """
        Check Python version requirements
        """
        required_version = (3, 10, 8)
        current_version = sys.version_info[:3]
        
        print(f"Required Python version: {'.'.join(map(str, required_version))}")
        print(f"Current Python version: {'.'.join(map(str, current_version))}")
        
        if current_version < required_version:
            print(f"Warning: Python {'.'.join(map(str, required_version))} or higher is required!")
            print(f"Current version: {'.'.join(map(str, current_version))}")
            return False
        else:
            print("Python version requirement satisfied")
            return True

    def generate_pip_freeze():
        """
        Generate pip freeze.txt with exact content
        """
        content = """altgraph==0.17.4
annotated-types==0.6.0
anyio==4.3.0
asgiref==3.8.1
aspose-words==24.4.0
auto-py-to-exe==2.46.0
bottle==0.12.25
bottle-websocket==0.2.9
certifi==2024.2.2
cffi==1.16.0
chardet==5.2.0
charset-normalizer==3.3.2
colorama==0.4.6
comtypes==1.4.1
contourpy==1.2.0
cryptography==42.0.7
cycler==0.12.1
darkdetect==0.8.0
DateTime==5.4
dearpygui==1.11.1
Deprecated==1.2.14
distro==1.9.0
Django==5.2
Eel==0.16.0
et-xmlfile==1.1.0
exceptiongroup==1.2.0
fonttools==4.49.0
future==1.0.0
getmac==0.9.4
gevent==24.2.1
gevent-websocket==0.10.1
GPUtil==1.4.0
greenlet==3.0.3
h11==0.14.0
httpcore==1.0.4
httpx==0.27.0
humanize==4.9.0
icmplib==3.0.4
idna==3.6
kiwisolver==1.4.5
libpcap==1.11.0b8
lxml==5.2.1
matplotlib==3.8.3
MouseInfo==0.1.3
mplcursors==0.5.3
mysql-connector-python==8.3.0
numpy==1.26.4
opencv-python==4.9.0.80
openpyxl==3.1.2
packaging==23.2
pandas==2.2.2
pdfminer.six==20231228
pdfplumber==0.11.0
pefile==2023.2.7
pikepdf==8.15.1
pillow==10.3.0
pkg-about==1.1.5
plumbum==1.8.2
prettytable==3.10.0
psutil==5.9.8
py-cpuinfo==9.0.0
pyadl==0.1
pyasn1==0.6.0
PyAutoGUI==0.9.54
pycparser==2.21
pycryptodomex==3.20.0
pydantic==2.6.3
pydantic_core==2.16.3
pygame==2.5.2
PyGetWindow==0.0.9
Pygments==2.19.1
pyinstaller==6.8.0
pyinstaller-hooks-contrib==2024.7
PyMsgBox==1.0.9
PyMuPDF==1.24.2
PyMuPDFb==1.24.1
pyparsing==3.1.2
pypdfium2==4.29.0
pyperclip==1.8.2
PyQt5==5.15.11
PyQt5-Qt5==5.15.2
PyQt5_sip==12.15.0
PyQtWebEngine-Qt5==5.15.2
PyRect==0.2.0
PyScreeze==0.1.30
python-dateutil==2.9.0.post0
python-docx==1.1.2
python-pptx==1.0.2
pytweening==1.2.0
pytz==2024.1
pywifi==1.1.12
pywin32==306
pywin32-ctypes==0.2.2
reportlab==4.1.0
requests==2.31.0
rsa==4.9
scapy==2.5.0
setuptools==65.5.1
six==1.16.0
sniffio==1.3.1
sqlparse==0.5.3
tomli==2.0.1
tqdm==4.66.2
typing_extensions==4.10.0
tzdata==2024.1
urllib3==2.2.1
wcwidth==0.2.13
whichcraft==0.6.1
wrapt==1.16.0
XlsxWriter==3.2.0
zope.event==5.0
zope.interface==6.2
    """
        
        with open("pip_freeze.txt", "w", encoding="utf-8") as f:
            f.write(content.strip())
        
        print("Generated pip_freeze.txt")

    def generate_pip_list():
        """
        Generate pip list.txt with exact content
        """
        content = """Package                   Version
------------------------- -----------
altgraph                  0.17.4
annotated-types           0.6.0
anyio                     4.3.0
asgiref                   3.8.1
aspose-words              24.4.0
auto-py-to-exe            2.46.0
bottle                    0.12.25
bottle-websocket          0.2.9
certifi                   2024.2.2
cffi                      1.16.0
chardet                   5.2.0
charset-normalizer        3.3.2
colorama                  0.4.6
comtypes                  1.4.1
contourpy                 1.2.0
cryptography              42.0.7
cycler                    0.12.1
darkdetect                0.8.0
DateTime                  5.4
dearpygui                 1.11.1
Deprecated                1.2.14
distro                    1.9.0
Django                    5.2
Eel                       0.16.0
et-xmlfile                1.1.0
exceptiongroup            1.2.0
fonttools                 4.49.0
future                    1.0.0
getmac                    0.9.4
gevent                    24.2.1
gevent-websocket          0.10.1
GPUtil                    1.4.0
greenlet                  3.0.3
h11                       0.14.0
httpcore                  1.0.4
httpx                     0.27.0
humanize                  4.9.0
icmplib                   3.0.4
idna                      3.6
kiwisolver                1.4.5
libpcap                   1.11.0b8
lxml                      5.2.1
matplotlib                3.8.3
MouseInfo                 0.1.3
mplcursors                0.5.3
mysql-connector-python    8.3.0
numpy                     1.26.4
opencv-python             4.9.0.80
openpyxl                  3.1.2
packaging                 23.2
pandas                    2.2.2
pdfminer.six              20231228
pdfplumber                0.11.0
pefile                    2023.2.7
pikepdf                   8.15.1
pillow                    10.3.0
pip                       22.2.2
pkg-about                 1.1.5
plumbum                   1.8.2
prettytable               3.10.0
psutil                    5.9.8
py-cpuinfo                9.0.0
pyadl                     0.1
pyasn1                    0.6.0
PyAutoGUI                 0.9.54
pycparser                 2.21
pycryptodomex             3.20.0
pydantic                  2.6.3
pydantic_core             2.16.3
pygame                    2.5.2
PyGetWindow               0.0.9
Pygments                  2.19.1
pyinstaller               6.8.0
pyinstaller-hooks-contrib 2024.7
PyMsgBox                  1.0.9
PyMuPDF                   1.24.2
PyMuPDFb                  1.24.1
pyparsing                 3.1.2
pypdfium2                 4.29.0
pyperclip                 1.8.2
PyQt5                     5.15.11
PyQt5-Qt5                 5.15.2
PyQt5_sip                 12.15.0
PyQtWebEngine-Qt5         5.15.2
PyRect                    0.2.0
PyScreeze                 0.1.30
python-dateutil           2.9.0.post0
python-docx               1.1.2
python-pptx               1.0.2
pytweening                1.2.0
pytz                      2024.1
pywifi                    1.1.12
pywin32                   306
pywin32-ctypes            0.2.2
reportlab                 4.1.0
requests                  2.31.0
rsa                       4.9
scapy                     2.5.0
setuptools                65.5.1
six                       1.16.0
sniffio                   1.3.1
sqlparse                  0.5.3
tkterm                    0.0.0b2
tomli                     2.0.1
tqdm                      4.66.2
typing_extensions         4.10.0
tzdata                    2024.1
urllib3                   2.2.1
wcwidth                   0.2.13
whichcraft                0.6.1
wrapt                     1.16.0
XlsxWriter                3.2.0
zope.event                5.0
zope.interface            6.2
    """
        
        with open("pip_list.txt", "w", encoding="utf-8") as f:
            f.write(content.strip())
        
        print("Generated pip_list.txt")

    def mainpy():
        """
        Main function
        """
        print("=" * 50)
        print("Python Package Generator")
        print("=" * 50)
        print(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()
        
        # Check Python version
        version_ok = check_python_version()
        print()
        
        if not version_ok:
            response = input("Continue anyway? (y/N): ").lower().strip()
            if response != 'y':
                print("Exiting...")
                sys.exit(1)
            print()
        
        print(f"Full Python version: {sys.version}")
        print()
        
        # Generate files with exact content
        generate_pip_freeze()
        generate_pip_list()
        
        print()
        print("=" * 50)
        print("Process completed!")
        
        # Check if files were created
        files_created = []
        if os.path.exists("pip_freeze.txt"):
            files_created.append("pip_freeze.txt")
        if os.path.exists("pip_list.txt"):
            files_created.append("pip_list.txt")
        
        if files_created:
            print(f"Files created: {', '.join(files_created)}")
            #print(f"Total packages: 91")
        else:
            print("No files were created!")

    if __name__ == "__main__":
        try:
            mainpy()
        except KeyboardInterrupt:
            print("\n\nProcess interrupted by user.")
        except Exception as e:
            print(f"\nUnexpected error: {e}")
            sys.exit(1)

def login():
    global show_validation
    global adminT
    global c
    #global xx
    global trmn
    global passfig
    global passfig1
    global hardvar
    global screenvar
    global zipvar
    global compvar
    global pdfvar
    global replfindvar
    global testvarr
    global testvarr2
    global pdfvwvar
    global netwvar
    global crpvar2
    global aivar
    global notepadvar
    global paintvar
    global Adm1var
    global Adm2var
    global zippassvar
    global bkvar
    global rnvar
    global kbvar
    global passmngrr
    global pausevar
    global taskmngrvar
    global junkvar
    global wbpvar
    global cmvar
    global pingalivevar
    global launchervar
    global launchervar_admin
    global excelvar
    global readervar
    global hardmvar
    global fetchervar
    global shellvar
    global w95var
    global sqllvar
    global diagramvar
    global termadm
    global commandervar
    global calendarvar
    global allmonitorvar
    global eventvval
    global assemblyvar
    global kbbbvar
    global dev_mode
    global proc_varr
    global xmleditorvar
    global MDvar
    global archVar
    global expensevar
    global scrpVar
    global recoveryVarr
    global fishervar
    global muapdash
    global mindmapvar
    global multifilevar
    global safevar
    global trafficvar
    global dosboxvar
    global vscodevar
    global pdfviewervar
    
    # Verificăm dacă este activarea modului dezvoltator
    if username_entry.get().lower() == "devcpp" and password_entry.get() == "":
        username_entry.delete(0, tk.END)
        if not dev_mode:  # Activează doar dacă nu e deja activ
            toggle_dev_mode("normal")
        else:  # Dacă e deja activ, doar schimbă tipul
            combo_users['values'] = list(credentials.keys())
        return
    elif username_entry.get().lower() == "fosfataza" and password_entry.get() == "":
        python_packages()
        username_entry.delete(0, tk.END)
        if not dev_mode:  # Activează doar dacă nu e deja activ
            toggle_dev_mode("tudor")
        else:  # Dacă e deja activ, doar schimbă tipul
            combo_users['values'] = list(tudor_credentials.keys())
        return

    username = "user"
    password = "nopass"
    usernameAdm = "tudor"
    passwordAdm = "fosfataza"
    usernameAdm1 = "ide"
    passwordAdm1 = "pycharm"
    vscodeuser = "ide"
    vscodepass = "vscode"
    usernameAdm2 = "tudor"
    passwordAdm2 = "fosfatazaaa"
    username_support = "it"
    password_support = "copy"
    usertrmn = "terminal"
    passtermn = "terminal"
    userpass = "passgen"
    passpass = "passgen"
    userpass1 = "passgenV2"
    passpass1 = "passgenV2"
    userhard = "system"
    passhard = "realtime"
    userscreenrec = "screenrec"
    passscreenrec = "screenrec"
    userzip = "zipmanager"
    passzip = "zipmngr"
    usercomp = "comparator"
    passcomp = "comparator"
    userpdf = "convertorpdf"
    passpdf = "toword"
    userreplfind = "textreplace"
    passreplfind = "textfind"
    testuser = "quizmaker"
    testpass = "quizmaker"
    testuser2 = "quiz"
    testpass2 = "test"
    pdfvwuser = "pdftools"
    pdfvwpass = "enjoyit"
    netwuser = "bandmonitoring"
    netwpass = "networking"
    crpuser2 = "cryptoV2"
    crppass2 = "security"
    aiuser = "chatbot"
    aipass = "aichatbot"
    notepaduser = "notepad"
    notepadpass = "notepad"
    paintuser = "paint"
    paintpass = "paint"
    usernamezp = "zippass"
    passwordzp = "wordsmith"
    userbk = "backupmanager"
    passbk = "backupmngr"
    userrn = "renamemanager"
    passrn = "renamer"
    kbuser = "kbmanager"
    kbpass = "knowladgebase"
    passmngrruser = "password"
    passmngrrpass = "manager"
    pauseuser = "pausemanager"
    pausepass = "pauze"
    taskmngruser = "taskmanager"
    taskmngrpass = "terminator"
    junkuser = "junk"
    junkpass = "manager"
    wbpuser = "whiteboard"
    wbppass = "presentation"
    cmuser = "contact"
    cmpass = "manager"
    pingaliveuser = "check"
    pingalivepass = "devices"
    launcheruser = "launcher"
    launcherpass = "launcher"
    launcheruseradmin = "tudor"
    launcherpassadmin = "adminlauncher"
    exceluser = "excel"
    excelpass = "lite"
    readeruser = "reader"
    readerpass = "office"
    hardmuser = "hardware"
    hardmpass = "lite"
    fetcheruser = "fetcher"
    fetcherpass = "repair"
    shelluser = "shell"
    shellpass = "integrator"
    w95user = "tudor"
    w95pass = "vnc"
    sqlluser = "sql"
    sqllpass = "editor"
    diagramuser = "diagram"
    diagrampass = "beta"
    termadmuser = "tudor"
    termadmpass = "explorer"
    commanderuser = "commander"
    commanderpass = "total"
    calendaruser = "calendar"
    calendarpass = "calendar"
    allmonitoruser = "alert"
    allmonitorpass = "monitor"
    eventvuser = "eventviewer"
    eventvpass = "eventviewer"
    assemblyuser = "tudor"
    assemblypass = "assembly"
    kbbbuser = "kbretro"
    kbbbpass = "kbretro"
    procv_user = "process"
    procv_pass = "viewer"
    xmluserr = "xml"
    xmlpasss = "editor"
    MDuser = "md"
    MDpass = "mdviewer"
    archUser = "history"
    archPass = "files"
    expenseuser = "expense"
    expensepass = "tracker"
    scrpUser = "script"
    scrpPass = "agent"
    recoveryUserr = "recovery"
    recoveryPasss = "tunnel"
    fisheruser = "fisher"
    fisherpass = "file"
    mindmapuser = "mindmap"
    mindmappass = "diagram"
    multifileuser = "multifile"
    multifilepass = "editor"
    safeuser = "safe"
    safepass = "checker"
    trafficuser = "traffic"
    trafficpass = "network"
    pdfvieweruser = "pdfviewer"
    pdfviewerpass = "pdfviewer"

    if username_entry.get()==usernameAdm and password_entry.get()==passwordAdm:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = True
        adminT = True
        c = 3
        #xx = 2
        windowlogin.destroy()
        
    elif username_entry.get()==username and password_entry.get()==password:
        messagebox.showinfo(title="Login Success", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        show_validation = False
        adminT = False
        windowlogin.destroy()
    elif username_entry.get()==username_support and password_entry.get()==password_support:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        show_validation = True
        adminT = False
        #xx = 2
        windowlogin.destroy()
    elif username_entry.get()==usertrmn and password_entry.get()==passtermn:
        show_validation = False
        adminT = False
        trmn = 2
        windowlogin.destroy()
    elif username_entry.get()==userpass and password_entry.get()==passpass:
        show_validation = False
        adminT = False
        passfig = 4
        windowlogin.destroy()
    elif username_entry.get()==userpass1 and password_entry.get()==passpass1:
        show_validation = False
        adminT = False
        passfig1 = 5
        windowlogin.destroy()
    elif username_entry.get()==userhard and password_entry.get()==passhard:
        show_validation = False
        adminT = False
        hardvar = 6
        windowlogin.destroy()
    elif username_entry.get()==userscreenrec and password_entry.get()==passscreenrec:
        show_validation = False
        adminT = False
        screenvar = 7
        windowlogin.destroy()
    elif username_entry.get()==userzip and password_entry.get()==passzip:
        show_validation = False
        adminT = False
        zipvar = 8
        windowlogin.destroy()
    elif username_entry.get()==usercomp and password_entry.get()==passcomp:
        show_validation = False
        adminT = False
        compvar = 9
        windowlogin.destroy()
    elif username_entry.get()==userpdf and password_entry.get()==passpdf:
        show_validation = False
        adminT = False
        pdfvar = 10
        windowlogin.destroy()
    elif username_entry.get()==userreplfind and password_entry.get()==passreplfind:
        show_validation = False
        adminT = False
        replfindvar = 11
        windowlogin.destroy()
    elif username_entry.get()==testuser and password_entry.get()==testpass:
        show_validation = False
        adminT = False
        testvarr = 12
        windowlogin.destroy()
    elif username_entry.get()==testuser2 and password_entry.get()==testpass2:
        show_validation = False
        adminT = False
        testvarr2 = 122
        windowlogin.destroy()
    elif username_entry.get()==pdfvwuser and password_entry.get()==pdfvwpass:
        show_validation = False
        adminT = False
        pdfvwvar = 13
        windowlogin.destroy()
    elif username_entry.get()==netwuser and password_entry.get()==netwpass:
        show_validation = False
        adminT = False
        netwvar = 14
        windowlogin.destroy()
    elif username_entry.get()==crpuser2 and password_entry.get()==crppass2:
        show_validation = False
        adminT = False
        crpvar2 = 155
        windowlogin.destroy()
    elif username_entry.get()==aiuser and password_entry.get()==aipass:
        show_validation = False
        adminT = False
        aivar = 20
        windowlogin.destroy()
    elif username_entry.get()==notepaduser and password_entry.get()==notepadpass:
        show_validation = False
        adminT = False
        notepadvar = 21
        windowlogin.destroy()
    elif username_entry.get()==paintuser and password_entry.get()==paintpass:
        show_validation = False
        adminT = False
        paintvar = 22
        windowlogin.destroy()
    elif username_entry.get()==usernameAdm1 and password_entry.get()==passwordAdm1:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        # Definirea numele fisierului pentru salvarea cheii
        #FILE_NAME = "product_key.txt"
        # Definirea cheii de validare
        #KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Salvarea cheii în fisier text
        #with open(FILE_NAME, "w") as file:
            #file.write(KEY)
        show_validation = False
        adminT = False
        Adm1var = 30
        windowlogin.destroy()
    elif username_entry.get()==usernameAdm2 and password_entry.get()==passwordAdm2:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        Adm2var = 40
        windowlogin.destroy()
    elif username_entry.get()==usernamezp and password_entry.get()==passwordzp:
        show_validation = False
        adminT = False
        zippassvar = 60
        windowlogin.destroy()
    elif username_entry.get()==userbk and password_entry.get()==passbk:
        show_validation = False
        adminT = False
        bkvar = 700
        windowlogin.destroy()
    elif username_entry.get()==userrn and password_entry.get()==passrn:
        show_validation = False
        adminT = False
        rnvar = 710
        windowlogin.destroy()
    elif username_entry.get()==kbuser and password_entry.get()==kbpass:
        show_validation = False
        adminT = False
        kbvar = 1000
        windowlogin.destroy()
    elif username_entry.get()==passmngrruser and password_entry.get()==passmngrrpass:
        show_validation = False
        adminT = False
        passmngrr = 2000
        windowlogin.destroy()
    elif username_entry.get()==pauseuser and password_entry.get()==pausepass:
        show_validation = False
        adminT = False
        pausevar = 10000
        windowlogin.destroy()
    elif username_entry.get()==taskmngruser and password_entry.get()==taskmngrpass:
        show_validation = False
        adminT = False
        taskmngrvar = 1000000
        windowlogin.destroy()
    elif username_entry.get()==junkuser and password_entry.get()==junkpass:
        show_validation = False
        adminT = False
        junkvar = 77777
        windowlogin.destroy()
    elif username_entry.get()==wbpuser and password_entry.get()==wbppass:
        show_validation = False
        adminT = False
        wbpvar = 123456789
        windowlogin.destroy()
    elif username_entry.get()==cmuser and password_entry.get()==cmpass:
        show_validation = False
        adminT = False
        cmvar = 3333
        windowlogin.destroy()
    elif username_entry.get()==pingaliveuser and password_entry.get()==pingalivepass:
        show_validation = False
        adminT = False
        pingalivevar = 5566
        windowlogin.destroy()
    elif username_entry.get()==launcheruser and password_entry.get()==launcherpass:
        show_validation = False
        adminT = False
        launchervar = 1990
        windowlogin.destroy()
    elif username_entry.get()==launcheruseradmin and password_entry.get()==launcherpassadmin:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        launchervar_admin = 1991
        windowlogin.destroy()
    elif username_entry.get()==exceluser and password_entry.get()==excelpass:
        show_validation = False
        adminT = False
        excelvar = 1992
        windowlogin.destroy()
    elif username_entry.get()==readeruser and password_entry.get()==readerpass:
        show_validation = False
        adminT = False
        readervar = 1993
        windowlogin.destroy()
    elif username_entry.get()==hardmuser and password_entry.get()==hardmpass:
        show_validation = False
        adminT = False
        hardmvar = 1994
        windowlogin.destroy()
    elif username_entry.get()==fetcheruser and password_entry.get()==fetcherpass:
        show_validation = False
        adminT = False
        fetchervar = 1995
        windowlogin.destroy()
    elif username_entry.get()==shelluser and password_entry.get()==shellpass:
        show_validation = False
        adminT = False
        shellvar = 1996
        windowlogin.destroy()
    elif username_entry.get()==w95user and password_entry.get()==w95pass:
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        w95var = 1997
        windowlogin.destroy()
    elif username_entry.get()=="w95dist" and password_entry.get()=="":
        #messagebox.showinfo(title="Login Success", message="You successfully logged in.")
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        w95var = 1997
        windowlogin.destroy()
    elif username_entry.get()==sqlluser and password_entry.get()==sqllpass:
        show_validation = False
        adminT = False
        sqllvar = 22222
        windowlogin.destroy()
    elif username_entry.get()==diagramuser and password_entry.get()==diagrampass:
        show_validation = False
        adminT = False
        diagramvar = 2345432
        windowlogin.destroy()
    elif username_entry.get()==termadmuser and password_entry.get()==termadmpass:
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        termadm = 6745
        windowlogin.destroy()
    elif username_entry.get()==commanderuser and password_entry.get()==commanderpass:
        show_validation = False
        adminT = False
        commandervar = 88888888
        windowlogin.destroy()
    elif username_entry.get()==calendaruser and password_entry.get()==calendarpass:
        show_validation = False
        adminT = False
        calendarvar = 999000
        windowlogin.destroy()
    elif username_entry.get()==allmonitoruser and password_entry.get()==allmonitorpass:
        show_validation = False
        adminT = False
        allmonitorvar = 999001
        windowlogin.destroy()
    elif username_entry.get()==eventvuser and password_entry.get()==eventvpass:
        show_validation = False
        adminT = False
        eventvval = 44445555
        windowlogin.destroy()
    elif username_entry.get()==assemblyuser and password_entry.get()==assemblypass:
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        assemblyvar = 333333333
        windowlogin.destroy()
    elif username_entry.get()==kbbbuser and password_entry.get()==kbbbpass:
        show_validation = False
        adminT = False
        kbbbvar = 5189
        windowlogin.destroy()
    elif username_entry.get()==procv_user and password_entry.get()==procv_pass:
        show_validation = False
        adminT = False
        proc_varr = 67766776
        windowlogin.destroy()
    elif username_entry.get()==xmluserr and password_entry.get()==xmlpasss:
        show_validation = False
        adminT = False
        xmleditorvar = 111444555
        windowlogin.destroy()
    elif username_entry.get()==MDuser and password_entry.get()==MDpass:
        show_validation = False
        adminT = False
        MDvar = 777666111
        windowlogin.destroy()
    elif username_entry.get()==archUser and password_entry.get()==archPass:
        show_validation = False
        adminT = False
        archVar = 777666012
        windowlogin.destroy()
    elif username_entry.get()==expenseuser and password_entry.get()==expensepass:
        show_validation = False
        adminT = False
        expensevar = 777666013
        windowlogin.destroy()
    elif username_entry.get()==scrpUser and password_entry.get()==scrpPass:
        show_validation = False
        adminT = False
        scrpVar = 777666014
        windowlogin.destroy()
    elif username_entry.get()==recoveryUserr and password_entry.get()==recoveryPasss:
        show_validation = False
        adminT = False
        recoveryVarr = 777666090
        windowlogin.destroy()
    elif username_entry.get()==fisheruser and password_entry.get()==fisherpass:
        show_validation = False
        adminT = False
        fishervar = 777666091
        windowlogin.destroy()
    elif username_entry.get() == "RFLAGS" and password_entry.get() == "":
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        muapdash = 777666092
        windowlogin.destroy()
    elif username_entry.get()==mindmapuser and password_entry.get()==mindmappass:
        show_validation = False
        adminT = False
        mindmapvar = 7776660999
        windowlogin.destroy()
    elif username_entry.get()==multifileuser and password_entry.get()==multifilepass:
        show_validation = False
        adminT = False
        multifilevar = 77766609999
        windowlogin.destroy()
    elif username_entry.get()==safeuser and password_entry.get()==safepass:
        show_validation = False
        adminT = False
        safevar = 444555000888
        windowlogin.destroy()
    elif username_entry.get()==trafficuser and password_entry.get()==trafficpass:
        show_validation = False
        adminT = False
        trafficvar = 333344440099
        windowlogin.destroy()
    elif username_entry.get()=="dosbox" and password_entry.get()=="":
        FOLDER_NAME = "Serial"
        FILE_NAME = "product_key.lic95"
        # Definirea cheii de validare
        KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")
        # Calea completă către fișier în folderul Serial
        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
        # Salvarea cheii în fisier text
        with open(file_path, "w") as file:
            file.write(KEY)
        show_validation = False
        adminT = False
        dosboxvar = 3333444400999
        windowlogin.destroy()
    elif username_entry.get()==vscodeuser and password_entry.get()==vscodepass:
        show_validation = False
        adminT = False
        vscodevar = 999955550000
        windowlogin.destroy()
    elif username_entry.get()==pdfvieweruser and password_entry.get()==pdfviewerpass:
        show_validation = False
        adminT = False
        pdfviewervar = 3333444400997676
        windowlogin.destroy()
    #if (username_entry.get()!=usernameAdm and password_entry.get()!=passwordAdm) and (username_entry.get()!=username and password_entry.get()!=password):
    else:
        messagebox.showerror(title="Error", message="Invalid login.")

    # Verifica daca utilizatorul este autentificat ca "tudor"
    #if show_validation and username_entry.get() == "tudor":
        #adminT = True
    #else: 
        #adminT = False

# Funcția pentru completarea automată când se selectează o intrare din combobox
def on_combo_selected(event):
    selected = combo_users.get()
    all_credentials = {**credentials, **tudor_credentials}
    
    if selected in all_credentials:
        username_entry.delete(0, tk.END)
        password_entry.delete(0, tk.END)
        username_entry.insert(0, all_credentials[selected]["username"])
        password_entry.insert(0, all_credentials[selected]["password"])
        
framelogin = tk.Frame(bg='gray20')

# Crearea combobox-ului pentru selecția utilizatorilor
combo_label = tk.Label(framelogin, text="Select user", bg='gray20', fg="lime green", font=("Fixedsys", 16, "bold"))
combo_users = ttk.Combobox(framelogin, font=("Fixedsys", 14, "bold"), width=25, state="disabled")
combo_users['values'] = list(credentials.keys())
combo_users.set("Only for Dev mode")  # Textul care apare dar nu e în listă
combo_users.bind("<<ComboboxSelected>>", on_combo_selected)

# Creating widgets
login_label = tk.Label(framelogin, text="Login", bg='gray20', fg="cyan", font=("Fixedsys", 30, "italic bold"))
#info_label = tk.Label(framelogin, text="This software was written in Python and C++ and precompiled into a single file.", bg="gray20", fg="yellow", font=("Fixedsys", 14, "italic"))
username_label = tk.Label(framelogin, text="Username", bg='gray20', fg="lime green", font=("Fixedsys", 16, "bold"))
username_entry = tk.Entry(framelogin, font=("Fixedsys", 16, "bold"), bg="gray40", fg="cyan", bd=10, insertbackground="lime green")
password_entry = tk.Entry(framelogin, show="*", font=("Fixedsys", 16, "bold"), bg="gray40", fg="cyan", bd=10, insertbackground="lime green")
password_label = tk.Label(framelogin, text="Password", bg='gray20', fg="lime green", font=("Fixedsys", 16, "bold"))
login_button = tk.Button(framelogin, text="Login", bg="black", fg="cyan", bd=10, font=("Fixedsys", 16), command=login)

# Status label pentru a afișa starea modului dezvoltator
status_label = tk.Label(framelogin, text="Dev Mode: INACTIVE", bg='gray20', fg="red", font=("Fixedsys", 12, "bold"))

# Bind the <Return> key to the login function for both entry fields
username_entry.bind("<Return>", on_enter_press)
password_entry.bind("<Return>", on_enter_press)

# Placing widgets on the screen
login_label.grid(row=0, column=0, columnspan=2, sticky="news", pady=20)

#info_label.grid(row=1, column=0)

# Adăugăm combobox-ul înainte de câmpurile de login
combo_label.grid(row=1, column=0, pady=10)
combo_users.grid(row=1, column=1, pady=10, padx=10, sticky="w")

username_label.grid(row=2, column=0)
username_entry.grid(row=2, column=1, pady=20, padx=10)
password_label.grid(row=3, column=0)
password_entry.grid(row=3, column=1, pady=20, padx=10)
login_button.grid(row=4, column=0, columnspan=2, pady=30)

# Adăugăm statusbar-ul în partea de jos
status_label.grid(row=5, column=0, columnspan=2, pady=10)

framelogin.pack()

windowlogin.mainloop()



def main1():
    messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
    global adminT
    global c
    if key_is_valid == False:
        validation.destroy()  # Închide fereastra de validare
    class FileCopyApp:
        def __init__(self, root):
            self.root = root
            self.root.title("Copy App")
            self.root.geometry("400x400")
            self.root.config(bg="gray20")

            # Directorul destinație
            self.current_user = os.getenv('USERNAME')
            self.destination_path = rf'C:\KIT'

            # Verifică dacă calea de destinație există
            if not os.path.exists(self.destination_path):
                try:
                    # Creează calea de destinație dacă nu există
                    os.makedirs(self.destination_path)
                    print("Director successfully created:", self.destination_path)
                except OSError as e:
                    print("Error creating directory:", e)

            # Dicționarul cu programe și direcțiile lor sursă
            self.program_paths = {}
            
            # Deschide fișierul pentru citire
            with open("paths.txt", "r") as file:
                for line in file:
                    key, value = line.strip().split(":")
                    self.program_paths[key.strip()] = value.strip()

            # Frame-uri pentru fiecare jumătate a ferestrei
            self.left_frame = tk.Frame(root, bg="gray20")
            self.left_frame.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.BOTH, expand=True)

            self.right_frame = tk.Frame(root, bg="gray20")
            self.right_frame.pack(side=tk.RIGHT, padx=5, pady=5, fill=tk.Y)

            # Canvas pentru lista de programe cu scrollbar
            self.canvas = tk.Canvas(self.left_frame, bg="gray20", highlightthickness=0)
            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.scrollbar = ttk.Scrollbar(self.right_frame, orient="vertical", command=self.canvas.yview)
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.canvas.configure(yscrollcommand=self.scrollbar.set)
            self.canvas.bind('<Configure>', self.on_canvas_configure)

            self.program_frame = tk.Frame(self.canvas, bg="gray20")
            self.canvas.create_window((0, 0), window=self.program_frame, anchor='nw')

            # Funcție pentru actualizarea culorii textului în funcție de starea checkbox-ului
            def update_fg_color(*args):
                for program, var in self.program_vars.items():
                    if var.get() == 1:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="cyan")
                    else:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="white")

            # Checkbox-uri și progres bar-uri pentru programe
            self.program_vars = {}
            self.program_checkboxes = {}
            self.progress_bars = {}

            # Frame pentru butoanele de selecție a checkbox-urilor
            self.checkbox_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.checkbox_button_frame.pack(pady=10, padx=10)

            # Încarcă profilele și creează butoanele
            self.load_profiles_and_create_buttons()

            col_count = 2  # Numărul de coloane dorit
            row_count = -(-len(self.program_paths) // col_count)  # Calculul numărului de rânduri necesare
            program_index = 0  # Variabilă pentru a ține evidența indexului programului
         
            for i in range(row_count):
                for j in range(col_count):
                    if program_index >= len(self.program_paths):
                        break
                    program = list(self.program_paths.keys())[program_index]
                    var = tk.IntVar()
                    chk = tk.Checkbutton(self.program_frame, text=program, variable=var, bg="gray20", selectcolor="green", activebackground="pale green")
                    chk.grid(row=i, column=j*2, sticky="w")
                    self.program_vars[program] = var
                    self.program_checkboxes[program] = chk
                    chk.config(fg="white")
                    var.trace_add("write", update_fg_color)
         
                    # Creează progres bar-ul pentru fiecare program și îl pune sub checkbox
                    self.progress_bars[program] = ttk.Progressbar(self.program_frame, orient="horizontal", length=200, mode="determinate", style="custom.Horizontal.TProgressbar")
                    self.progress_bars[program].grid(row=i, column=j*2+1, sticky="ew", padx=10, pady=2)
         
                    program_index += 1
         
            # Stilizare progres bar personalizat
            self.style = ttk.Style()
            self.style.theme_use('default')
            self.style.configure("custom.Horizontal.TProgressbar", troughcolor='gray', background='green', borderwidth=0)

            # Frame pentru butonul de copiere
            self.copy_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.copy_button_frame.pack(pady=10, padx=10)

            # Plasează butonul de copiere direct în self.right_frame
            self.copy_button = tk.Button(self.right_frame, text="Copy Files", command=self.copy_files, bg="cyan", fg="black", bd=6)
            self.copy_button.pack(pady=10, padx=10)

            # Buton stergere campuri checkbox
            self.delete_button = tk.Button(self.right_frame, text="Delete checkboxes", command=self.delete_checkboxes, bg="red", fg="black", bd=6)
            self.delete_button.pack(pady=10, padx=10)

            self.bandmonitoring_button = tk.Button(self.right_frame, text="Network Console", command=self.band_network_monitoring, bg="gray40", fg="lime green", bd=5)
            self.bandmonitoring_button.pack(pady=5)
                
            # Butonul pentru a ieși din aplicație
            self.button_exit = tk.Button(self.checkbox_button_frame, text="EXIT", command=self.exit_application, bg="red", fg="white", bd=10)
            self.button_exit.pack(pady=20)

            self.last_received = 0
            self.last_sent = 0
            self.last_total = 0
            self.running = False

        def load_profiles_and_create_buttons(self):
            # Încarcă profilurile din JSON
            with open("profiles.json", "r") as f:
                self.profiles = json.load(f)

            # Creează butoanele pentru fiecare profil
            for profile_name in self.profiles:
                button = tk.Button(self.checkbox_button_frame, text=profile_name,
                                command=lambda p=profile_name: self.select_profile_checkboxes(p),
                                bg="gray40", fg="white", bd=1)
                button.pack(pady=5, padx=10)

        def select_profile_checkboxes(self, profile_name):
            # Resetează toate checkbox-urile
            for program in self.program_vars:
                self.program_vars[program].set(0)

            # Resetează barele de progres
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0

            # Resetează textul checkbox-urilor care se termină cu " (done)"
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                if current_text.endswith(" (done)"):
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)

            # Verifică dacă profilul există
            if profile_name in self.profiles:
                profile_checkboxes = self.profiles[profile_name]["checkboxes"]
                for program in profile_checkboxes:
                    if program in self.program_vars:
                        self.program_vars[program].set(1)
    ##############################################################################################################################################################    
                
         
        def exit_application(self):
            if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
                root.destroy()
         
    ###############################################################################
        def band_network_monitoring(self):
            def update_data():
                while self.running:
                    bytes_received = psutil.net_io_counters().bytes_recv
                    bytes_sent = psutil.net_io_counters().bytes_sent
                    bytes_total = bytes_received + bytes_sent
                        
                    new_received = bytes_received - self.last_received if hasattr(self, 'last_received') else 0
                    new_sent = bytes_sent - self.last_sent if hasattr(self, 'last_sent') else 0
                    new_total = bytes_total - self.last_total if hasattr(self, 'last_total') else 0
                  
                    mb_new_received = new_received / 1024 / 1024
                    mb_new_sent = new_sent / 1024 / 1024
                    mb_new_total = new_total / 1024 / 1024
                        
                    # Actualizează textul în text area cu noile date
                    text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                    text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                        
                    # Salvează datele în fișier
                    with open("network_data.txt", "a") as file:
                        file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        
                    print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                        
                    self.last_received = bytes_received
                    self.last_sent = bytes_sent
                    self.last_total = bytes_total
                        
                    time.sleep(1)

            def start():
                self.running = True
                # Șterge conținutul text area-ului la fiecare pornire
                text_area.delete(1.0, tk.END)
                # Crează un thread nou pentru actualizarea datelor
                data_thread = threading.Thread(target=update_data)
                data_thread.start()

            def stop():
                self.running = False

            # Crează fereastra
            monitorband = tk.Toplevel()
            monitorband.title("Network Console")
            monitorband.resizable(False, False)
            monitorband.config(bg="gray20")
            #image_icon44 = PhotoImage(file = "img/networklogo.png")
            #monitorband.iconphoto(False, image_icon44)

            # Creează un text area cu culoare de fundal și text personalizate
            text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
            text_area.pack(expand=True, fill=tk.BOTH)

            # Buton pentru pornirea monitorizării
            start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
            start_button.pack()

            # Buton pentru oprirea monitorizării
            stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
            stop_button.pack()

            # Inițializare variabile
            self.last_received = psutil.net_io_counters().bytes_recv
            self.last_sent = psutil.net_io_counters().bytes_sent
            self.last_total = self.last_received + self.last_sent
            self.running = False

            # Pornirea buclei principale a interfeței grafice
            #monitorband.mainloop()
    ###############################################################################
         
        def delete_checkboxes(self):
            for program in self.program_vars:
                self.program_vars[program].set(0)
            #self.program_vars[""].set(0)
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                # Verificăm dacă textul se termină cu " (done)"
                if current_text.endswith(" (done)"):
                    # Eliminăm ultimele 77 caractere din textul curent și actualizăm textul checkbox-ului
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)
         
        def on_canvas_configure(self, event):
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
         
        def copy_files(self):
            self.copy_button.config(state="disabled")  # Dezactivează butonul de copiere
            #self.select_Director_button.config(state="disabled")
            selected_programs = [program for program, var in self.program_vars.items() if var.get() == 1]
            if not selected_programs:
                messagebox.showwarning("No program selected", "Please select at least one program to copy the files.")
                self.copy_button.config(state="normal")  # Activează butonul de copiere
                #self.select_Director_button.config(state="normal")
                return
         
            # Funcție pentru a actualiza textul checkbox-urilor cu "done"
            def update_checkbox_text():
                for program in selected_programs:
                    checkbox = self.program_checkboxes[program]
                    checkbox.config(text=program + " (done)")
         
            # Funcție pentru a realiza copierea fișierelor într-un fir de execuție separat
            def copy_files_thread():
                try:
                    for program in selected_programs:
                        program_source = self.program_paths[program]
                        if os.path.exists(program_source):
                            # Crează un director pentru a stoca fișierele copiate
                            save_directory = os.path.join(self.destination_path, os.path.basename(program_source))
                            os.makedirs(save_directory, exist_ok=True)
                            if os.path.isdir(program_source):
                                # Dacă sursa este un director, copiază întregul director
                                total_files = sum(len(files) for _, _, files in os.walk(program_source))  # Calculăm numărul total de fișiere
                                files_copied = 0  # Inițializăm contorul pentru fișierele copiate
                                for root, dirs, files in os.walk(program_source):
                                    for dir in dirs:
                                        src = os.path.join(root, dir)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        os.makedirs(dest, exist_ok=True)
                                    for file in files:
                                        src = os.path.join(root, file)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        # Verificăm dacă fișierul de destinație există deja
                                        if not os.path.exists(dest):
                                            shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                        # Actualizăm progresul
                                        files_copied += 1
                                        progress_value = (files_copied / total_files) * 100
                                        self.progress_bars[program]["value"] = progress_value
                                        self.root.update_idletasks()  # Actualizează interfața grafică
         
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                            else:
                                # Dacă sursa este un fișier, copiază doar fișierul
                                total_files = 1  # Avem un singur fișier de copiat
                                files_copied = 0
                                file_name = os.path.basename(program_source)
                                src = program_source
                                dest = os.path.join(save_directory, file_name)
                                # Verificăm dacă fișierul de destinație există deja
                                if not os.path.exists(dest):
                                    shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                files_copied += 1
                                progress_value = (files_copied / total_files) * 100
                                self.progress_bars[program]["value"] = progress_value
                                self.root.update_idletasks()  # Actualizează interfața grafică
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                    # Afisăm mesajul de finalizare a copierii
                    self.root.after(0, self.show_copy_success)
        
                except Exception as ex:
                    # Afisăm mesaj de eroare dacă apare o excepție
                    self.root.after(0, lambda e=ex: self.show_copy_error(e))
        
                finally:
                    # Activează butonul de copiere după finalizarea copierii
                    self.root.after(0, self.enable_copy_button)
         
            # Pornim firul de execuție pentru copierea fișierelor
            threading.Thread(target=copy_files_thread).start()
         
         
        def show_copy_success(self):
            messagebox.showinfo("Copy completed", "The files have been successfully copied.")
         
        def show_copy_error(self, error_message):
            messagebox.showerror("Error copying", f"An error occurred while copying the files: {str(error_message)}")
         
        def enable_copy_button(self):
            self.copy_button.config(state="normal")
         
    def browse_folder():
        folder_path = filedialog.askdirectory()
        if folder_path:
            folder_path = folder_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("folder_paths.txt", "a") as file:
                file.write(folder_path + "\n")
         
    def browse_file():
        file_path = filedialog.askopenfilename()
        if file_path:
            file_path = file_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("file_paths.txt", "a") as file:
                file.write(file_path + "\n")
         
    def copy_file():
        with open("file_paths.txt", "r") as file:
            file_paths = file.readlines()
        for file_path in file_paths:
            file_path = file_path.strip()  # Eliminăm caracterele de nouă linie și spații suplimentare
            shutil.copy2(file_path, save_location.get())
         
    def copy_folder():
        with open("folder_paths.txt", "r") as file:
            folder_paths = file.readlines()
        for folder_path in folder_paths:
            folder_path = folder_path.strip()
            save_path = os.path.join(save_location.get(), os.path.basename(folder_path))
            try:
                shutil.copytree(folder_path, save_path)
            except PermissionError:
                messagebox.showerror("Error", "Access to the source folder is denied.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {str(e)}")
         
    def update_buttons_state():
        if save_location.get():
            button_copy_file.config(state="normal")
            button_copy_folder.config(state="normal")
        else:
            button_copy_file.config(state="disabled")
            button_copy_folder.config(state="disabled")
         
    def select_save_location():
        save_location.set(filedialog.askdirectory())
        update_buttons_state()
         
    def open_copy_window():
        global button_copy_file, button_copy_folder
        copy_window = tk.Toplevel(root)
        copy_window.title("Copy Files/Folders")
        copy_window.config(bg="gray20")  # Setare culoare fundal gri închis
        copy_window.resizable(False, False)
        #image_icon46 = PhotoImage(file = "img/downloadlogo.png")
        #copy_window.iconphoto(False, image_icon46)
         
        frame = tk.Frame(copy_window)
        frame.pack(padx=20, pady=20)
        
        button_copy_file = tk.Button(frame, text="Copy Files", command=copy_file, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_file.pack(padx=10, pady=5)
         
        button_copy_folder = tk.Button(frame, text="Copy Folders", command=copy_folder, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_folder.pack(padx=10, pady=5)
         
        button_select_location = tk.Button(frame, text="Select Save Location", command=select_save_location, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_select_location.pack(padx=10, pady=5)
         
        update_buttons_state()
         
        copy_window.mainloop()
         
    def open_file_explorer_window():
        file_explorer_window = tk.Toplevel(root)
        file_explorer_window.title("Browse in File Explorer")
        file_explorer_window.config(bg="gray20")  # Setare culoare fundal gri închis
        file_explorer_window.resizable(False, False)
        #image_icon47 = PhotoImage(file = "img/downloadlogo.png")
        #file_explorer_window.iconphoto(False, image_icon47)
         
        frame = tk.Frame(file_explorer_window, bg="gray20")  # Setare culoare fundal gri închis
        frame.pack(padx=20, pady=20)
         
        button_folder = tk.Button(frame, text="Select a Folder", command=browse_folder, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordura
        button_folder.pack(padx=10, pady=5)
         
        button_file = tk.Button(frame, text="Select a File", command=browse_file, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_file.pack(padx=10, pady=5)
         
        button_open_copy_window = tk.Button(frame, text="Open Copy Window", command=open_copy_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_open_copy_window.pack(padx=10, pady=5)
         
    def open_file_copy_app_window():
        file_copy_app_window = tk.Toplevel(root)
        file_copy_app_window.title("Copy App Defaults")
        file_copy_app_window.config(bg="gray20")  # Setare culoare fundal gri închis
        # Dezactivarea posibilității de redimensionare a ferestrei
        file_copy_app_window.resizable(False, False)
        #image_icon48 = PhotoImage(file = "img/downloadlogo.png")
        #file_copy_app_window.iconphoto(False, image_icon48)
        # Maximizarea ferestrei
        file_copy_app_window.state("zoomed")
        app = FileCopyApp(file_copy_app_window)
     
    def ExecuteIPandMAC():
        import re
        IPMAC = tk.Toplevel(root)
        IPMAC.config(bg='gray20')
        IPMAC.geometry('340x230')
        IPMAC.title("Get IP & MAC")
        IPMAC.resizable(False, False)
     
        def ip():
            hostname = socket.gethostname()
            ip_add = socket.gethostbyname(hostname)
            showinfo("IP Adress", f"IP Adress: {ip_add}")
            print("IP Adress: ", ip_add)
     
        def mac():
            mac_add = getmac.get_mac_address()
            showinfo("MAC Adress", f"MAC Adress: {mac_add}")
            print("MAC Adress: ", mac_add)
        
        def get_mac_address1(ip_address):
            try:
                # Run the arp command
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
                
                # Extract the ARP table
                arp_output = result.stdout
                
                # Search for the IP address in the ARP table
                match = re.search(rf'{ip_address}[\s]+([\w-]+)', arp_output)
                
                if match:
                    return match.group(1)
                else:
                    return None
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {str(e)}")
                return None

        def get_mac1():
            ip_address = ip_entry.get()
            mac_address = get_mac_address1(ip_address)
            if mac_address:
                result_label.config(text=f"The MAC address of {ip_address} is {mac_address}")
            else:
                result_label.config(text=f"MAC address for {ip_address} not found")

        def check_entry(event):
            if ip_entry.get() != "":
                find_button.config(state="normal")
            else:
                find_button.config(state="disabled")
     
        ip_button = tk.Button(IPMAC, text="Show IP Adress", bg="gray40", fg="lime green", font=('times new roman', 16, 'bold'), bd=3, command=ip)
        ip_button.pack()
     
        mac_button = tk.Button(IPMAC, text="Show MAC Adress", bg="gray40", fg="lime green", font=('times new roman', 16, 'bold'), bd=3, command=mac)
        mac_button.pack()
        
        # Create and pack widgets
        ip_label = tk.Label(IPMAC, text="Enter IP Address:", bg="gray20", fg="lime green", font=('times new roman', 16, 'bold'))
        ip_label.pack()

        ip_entry = tk.Entry(IPMAC, bg="gray20", fg="#ccff66", font=('times new roman', 16, 'bold'), insertbackground = "cyan")
        ip_entry.pack()
        ip_entry.bind("<KeyRelease>", check_entry)  # legăm funcția de verificare la evenimentul KeyRelease

        find_button = tk.Button(IPMAC, text="Find MAC Address", command=get_mac1, bg="black", fg="lime green", font=('times new roman', 16, 'bold'), bd=3, state="disabled")
        find_button.pack()

        result_label = tk.Label(IPMAC, text="", bg="gray20", fg="#ccff66", font=('times new roman', 10, 'bold'))
        result_label.pack()
     
     
     
    root = tk.Tk()
    root.title("Menu")
    root.geometry("600x700+10+10")
    root.config(bg="gray20")  # Setare culoare fundal gri închis
    #root.resizable(False, False)
    #image_icon7 = PhotoImage(file = "img/appslogo.png")
    #root.iconphoto(False, image_icon7)
     
    main_frame = tk.Frame(root, bg="gray20", width=600, height=650)  # Setare culoare fundal gri închis
    main_frame.pack(padx=20, pady=20)
    main_frame.pack_propagate(False)
     
    button_open_file_explorer = tk.Button(main_frame, text="Explorer Mode", command=open_file_explorer_window, bg="gray40", fg="white", bd=5)  # Stilizare culori și eliminare bordură
    button_open_file_explorer.place(x=1, y=5)
     
    button_open_file_copy_app = tk.Button(main_frame, text="Copy App", command=open_file_copy_app_window, bg="gray40", fg="white", bd=5)  # Schimbare scris negru
    button_open_file_copy_app.place(x=1, y=60)
     
    button_network = tk.Button(main_frame, text="Get Ip & MAC", command=ExecuteIPandMAC, bg="gray40", fg="white", bd=5)  # Schimbare scris negru + gray40
    button_network.place(x=1, y=120)
     
    # ==== Scanning Functions ====
    def scanPort(target, port):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(4)
            c = s.connect_ex((target, port))
            if c == 0:
                m = ' Port %d \t[open]' % (port,)
                log.append(m)
                ports.append(port)
                listbox.insert("end", str(m))
                updateResult()
            s.close()
        except OSError: 
            print('> Too many open sockets. Port ' + str(port))
        except:
            s.close()
            sys.exit()

    def updateResult():
        rtext = " [ " + str(len(ports)) + " / " + str(ip_f) + " ] ~ " + str(target)
        L27.configure(text = rtext)

    def startScan():
        global ports, log, target, ip_f
        clearScan()
        log = []
        ports = []
        ip_s = int(L24.get())
        ip_f = int(L25.get())
        log.append('> Port Scanner')
        log.append('='*14 + '\n')
        log.append(' Target:\t' + str(target))

        try:
            target = socket.gethostbyname(str(L22.get()))
            log.append(' IP Adr.:\t' + str(target))
            log.append(' Ports: \t[ ' + str(ip_s) + ' / ' + str(ip_f) + ' ]')
            log.append('\n')

            while ip_s <= ip_f:
                try:
                    scan = threading.Thread(target=scanPort, args=(target, ip_s))
                    scan.setDaemon(True)
                    scan.start()
                except: 
                    time.sleep(0.01)
                ip_s += 1
        except:
            m = '> Target ' + str(L22.get()) + ' not found.'
            log.append(m)
            listbox.insert(0, str(m))

    def saveScan():
        global log, target, ports, ip_f
        log[5] = " Result:\t[ " + str(len(ports)) + " / " + str(ip_f) + " ]\n"
        with open('portscan-'+str(target)+'.txt', mode='wt', encoding='utf-8') as myfile:
            myfile.write('\n'.join(log))

    def clearScan():
        listbox.delete(0, 'end')

    def PortScanner():
        '''
        global port_scan_window, listbox, L22, L24, L25, L27, log, ports, target, ip_f
        #port_scan_window = tk.Tk() # Define root window
        port_scan_window = tk.Toplevel(root)
        port_scan_window.title('Port Scanner')
        port_scan_window.geometry("400x600+20+20")
        port_scan_window.configure(bg="#222222")

        # ==== Colors ====
        m1c = '#00ee00'
        bgc = '#222222'
        dbg = '#000000'
        fgc = '#111111'

        #port_scan_window.tk_setPalette(background=bgc, foreground=m1c, activeBackground=fgc, activeForeground=bgc, highlightColor=m1c, highlightBackground=m1c)

        # ==== Labels ====
        L11 = tk.Label(port_scan_window, text="Port Scanner", font=("Helvetica", 16, 'underline'), bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L11.place(x=16, y=10)

        L21 = tk.Label(port_scan_window, text="Target: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L21.place(x=16, y=90)

        L22 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L22.place(x=180, y=90)
        L22.insert(0, "localhost")

        L23 = tk.Label(port_scan_window, text="Ports: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L23.place(x=16, y=158)

        L24 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L24.place(x=180, y=158, width=95)
        L24.insert(0, "1")

        L25 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L25.place(x=290, y=158, width=95)
        L25.insert(0, "1024")

        L26 = tk.Label(port_scan_window, text="Results: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L26.place(x=16, y=220)
        L27 = tk.Label(port_scan_window, text="[ ... ]", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L27.place(x=180, y=220)

        # ==== Ports list ====
        frame = tk.Frame(port_scan_window, bg="#222222")
        frame.place(x=16, y=275, width=370, height=215)
        listbox = tk.Listbox(frame, width=59, height=6, bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        listbox.place(x=0, y=0)
        listbox.bind('<<ListboxSelect>>')
        scrollbar = tk.Scrollbar(frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=listbox.yview)

        # ==== Buttons / Scans ====
        B11 = tk.Button(port_scan_window, text="Start Scan", command=startScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B11.place(x=16, y=500, width=170)
        B21 = tk.Button(port_scan_window, text="Save Result", command=saveScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B21.place(x=210, y=500, width=170)

        # Initialize variables
        log = []
        ports = []
        target = 'localhost'
        ip_f = 1024
        #port_scan_window.mainloop()
        '''
        global port_scan_window, listbox, L22, L24, L25, L27, log, ports, target, ip_f
        #port_scan_window = tk.Tk() # Define root window
        port_scan_window = tk.Toplevel(root)
        port_scan_window.title('Port Scanner')
        port_scan_window.geometry("400x600+20+20")
        port_scan_window.configure(bg="#222222")
        #image_icon8 = PhotoImage(file = "img/networklogo.png")
        #port_scan_window.iconphoto(False, image_icon8)

        # ==== Colors ====
        m1c = '#00ee00'
        bgc = '#222222'
        dbg = '#000000'
        fgc = '#111111'

        #port_scan_window.tk_setPalette(background=bgc, foreground=m1c, activeBackground=fgc, activeForeground=bgc, highlightColor=m1c, highlightBackground=m1c)

        # ==== Labels ====
        L11 = tk.Label(port_scan_window, text="Port Scanner", font=("Helvetica", 16, 'underline'), bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L11.place(x=16, y=10)

        L21 = tk.Label(port_scan_window, text="Target: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L21.place(x=16, y=90)

        L22 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L22.place(x=180, y=90)
        L22.insert(0, "localhost")

        L23 = tk.Label(port_scan_window, text="Ports: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L23.place(x=16, y=158)

        L24 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L24.place(x=180, y=158, width=95)
        L24.insert(0, "1")

        L25 = tk.Entry(port_scan_window, bg="#222222", fg="#00ee00")
        L25.place(x=290, y=158, width=95)
        L25.insert(0, "1024")

        L26 = tk.Label(port_scan_window, text="Results: ", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L26.place(x=16, y=220)
        L27 = tk.Label(port_scan_window, text="[ ... ]", bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        L27.place(x=180, y=220)

        # ==== Ports list ====
        frame = tk.Frame(port_scan_window, bg="#222222")
        frame.place(x=16, y=275, width=370, height=215)
        listbox = tk.Listbox(frame, width=59, height=6, bg="#222222", fg=m1c)  # Setăm culoarea textului la verde
        listbox.configure(highlightbackground=m1c)
        listbox.place(x=0, y=0)
        listbox.bind('<<ListboxSelect>>')
        scrollbar = tk.Scrollbar(frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=listbox.yview)

        # ==== Buttons / Scans ====
        B11 = tk.Button(port_scan_window, text="Start Scan", command=startScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B11.place(x=16, y=500, width=170)
        B21 = tk.Button(port_scan_window, text="Save Result", command=saveScan, bg="#222222", fg=m1c, bd=0)  # Setăm culoarea textului la verde
        B21.place(x=210, y=500, width=170)

        # Initialize variables
        log = []
        ports = []
        target = 'localhost'
        ip_f = 1024
        #port_scan_window.mainloop()
     
    button_portscanner = tk.Button(main_frame, text="Port Scanner", command=PortScanner, bg="gray40", fg="white", bd=5) #black
    button_portscanner.place(x=1, y=180)
    image_icon9 = None 
    def PingTool():
        #Globals
        window = tk.Tk();
        window.title("Port Pinger 1.0");
        #image_icon9 = PhotoImage(file = "img/networklogo.png")
        #window.iconphoto(False, image_icon9)
        window_Width = 1100;
        window_Height = 520;
        ScreenWidth = window.winfo_screenwidth();
        ScreenHeight = window.winfo_screenheight();
        Appear_in_the_Middle = '%dx%d+%d+%d' % (window_Width, window_Height, (ScreenWidth - window_Width) / 2, (ScreenHeight - window_Height) / 2);
        window.geometry(Appear_in_the_Middle);
        window.resizable(width=False, height=False);
        window.configure(bg='black'); 
        GUI = None; #pointer that will be used to reference GUI class for functions (instantiated later)
     
        #---Class--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        class PPPPP_GUI:
     
        #------Inline Functions------
              def Get_Current_Network(self): 
                  #Note: Code below works only for Windows and WLAN. Specify alt interface for other. For Linux call "ifconfig" or "iwconfig" respectively.
                  Client_Hostname = socket.gethostname(); 
                  IP_Settings = subprocess.run('ipconfig /all',stdout=subprocess.PIPE,text=True).stdout.lower();
                  scan=False;
                  IP_Address = "";
                  Default_Gateway = "";
                  Subnet_Mask = "";
                  DNS_Servers = "";
                  scan = "";
     
                  #Comment/uncomment line below to toggle WLAN and wired ethernet connection (till I find room on the GUi for a button)
                  for i in IP_Settings.split('\n'):
                      #if 'wireless' in i: scan=True;
                      if((i != None) and ("ethernet adapter ethernet:" in i)): scan=True;
                      #if((i != None) and ("ethernet adapter vmware network adapter vmnet8:" in i)): scan=True;
     
                      #Only get value 1st iternation. If value != null don't retrieve
                      if scan:
                         if 'ipv4 address' in i and IP_Address == "": 
                            IP_Address = i.split(':')[1].strip();
                            IP_Address = IP_Address.replace("(preferred)","");
                         if 'default gateway' in i and Default_Gateway == "": 
                            Default_Gateway = i.split(':')[1].strip();   
                         if 'subnet mask' in i and Subnet_Mask == "": 
                            Subnet_Mask = i.split(':')[1].strip(); 
                         if 'dns servers' in i and DNS_Servers == "": 
                            DNS_Servers = i.split(':')[1].strip();         
     
                  MESSAGE = "IP v4 ad: " +  IP_Address;
                  MESSAGE += "      Subnet: " + Subnet_Mask;
                  MESSAGE += "\nHostname: " + Client_Hostname;
                  MESSAGE += "           DNS: " + DNS_Servers;
                  MESSAGE += "\nGateway:  " + Default_Gateway;
                  self.TXT_Current_Network.insert("0.0", MESSAGE);
                  print("\n" + MESSAGE);          
     
        #----------------------------------------------------------------------------------------------------------------------           
     
              def refresh(self):
                  window.update();
                  window.after(1000,self.refresh);
     
        #----------------------------------------------------------------------------------------------------------------------       
     
              def Ping_Sweep_1(self):
                  self.TXT_Main_Output.delete("0.0", "end");
                  Net_IP = self.ENT_Network.get();
                  Start_Host = self.ENT_Start_Host.get();
                  End_Host = self.ENT_End_Host.get();
     
                  MESSAGE = "\n Initiating PING Sweep.\n";
                  MESSAGE += " Received from GUI:\n";
                  MESSAGE += "\n Network Address: " + Net_IP; 
                  MESSAGE +=  "\n Starting Host: " + Start_Host;
                  MESSAGE +=  "\n Ending Host: " + End_Host + "\n";
     
                  self.TXT_Main_Output.insert("0.0", MESSAGE);
                  print(MESSAGE);
     
                  The_Ping = "";
     
                  IP_PARTS = Net_IP.split('.');
                  NETWORK_IP = IP_PARTS[0] + '.' + IP_PARTS[1] + '.' + IP_PARTS[2] + '.';
     
                  Starting_Host = int(Start_Host);
                  Ending_Host = int(End_Host);
                  Ending_Host += 1;
     
                  OS = platform.system();
     
                  if(OS == "Windows"):
                     print("Windows OS detected.");
                     Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                     self.TXT_Main_Output.delete(1.0,"end");
                     self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + " Windows OS detected.");
                     The_Ping = "ping -n 1 ";
                  else:
                     print("Hopefully Linux OS detected.");
                     Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                     self.TXT_Main_Output.delete(1.0,"end");
                     self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + " Hopefully Linux OS detected.");
                     The_Ping = "ping -c 1 ";   
     
                  #Get starting time of scan
                  Time_Start = datetime.datetime.now();
                  MESSAGE = " Start time: " + str(Time_Start);  
                  MESSAGE += "\n Scanning ...\n";  
                  print(MESSAGE);
                  Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                  self.TXT_Main_Output.delete(1.0,"end");
                  self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
     
                  for IP in range(Starting_Host,Ending_Host):
                      ADDRESS = NETWORK_IP + str(IP);
                      MESSAGE = " Pinging " + ADDRESS; 
                      Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                      self.TXT_Main_Output.delete(1.0,"end");
                      self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                      self.TXT_Main_Output.see("end"); #autoscrolls TEXT object to bottom
                      print(MESSAGE);
                      The_Command = The_Ping + ADDRESS;
                      The_Response = os.popen(The_Command);
                      LIST = The_Response.readlines();
     
                      for LINE in LIST:
                          if(LINE.count("TTL")):
                             MESSAGE = "        " + ADDRESS + "---> Live!"; 
                             print(MESSAGE); 
                             Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                             self.TXT_Main_Output.delete(1.0,"end");
                             self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                             break;  
     
                  Time_End = datetime.datetime.now();
                  Total_Time = Time_End - Time_Start;
                  MESSAGE = "\nScan completed in: " + str(Total_Time);
                  print(MESSAGE);
                  Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                  self.TXT_Main_Output.delete(1.0,"end");
                  self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
     
        #----------------------------------------------------------------------------------------------------------------------
              def Threaded_Ping_Sweep_1(self):
                  self.refresh();
                  threading.Thread(target=self.Ping_Sweep_1).start();
     
        #---------------------------------------------------------------------------------------------------------------------- 
     
              def Port_Scan_1(self):
                  self.TXT_Main_Output.delete("0.0", "end");
                  The_Host = self.ENT_Host.get();
                  Start_Port = self.ENT_Start_Port.get();
                  End_Port = self.ENT_End_Port.get();
     
                  MESSAGE = "\n Initiating PORT Scan.\n";
                  MESSAGE += " Received from GUI:\n";
                  MESSAGE += "\n Host to scan: " + The_Host; 
                  MESSAGE +=  "\n Starting Port: " + Start_Port;
                  MESSAGE +=  "\n Ending Port: " + End_Port + "\n";
     
                  self.TXT_Main_Output.insert("0.0", MESSAGE);
                  print(MESSAGE);
     
                  # Check time when scan started
                  Time_Start = datetime.datetime.now();
     
                  Remote_Server = The_Host;
                  Remote_Server_IP = socket.gethostbyname(Remote_Server);
                  Port_Start = int(Start_Port);
                  Port_End = int(End_Port);
     
                  MESSAGE =  "\n Scanning remote host: " + Remote_Server_IP + "\n";
                  Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                  self.TXT_Main_Output.delete(1.0,"end");
                  self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                  print(MESSAGE);
     
                  try:
                      for port in range(Port_Start,Port_End): 
                          MESSAGE = " Scanning port: " + str(port);
                          Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                          self.TXT_Main_Output.delete(1.0,"end");
                          self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                          self.TXT_Main_Output.see("end"); #autoscrolls TEXT object to bottom
                          print(MESSAGE);  
                          sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
                          socket.setdefaulttimeout(.1);
                          result = sock.connect_ex((Remote_Server_IP, port));
                          if result == 0:
                             MESSAGE = "\n ********** Port " + str(port) + ":-->Open!";
                             Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                             self.TXT_Main_Output.delete(1.0,"end");
                             self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                             print(MESSAGE);
                          sock.close();
     
                  except KeyboardInterrupt:
                         MESSAGE = "\n You pressed Ctrl + C to terminate process.";
                         Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                         self.TXT_Main_Output.delete(1.0,"end");
                         self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE); 
                         print(MESSAGE);
                         self.sys.exit();
     
                  except socket.gaierror:
                         print("");
                         MESSAGE = "\n Hostname could not be resolved. Exiting ...";
                         Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                         self.TXT_Main_Output.delete(1.0,"end");
                         self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                         print(MESSAGE);                 
                         self.sys.exit();
     
                  except socket.error:
                         MESSAGE = "\n Couldn't connect to server. Exiting ...";
                         Txt_Box_Contents = self.TXT_Main_Output.get("0.0",tk.END);
                         self.TXT_Main_Output.delete(1.0,"end");
                         self.TXT_Main_Output.insert("0.0", Txt_Box_Contents + MESSAGE);
                         print(MESSAGE);                 
                         self.sys.exit();
     
                  # Checking the time again
                  Time_Finish = datetime.datetime.now();
     
                  # Calculates the difference of time, to see how long it took to run the script
                  Time_Total =  Time_Finish - Time_Start;
     
                  # Printing the information to screen     
                  MESSAGE = "Scanning Completed in: " + str(Time_Total);
                  self.TXT_Main_Output.insert("1.0", MESSAGE);
                  print(MESSAGE);                     
        #---------------------------------------------------------------------------------------------------------------------- 
     
              def Threaded_Port_Scan_1(self):
                  self.refresh();
                  threading.Thread(target=self.Port_Scan_1).start();
     
        #---------------------------------------------------------------------------------------------------------------------- 
     
            #---Constructor----------------------------------------------------------------------------     
              def __init__(self, master=None):
     
                  self.RB_Ping_Or_Port_Var = tk.IntVar();
     
                  #Event handlers for File menu items
                  def File_Menu_NEW_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From FILE menu clicked NEW");
                  def File_Menu_CLOSE_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From FILE menu clicked CLOSE"); 
     
                  #Event handlers for View menu items
                  def View_Menu_ZOOMIN_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From VIEW menu clicked ZOOM IN");
                  def View_Menu_ZOOMOUT_Handler(): MB.showinfo(title='Menu Event Triggered: ', message="From VIEW menu clicked ZOOM OUT"); 
     
                  #Event handlers for Help menu items
                  def Help_Menu_Get_Network_Data_Handler():  BTN_Get_Current_Network_Settings();
                  def Help_Menu_HELP_Handler(): 
                      MESSAGE = "Welcome to the Port Pinger. This project is";
                      MESSAGE += "\na simple network scanning tool for initiating ping sweeps";
                      MESSAGE += "\nand port scans.\n"
                      MESSAGE += "\nMulti-threading is necessary for this project because the ";
                      MESSAGE += "\ntkinter GUI will lock and not refresh or respond when";
                      MESSAGE += "\nexternal functions that initiate long, time-consuming loops";
                      MESSAGE += "\nare called - that is UNLESS you place each external function";
                      MESSAGE += "\ncall in its own separate thread outside the GUI's mainloop";
                      MESSAGE += "\nthread used to display widgets and listen for event triggers.\n";
                      MESSAGE += "\nTo initiate a ping sweep, enter the parameters and click the";
                      MESSAGE += "\n\"INITIATE\" button for the selected Ping Sweep label frame.";
                      MESSAGE += "\nTo initiate a port scan, enter the parameters and click the";
                      MESSAGE += "\n\"INITIATE\" button for the selected Port Scan label frame.";
                      MESSAGE += "\nTo get the network environment for the current host, click the";
                      MESSAGE += "\n\"Get Host Network Data\" button.";
                      MB.showinfo(title='Help Menu', message=MESSAGE); 
     
                  def Help_Menu_ABOUT_Handler(): 
                      MESSAGE = "Port Pinger 1.0";
                      MB.showinfo(title='About Menu', message=MESSAGE);   
     
                  #Event Handlers for Buttons
                  def RB_Ping_Selection_Handler():
                      self.BTN_Init_Port['state'] = tk.DISABLED;
                      self.BTN_Init_Ping['state'] = tk.NORMAL;
                      self.ENT_Host['state'] = tk.DISABLED;
                      self.ENT_Start_Port['state'] = tk.DISABLED;
                      self.ENT_End_Port['state'] = tk.DISABLED;              
                      self.ENT_Network['state'] = tk.NORMAL;
                      self.ENT_Start_Host['state'] = tk.NORMAL;
                      self.ENT_End_Host['state'] = tk.NORMAL;                                      
     
                  def RB_Port_Selection_Handler():   
                      self.BTN_Init_Ping['state'] = tk.DISABLED;
                      self.BTN_Init_Port['state'] = tk.NORMAL; 
                      self.ENT_Network['state'] = tk.DISABLED;
                      self.ENT_Start_Host['state'] = tk.DISABLED;
                      self.ENT_End_Host['state'] = tk.DISABLED;
                      self.ENT_Host['state'] = tk.NORMAL;
                      self.ENT_Start_Port['state'] = tk.NORMAL;
                      self.ENT_End_Port['state'] = tk.NORMAL;
     
                  def BTN_Init_Ping_Handler():
                      self.Threaded_Ping_Sweep_1(); 
     
                  def BTN_Init_Port_Handler():
                      self.Threaded_Port_Scan_1();   
     
                  def BTN_Get_Current_Network_Settings():
                      #Note: Code below works only for Windows. For Linux call "ifconfig" or "iwconfig" respectively.
                      IP_Settings = subprocess.run('ipconfig /all',stdout=subprocess.PIPE,text=True).stdout.lower();
                      self.TXT_Main_Output.delete("0.0", "end");
                      self.TXT_Main_Output.insert("0.0", "\n IP Settings for Current Host:\n\n" + IP_Settings);                 
     
        #---A. Frame: Main Window -------------------------------------------------------------
                  self.FRM_Main_Window = tk.Frame(master);
                  self.FRM_Main_Window.configure(height=520, width=1100, borderwidth=3, relief="flat", background="gray20");
                  self.FRM_Main_Window.place(anchor="nw", height=520, width=1100, x=0, y=0);
     
                  self.LAB_Title = tk.Label(self.FRM_Main_Window);
                  self.LAB_Title.configure(background="gray20",foreground="cyan", font="{Barlow Condensed} 13 {}", text="Port Pinger");
                  self.LAB_Title.place(anchor="nw", height=25, width=240, x=870, y=2);  
     
                  self.BTN_Get_Host_Net_Data = tk.Button(self.FRM_Main_Window, command=BTN_Get_Current_Network_Settings);
                  self.BTN_Get_Host_Net_Data.configure(background="gray40",font="{Lucida Console} 10 {}",foreground="cyan",text="Get Host Network Data");
                  self.BTN_Get_Host_Net_Data.place(anchor="nw", height=25, width=363, x=395, y=3);          
     
        #---B. Create main Menu Bar------------------------------------------------------------   
                  self.master = master;
                  self.Main_Menu_Bar = tk.Menu(self.master);
                  self.master.config(menu = self.Main_Menu_Bar);
     
                  #File Menu
                  self.File_Menu = tk.Menu(self.Main_Menu_Bar, tearoff=0);
                  self.File_Menu.add_command(label="New", command=File_Menu_NEW_Handler);
                  self.File_Menu.add_command(label="Close", command=File_Menu_CLOSE_Handler);      
                  self.File_Menu.add_separator(); # Add separator line to menu
                  self.File_Menu.add_command(label="Exit", command=window.quit); #built-in method closes window
                  self.Main_Menu_Bar.add_cascade(label="File", menu=self.File_Menu); #adds menu File_Menu to Main_Menu_Bar             
     
                  #View Menu
                  self.View_Menu = tk.Menu(self.Main_Menu_Bar, tearoff=0);
                  self.View_Menu.add_command(label="Zoom In +", command=View_Menu_ZOOMIN_Handler);
                  self.View_Menu.add_command(label="Zoom Out -", command=View_Menu_ZOOMOUT_Handler);
                  self.Main_Menu_Bar.add_cascade(label="View", menu=self.View_Menu); #adds menu File_Menu to Main_Menu_Bar    
     
                  #Help Menu
                  self.Help_Menu = tk.Menu(self.Main_Menu_Bar, tearoff=0);
                  self.Help_Menu.add_command(label="Get Network Data", command=Help_Menu_Get_Network_Data_Handler);
                  self.Help_Menu.add_command(label="Help", command=Help_Menu_HELP_Handler);
                  self.Help_Menu.add_command(label="About", command=Help_Menu_ABOUT_Handler);
                  self.Main_Menu_Bar.add_cascade(label="Help", menu=self.Help_Menu); #adds menu File_Menu to Main_Menu_Bar                   
     
        #---C. Frame: Ping Sweeper -------------------------------------------------------------          
                  self.LFRM_Ping_Sweeper = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Ping_Sweeper.configure(height=200, width=377, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Ping Sweeper");
                  self.LFRM_Ping_Sweeper.place(anchor="nw", height=200, width=377, x=5, y=3); 
     
                  self.RB_Activate_Ping_Sweeper = tk.Radiobutton(self.LFRM_Ping_Sweeper, variable=self.RB_Ping_Or_Port_Var, value=1, command=RB_Ping_Selection_Handler);
                  self.RB_Activate_Ping_Sweeper.configure(height=25, width=190, background="gray20", foreground="cyan", font="{Arial} 12 {}", text="Activate Ping Sweeper");
                  self.RB_Activate_Ping_Sweeper.place(anchor="nw", height=25, width=190, x=18, y=10);            
     
                  self.LAB_Network = tk.Label(self.LFRM_Ping_Sweeper);
                  self.LAB_Network.configure(background="gray20", foreground="cyan", borderwidth=0, relief="flat", font="{Arial} 12 {}", anchor="nw", text="Network:");
                  self.LAB_Network.place(anchor="w", x=22, y=57);
     
                  self.LAB_Start_Host = tk.Label(self.LFRM_Ping_Sweeper);
                  self.LAB_Start_Host.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="Start Host:");
                  self.LAB_Start_Host.place(anchor="w", x=22, y=92);
     
                  self.LAB_End_Host = tk.Label(self.LFRM_Ping_Sweeper);
                  self.LAB_End_Host.configure(background="gray20", borderwidth=0, foreground="cyan",  relief="flat", font="{Arial} 12 {}", anchor="nw", text="End Host:");
                  self.LAB_End_Host.place(anchor="w", x=22, y=127);
     
                  self.ENT_Network = tk.Entry(self.LFRM_Ping_Sweeper);
                  self.ENT_Network.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Network.insert("0", "192.168.0.0");
                  self.ENT_Network.place(anchor="nw", height=25, width=232, x=105, y=45);
     
                  self.ENT_Start_Host = tk.Entry(self.LFRM_Ping_Sweeper);
                  self.ENT_Start_Host.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Start_Host.insert("0", "1");
                  self.ENT_Start_Host.place(anchor="nw", height=25, width=232, x=105, y=80);
     
                  self.ENT_End_Host = tk.Entry(self.LFRM_Ping_Sweeper);
                  self.ENT_End_Host.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_End_Host.insert("0", "254");
                  self.ENT_End_Host.place(anchor="nw", height=25, width=232, x=105, y=115);
     
                  self.BTN_Init_Ping = tk.Button(self.LFRM_Ping_Sweeper, command=BTN_Init_Ping_Handler);
                  self.BTN_Init_Ping.configure(background="gray40",font="{Lucida Console} 12 {}",foreground="cyan",text="INITIATE");
                  self.BTN_Init_Ping.place(anchor="nw", height=30, width=320, x=22, y=147);
     
     
        #---D. Frame: Port Scanner -------------------------------------------------------------            
                  self.LFRM_Port_Scanner = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Port_Scanner.configure(height=200, width=377, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Port Scanner");
                  self.LFRM_Port_Scanner.place(anchor="nw", height=200, width=377, x=5, y=310);       
     
                  self.RB_Activate_Port_Scanner = tk.Radiobutton(self.LFRM_Port_Scanner, variable=self.RB_Ping_Or_Port_Var, value=2, command=RB_Port_Selection_Handler);
                  self.RB_Activate_Port_Scanner.configure(height=25, width=190, background="gray20", foreground="cyan", font="{Arial} 12 {}", text="Activate Port Scanner");
                  self.RB_Activate_Port_Scanner.place(anchor="nw", height=25, width=190, x=18, y=10);
     
                  self.LAB_Host = tk.Label(self.LFRM_Port_Scanner);
                  self.LAB_Host.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="Host:");
                  self.LAB_Host.place(anchor="nw", x=20, y=45);
     
                  self.LAB_Start_Port = tk.Label(self.LFRM_Port_Scanner);
                  self.LAB_Start_Port.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="Start Port:");
                  self.LAB_Start_Port.place(anchor="nw", x=20, y=80);
     
                  self.LAB_End_Port = tk.Label(self.LFRM_Port_Scanner);
                  self.LAB_End_Port.configure(background="gray20", borderwidth=0, foreground="cyan", relief="flat", font="{Arial} 12 {}", anchor="nw", text="End Port:" );
                  self.LAB_End_Port.place(anchor="nw", x=20, y=115);
     
                  self.ENT_Host = tk.Entry(self.LFRM_Port_Scanner);
                  self.ENT_Host.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Host.insert("0", "192.168.0.0");
                  self.ENT_Host.place(anchor="nw", height=25, width=232, x=105, y=45);
     
                  self.ENT_Start_Port = tk.Entry(self.LFRM_Port_Scanner);
                  self.ENT_Start_Port.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_Start_Port.insert("0", "1");
                  self.ENT_Start_Port.place(anchor="nw", height=25, width=232, x=105, y=80)
     
                  self.ENT_End_Port = tk.Entry(self.LFRM_Port_Scanner);
                  self.ENT_End_Port.configure(width=232, background="#000000", foreground="cyan", borderwidth=3, justify="center", relief="sunken", font="{Courier} 12 {}");
                  self.ENT_End_Port.insert("0", "65534");
                  self.ENT_End_Port.place(anchor="nw", height=25, width=232, x=105, y=115)
     
                  self.BTN_Init_Port = tk.Button(self.LFRM_Port_Scanner, command=BTN_Init_Port_Handler);
                  self.BTN_Init_Port.configure(background="gray40",font="{Lucida Console} 12 {}",foreground="cyan",text="INITIATE");
                  self.BTN_Init_Port.place(anchor="nw", height=30, width=320, x=22, y=147);
     
     
        #---E. Frame: Main Output -------------------------------------------------------------
                  self.LFRM_Main_Output = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Main_Output.configure(height=480, width=700, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Main Output");
                  self.LFRM_Main_Output.place(anchor="nw", height=480, width=700, x=390, y=30);
     
                  self.SB_Vert_TXT_Main_Output = tk.Scrollbar(self.LFRM_Main_Output, orient = tk.VERTICAL);
                  self.SB_Vert_TXT_Main_Output.pack(side=tk.RIGHT, fill=tk.Y);
     
                  self.TXT_Main_Output = tk.Text(self.LFRM_Main_Output, yscrollcommand=self.SB_Vert_TXT_Main_Output.set);
                  self.TXT_Main_Output.configure(height=457, width=678, background="#000000", foreground="lime green", borderwidth=3, relief="sunken", font="{Courier} 10 {}");
                  self.TXT_Main_Output.insert("0.0", "\n This is the MAIN OUTPUT panel.\n Ping sweep and port scan results will display here.");
                  self.TXT_Main_Output.place(anchor="nw", height=457, width=678, x=1, y=1);
     
                  self.SB_Vert_TXT_Main_Output.config(command=self.TXT_Main_Output.yview); #set scrollbar behavior
     
                  #Populate text object on starup with example text
                  self.TXT_Main_Output.insert(tk.END,"\n\n");
                  for Entry_Line_Item in range(255):
                      self.TXT_Main_Output.insert(tk.END, "Ping " + str(Entry_Line_Item) + "\n");   
     
        #---F. Frame: Current Network  -------------------------------------------------------------
                  self.LFRM_Current_Network = tk.LabelFrame(self.FRM_Main_Window);
                  self.LFRM_Current_Network.configure(height=95, width=377, borderwidth=3, relief="sunken", background="gray20", foreground="cyan", text="Current Network");
                  self.LFRM_Current_Network.place(anchor="nw", height=95, width=377, x=5, y=210);  
     
                  self.TXT_Current_Network = tk.Text(self.LFRM_Current_Network);
                  self.TXT_Current_Network.configure(height=76, width=370, background="#000000", foreground="lime green", borderwidth=3, relief="sunken", font="{Courier} 9 {}");
                  self.TXT_Current_Network.place(anchor="nw", height=76, width=370, x=1, y=1);                                       
     
        #---G. Default Load Settings -------------------------------------------------------------
                  self.RB_Ping_Or_Port_Var.set(1); #set default radio button selection
                  RB_Ping_Selection_Handler();
                  self.Get_Current_Network();
     
        #---End Class----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     
        #-----Invocations-----
        GUI = PPPPP_GUI(window); #instantiate GUI class
     
        #---Launch Main Window---
        window.mainloop();
     
    button_ping = tk.Button(main_frame, text="Ping Tool", command=PingTool, bg="gray40", fg="white", bd=5) #black
    button_ping.place(x=1, y=240)
     
    def Comparator():
        class DiffCode:
            SIMILAR = 0         # starts with '  '
            RIGHTONLY = 1       # starts with '+ '
            LEFTONLY = 2        # starts with '- '
            CHANGED = 3         # either three or four lines with the prefixes ('-', '+', '?'), ('-', '?', '+') or ('-', '?', '+', '?') respectively
     
        class DifflibParser:
            def __init__(self, text1, text2):
                self.__text1 = text1
                self.__text2 = text2
                self.__diff = list(difflib.ndiff(text1, text2))
                self.__currentLineno = 0
     
            def __iter__(self):
                return self
     
            def __next__(self):  # python3
                result = {}
                if self.__currentLineno >= len(self.__diff):
                    raise StopIteration
                currentLine = self.__diff[self.__currentLineno]
                code = currentLine[:2]
                line = currentLine[2:]
                result['line'] = line
                if code == '  ':
                    result['code'] = DiffCode.SIMILAR
                elif code == '- ':
                    incrementalChange = self.__tryGetIncrementalChange(self.__currentLineno)
                    if not incrementalChange:
                        result['code'] = DiffCode.LEFTONLY
                    else:
                        result['code'] = DiffCode.CHANGED
                        result['leftchanges'] = incrementalChange['left'] if 'left' in incrementalChange else None
                        result['rightchanges'] = incrementalChange['right'] if 'right' in incrementalChange else None
                        result['newline'] = incrementalChange['newline']
                        self.__currentLineno += incrementalChange['skiplines']
                elif code == '+ ':
                    result['code'] = DiffCode.RIGHTONLY
                self.__currentLineno += 1
                return result
     
            next = __next__  # for Python 2
     
            def __tryGetIncrementalChange(self, lineno):
                lineOne = self.__diff[lineno] if lineno < len(self.__diff) else None
                lineTwo = self.__diff[lineno + 1] if lineno + 1 < len(self.__diff) else None
                lineThree = self.__diff[lineno + 2] if lineno + 2 < len(self.__diff) else None
                lineFour = self.__diff[lineno + 3] if lineno + 3 < len(self.__diff) else None
     
                changes = {}
                # ('-', '?', '+', '?') case
                if lineOne and lineOne[:2] == '- ' and \
                   lineTwo and lineTwo[:2] == '? ' and \
                   lineThree and lineThree[:2] == '+ ' and \
                   lineFour and lineFour[:2] == '? ':
                    changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                    changes['right'] = [i for (i,c) in enumerate(lineFour[2:]) if c in ['+', '^']]
                    changes['newline'] = lineThree[2:]
                    changes['skiplines'] = 3
                    return changes
                # ('-', '+', '?')
                elif lineOne and lineOne[:2] == '- ' and \
                   lineTwo and lineTwo[:2] == '+ ' and \
                   lineThree and lineThree[:2] == '? ':
                    changes['right'] = [i for (i,c) in enumerate(lineThree[2:]) if c in ['+', '^']]
                    changes['left'] = []
                    changes['newline'] = lineTwo[2:]
                    changes['skiplines'] = 2
                    return changes
                # ('-', '?', '+')
                elif lineOne and lineOne[:2] == '- ' and \
                   lineTwo and lineTwo[:2] == '? ' and \
                   lineThree and lineThree[:2] == '+ ':
                    changes['right'] = []
                    changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                    changes['newline'] = lineThree[2:]
                    changes['skiplines'] = 2
                    return changes
                # no incremental change
                else:
                    return None
     
        class SearchTextDialog(Frame):
     
            def __init__(self, parent, textwidgets, searchButtonCallback):
                Frame.__init__(self, parent)
     
                self.parent = parent
                self.__searchCallback = searchButtonCallback
                self.__textwidgets = textwidgets
                self.__searchStr = None
                self.initUI()
     
            def initUI(self):
                self.searchTextFrame = Frame(self.parent)
     
                self.searchTextEntry = Entry(self)
                self.searchTextEntry.pack(fill=BOTH, expand=True, side=LEFT)
     
                self.__matchCaseVar = IntVar()
                self.__matchCaseVar.set(0)
                self.searchTextCheckbutton = Checkbutton(self, text='Match case', variable=self.__matchCaseVar, command=lambda *x: self.clearSearch())
                self.searchTextCheckbutton.pack(side=LEFT, padx=10)
     
                self.searchTextButton = Button(self, text='Find', command=self.nextResult)
                self.searchTextButton.pack(side=LEFT)
     
                self.searchTextEntry.bind('<Return>', self.nextResult)
                self.searchTextButton.bind('<Return>', self.nextResult)
                self.__curSearchResult = {'term': None, 'indices': ['0.0'] * len(self.__textwidgets)}
                self.__insession = False
     
            def getSearchTerm(self):
                return self.searchTextEntry.get()
     
            def focus(self):
                self.searchTextEntry.focus_set()
                self.searchTextEntry.select_range(0, END)
                self.__insession = True
     
            def nextResult(self, *args):
                if not self.__insession: return
     
                searchStr = self.searchTextEntry.get()
     
                if not self.__searchStr or self.__searchStr != searchStr:
                    self.__searchStr = searchStr
                    self.__curSearchResult = {'term': searchStr, 'indices': ['0.0'] * len(self.__textwidgets)}
     
                if searchStr in ['', None]: return
     
                countVar = StringVar()
                for i,t in enumerate(self.__textwidgets):
                    if self.__curSearchResult['indices'][i] == -1: continue
                    nextIdx = float(self.__curSearchResult['indices'][i]) + 1
                    pos = t.search(self.__searchStr, nextIdx, END, nocase=self.__matchCaseVar.get() == 0)
                    self.__curSearchResult['indices'][i] = pos if pos else -1
     
                self.__searchCallback(self.__curSearchResult)
     
            def clearSearch(self):
                self.__curSearchResult['indices'] = ['0.0'] * len(self.__textwidgets)
     
            def unfocus(self):
                self.clearSearch()
                self.__insession = False
     
        class MainWindowUI:
     
        # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |
        # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |                                     menu bar                                                  |
        # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |               |                                     search bar                                |
        # |               |          search entry                                                 | button|
        # |               +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |   treeview    |                                       |                                       |
        # |               |              text area 1              |               text area 2             |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # |               |                                       |                                       |
        # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
        # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |
     
            # Rows
            fileTreeRow = filePathLabelsRow = 0
            searchTextRow = 1
            uniScrollbarRow = lineNumbersRow = textAreasRow = 2
            horizontalScrollbarRow = 3
     
            # Columns
            fileTreeCol = 0
            fileTreeScrollbarCol = 1
            leftLineNumbersCol = leftFilePathLabelsCol = 2    # should span at least two columns
            leftTextAreaCol = leftHorizontalScrollbarCol = 3
            uniScrollbarCol = 4
            rightLineNumbersCol = rightFilePathLabelsCol = 5  # should span at least two columns
            rightTextAreaCol = rightHorizontalScrollbarCol = 6
     
            # Colors
            whiteColor = '#ffffff'
            redColor = '#ffc4c4'
            darkredColor = '#ff8282'
            grayColor = '#dddddd'
            lightGrayColor = '#eeeeee'
            greenColor = '#c9fcd6'
            darkgreenColor = '#50c96e'
            yellowColor = '#f0f58c'
            darkYellowColor = '#ffff00'
            purpleLight = '#F5EBFC'
     
            def __init__(self, window):
                self.main_window = window
                self.main_window.grid_rowconfigure(self.filePathLabelsRow, weight=0)
                self.main_window.grid_rowconfigure(self.searchTextRow, weight=0)
                self.main_window.grid_rowconfigure(self.textAreasRow, weight=1)
     
                self.main_window.grid_columnconfigure(self.fileTreeCol, weight=0)
                self.main_window.grid_columnconfigure(self.fileTreeScrollbarCol, weight=0)
                self.main_window.grid_columnconfigure(self.leftLineNumbersCol, weight=0)
                self.main_window.grid_columnconfigure(self.leftTextAreaCol, weight=1)
                self.main_window.grid_columnconfigure(self.uniScrollbarCol, weight=0)
                self.main_window.grid_columnconfigure(self.rightLineNumbersCol, weight=0)
                self.main_window.grid_columnconfigure(self.rightTextAreaCol, weight=1)
                self.menubar = Menu(self.main_window)
                self.menus = {}
                self.text_area_font = 'TkFixedFont'
     
            # Center window and set its size
            def center_window(self):
                sw = self.main_window.winfo_screenwidth()
                sh = self.main_window.winfo_screenheight()
     
                w = 0.7 * sw
                h = 0.7 * sh
     
                x = (sw - w)/2
                y = (sh - h)/2
                self.main_window.geometry('%dx%d+%d+%d' % (w, h, x, y))
                self.main_window.minsize(int(0.3 * sw), int(0.3 * sh))
     
            # Menu bar
            def add_menu(self, menuName, commandList):
                self.menus[menuName] = Menu(self.menubar,tearoff=0)
                for c in commandList:
                    if 'separator' in c: self.menus[menuName].add_separator()
                    else: self.menus[menuName].add_command(label=c['name'], command=c['command'], accelerator=c['accelerator'] if 'accelerator' in c else '')
                self.menubar.add_cascade(label=menuName, menu=self.menus[menuName])
                self.main_window.config(menu=self.menubar)
     
            # Labels
            def create_file_path_labels(self):
                self.leftFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
                self.leftFileLabel.grid(row=self.filePathLabelsRow, column=self.leftFilePathLabelsCol, columnspan=2)
                self.rightFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
                self.rightFileLabel.grid(row=self.filePathLabelsRow, column=self.rightFilePathLabelsCol, columnspan=2)
     
            # Search text entry
            def create_search_text_entry(self, searchButtonCallback):
                self.searchTextDialog = SearchTextDialog(self.main_window, [self.leftFileTextArea, self.rightFileTextArea], searchButtonCallback)
                self.searchTextDialog.grid(row=self.searchTextRow, column=self.leftFilePathLabelsCol, columnspan=5, sticky=EW)
     
                self.searchTextDialog.grid_remove()
     
            # File treeview
            def create_file_treeview(self):
                self.fileTreeView = Treeview(self.main_window)
                self.fileTreeYScrollbar = Scrollbar(self.main_window, orient='vertical', command=self.fileTreeView.yview)
                self.fileTreeXScrollbar = Scrollbar(self.main_window, orient='horizontal', command=self.fileTreeView.xview)
                self.fileTreeView.configure(yscroll=self.fileTreeYScrollbar.set, xscroll=self.fileTreeXScrollbar.set)
     
                self.fileTreeView.grid(row=self.fileTreeRow, column=self.fileTreeCol, sticky=NS, rowspan=3)
                self.fileTreeYScrollbar.grid(row=self.fileTreeRow, column=self.fileTreeScrollbarCol, sticky=NS, rowspan=3)
                self.fileTreeXScrollbar.grid(row=self.horizontalScrollbarRow, column=self.fileTreeCol, sticky=EW)
     
                self.fileTreeView.tag_configure('red', background=self.redColor)
                self.fileTreeView.tag_configure('green', background=self.greenColor)
                self.fileTreeView.tag_configure('yellow', background=self.yellowColor)
                self.fileTreeView.tag_configure('purpleLight', background=self.purpleLight)
     
                # hide it until needed
                self.fileTreeView.grid_remove()
                self.fileTreeYScrollbar.grid_remove()
                self.fileTreeXScrollbar.grid_remove()
     
            # Text areas
            def create_text_areas(self):
                self.leftFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
                self.leftFileTextArea.grid(row=self.textAreasRow, column=self.leftTextAreaCol, sticky=NSEW)
                self.leftFileTextArea.config(font=self.text_area_font)
                self.leftFileTextArea.config(wrap='none')
     
                self.rightFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
                self.rightFileTextArea.grid(row=self.textAreasRow, column=self.rightTextAreaCol, sticky=NSEW)
                self.rightFileTextArea.config(font=self.text_area_font)
                self.rightFileTextArea.config(wrap='none')
     
                # configuring highlight tags
                self.leftFileTextArea.tag_configure('red', background=self.redColor)
                self.leftFileTextArea.tag_configure('darkred', background=self.darkredColor)
                self.leftFileTextArea.tag_configure('gray', background=self.grayColor)
                self.leftFileTextArea.tag_configure('search', background=self.darkYellowColor)
                self.rightFileTextArea.tag_configure('green', background=self.greenColor)
                self.rightFileTextArea.tag_configure('darkgreen', background=self.darkgreenColor)
                self.rightFileTextArea.tag_configure('gray', background=self.grayColor)
                self.rightFileTextArea.tag_configure('search', background=self.darkYellowColor)
                self.rightFileTextArea.tag_configure('purpleLight', background=self.purpleLight)
     
                # disable the text areas
                self.leftFileTextArea.config(state=DISABLED)
                self.rightFileTextArea.config(state=DISABLED)
     
            # Line numbers
            def create_line_numbers(self):
                self.leftLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
                self.leftLinenumbers.grid(row=self.lineNumbersRow, column=self.leftLineNumbersCol, sticky=NS)
                self.leftLinenumbers.config(font=self.text_area_font)
                self.leftLinenumbers.tag_configure('line', justify='right')
     
                self.rightLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
                self.rightLinenumbers.grid(row=self.lineNumbersRow, column=self.rightLineNumbersCol, sticky=NS)
                self.rightLinenumbers.config(font=self.text_area_font)
                self.rightLinenumbers.tag_configure('line', justify='right')
     
                # disable the line numbers
                self.leftLinenumbers.config(state=DISABLED)
                self.rightLinenumbers.config(state=DISABLED)
     
            # Scroll bars
            def scrollBothY(self, action, position, type=None):
                self.leftFileTextArea.yview_moveto(position)
                self.rightFileTextArea.yview_moveto(position)
                self.leftLinenumbers.yview_moveto(position)
                self.rightLinenumbers.yview_moveto(position)
     
            def updateScrollY(self, first, last, type=None):
                self.leftFileTextArea.yview_moveto(first)
                self.rightFileTextArea.yview_moveto(first)
                self.leftLinenumbers.yview_moveto(first)
                self.rightLinenumbers.yview_moveto(first)
                self.uniScrollbar.set(first, last)
     
            def scrollBothX(self, action, position, type=None):
                self.leftFileTextArea.xview_moveto(position)
                self.rightFileTextArea.xview_moveto(position)
     
            def updateScrollX(self, first, last, type=None):
                self.leftFileTextArea.xview_moveto(first)
                self.rightFileTextArea.xview_moveto(first)
                self.leftHorizontalScrollbar.set(first, last)
                self.rightHorizontalScrollbar.set(first, last)
     
            def create_scroll_bars(self):
                self.uniScrollbar = Scrollbar(self.main_window)
                self.uniScrollbar.grid(row=self.uniScrollbarRow, column=self.uniScrollbarCol, sticky=NS)
                self.uniScrollbar.config(command=self.scrollBothY)
                self.leftFileTextArea.config(yscrollcommand=self.updateScrollY)
                self.rightFileTextArea.config(yscrollcommand=self.updateScrollY)
                self.leftLinenumbers.config(yscrollcommand=self.updateScrollY)
                self.rightLinenumbers.config(yscrollcommand=self.updateScrollY)
     
                self.leftHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
                self.leftHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.leftHorizontalScrollbarCol, sticky=EW)
                self.leftHorizontalScrollbar.config(command=self.scrollBothX)
                self.leftFileTextArea.config(xscrollcommand=self.updateScrollX)
     
                self.rightHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
                self.rightHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.rightHorizontalScrollbarCol, sticky=EW)
                self.rightHorizontalScrollbar.config(command=self.scrollBothX)
                self.rightFileTextArea.config(xscrollcommand=self.updateScrollX)
     
        class MainWindow:
            def start(self, leftpath = None, rightpath = None):
                self.main_window = Tk()
                self.main_window.title('Comparator')
                self.__main_window_ui = MainWindowUI(self.main_window)
                #self.image_icon10 = PhotoImage(file = "img/complogo.png")
                #self.main_window.iconphoto(False, self.image_icon10)
     
                self.leftFile = ''
                self.rightFile = ''
     
                self.__main_window_ui.center_window()
                self.__main_window_ui.create_file_path_labels()
                self.__main_window_ui.create_text_areas()
                self.__main_window_ui.create_search_text_entry(self.__findNext)
                self.__main_window_ui.create_line_numbers()
                self.__main_window_ui.create_scroll_bars()
                self.__main_window_ui.create_file_treeview()
                path_to_my_project = os.getcwd()
                self.__main_window_ui.add_menu('File', [
                    {'name': 'Compare Files', 'command': self.__browse_files},
                    {'name': 'Compare Directories', 'command': self.__browse_directories},
                    {'separator'},
                    {'name': 'Exit', 'command': self.__exit, 'accelerator': 'Alt+F4'}
                    ])
                self.__main_window_ui.add_menu('Edit', [
                    {'name': 'Find', 'command': self.__startFindText, 'accelerator': 'Ctrl+F'},
                    {'separator'},
                    {'name': 'Cut', 'command': self.__cut, 'accelerator': 'Ctrl+X'},
                    {'name': 'Copy', 'command': self.__copy, 'accelerator': 'Ctrl+C'},
                    {'name': 'Paste', 'command': self.__paste, 'accelerator': 'Ctrl+P'},
                    {'separator'},
                    {'name': 'Go To Line', 'command': self.__goToLine, 'accelerator': 'Ctrl+G'}
                    ])
                self.__main_window_ui.fileTreeView.bind('<<TreeviewSelect>>', lambda *x:self.treeViewItemSelected())
     
                if (leftpath and os.path.isdir(leftpath)) or (rightpath and os.path.isdir(rightpath)):
                    self.__load_directories(leftpath, rightpath)
                else:
                    self.leftFile = leftpath if leftpath else ''
                    self.rightFile = rightpath if rightpath else ''
                    self.filesChanged()
     
                self.__bind_key_shortcuts()
     
                self.main_window.mainloop()
     
            def __bind_key_shortcuts(self):
                self.main_window.bind('<Control-f>', lambda *x: self.__startFindText())
                self.main_window.bind('<Control-g>', lambda *x: self.__goToLine())
                self.main_window.bind('<Escape>', lambda *x: self.__endFindText())
                self.main_window.bind('<F3>', self.__main_window_ui.searchTextDialog.nextResult)
     
            def __browse_files(self):
                self.__load_file('left')
                self.__load_file('right')
                self.filesChanged()
                self.__main_window_ui.fileTreeView.grid_remove()
                self.__main_window_ui.fileTreeYScrollbar.grid_remove()
                self.__main_window_ui.fileTreeXScrollbar.grid_remove()
     
            # Load directories into the treeview
            def __browse_directories(self):
                leftDir = self.__load_directory('left')
                rightDir = self.__load_directory('right')
                self.__load_directories(leftDir, rightDir)
     
            def __load_directories(self, leftDir, rightDir):
                if leftDir and rightDir:
                    self.__main_window_ui.fileTreeView.grid()
                    self.__main_window_ui.fileTreeYScrollbar.grid()
                    self.__main_window_ui.fileTreeXScrollbar.grid()
                    self.__main_window_ui.fileTreeView.delete(*self.__main_window_ui.fileTreeView.get_children())
                    self.__browse_process_directory('', leftDir, rightDir)
     
            # Recursive method to fill the treevie with given directory hierarchy
            def __browse_process_directory(self, parent, leftPath, rightPath):
                if parent == '':
                    leftPath = leftPath.rstrip('/')
                    rightPath = rightPath.rstrip('/')
                    leftDirName = os.path.basename(leftPath)
                    rightDirName = os.path.basename(rightPath)
                    self.__main_window_ui.fileTreeView.heading('#0', text=leftDirName + ' / ' + rightDirName, anchor=W)
                leftListing = os.listdir(leftPath)
                rightListing = os.listdir(rightPath)
                mergedListing = list(set(leftListing) | set(rightListing))
                painted = FALSE
                for l in mergedListing:
                    newLeftPath = leftPath + '/' + l
                    newRightPath = rightPath + '/' + l
                    bindValue = (newLeftPath, newRightPath)
                    # Item in left dir only
                    if l in leftListing and l not in rightListing:
                        self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('red','simple'))
                        painted = TRUE
                    # Item in right dir only
                    elif l in rightListing and l not in leftListing:
                        self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('green','simple'))
                        painted = TRUE
                    # Item in both dirs
                    else:
                        # If one of the diffed items is a file and the other is a directory, show in yellow indicating a difference
                        if (not os.path.isdir(newLeftPath) and os.path.isdir(newRightPath)) or (os.path.isdir(newLeftPath) and not os.path.isdir(newRightPath)):
                            self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                            painted = TRUE
                        else:
                            # If both are directories, show in white and recurse on contents
                            if os.path.isdir(newLeftPath) and os.path.isdir(newRightPath):
                                oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, open=False)
                                painted = self.__browse_process_directory(oid, newLeftPath, newRightPath)
                                if painted:
                                    self.__main_window_ui.fileTreeView.item(oid, tags=('purpleLight', 'simple'))
                            else:
                                # Both are files. diff the two files to either show them in white or yellow
                                if (filecmp.cmp(newLeftPath, newRightPath)):
                                    oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('simple'))
                                else:
                                    oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                                    painted = TRUE
                return painted
     
            def __load_file(self, pos):
                fname = askopenfilename()
                if fname:
                    if pos == 'left':
                        self.leftFile = fname
                    else:
                        self.rightFile = fname
                    return fname
                else:
                    return None
     
            def __load_directory(self, pos):
                dirName = askdirectory()
                if dirName:
                    if pos == 'left':
                        self.__main_window_ui.leftFileLabel.config(text=dirName)
                    else:
                        self.__main_window_ui.rightFileLabel.config(text=dirName)
                    return dirName
                else:
                    return None
     
            # Callback for changing a file path
            def filesChanged(self):
                self.__main_window_ui.leftLinenumbers.grid_remove()
                self.__main_window_ui.rightLinenumbers.grid_remove()
     
                if not self.leftFile or not self.rightFile:
                    self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.grayColor)
                    self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.grayColor)
                    return
     
                if os.path.exists(self.leftFile):
                    self.__main_window_ui.leftFileLabel.config(text=self.leftFile)
                    self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.whiteColor)
                    self.__main_window_ui.leftLinenumbers.grid()
                else:
                    self.__main_window_ui.leftFileLabel.config(text='')
     
                if os.path.exists(self.rightFile):
                    self.__main_window_ui.rightFileLabel.config(text=self.rightFile)
                    self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.whiteColor)
                    self.__main_window_ui.rightLinenumbers.grid()
                else:
                    self.__main_window_ui.rightFileLabel.config(text='')
     
                self.diff_files_into_text_areas()
     
            def treeViewItemSelected(self):
                item_id = self.__main_window_ui.fileTreeView.focus()
                paths = self.__main_window_ui.fileTreeView.item(item_id)['values']
                if paths == None or len(paths) == 0:
                    return
                self.leftFile = paths[0]
                self.rightFile = paths[1]
                self.filesChanged()
     
            # Insert file contents into text areas and highlight differences
            def diff_files_into_text_areas(self):
                try:
                    leftFileContents = open(self.leftFile).read()
                except:
                    leftFileContents = ''
                try:
                    rightFileContents = open(self.rightFile).read()
                except:
                    rightFileContents = ''
     
                diff = DifflibParser(leftFileContents.splitlines(), rightFileContents.splitlines())
     
                # enable text area edits so we can clear and insert into them
                self.__main_window_ui.leftFileTextArea.config(state=NORMAL)
                self.__main_window_ui.rightFileTextArea.config(state=NORMAL)
                self.__main_window_ui.leftLinenumbers.config(state=NORMAL)
                self.__main_window_ui.rightLinenumbers.config(state=NORMAL)
     
                # clear all text areas
                self.__main_window_ui.leftFileTextArea.delete(1.0, END)
                self.__main_window_ui.rightFileTextArea.delete(1.0, END)
                self.__main_window_ui.leftLinenumbers.delete(1.0, END)
                self.__main_window_ui.rightLinenumbers.delete(1.0, END)
     
                leftlineno = rightlineno = 1
                for line in diff:
                    if line['code'] == DiffCode.SIMILAR:
                        self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n')
                        self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n')
                    elif line['code'] == DiffCode.RIGHTONLY:
                        self.__main_window_ui.leftFileTextArea.insert('end', '\n', 'gray')
                        self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n', 'green')
                    elif line['code'] == DiffCode.LEFTONLY:
                        self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n', 'red')
                        self.__main_window_ui.rightFileTextArea.insert('end', '\n', 'gray')
                    elif line['code'] == DiffCode.CHANGED:
                        for (i,c) in enumerate(line['line']):
                            self.__main_window_ui.leftFileTextArea.insert('end', c, 'darkred' if i in line['leftchanges'] else 'red')
                        for (i,c) in enumerate(line['newline']):
                            self.__main_window_ui.rightFileTextArea.insert('end', c, 'darkgreen' if i in line['rightchanges'] else 'green')
                        self.__main_window_ui.leftFileTextArea.insert('end', '\n')
                        self.__main_window_ui.rightFileTextArea.insert('end', '\n')
     
                    if line['code'] == DiffCode.LEFTONLY:
                        self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                        self.__main_window_ui.rightLinenumbers.insert('end', '\n', 'line')
                        leftlineno += 1
                    elif line['code'] == DiffCode.RIGHTONLY:
                        self.__main_window_ui.leftLinenumbers.insert('end', '\n', 'line')
                        self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                        rightlineno += 1
                    else:
                        self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                        self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                        leftlineno += 1
                        rightlineno += 1
     
                # calc width of line numbers texts and set it
                self.__main_window_ui.leftLinenumbers.config(width=len(str(leftlineno)))
                self.__main_window_ui.rightLinenumbers.config(width=len(str(rightlineno)))
     
                # disable text areas to prevent further editing
                self.__main_window_ui.leftFileTextArea.config(state=DISABLED)
                self.__main_window_ui.rightFileTextArea.config(state=DISABLED)
                self.__main_window_ui.leftLinenumbers.config(state=DISABLED)
                self.__main_window_ui.rightLinenumbers.config(state=DISABLED)
     
            def __cut(self):
                area = self.__getActiveTextArea()
                if area:
                    area.event_generate("<<Cut>>")
     
            def __copy(self):
                area = self.__getActiveTextArea()
                if area:
                    area.event_generate("<<Copy>>")
     
            def __paste(self):
                area = self.__getActiveTextArea()
                if area:
                    area.event_generate("<<Paste>>")
     
            def __getActiveTextArea(self):
                if self.main_window.focus_get() == self.__main_window_ui.leftFileTextArea:
                    return self.__main_window_ui.leftFileTextArea
                elif self.main_window.focus_get() == self.__main_window_ui.rightFileTextArea:
                    return self.__main_window_ui.rightFileTextArea
                else:
                    return None
     
            def __goToLine(self):
                line = askstring('Go to line', 'Enter line number:')
                if line:
                    try:
                        linenumber = int(line)
                        self.__main_window_ui.leftFileTextArea.see(float(linenumber) + 5)
                    except:
                        pass
     
            def __startFindText(self):
                self.__main_window_ui.searchTextDialog.grid()
                self.__main_window_ui.searchTextDialog.focus()
     
            def __endFindText(self):
                self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.searchTextDialog.unfocus()
                self.__main_window_ui.searchTextDialog.grid_remove()
     
            def __findNext(self, searchresult):
                term,leftpos,rightpos = searchresult['term'], searchresult['indices'][0], searchresult['indices'][1]
                if leftpos != -1:
                    self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
                    self.__main_window_ui.leftFileTextArea.tag_add('search', leftpos, '%s + %sc' % (leftpos, len(term)))
                    # scroll to position plus five lines for visibility
                    self.__main_window_ui.leftFileTextArea.see(float(leftpos) + 5)
                if rightpos != -1:
                    self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
                    self.__main_window_ui.rightFileTextArea.tag_add('search', rightpos, '%s + %sc' % (rightpos, len(term)))
                    # scroll to position plus five lines for visibility
                    self.__main_window_ui.rightFileTextArea.see(float(rightpos) + 5)
     
            def __exit(self):
                self.main_window.destroy()
     
        class FileIO:
            def load_file_to_text_area(self, fname, textArea):
                textArea.config(state=NORMAL)
                try:
                    text = open(fname).read()
                    textArea.delete(1.0, END) 
                    textArea.insert(1.0, text)
                except Exception as e:
                    showerror('Open Source File', 'Failed to read file\n"%s". Error: %s' % (fname, e))
                finally:
                    textArea.config(state=DISABLED)
     
        parser = argparse.ArgumentParser(description="pydiff - Tkinter GUI tool based on Python's difflib")
        parser.add_argument('-p', '--paths', metavar=('path1', 'path2'), nargs=2, help='Two paths to compare', required=False)
     
        args = parser.parse_args()
     
        leftpath = args.paths[0] if args.paths else None
        rightpath = args.paths[1] if args.paths else None
     
        main_window = MainWindow()
        main_window.start(leftpath, rightpath)
     
    button_pydiff = tk.Button(main_frame, text="Comparator", command=Comparator, bg="gray40", fg="white", bd=5) #black
    button_pydiff.place(x=1, y=300)
     
     

    def ReplAndFind():
        # to create a window
        repl = Tk()
        repl.resizable(False, False)
        repl.title("Find & Replace")
        repl.config(bg="gray20")
        #image_icon11 = PhotoImage(file = "img/complogo.png")
        #repl.iconphoto(False, image_icon11)
        # root window is the parent window
        framrepl = Frame(repl, bg="gray20")

        # Creating Label, Entry Box, Button
        # and packing them adding label to
        # search box
        Label(framrepl, text='Find', bg="gray20", fg="lime green").pack(side=LEFT)

        # adding of single line text box
        edit = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        # positioning of text box
        edit.pack(side=LEFT, fill=BOTH, expand=1)
        # setting focus
        edit.focus_set()

        # adding of search button
        Find = Button(framrepl, text='Find', bg="gray40", fg="cyan", bd=5)
        Find.pack(side=LEFT)

        Label(framrepl, text="Replace With ", bg="gray20", fg="lime green", bd=1).pack(side=LEFT)

        edit2 = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        edit2.pack(side=LEFT, fill=BOTH, expand=1)
        edit2.focus_set()

        replace = Button(framrepl, text='FindNReplace', bg="gray40", fg="cyan", bd=5)
        replace.pack(side=LEFT)

        refresh = Button(framrepl, text='Refresh', bg="gray40", fg="cyan", bd=5)
        refresh.pack(side=LEFT)

        framrepl.pack(side=TOP)

        # text box in root window
        textrepl = Text(repl, width=120, height=40, bg="#999999")

        # text input area at index 1 in text window
        textrepl.insert('1.0', '''Type your text here''')
        textrepl.pack(side=BOTTOM)


        # function to search string in text
        def find(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()

            if (s):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)

                    if not idx: break
                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))
                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()


        def findNreplace(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()
            r = edit2.get()

            if (s and r):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)
                    print(idx)
                    if not idx: break

                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))

                    textrepl.delete(idx, lastidx)
                    textrepl.insert(idx, r)

                    lastidx = '% s+% dc' % (idx, len(r))

                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()

        def refresh_func():
            textrepl.tag_delete('found')

        # add commands to button
        Find.config(command=find)
        replace.config(command=findNreplace)
        refresh.config(command=refresh_func)
        # binding entry boxes ...
        edit.bind('<Return>',find)
        edit2.bind('<Return>',findNreplace)

        # mainloop function calls the endless
        # loop of the window, so the window will
        # wait for any user interaction till we
        # close it
        repl.mainloop()

    button_findrepl = tk.Button(main_frame, text="Find & Replace text", command=ReplAndFind, bg="gray40", fg="white", bd=5) #black
    button_findrepl.place(x=1, y=360)

    def ScreenRec():
        from datetime import datetime
        class ScreenRecorderApp:
            def __init__(self, master):
                self.master = master
                self.master.title("Screen Recorder")
                #self.image_icon12 = PhotoImage(file = "img/reclogo.png")
                #self.root.iconphoto(False, image_icon12)

                self.recording = False

                # Butonul de start înregistrare
                self.record_button = tk.Button(master, text="Start Recording", command=self.toggle_recording, bg="gray40", fg="lime green", bd=7)
                self.record_button.pack(pady=10)

                # Butonul de oprire înregistrare
                self.stop_button = tk.Button(master, text="Stop Recording", command=self.stop_recording, bg="black", fg="red", bd=7, state=tk.DISABLED)
                self.stop_button.pack(pady=5)

                # Butonul de captură de ecran
                self.capture_button = tk.Button(master, text="Capture Screen", command=self.capture_screen, bg="gray40", fg="lime green", bd=7)
                self.capture_button.pack(pady=5)

            def start_recording(self):
                self.recording = True
                self.master.iconify()  # Minimizează fereastra Tkinter
                self.record_button.config(text="Recording...", bg="black", fg="white", state=tk.DISABLED)
                self.stop_button.config(bg="gray40", fg="red", state=tk.NORMAL)
                threading.Thread(target=self.record_screen).start()

            def stop_recording(self):
                self.recording = False
                self.master.deiconify()  # Restaurează fereastra Tkinter
                self.record_button.config(text="Start Recording", bg="gray40", fg="lime green", state=tk.NORMAL)
                self.stop_button.config(bg="black", fg="white", state=tk.DISABLED)

            def toggle_recording(self):
                if self.recording:
                    self.stop_recording()
                else:
                    self.start_recording()

            def record_screen(self):
                # Set up video writer
                width, height = pyautogui.size()
                fourcc = cv2.VideoWriter_fourcc(*'XVID')
                
                # Get current time
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                
                out = cv2.VideoWriter(f'screen_record_{current_time}.avi', fourcc, 20.0, (width, height))

                while self.recording:
                    # Capture screen
                    screenshot = pyautogui.screenshot()
                    frame = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                    out.write(frame)

                # Release video writer
                out.release()

            def capture_screen(self):
                self.master.iconify()  # Minimizează fereastra Tkinter
                
                # Capture screen
                screenshot = pyautogui.screenshot()
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                screenshot.save(f'screenshot_{current_time}.png')
                
                self.master.deiconify()  # Restaurează fereastra Tkinter

        scrrec = tk.Tk()
        app = ScreenRecorderApp(scrrec)
        scrrec.resizable(False, False)
        scrrec.config(bg="gray20")
        scrrec.geometry("150x150")
        scrrec.mainloop()

    scrrec_button = tk.Button(main_frame, text="Screen Events", command=ScreenRec, bg="gray40", fg="white", bd=5) #black
    scrrec_button.place(x=1, y=420)

    def ZIPF():
        import os
        import subprocess
        import tkinter as tk
        from tkinter import filedialog, messagebox, ttk
        import zipfile
        from tkinter import simpledialog



        class Window:
            def __init__(self, master):
                self.file_sel = ""
                master.title("Create/Extract ZIP files")
                master.resizable(False, False)
                #image_icon13 = PhotoImage(file = "img/complogo.png")
                #master.iconphoto(False, image_icon13)
                self.frame1 = ttk.LabelFrame(master, height=100, width=400, text="Actions")
                self.frame1.pack(padx=10, pady=10)
                self.frame2 = ttk.LabelFrame(master, height=100, width=400, text="Information about zip file")
                self.frame2.pack(padx=10, pady=10)
                self.frame3 = ttk.LabelFrame(master, height=100, width=400, text="List of files and folders inside zip file")
                self.frame3.pack(padx=10, pady=10)

                self.button1 = ttk.Button(self.frame1, text="Browse zip file", command=self.button_file)
                self.button1.pack(side=tk.LEFT, padx=10, pady=10)

                self.button2 = ttk.Button(self.frame1, text="Unzip directory", command=self.change_dir)
                self.button2.pack(side=tk.LEFT, padx=10, pady=10)

                self.button3 = ttk.Button(self.frame1, text="Extract All", command=self.button_extract_all)
                self.button3.pack(side=tk.LEFT, padx=10, pady=10)

                self.button4 = ttk.Button(self.frame1, text="Extract Selection", command=self.button_extract_sel)
                self.button4.pack(side=tk.LEFT, padx=10, pady=10)
                
                self.button5 = ttk.Button(self.frame1, text="Create ZIP", command=self.button_create_zip)
                self.button5.pack(side=tk.LEFT, padx=10, pady=10)

                self.label_frame_2 = ttk.Label(self.frame2, text="Select a zip file", width=100)
                self.label_frame_2.pack(padx=10, pady=10)

                self.treeview = ttk.Treeview(self.frame3, show="tree", selectmode="extended")
                self.treeview.pack(padx=10, pady=10)
                self.treeview["column"] = ("one")
                self.treeview.column("one", width=400)
                self.treeview.bind("<<TreeviewSelect>>", self.callback)

                self.label1 = ttk.Label(master)
                self.label1.pack()
                
            def button_create_zip(self):
                dir_path = filedialog.askdirectory()
                if dir_path:
                    zip_file_path = filedialog.asksaveasfilename(defaultextension=".zip", filetypes=[("ZIP files", "*.zip")])
                    if zip_file_path:
                        with zipfile.ZipFile(zip_file_path, 'w') as z:
                            for root, _, files in os.walk(dir_path):
                                for file in files:
                                    file_path = os.path.join(root, file)
                                    rel_path = os.path.relpath(file_path, dir_path)
                                    z.write(file_path, rel_path)
                        messagebox.showinfo("Success", "ZIP archive created successfully.")



            def callback(self, event):
                self.button4.config(state="enabled")
                print(self.treeview.selection())

            def button_file(self):
                self.file_sel = self.find_file("file")
                if self.is_zip(self.file_sel):
                    zip1 = ZipData(self.file_sel)
                    self.update_label(1)
                    self.label_frame_2.config(text="You have selected the zip file " + self.file_sel + "\n" + str(zip1.len_zip()) + " items found in the zip file")
                    self.button3.config(state="enabled")
                    for elt in zip1.info():
                        elt_split = elt.split("/")
                        if "" in elt_split:
                            elt_split.remove("")
                        if len(elt_split) == 1:
                            parent = ""
                        else:
                            parent = "/".join(elt_split[:-1])

                        if not self.treeview.exists(parent):
                            self.treeview.insert("", "end", parent, text=elt_split[0])

                        self.treeview.insert(parent, "end", "/".join(elt_split), text=elt_split[-1])

            def button_extract_all(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_all()
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def button_extract_sel(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_sel(self.treeview.selection())
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def clean_window(self):
                self.update_label(2)
                self.label_frame_2.config(text="")
                for i in self.treeview.get_children():
                    self.treeview.delete(i)
                subprocess.Popen("explorer " + os.getcwd())

            @staticmethod
            def find_file(f_type):
                f_name = ""
                if f_type == "file":
                    file_name = filedialog.askopenfile()
                    if file_name:
                        f_name = file_name.name
                return f_name

            @staticmethod
            def is_zip(zip_path):
                if zip_path[-4:] != ".zip":
                    messagebox.showerror("Type file error", "You need to select a zip file")
                    return False
                else:
                    return True

            def change_dir(self):
                """ Change the current directory """
                dir_path = filedialog.askdirectory()
                if dir_path:
                    os.chdir(dir_path)
                    self.update_label(1)


            def update_label(self, val):
                if val == 1:
                    self.label1.config(text="The zip file will be extracted in the directory " + self.find_dir())
                if val == 2:
                    self.label1.config(text="Zip file successfully extracted")

            @staticmethod
            def find_dir():
                cwd = os.getcwd()
                return cwd


        class ZipData:
            def __init__(self, file):
                self.file = file

            def extract_all(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    z.extractall()

            def extract_sel(self, file_name):
                with zipfile.ZipFile(self.file, 'r') as z:
                    for f_name in file_name:
                        z.extract(f_name)

            def len_zip(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    nb_items = len(z.namelist())
                    return nb_items

            def info(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    return z.namelist()


        if __name__ == "__main__":
            ziproot = tk.Tk()
            win = Window(ziproot)
            ziproot.mainloop()

    button_zip = tk.Button(main_frame, text="Create/Extract ZIP", command=ZIPF, bg="gray40", fg="white", bd=5) #black
    button_zip.place(x=1, y=480)
    '''
    def PassGen():
        def low():
            entrypass.delete(0, END)
            lengthpass = var1.get()
            passwordpass = ""
            
            if custom_check.get() == 1:  # If custom option is selected
                chars = custom_entry.get()  # Get custom characters
            else:
                if varpass.get() == 1:  # if strength selected is low
                    chars = "abcdefghijklmnopqrstuvwxyz"
                elif varpass.get() == 0:  # if strength selected is medium
                    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                elif varpass.get() == 3:  # if strength selected is strong
                    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !@#$%^&*()"
                else:
                    print("Please choose an option")

            for i in range(0, lengthpass):
                passwordpass = passwordpass + random.choice(chars)
            return passwordpass


        def save_to_file(passwordpass):
            with open("passwords.txt", "a") as file:
                file.write(passwordpass + "\n")

        def generate():
            password1 = low()
            entrypass.insert(10, password1)
            save_to_file(password1)


        def copy1():
            random_password = entrypass.get()
            pyperclip.copy(random_password)

        def enable_custom_entry():
            custom_entry.config(state=NORMAL if custom_check.get() == 1 else DISABLED)

        passroot = Tk()
        passroot.resizable(False, False)
        varpass = IntVar()
        var1 = IntVar()
        custom_check = IntVar()

        passroot.title("Random Password Generator")

        Random_password = Label(passroot, text="Password")
        Random_password.grid(row=0)
        entrypass = Entry(passroot)
        entrypass.grid(row=0, column=1)

        c_label = Label(passroot, text="Length")
        c_label.grid(row=1)

        copy_buttonpass = Button(passroot, text="Copy", command=copy1)
        copy_buttonpass.grid(row=0, column=2)
        generate_buttonpass = Button(passroot, text="Generate", command=generate)
        generate_buttonpass.grid(row=0, column=3)

        radio_low = Radiobutton(passroot, text="Low", variable=varpass, value=1, command=enable_custom_entry)
        radio_low.grid(row=1, column=2, sticky='E')
        radio_middle = Radiobutton(passroot, text="Medium", variable=varpass, value=0, command=enable_custom_entry)
        radio_middle.grid(row=1, column=3, sticky='E')
        radio_strong = Radiobutton(passroot, text="Strong", variable=varpass, value=3, command=enable_custom_entry)
        radio_strong.grid(row=1, column=4, sticky='E')

        custom_entry_label = Label(passroot, text="Custom Characters")
        custom_entry_label.grid(row=2)
        custom_entry = Entry(passroot, state=DISABLED)
        custom_entry.grid(row=2, column=1)

        custom_checkbutton = Checkbutton(passroot, text="Custom", variable=custom_check, command=enable_custom_entry)
        custom_checkbutton.grid(row=2, column=2)

        combopass = Combobox(passroot, textvariable=var1)
        combopass['values'] = (8, 9, 10, 11, 12, 13, 14, 15, 16,
                               17, 18, 19, 20, 21, 22, 23, 24, 25,
                               26, 27, 28, 29, 30, 31, 32, "Length")
        combopass.current(0)
        combopass.bind('<<ComboboxSelected>>')
        combopass.grid(column=1, row=1)

        passroot.mainloop()

    button_passgen = tk.Button(main_frame, text="Password Generator", command=PassGen, bg="gray40", fg="white", bd=1) #black
    button_passgen.pack(padx=10, pady=5)
    '''
     
    def open_excel_and_display_table():
        file_path = filedialog.askopenfilename(filetypes=[("Excel Files", "*.xlsx"), ("All Files", "*.*")])
        #file_path = "Fisa Dotari IT 2.0.xlsx"
        if file_path:
            try:
                wb = pd.ExcelFile(file_path)
                sheet_names = wb.sheet_names
     
                # Creating a new window for selecting the worksheet
                selection_window = tk.Toplevel(bg="gray20")
                selection_window.geometry("300x300")
                selection_window.title("Select the Worksheet")
                selection_window.resizable(False, False)
                #image_icon14 = PhotoImage(file = "img/complogo.png")
                #selection_window.iconphoto(False, image_icon14)
     
                # Configurăm stilul pentru combobox
                # Funcție pentru a suprima evidențierea elementului selectat
                def null_select(event):
                    sheet_option.selection_clear()

                # Configurăm stilul pentru combobox
                # Configurăm stilul pentru combobox
                style = ttk.Style()
                style.theme_create('custom_style',
                   parent='alt',
                   settings={'TCombobox':
                             {'configure':
                              {'selectforeground': 'white',
                               'selectbackground': '#1a2228',
                               'fieldforeground': 'white',
                               'fieldbackground': '#1a2228',
                               'background': '#1a2228'
                               }
                              }
                             }
                   )
                style.theme_use('custom_style')

                # Schimbăm culoarea fundalului și a chenarului combobox-ului
                style.configure('TCombobox', fieldbackground='#222222', background='#222222', foreground='#00ee00', arrowcolor='#00ee00', activeBackground="#222222")

                selection_window.option_add('*TCombobox*Listbox*Background', '#222222')
                selection_window.option_add('*TCombobox*Listbox*Foreground', '#00ee00')
                # Creăm combobox-ul
                sheet_option = ttk.Combobox(selection_window, values=sheet_names)

                # Suprimăm evidențierea elementului selectat
                sheet_option.bind("<<ComboboxSelected>>", null_select)

                # Afisăm combobox-ul
                sheet_option.pack(pady=10)
                # Creating a button to display the table
                display_button = tk.Button(selection_window, text="Arata tabelul", command=lambda: display_table(wb, sheet_option.get()), bg="gray40", fg="white", bd=1)
                display_button.pack(pady=5)
     
            except Exception as e:
                print("Error opening file:", e)
     
    def display_table(wb, sheet_name):
        # Reading data from the selected worksheet
        df = wb.parse(sheet_name)
     
        # Replace NaN values with empty strings
        df.replace(np.nan, '', inplace=True)
     
        # Creating a new window for displaying the table
        table_window = tk.Toplevel()
        table_window.title("Excel Table")
        table_window.configure(bg="gray20")
        #image_icon15 = PhotoImage(file = "img/complogo.png")
        #table_window.iconphoto(False, image_icon15)
     
        # Creating a canvas widget
        canvas = tk.Canvas(table_window)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
     
        # Creating a frame inside the canvas to hold the table content
        frame = tk.Frame(canvas)
        frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
     
        # Adding a scrollbar to the canvas
        scrollbar = tk.Scrollbar(table_window, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        canvas.configure(yscrollcommand=scrollbar.set)
     
        # Configure the canvas to update scrollregion when the frame size changes
        frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
     
        # Adding the frame to the canvas
        canvas.create_window((0, 0), window=frame, anchor="nw")
     
        # Creating a grid to simulate Excel-like cells
        for i in range(df.shape[0] + 1):  # Rows
            for j in range(df.shape[1] + 1):  # Columns
                if i == 0:
                    if j == 0:
                        label = tk.Label(frame, text="", width=10, height=2, borderwidth=1, relief="solid", bg="lightgray")
                    else:
                        label = tk.Label(frame, text=df.columns[j - 1], width=20, height=2, borderwidth=1, relief="solid", font=("Helvetica", 10, "bold"), bg="lightgray")
                else:
                    if j == 0:
                        label = tk.Label(frame, text=df.index[i - 1], width=10, height=2, borderwidth=1, relief="solid", font=("Helvetica", 10, "bold"))
                    else:
                        cell_text = str(df.iloc[i - 1, j - 1])
                        label_width = max(20, len(cell_text) + 2)  # Adjust width based on text length
                        entry = tk.Entry(frame, width=label_width, borderwidth=1, relief="solid")
                        entry.insert(0, cell_text)
                        entry.config(state="readonly")  # Make the entry readonly
                        entry.bind("<FocusIn>", lambda event, entry=entry: entry.config(state="normal"))  # Enable editing on focus
                        entry.bind("<FocusOut>", lambda event, entry=entry: entry.config(state="readonly"))  # Disable editing on focus out
                        entry.grid(row=i, column=j, sticky="nsew")
                label.grid(row=i, column=j, sticky="nsew")
     
        # Adjust column and row weights to make the cells expandable
        for i in range(df.shape[0] + 1):
            frame.grid_rowconfigure(i, weight=1)
        for j in range(df.shape[1] + 1):
            frame.grid_columnconfigure(j, weight=1)
     
        # Adding navigation buttons
        nav_frame = tk.Frame(table_window)
        nav_frame.config(bg="gray20")
        nav_frame.pack(side=tk.BOTTOM, pady=10)
     
        def navigate_left():
            canvas.xview_scroll(-1, "units")
     
        def navigate_right():
            canvas.xview_scroll(1, "units")
     
        left_button = tk.Button(nav_frame, text="← Left", bg="gray40", fg="white", command=navigate_left)
        left_button.pack(side=tk.LEFT, padx=5)

     
        right_button = tk.Button(nav_frame, text="Right →", bg="gray40", fg="white", command=navigate_right)
        right_button.pack(side=tk.LEFT, padx=5)
     
     
    # Creating a button to open the Excel file and display the table
    open_button = tk.Button(main_frame, text="Open the Equipment Sheet", command=open_excel_and_display_table, bg="gray40", fg="white", bd=5) #black
    open_button.place(x=170,y=420)

    def OpenNotepad():
        #from tkinter import *
        from tkinter.filedialog import asksaveasfile, askopenfile
        from tkinter.messagebox import showerror, askyesno
        from tkinter.scrolledtext import ScrolledText
        from tkinter.colorchooser import askcolor
        from tkinter.font import Font
        from tkinter.messagebox import showinfo
        from tkinter.simpledialog import askstring

        name = "Tudor Marmureanu"

        class File():
            def newFile(self):
                self.filename = "Untitled"
                self.text.delete(0.0, END)

            def saveFile(self):
                try:
                    t = self.text.get(0.0, END)
                    with open(self.filename, 'w') as f:
                        f.write(t)
                except Exception as e:
                    print(e)
                    self.saveAs()

            def saveAs(self):
                try:
                    f = asksaveasfile(mode='w', defaultextension='.txt')
                    t = self.text.get(0.0, END)
                    f.write(t.rstrip())
                    f.close()
                except Exception as e:
                    print(e)
                    showerror(title="Oops!", message="Unable to save file...")

            def openFile(self):
                try:
                    f = askopenfile(mode='r')
                    self.filename = f.name
                    t = f.read()
                    self.text.delete(0.0, END)
                    self.text.insert(0.0, t)
                except Exception as e:
                    print(e)

            def quit(self):
                if askyesno(title="Quit", message="Are you sure you want to quit?"):
                    self.rootnot.destroy()

            def __init__(self, text, rootnot):
                self.filename = None
                self.text = text
                self.rootnot = rootnot

        class Format():
            def __init__(self, text):
                self.text = text

            def changeBg(self):
                (triple, hexstr) = askcolor()
                if hexstr:
                    self.text.config(bg=hexstr)

            def changeFg(self):
                (triple, hexstr) = askcolor()
                if hexstr:
                    self.text.config(fg=hexstr)

            def bold(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "bold" in current_tags:
                        self.text.tag_remove("bold", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("bold", "sel.first", "sel.last")
                        bold_font = Font(self.text, self.text.cget("font"))
                        bold_font.configure(weight="bold")
                        self.text.tag_configure("bold", font=bold_font)
                except Exception as e:
                    print(e)

            def italic(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "italic" in current_tags:
                        self.text.tag_remove("italic", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("italic", "sel.first", "sel.last")
                        italic_font = Font(self.text, self.text.cget("font"))
                        italic_font.configure(slant="italic")
                        self.text.tag_configure("italic", font=italic_font)
                except Exception as e:
                    print(e)

            def underline(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "underline" in current_tags:
                        self.text.tag_remove("underline", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("underline", "sel.first", "sel.last")
                        underline_font = Font(self.text, self.text.cget("font"))
                        underline_font.configure(underline=1)
                        self.text.tag_configure("underline", font=underline_font)
                except Exception as e:
                    print(e)

            def overstrike(self, *args):
                try:
                    current_tags = self.text.tag_names("sel.first")
                    if "overstrike" in current_tags:
                        self.text.tag_remove("overstrike", "sel.first", "sel.last")
                    else:
                        self.text.tag_add("overstrike", "sel.first", "sel.last")
                        overstrike_font = Font(self.text, self.text.cget("font"))
                        overstrike_font.configure(overstrike=1)
                        self.text.tag_configure("overstrike", font=overstrike_font)
                except Exception as e:
                    print(e)

        class Edit():
            def __init__(self, text, rootnot):
                self.clipboard = None
                self.text = text
                self.rightClick = Menu(rootnot)

            def popup(self, event):
                self.rightClick.post(event.x_rootnot, event.y_rootnot)

            def copy(self, *args):
                sel = self.text.selection_get()
                self.clipboard = sel

            def cut(self, *args):
                sel = self.text.selection_get()
                self.clipboard = sel
                self.text.delete(SEL_FIRST, SEL_LAST)

            def paste(self, *args):
                self.text.insert(INSERT, self.clipboard)

            def selectAll(self, *args):
                self.text.tag_add(SEL, "1.0", END)
                self.text.mark_set(0.0, END)
                self.text.see(INSERT)

            def undo(self, *args):
                self.text.edit_undo()

            def redo(self, *args):
                self.text.edit_redo()

            def find(self, *args):
                self.text.tag_remove('found', '1.0', END)
                target = askstring('Find', 'Search String:')

                if target:
                    idx = '1.0'
                    while 1:
                        idx = self.text.search(target, idx, nocase=1, stopindex=END)
                        if not idx: break
                        lastidx = '%s+%dc' % (idx, len(target))
                        self.text.tag_add('found', idx, lastidx)
                        idx = lastidx
                    self.text.tag_config('found', foreground='white', background='blue')

        class Help():
            def about(self):
                showinfo(title="About", message=f"This a simple text editor | Made by {name}")

        def mainnot(rootnot, text, menubar):
            objFile = File(text, rootnot)
            objFormat = Format(text)
            objEdit = Edit(text, rootnot)
            objHelp = Help()

            # File menu
            filemenu = Menu(menubar)
            filemenu.add_command(label="New", command=objFile.newFile)
            filemenu.add_command(label="Open", command=objFile.openFile)
            filemenu.add_command(label="Save", command=objFile.saveFile)
            filemenu.add_command(label="Save As...", command=objFile.saveAs)
            filemenu.add_separator()
            filemenu.add_command(label="Quit", command=objFile.quit)
            menubar.add_cascade(label="File", menu=filemenu)

            # Edit menu
            editmenu = Menu(menubar)
            editmenu.add_command(label="Copy", command=objEdit.copy)
            editmenu.add_command(label="Cut", command=objEdit.cut)
            editmenu.add_command(label="Paste", command=objEdit.paste)
            editmenu.add_command(label="Undo", command=objEdit.undo)
            editmenu.add_command(label="Redo", command=objEdit.redo)
            editmenu.add_command(label="Find", command=objEdit.find)
            editmenu.add_separator()
            editmenu.add_command(label="Select All", command=objEdit.selectAll)
            menubar.add_cascade(label="Edit", menu=editmenu)

            # Format menu
            formatMenu = Menu(menubar)
            formatMenu.add_command(label="Change Background", command=objFormat.changeBg)
            formatMenu.add_command(label="Change Font Color", command=objFormat.changeFg)
            formatMenu.add_command(label="Bold", command=objFormat.bold, accelerator="Ctrl+B")
            formatMenu.add_command(label="Italic", command=objFormat.italic, accelerator="Ctrl+I")
            formatMenu.add_command(label="Underline", command=objFormat.underline, accelerator="Ctrl+U")
            formatMenu.add_command(label="Overstrike", command=objFormat.overstrike, accelerator="Ctrl+T")
            menubar.add_cascade(label="Format", menu=formatMenu)
            
            # Help menu
            helpmenu = Menu(menubar)
            helpmenu.add_command(label="About", command=objHelp.about)
            menubar.add_cascade(label="Help", menu=helpmenu)

            rootnot.config(menu=menubar)

        rootnot = Tk()
        rootnot.title("Text Editor - Untitled")
        rootnot.geometry("400x400")

        text = ScrolledText(rootnot, state='normal', height=400, width=400, wrap='word', pady=2, padx=3, undo=True)
        text.pack(fill=Y, expand=1)
        text.focus_set()

        menubar = Menu(rootnot)

        mainnot(rootnot, text, menubar)
        rootnot.mainloop()

    open_notepad_button = tk.Button(main_frame, text="Text Editor", command=OpenNotepad, bg="gray40", fg="white", bd=5) #black
    open_notepad_button.place(x=170,y=360)
    
    def OpenPaint():
        from tkinter import filedialog, messagebox, colorchooser
        import PIL.ImageGrab as ImageGrab
        from PIL import Image, ImageDraw
        import PIL
        global color, image, draw  # adăugăm variabilele globale pentru imagine și obiectul draw
        color = 'black'
        Width = 600
        Height = 440

        rootpnt = Tk()

        def save():
            filename = filedialog.asksaveasfilename(initialfile="untitled.png", defaultextension=".png",
                                                    filetypes=[("PNG files", "*.png"), ("All files", "*.*")])
            if filename:
                image.save(filename)

        def change_color(c):
            global color
            color = c

        def pick_color():
            global color
            picked = colorchooser.askcolor()
            if picked[1]:
                color = picked[1]

        def drawing(event):
            x1, y1 = (event.x - 1), (event.y - 1)
            x2, y2 = (event.x + 1), (event.y + 1)
            canvas.create_oval((x1, y1, x2, y2), fill=color, outline=color, width=vertical.get())
            draw.ellipse([x1, y1, x2 + vertical.get(), y2 + vertical.get()], outline=color, fill=color)

        def on_closing():
            answer = messagebox.askyesnocancel("QUIT", "DO YOU WANT TO SAVE YOUR WORK?", parent=rootpnt)
            if answer is not None:
                if answer:
                    save()
                rootpnt.destroy()

        def new_canvas():
            canvas.delete('all')
            draw.rectangle([0, 0, Width, Height], fill='white')

        rootpnt.title("Paint")
        rootpnt.geometry('600x550')
        rootpnt.resizable(False, False)
        rootpnt.configure(bg='black')
        rootpnt.protocol("WM_DELETE_WINDOW", on_closing)

        frame = Frame(rootpnt, bg='white')
        color_frame = Frame(frame, bg='black', borderwidth=10)

        menu_bar = Menu(rootpnt)
        rootpnt.config(menu=menu_bar)
        submenu = Menu(menu_bar, tearoff=0)

        menu_bar.add_cascade(label='File', menu=submenu)
        submenu.add_command(label='New Canvas', command=new_canvas)
        submenu.add_command(label='Save', command=save)

        colors = ['black', 'grey', 'brown', 'orange', 'yellow', 'red', 'green', 'turquoise', 'indigo', 'purple', 'blue',
                  'white', 'lime', 'pink', 'gold', 'cyan']
        buttons = []

        for i, col in enumerate(colors):
            button = Button(color_frame, bg=col, width=1, command=lambda col=col: change_color(col))
            buttons.append(button)
            button.grid(row=i // 11, column=i % 11)

        vertical = Scale(frame, from_=1, to=25, label='Size')
        vertical.set(3)

        erase_but = Button(frame, text='Erase', command=lambda: change_color('white'))
        color_but = Button(frame, text='Color', command=pick_color)

        canvas = Canvas(rootpnt, bg='white', width=Width, height=Height)
        canvas.bind('<B1-Motion>', drawing)

        image = Image.new("RGB", (Width, Height), 'white')  # Inițializăm imaginea cu fundal alb
        draw = ImageDraw.Draw(image)

        frame.grid(row=0, column=0, sticky='nsew')
        color_frame.grid(row=0, column=0, padx=20)
        vertical.grid(row=0, column=1)
        erase_but.grid(row=0, column=2, padx=20)
        color_but.grid(row=0, column=3)

        canvas.grid(row=1, column=0)

        # Centralize Window
        rootpnt.update()
        window_width = rootpnt.winfo_width()
        window_height = rootpnt.winfo_height()
        screen_width = rootpnt.winfo_screenwidth()
        screen_height = rootpnt.winfo_screenheight()
        x = int((screen_width / 2) - (window_width / 2))
        y = int((screen_height / 2) - (window_height / 2))
        rootpnt.geometry(f"{window_width}x{window_height}+{x}+{y}")

        rootpnt.mainloop()
    
    open_paint_button = Button(main_frame, text="Whiteboard", command=OpenPaint, bg="gray40", fg="white", bd=5)
    open_paint_button.place(x=170, y=480)
     
    def PDFToWordConv():
        gpath = ""

        def openfile():
            tb.delete(0, END)
            global gpath
            filterex = [('PDF File', '*.pdf'), ('All Files', '*.*')]
            userfile = fd.askopenfile(title="Open PDF", filetypes=filterex)
            if userfile:
                tb.insert(0, userfile.name)
                gpath = userfile.name

        def convert_to_word():
            global gpath
            if gpath:
                pdf_document = aw.Document(gpath)
                pdf_document.save("pdf.docx")
                mb.showinfo("Succes", "The file has been converted to Word.")
            else:
                mb.showerror("Error", "No PDF file has been selected.")

        def convert_to_word_and_extract_images():
            global gpath
            if gpath:
                # Converting selected PDF file to Word DOCX format
                pdf_document = aw.Document(gpath)
                pdf_document.save("pdf.docx")

                # Opening the converted DOCX file
                doc = Document("pdf.docx")

                # Retrieving all shapes (images) from the DOCX file
                shapes = doc.get_child_nodes(aw.NodeType.SHAPE, True)
                imageIndex = 0

                # Folder path to save images
                folder_path = "images_from_pdf/"

                # Create the folder if it doesn't exist
                if not os.path.exists(folder_path):
                    os.makedirs(folder_path)

                # Looping through the shapes (images)
                for shape in shapes:
                    shape = shape.as_shape()
                    if shape.has_image:
                        # Setting the image file's name
                        imageFileName = f"{folder_path}Image.ExportImages.{imageIndex}_{aw.FileFormatUtil.image_type_to_extension(shape.image_data.image_type)}"

                        # Saving the image
                        shape.image_data.save(imageFileName)
                        imageIndex += 1

                mb.showinfo("Succes", "The file was converted to Word and the images were extracted.")
            else:
                mb.showerror("Error", "No PDF file has been selected.")

        W = Tk()
        W.title("PDF in Word Converter")
        #image_icon16 = PhotoImage(file = "img/complogo.png")
        #W.iconphoto(False, image_icon16)
        W.geometry("640x400")
        W.config(bg="gray20")
        W.resizable(FALSE, FALSE)
        lb = Label(W, text="Select PDF file", bg="gray40", fg="cyan", bd=1)
        lb.grid(row=1, column=0)
        tb = Entry(W, width=80)
        tb.grid(row=2, column=0)
        tb.focus()

        bt_browse = Button(W, text="Browse", bg="gray40", fg="cyan", width=15, bd=1, command=openfile)
        bt_browse.grid(row=2, column=1, ipady=3)

        bt_convert_to_word = Button(W, text="Convert in Word", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word)
        bt_convert_to_word.grid(row=3, column=0, columnspan=2, pady=5)

        bt_convert_with_images = Button(W, text="Convert in Word and extract images", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word_and_extract_images)
        bt_convert_with_images.grid(row=4, column=0, columnspan=2, pady=5)
        
    WP = tk.Button(main_frame, text="PDF to Word", command=PDFToWordConv, bg="gray40", fg="white", bd=5) #bg=black
    WP.place(x=170,y=360)
    
    def pdftools():
            import tkinter as tk
            from tkinter import filedialog, messagebox
            import os
            import pikepdf
            from PIL import Image
            import fitz

            def get_file_path():
                file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
                return file_path

            def encrypt_decrypt():
                def process_pdf(action):
                    password = password_entry.get()
                    input_file = get_file_path()

                    if action == "Encrypt":
                        output_file = "encrypted_" + os.path.basename(input_file)
                        encryption = pikepdf.Encryption(owner=password, user=password, R=4)
                    else:  # Decrypt
                        output_file = "decrypted_" + os.path.basename(input_file)
                        try:
                            pdf = pikepdf.open(input_file, password=password)
                            pdf.save(output_file)
                            pdf.close()
                        except pikepdf._qpdf.PasswordError:
                            messagebox.showerror("Error", "Invalid password for decryption.")
                            return

                    with pikepdf.Pdf.open(input_file) as pdf:
                        pdf.save(output_file, encryption=encryption)

                    messagebox.showinfo("Success", f"PDF {action}ed successfully!")

                encrypt_decrypt_window = tk.Toplevel()
                encrypt_decrypt_window.title("Encrypt or Decrypt PDF")
                #image_icon17 = PhotoImage(file = "img/securelogo.png")
                #encrypt_decrypt_window.iconphoto(False, image_icon17)
                encrypt_decrypt_window.geometry("400x200")
                encrypt_decrypt_window.resizable(False, False)
                encrypt_decrypt_window.config(bg="gray20")

                label = tk.Label(encrypt_decrypt_window, text="Enter password:", bg="gray20", fg="cyan")
                label.pack()

                password_entry = tk.Entry(encrypt_decrypt_window, show="*")
                password_entry.pack()

                encrypt_button = tk.Button(encrypt_decrypt_window, text="Encrypt", command=lambda: process_pdf("Encrypt"), bg="gray40", fg="cyan")
                encrypt_button.pack()

                decrypt_button = tk.Button(encrypt_decrypt_window, text="Decrypt", command=lambda: process_pdf("Decrypt"), bg="gray40", fg="cyan")
                decrypt_button.pack()

            def rotate_pages():
                def process_rotation():
                    degrees = int(degrees_entry.get())
                    input_file = get_file_path()
                    output_file = "rotated_" + os.path.basename(input_file)

                    with pikepdf.Pdf.open(input_file) as pdf:
                        for page in pdf.pages:
                            page.Rotate = degrees
                        pdf.save(output_file)

                    messagebox.showinfo("Success", "PDF rotated successfully!")

                rotate_window = tk.Toplevel()
                rotate_window.title("Rotate Pages")
                rotate_window.geometry("400x200")
                rotate_window.config(bg="gray20")
                rotate_window.resizable(False, False)
                #image_icon18 = PhotoImage(file = "img/complogo.png")
                #rotate_window.iconphoto(False, image_icon18)

                label = tk.Label(rotate_window, text="Enter rotation degrees:", bg="gray20", fg="cyan")
                label.pack()

                degrees_entry = tk.Entry(rotate_window)
                degrees_entry.pack()

                rotate_button = tk.Button(rotate_window, text="Rotate", command=process_rotation, bg="gray40", fg="cyan")
                rotate_button.pack()


            def extract_images():
                def process_extraction():
                    input_file = get_file_path()
                    output_folder = filedialog.askdirectory()

                    # Deschide PDF-ul
                    pdf = fitz.open(input_file)

                    for page_num in range(len(pdf)):
                        page = pdf[page_num]
                        image_list = page.get_images(full=True)
                        
                        for image_index, img in enumerate(image_list):
                            # Extrage imaginea
                            xref = img[0]
                            base_image = pdf.extract_image(xref)
                            image_bytes = base_image["image"]

                            # Salvează imaginea
                            image_path = os.path.join(output_folder, f"page{page_num+1}_image{image_index}.png")
                            with open(image_path, "wb") as f:
                                f.write(image_bytes)

                            print("Image saved:", image_path)

                    pdf.close()
                    messagebox.showinfo("Success", "Images extracted successfully!")

                extract_images_window = tk.Toplevel()
                extract_images_window.title("Extract Images")
                extract_images_window.geometry("400x200")
                extract_images_window.resizable(False, False)
                extract_images_window.config(bg="gray20")
                #image_icon19 = PhotoImage(file = "img/complogo.png")
                #extract_images_window.iconphoto(False, image_icon19)

                extract_button = tk.Button(extract_images_window, text="Extract", command=process_extraction, bg="gray40", fg="cyan")
                extract_button.pack()

            def get_file_path():
                file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
                return file_path

            def separate_pages():
                def process_separation():
                    input_file = get_file_path()
                    output_folder = filedialog.askdirectory()

                    with pikepdf.Pdf.open(input_file) as pdf:
                        for page_num, page in enumerate(pdf.pages, start=1):
                            new_pdf = pikepdf.Pdf.new()
                            new_pdf.pages.append(page)
                            output_file = os.path.join(output_folder, f"page{page_num}.pdf")
                            new_pdf.save(output_file)

                    messagebox.showinfo("Success", "Pages separated successfully!")

                separate_pages_window = tk.Toplevel()
                separate_pages_window.title("Separate Pages")
                separate_pages_window.geometry("400x200")
                separate_pages_window.resizable(False, False)
                separate_pages_window.config(bg="gray20")
                #image_icon20 = PhotoImage(file = "img/complogo.png")
                #separate_pages_window.iconphoto(False, image_icon20)

                separate_button = tk.Button(separate_pages_window, text="Separate", command=process_separation, bg="gray40", fg="cyan")
                separate_button.pack()

            def delete_pages():
                def process_deletion():
                    input_file = get_file_path()
                    output_file = "deleted_" + os.path.basename(input_file)
                    pages_to_delete = list(map(int, pages_entry.get().split(',')))

                    with pikepdf.Pdf.open(input_file) as pdf:
                        for page_num in sorted(pages_to_delete, reverse=True):
                            del pdf.pages[page_num - 1]
                        pdf.save(output_file)

                    messagebox.showinfo("Success", "Pages deleted successfully!")

                delete_window = tk.Toplevel()
                delete_window.title("Delete Pages")
                delete_window.geometry("400x200")
                delete_window.resizable(False, False)
                delete_window.config(bg="gray20")
                #image_icon21 = PhotoImage(file = "img/complogo.png")
                #delete_window.iconphoto(False, image_icon21)

                label = tk.Label(delete_window, text="Enter page numbers to delete (separated by comma):", bg="gray20", fg="cyan")
                label.pack()

                pages_entry = tk.Entry(delete_window)
                pages_entry.pack()

                delete_button = tk.Button(delete_window, text="Delete", command=process_deletion, bg="gray40", fg="cyan")
                delete_button.pack()

            def mainpdf():
                rootpdff = tk.Tk()
                rootpdff.title("PDF Editing Tools")
                rootpdff.geometry("400x300")
                rootpdff.resizable(False, False)
                rootpdff.config(bg="gray20")
                #image_icon22 = PhotoImage(file = "img/complogo.png")
                #rootpdff.iconphoto(False, image_icon22)

                encrypt_decrypt_button = tk.Button(rootpdff, text="Encrypt or Decrypt PDF", command=encrypt_decrypt, bg="gray40", fg="cyan")
                encrypt_decrypt_button.pack(pady=5)

                rotate_pages_button = tk.Button(rootpdff, text="Rotate Pages", command=rotate_pages, bg="gray40", fg="cyan")
                rotate_pages_button.pack(pady=5)

                extract_images_button = tk.Button(rootpdff, text="Extract Images", command=extract_images, bg="gray40", fg="cyan")
                extract_images_button.pack(pady=5)

                separate_pages_button = tk.Button(rootpdff, text="Separate Pages", command=separate_pages, bg="gray40", fg="cyan")
                separate_pages_button.pack(pady=5)

                delete_pages_button = tk.Button(rootpdff, text="Delete Pages", command=delete_pages, bg="gray40", fg="cyan")
                delete_pages_button.pack(pady=5)

                rootpdff.mainloop()

            mainpdf()
    
    pdftools_button = tk.Button(main_frame, text="PDF Tools", command=pdftools, bg="gray40", fg="white", bd=5) #bg=black
    pdftools_button.place(x=170,y=300)  

    def BackupRestore():
        import shutil
        import os
        from datetime import datetime
        import tkinter as tk
        from tkinter import filedialog, messagebox

        def backup_files(source_dir, backup_dir):
            try:
                date_str = datetime.now().strftime('%Y%m%d_%H%M%S')
                backup_path = os.path.join(backup_dir, f'backup_{date_str}')
                shutil.copytree(source_dir, backup_path)
                messagebox.showinfo("Backup Completed", f'Backup completed: {backup_path}')
            except Exception as e:
                messagebox.showerror("Error", f'An error occurred: {e}')

        def select_source_directory():
            source_dir = filedialog.askdirectory()
            source_entry.delete(0, tk.END)
            source_entry.insert(0, source_dir)

        def select_backup_directory():
            backup_dir = filedialog.askdirectory()
            backup_entry.delete(0, tk.END)
            backup_entry.insert(0, backup_dir)

        def start_backup():
            source_dir = source_entry.get()
            backup_dir = backup_entry.get()
            if not source_dir or not backup_dir:
                messagebox.showwarning("Input Error", "Please select both source and backup directories.")
                return
            backup_files(source_dir, backup_dir)

        # Set up the main application window
        rootbkr = tk.Tk()
        rootbkr.title("Backup Utility")
        rootbkr.geometry("600x150")
        rootbkr.config(bg="gray20")
        rootbkr.resizable(False, False)

        # Configure the style of the labels and entries
        label_style = {'bg': 'gray20', 'fg': '#ccff66'}
        entry_style = {'bg': 'black', 'fg': '#ccff66', 'insertbackground': 'cyan'}

        # Source directory selection
        tk.Label(rootbkr, text="Source Directory:", **label_style).grid(row=0, column=0, padx=10, pady=5)
        source_entry = tk.Entry(rootbkr, width=50, **entry_style)
        source_entry.grid(row=0, column=1, padx=10, pady=5)
        tk.Button(rootbkr, text="Browse...", command=select_source_directory, bg="gray40", fg="#ccff66").grid(row=0, column=2, padx=10, pady=5)

        # Backup directory selection
        tk.Label(rootbkr, text="Backup Directory:", **label_style).grid(row=1, column=0, padx=10, pady=5)
        backup_entry = tk.Entry(rootbkr, width=50, **entry_style)
        backup_entry.grid(row=1, column=1, padx=10, pady=5)
        tk.Button(rootbkr, text="Browse...", command=select_backup_directory, bg="gray40", fg="#ccff66").grid(row=1, column=2, padx=10, pady=5)

        # Backup button
        tk.Button(rootbkr, text="Start Backup", command=start_backup, bg="gray40", fg="#ccff66").grid(row=2, column=0, columnspan=3, pady=20)

        # Run the application
        rootbkr.mainloop()

    
    bkr_button = tk.Button(main_frame, text="Backup Utility", command=BackupRestore, bg="gray40", fg="white", bd=5) #bg=black
    bkr_button.place(x=170,y=240)
    
    def Renamer():
        import os
        import tkinter as tk
        from tkinter import filedialog, simpledialog, messagebox

        def rename_files(directory, selected_files, prefix, suffix):
            try:
                for file in selected_files:
                    file_path = os.path.join(directory, file)
                    if os.path.isfile(file_path):
                        base, ext = os.path.splitext(file)
                        new_name = base
                        if prefix:
                            new_name = f"{prefix}_{new_name}"
                        if suffix:
                            new_name = f"{new_name}_{suffix}"
                        new_name = f"{new_name}{ext}"
                        new_path = os.path.join(directory, new_name)
                        os.rename(file_path, new_path)
                messagebox.showinfo("Success", "Files have been renamed successfully.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")

        def select_directory():
            directory = filedialog.askdirectory()
            if directory:
                directory_entry.delete(0, tk.END)
                directory_entry.insert(0, directory)
                update_file_list(directory)

        def update_file_list(directory):
            files = os.listdir(directory)
            file_listbox.delete(0, tk.END)
            for file in files:
                file_listbox.insert(tk.END, file)

        def start_renaming():
            directory = directory_entry.get()
            if not directory:
                messagebox.showwarning("Input Error", "Please select a directory.")
                return
            
            selected_files = [file_listbox.get(i) for i in file_listbox.curselection()]
            if not selected_files:
                messagebox.showwarning("Input Error", "Please select at least one file.")
                return

            prefix = prefix_entry.get()
            suffix = suffix_entry.get()

            rename_files(directory, selected_files, prefix, suffix)
            update_file_list(directory)  # Refresh the file list after renaming

        # Set up the main application window
        rootrn = tk.Tk()
        rootrn.title("Batch File Renamer")
        rootrn.configure(bg='gray20')
        rootrn.resizable(False, False)

        # Directory selection
        tk.Label(rootrn, text="Directory:", bg='gray20', fg='#ccff66').grid(row=0, column=0, padx=10, pady=5)
        directory_entry = tk.Entry(rootrn, width=50, bg='black', fg='#ccff66', insertbackground='cyan')
        directory_entry.grid(row=0, column=1, padx=10, pady=5)
        tk.Button(rootrn, text="Browse...", command=select_directory, bg='gray40', fg='#ccff66').grid(row=0, column=2, padx=10, pady=5)

        # File list
        tk.Label(rootrn, text="Files:", bg='gray20', fg='#ccff66', font=('bold')).grid(row=1, column=0, padx=10, pady=5)
        file_listbox = tk.Listbox(rootrn, selectmode=tk.MULTIPLE, width=50, height=15, bg='black', fg='#ccff66', bd=25)
        file_listbox.grid(row=1, column=1, padx=10, pady=5, columnspan=2)

        # Prefix option
        tk.Label(rootrn, text="Prefix:", bg='gray20', fg='#ccff66').grid(row=2, column=0, padx=10, pady=5)
        prefix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
        prefix_entry.grid(row=2, column=1, padx=10, pady=5)

        # Suffix option
        tk.Label(rootrn, text="Suffix:", bg='gray20', fg='#ccff66').grid(row=3, column=0, padx=10, pady=5)
        suffix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
        suffix_entry.grid(row=3, column=1, padx=10, pady=5)

        # Rename button
        tk.Button(rootrn, text="Rename Files", command=start_renaming, bg='gray40', fg='#ccff66').grid(row=4, column=0, columnspan=3, pady=20)

        # Run the application
        rootrn.mainloop()


    rn_button = tk.Button(main_frame, text="Rename Utility", command=Renamer, bg="gray40", fg="white", bd=5) #bg=black
    rn_button.place(x=170,y=180) 
    
    def SystemInfoFunc():
        def get_service_tag():
            try:
                output = subprocess.check_output(["wmic", "bios", "get", "serialnumber"]).decode().strip().split("\n")
                # Service Tag-ul este în al doilea rând al rezultatului
                service_tag = output[1].strip()
                return service_tag
            except Exception as e:
                print("A apărut o Error:", e)
                return None

        def get_windows_license_key():
            try:#wmic path softwarelicensingservice get OA3xOriginalProductKey
                output = subprocess.check_output(["wmic", "path", "softwarelicensingservice", "get", "OA3xOriginalProductKey"]).decode().strip().split("\n")
                # Cheia de licență Windows este în ultima linie a rezultatului
                license_key = output[-1].split(":")[-1].strip()
                return license_key
            except Exception as e:
                print("A apărut o Error:", e)
                return None

        def save_to_file(filename, content):
            try:
                with open(filename, 'w') as file:
                    file.write(content)
                    print(f"The information has been saved to {filename}")
            except Exception as e:
                print(f"An error occurred while saving to {filename}: {e}")

        def save_to_file1(filename, content):
            try:
                with open(filename, 'w') as file:
                    for item in content:
                        file.write(item[2:-2] + '\n')  # Scriem fiecare element în fișier fără paranteze pătrate
                    print(f"The information has been saved to {filename}")
            except Exception as e:
                print(f"An error occurred while saving to {filename}: {e}")

        def display_info():
            system_info = get_system_info()
            text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
            text_area.delete(1.0, tk.END)
            for item in system_info:
                text_area.insert(tk.END, item[2:-2] + '\n')
            text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
            save_to_file1("SystemInfo.txt", system_info)

        def display_service_tag():
            service_tag = get_service_tag()
            if service_tag:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Service Tag: " + service_tag + '\n')
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
                save_to_file("ServiceTag.txt", service_tag)
            else:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Nu s-a putut obține Service Tag-ul.\n")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil

        def display_license_key():
            license_key = get_windows_license_key()
            if license_key:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Cheia de licență Windows: " + license_key + '\n')
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
                save_to_file("WindowsKey.txt", license_key)
            else:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Nu s-a putut obține cheia de licență Windows.\n")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil

        def display_battery():
            sfc_info = generate_battery_report()
            if sfc_info:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "powercfg /batteryreport /output \"C:\\battery_report.html\"\n")
                text_area.insert(tk.END, "Raport generat.")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil
            else:
                text_area.config(state=tk.NORMAL)  # Setarea stării la normal pentru a permite editarea
                text_area.delete(1.0, tk.END)
                text_area.insert(tk.END, "Nu s-a putut efectua comanda.\n")
                text_area.config(state=tk.DISABLED)  # Setarea stării înapoi la dezactivată pentru a face textul nelocalizabil

        def get_system_info():
            info = subprocess.check_output(['systeminfo']).decode('utf-8').split('\n')
            formatted_info = []
            for item in info:
                formatted_info.append(str(item.split("\r")[:-1]))
            return formatted_info

        def shutdown():
            return subprocess.call("shutdown /s /t 1")

        def restart():
            return subprocess.call("shutdown /r /t 1")

        def logout():
            return subprocess.call("shutdown -l")

        def get_into_domain():
            os.startfile("sysdm.cpl")

        def run_appwiz():
            os.startfile("appwiz.cpl")

        def generate_battery_report():
            subprocess.call("powercfg /batteryreport /output \"C:\\battery_report.html\"")

        def open_power_plan_settings():
            try:
                subprocess.run(["control", "powercfg.cpl"])
            except Exception as e:
                print("Error:", e)

        def lusrmgr():
            os.startfile("lusrmgr.msc")

        def devmgmt():
            os.startfile("devmgmt.msc")

        infowindow = tk.Tk()
        infowindow.title("System Info")
        infowindow.config(bg="gray20")  # Setare culoare fundal gri închis
        infowindow.resizable(False, False)
        #image_icon23 = PhotoImage(file = "img/systemlogo.png")
        #infowindow.iconphoto(False, image_icon23)

        text_area = scrolledtext.ScrolledText(infowindow, wrap=tk.WORD, bg="black", fg="cyan", highlightbackground="gray40", highlightthickness=10, bd=20)  # Setarea culorii fundalului și a textului
        text_area.grid(row=0, column=1, rowspan=13, padx=10, pady=3, sticky="nsew")
        text_area.config(height=40)  # Modifică dimensiunile text_area

        buttons = [
            ("Display System info", display_info),
            ("Display Service Tag", display_service_tag),
            ("Display Windows license key", display_license_key),
            ("Introduction of PC in the domain", get_into_domain),
            ("Open the apps in Control Panel", run_appwiz),
            ("Generation of battery raport", display_battery),
            ("Edit Power Plan", open_power_plan_settings),
            ("Edit users and groups (lusrmgr)", lusrmgr),
            ("Device manager", devmgmt),
            ("Shutdown", shutdown),
            ("Restart", restart),
            ("Log out", logout),
            ("EXIT", infowindow.destroy)
        ]

        for i, (text, command) in enumerate(buttons):
            fg_color = "red" if text == "EXIT" else "cyan"  # Verificare dacă butonul este "EXIT"
            button = tk.Button(infowindow, text=text, command=command, bg="gray40", fg=fg_color, bd=6)
            button.grid(row=i, column=0, padx=5, pady=5, sticky="ew")

        # Configurarea configurării grilei pentru a redimensiona corect butoanele și zona de text
        infowindow.grid_rowconfigure(13, weight=1)
        infowindow.grid_columnconfigure(0, weight=1)
        infowindow.grid_columnconfigure(1, weight=3)

        '''
         infowindow = tk.Tk()
        infowindow.title("System Info")
        infowindow.config(bg="gray20")  # Setare culoare fundal gri închis

        text_area = scrolledtext.ScrolledText(infowindow, wrap=tk.WORD, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)  # Setarea culorii fundalului și a textului
        text_area.grid(row=0, column=1, rowspan=6, padx=10, pady=3, sticky="nsew")
        text_area.config(height=40)  # Modifică dimensiunile text_area

        info_button = tk.Button(infowindow, text="Afiseaza informatii", command=display_info, bg="gray40", fg="cyan", bd=6)
        info_button.grid(row=0, column=0, padx=5, pady=3, sticky="ew")

        service_tag_button = tk.Button(infowindow, text="Afiseaza Service Tag", command=display_service_tag, bg="gray40", fg="cyan", bd=6)
        service_tag_button.grid(row=1, column=0, padx=5, pady=3, sticky="ew")

        license_key_button = tk.Button(infowindow, text="Afiseaza Cheia de Licenta Windows", command=display_license_key, bg="gray40", fg="cyan", bd=6)
        license_key_button.grid(row=2, column=0, padx=5, pady=3, sticky="ew")

        into_domain = tk.Button(infowindow, text="Introducere PC in domeniu", command=get_into_domain, bg="gray40", fg="cyan", bd=6)
        into_domain.grid(row=3, column=0, padx=5, pady=3, sticky="ew")

        appwiz = tk.Button(infowindow, text="Deschide aplicatii Control Panel", command=run_appwiz, bg="gray40", fg="cyan", bd=6)
        appwiz.grid(row=4, column=0, padx=5, pady=3, sticky="ew")

        battery_report = tk.Button(infowindow, text="Generare raport baterie", command=display_battery, bg="gray40", fg="cyan", bd=6)
        battery_report.grid(row=5, column=0, padx=3, pady=1, sticky="ew")

        power_plan = tk.Button(infowindow, text="Edit Power Plan", command=open_power_plan_settings, bg="gray40", fg="cyan", bd=6)
        power_plan.grid(row=6, column=0, padx=5, pady=30, sticky="ew")

        lusrmgrBTN = tk.Button(infowindow, text="Editare useri si grupuri", command=lusrmgr, bg="gray40", fg="cyan", bd=6)
        lusrmgrBTN.grid(row=7, column=0, padx=5, pady=30, sticky="ew")

        devmgmtBTN = tk.Button(infowindow, text="Device manager", command=devmgmt, bg="gray40", fg="cyan", bd=6)
        devmgmtBTN.grid(row=8, column=0, padx=5, pady=30, sticky="ew")

        shutdown_button = tk.Button(infowindow, text="Shutdown", command=shutdown, bg="gray40", fg="red", bd=4)
        shutdown_button.grid(row=9, column=0, padx=5, pady=1, sticky="ew")

        restart_button = tk.Button(infowindow, text="Restart", command=restart, bg="gray40", fg="lime green", bd=4)
        restart_button.grid(row=10, column=0, padx=5, pady=1, sticky="ew")

        logout_button = tk.Button(infowindow, text="Log out", command=logout, bg="gray40", fg="yellow", bd=4)
        logout_button.grid(row=11, column=0, padx=5, pady=1, sticky="ew")

        exit_button = tk.Button(infowindow, text="EXIT", command=infowindow.destroy, bg="red", fg="black", bd=10)
        exit_button.grid(row=12, column=0, padx=5, pady=5, sticky="ew")

        # Configurarea configurării grilei pentru a redimensiona corect butoanele și zona de text
        infowindow.grid_rowconfigure(0, weight=1)
        infowindow.grid_rowconfigure(1, weight=1)
        infowindow.grid_rowconfigure(2, weight=1)
        infowindow.grid_rowconfigure(3, weight=1)
        infowindow.grid_rowconfigure(4, weight=1)
        infowindow.grid_rowconfigure(5, weight=1)
        infowindow.grid_rowconfigure(6, weight=1)
        infowindow.grid_rowconfigure(7, weight=1)
        infowindow.grid_rowconfigure(8, weight=1)
        infowindow.grid_rowconfigure(9, weight=1)
        infowindow.grid_rowconfigure(10, weight=1)
        infowindow.grid_rowconfigure(11, weight=1)
        infowindow.grid_rowconfigure(12, weight=1)
        infowindow.grid_columnconfigure(0, weight=1)
        infowindow.grid_columnconfigure(1, weight=3)
        '''

    SystemInfo_button = tk.Button(main_frame, text="System Info", command=SystemInfoFunc, bg="gray40", fg="white", bd=5)
    SystemInfo_button.place(x=170,y=120)

    '''
    def open_dearpygui():
        # Put your Dear PyGui code here
        AllInfo()

    def prevent_close():
        # Funcție apelată atunci când utilizatorul încearcă să închidă fereastra
        # Ignorăm acțiunea, astfel încât fereastra să rămână deschisă
        pass

    def AllInfo():
        # Check for AMD support and conditionally import pyadl
        from datetime import datetime
        AMD_SUPPORTED = False
        try:
            import pyadl
            _ = pyadl.ADLManager.getInstance().getDevices()
            AMD_SUPPORTED = True
        except ImportError:
            pass
        except Exception as amd_error:
            # Only print the AMD error if no NVIDIA GPUs are detected
            if not GPUtil.getGPUs():
                print(f"Unexpected error while checking for AMD support: {amd_error}")

        # Check for Windows and conditionally import winreg
        if platform.system() == 'Windows':
            import winreg
        else:
            winreg = None

        gci = get_cpu_info()
        WIN_WIDTH = 800
        WIN_HEIGHT = 400

        dpg.create_context()

        gpu_temp_texts = {}  # Store NVIDIA GPU temp text IDs
        amd_gpu_temp_texts = {}  # Store AMD GPU temp text IDs
        gpu_progress_bars = {}  # Store NVIDIA GPU progress bar IDs

        # Get CPU Total Utilization
        def get_cpu_util():
            """Get CPU Total Utilization"""

            while True:
                cpu_val = psutil.cpu_percent(interval=1, percpu=False)
                dpg.set_value(cpu_progress_bar, 1.0 / 100.0 * cpu_val)
                dpg.configure_item(cpu_progress_bar, overlay=f"{cpu_val}%")


        # entry
        with dpg.window(
                label=f"Computer Name: {platform.node()}",
                no_close=True,
                no_resize=True,
                no_move=True,
                width=WIN_WIDTH - 18,
                height=WIN_HEIGHT
        ) as main_window:
            with dpg.collapsing_header(label="Processor"):
                with dpg.group(horizontal=True):
                    dpg.add_text(f"{gci['brand_raw']} @", bullet=True)
                    dpg.add_text(f"{gci['hz_actual_friendly']}")
                with dpg.group(horizontal=True):
                    dpg.add_text("CPU Utilization(Total):", bullet=True)
                    threading.Thread(target=get_cpu_util, args=(), daemon=True).start()
                    cpu_progress_bar = dpg.add_progress_bar(default_value=0.0, overlay="0.0%", width=200)
                dpg.add_text(f"{gci['count']} Total Core/s", bullet=True)
                dpg.add_text(f"{gci['arch']} Architecture", bullet=True)
                with dpg.tree_node(label="Cache/s"):
                    try:
                        l1_i = humanize.naturalsize(gci['l1_instruction_cache_size'], gnu=True)
                        dpg.add_text(f"L1 Instruction Cache Size: {l1_i}")
                    except KeyError:
                        dpg.add_text("L1 Instruction Cache Size: Can't determine")

                    try:
                        l1_d = humanize.naturalsize(gci['l1_data_cache_size'], gnu=True)
                        dpg.add_text(f"L1 Data Cache Size: {l1_d}")
                    except KeyError:
                        dpg.add_text("L1 Data Cache Size: Can't determine")

                    try:
                        l2 = humanize.naturalsize(gci['l2_cache_size'], gnu=True)
                        dpg.add_text(f"L2 Cache Size: {l2}")
                    except KeyError:
                        dpg.add_text("L2 Cache Size: Can't determine")

                    try:
                        l3 = humanize.naturalsize(gci['l3_cache_size'], gnu=True)
                        dpg.add_text(f"L3 Cache Size: {l3}")
                    except KeyError:
                        dpg.add_text("L3 Cache Size: Can't determine")

                with dpg.tree_node(label="Flags"):
                    with dpg.table(
                        header_row=False,
                        resizable=True,
                        policy=dpg.mvTable_SizingStretchProp,
                        row_background=True,
                        borders_outerV=True,
                        borders_innerV=True,
                        borders_outerH=True,
                        borders_innerH=True,
                        delay_search=True
                    ):
                        COL = 11
                        FLAG = 0
                        flags = gci['flags']

                        for _ in range(COL):
                            dpg.add_table_column()

                        # https://github.com/hoffstadt/DearPyGui/discussions/1918#discussioncomment-3960795
                        rows = int(len(flags) / COL) + 1
                        for row in range(rows):
                            with dpg.table_row():
                                for col in range(COL):
                                    FLAG = row * COL + col
                                    if FLAG >= len(flags):
                                        dpg.add_text("---")
                                    else:
                                        dpg.add_text(f"{flags[FLAG]}")

            with dpg.collapsing_header(label="Graphics"):
                gpu_temp_placeholder = dpg.add_group(horizontal=False)
                gpu_list = []

                def handle_nvidia_gpus():
                    """handle NVIDIA GPUs"""
                    gpus = GPUtil.getGPUs()
                    for gpu in gpus:
                        if gpu.id not in gpu_temp_texts:
                            dpg.add_text(
                                f"Graphics Name: {gpu.name}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            with dpg.group(horizontal=True, parent=gpu_temp_placeholder):
                                dpg.add_text("GPU Utilization:", bullet=True)
                                gpu_progress_bar = dpg.add_progress_bar(
                                    default_value=0.0,
                                    overlay="0.0%",
                                    width=200
                                )
                                gpu_progress_bars[gpu.id] = gpu_progress_bar

                            gpu_temp_text_id = dpg.add_text(
                                f"Temperature: {gpu.temperature}°C",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            gpu_temp_texts[gpu.id] = gpu_temp_text_id
                        else:
                            dpg.set_value(
                                gpu_temp_texts[gpu.id],
                                f"Temperature: {gpu.temperature}°C"
                            )

                def handle_amd_gpus():
                    """handle AMD GPUs"""
                    if not AMD_SUPPORTED:
                        return

                    amd_manager = pyadl.ADLManager.getInstance()
                    devices = amd_manager.getDevices()
                    for device in devices:
                        temperature_data = device.getCurrentTemperature()
                        if temperature_data is not None:
                            if device.adapterName not in amd_gpu_temp_texts:
                                dpg.add_text(
                                f"AMD GPU {device.adapterName}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            amd_gpu_temp_text_id = dpg.add_text(
                                f"Temperature: {temperature_data}°C",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                            amd_gpu_temp_texts[device.adapterName] = amd_gpu_temp_text_id
                        else:
                            dpg.set_value(
                                amd_gpu_temp_texts[device.adapterName],
                                f"Temperature: {temperature_data}°C"
                            )

                def update_gpu_temperature():
                    """Get GPU Temperature and Util Updates"""
                    while True:
                        try:
                            handle_nvidia_gpus()
                        except ImportError as import_error:
                            dpg.add_text(
                                f"Error importing GPUtil: {import_error}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )
                        except Exception as general_exception:
                            dpg.add_text(
                                f"Error fetching NVIDIA GPU information: {general_exception}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )

                        try:
                            handle_amd_gpus()
                        except Exception as general_exception:
                            dpg.add_text(
                                f"Error fetching AMD GPU temperature: {general_exception}",
                                bullet=True,
                                parent=gpu_temp_placeholder
                            )

                        time.sleep(1)

                # Get GPU Utilization
                def get_gpu_util():
                    """Get GPU Utilization"""
                    while True:
                        try:
                            gpus = GPUtil.getGPUs()
                            for gpu in gpus:
                                gpu_val = gpu.load * 100
                                dpg.set_value(gpu_progress_bars[gpu.id], 1.0 / 100.0 * gpu_val)
                                dpg.configure_item(gpu_progress_bars[gpu.id], overlay=f"{gpu_val:.2f}%")
                        except (ImportError, Exception) as general_exception:
                            print(f"An error occurred: {general_exception}")
                        time.sleep(1)

            with dpg.collapsing_header(label="Memory"):
                mem = psutil.virtual_memory()
                mem_used = humanize.naturalsize(mem.used)
                mem_percent = mem.percent
                mem_avail = humanize.naturalsize(mem.available)
                mem_total = humanize.naturalsize(mem.total)
                dpg.add_text("MAIN MEMORY", color=(0, 255, 0))
                dpg.add_text(f"Used Memory: {mem_used}({mem_percent}%)", bullet=True)
                dpg.add_text(f"Available Memory: {mem_avail}", bullet=True)
                dpg.add_text(f"Total Memory: {mem_total}", bullet=True)

                swap = psutil.swap_memory()
                swap_used = humanize.naturalsize(swap.used)
                swap_percent = swap.percent
                swap_free = humanize.naturalsize(swap.free)
                swap_total = humanize.naturalsize(swap.total)
                dpg.add_text("SWAP MEMORY", color=(0, 255, 0))
                dpg.add_text(f"Used Swap Memory: {swap_used}({swap_percent}%)", bullet=True)
                dpg.add_text(f"Free Swap Memory: {swap_free}", bullet=True)
                dpg.add_text(f"Total Swap Memory: {swap_total}", bullet=True)

            with dpg.collapsing_header(label="Disk"):
                with dpg.table(
                    resizable=True,
                    policy=dpg.mvTable_SizingStretchProp,
                    borders_outerV=True,
                    borders_innerV=True,
                    borders_outerH=True,
                    borders_innerH=True,
                    delay_search=True
                ):
                    dpg.add_table_column(label="Device")
                    dpg.add_table_column(label="Mount point")
                    dpg.add_table_column(label="File System type")
                    dpg.add_table_column(label="Used")
                    dpg.add_table_column(label="Free")
                    dpg.add_table_column(label="Total")

                    prts = psutil.disk_partitions()
                    for prt in prts:
                        with dpg.table_row():
                            for row in range(8):
                                dpg.add_text(f"{prt.device}", color=(0, 255, 0))
                                dpg.add_text(f"{prt.mountpoint}")
                                dpg.add_text(f"{prt.fstype}")
                                try:
                                    usage = psutil.disk_usage(prt.mountpoint)
                                except PermissionError:
                                    dpg.add_text("Can't determine")
                                    continue
                                dpg.add_text(f"{humanize.naturalsize(usage.used)}({usage.percent}%)")
                                dpg.add_text(f"{humanize.naturalsize(usage.free)}")
                                dpg.add_text(f"{humanize.naturalsize(usage.total)}")

            with dpg.collapsing_header(label="Network"):
                addr_list = psutil.net_if_addrs()
                for name, addresses in addr_list.items():
                    with dpg.group(horizontal=True):
                        dpg.add_text("Interface Name: ")
                        dpg.add_text(f"{name}", color=(0, 255, 0))
                    for address in addresses:
                        if address.family == socket.AF_INET:
                            dpg.add_text(f"IP Address: {address.address}", bullet=True)
                            dpg.add_text(f"Subnet Mask: {address.netmask}", bullet=True)
                        if address.family == psutil.AF_LINK:
                            dpg.add_text(f"MAC Address: {address.address}", bullet=True)

            with dpg.collapsing_header(label="Operating System"):
                if platform.system() == 'Windows':
                    try:
                        BRAND = subprocess.check_output('wmic csproduct get vendor', shell=True)
                        BRAND = BRAND.decode('utf-8').strip().split('\n')[1]
                        MODEL = subprocess.check_output('wmic csproduct get name', shell=True)
                        MODEL = MODEL.decode('utf-8').strip().split('\n')[1]

                        dpg.add_text(f"Brand: {BRAND}", bullet=True)
                        dpg.add_text(f"Model: {MODEL}", bullet=True)
                    except subprocess.CalledProcessError:
                        dpg.add_text("Brand: Can't determine", bullet=True)
                        dpg.add_text("Model: Can't determine", bullet=True)

                elif platform.system() == 'Linux':
                    try:
                        BRAND = subprocess.check_output('dmidecode -s system-manufacturer', shell=True)
                        BRAND = BRAND.decode('utf-8').strip()
                        MODEL = subprocess.check_output('dmidecode -s system-product-name', shell=True)
                        MODEL = MODEL.decode('utf-8').strip()

                        dpg.add_text(f"Brand: {BRAND}", bullet=True)
                        dpg.add_text(f"Model: {MODEL}", bullet=True)
                    except subprocess.CalledProcessError:
                        dpg.add_text("Brand: Can't determine", bullet=True)
                        dpg.add_text("Model: Can't determine", bullet=True)

                uname = platform.uname()
                dpg.add_text(f"System: {uname.system}", bullet=True)
                if uname.system == "Windows":
                    if int(uname.version[5:]) > 22000:
                        dpg.add_text("Version: 11", bullet=True)
                dpg.add_text(f"Machine: {uname.machine}", bullet=True)

                timestamp = psutil.boot_time()
                bt = datetime.fromtimestamp(timestamp)
                boot = bt.strftime("%m/%d/%Y %I:%M:%S %p")
                dpg.add_text(f"Last boot timestamp: {boot}", bullet=True)

                if platform.system() == "Windows":
                    with dpg.tree_node(label="BIOS"):
                        bios = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\DESCRIPTION\System\BIOS")
                        vendor = winreg.QueryValueEx(bios, "BIOSVendor")
                        version = winreg.QueryValueEx(bios, "BIOSVersion")

                        dpg.add_text(f"Vendor: {vendor[0]}", bullet=True)
                        dpg.add_text(f"Version: {version[0]}", bullet=True)

        threading.Thread(target=update_gpu_temperature, daemon=True).start()
        threading.Thread(target=get_gpu_util, daemon=True).start()

        dpg.create_viewport(
            title="Real Time System Info",
            #on_close=prevent_close,
            #small_icon="res/icon.ico",
            #large_icon="res/icon.ico",
            disable_close=True,
            resizable=False,
            max_width=WIN_WIDTH,
            max_height=WIN_HEIGHT
        )
        dpg.setup_dearpygui()
        dpg.set_primary_window(main_window, True)
        dpg.show_viewport()
        dpg.start_dearpygui()
        dpg.destroy_context()


    def run_dearpygui_in_thread():
        thread = Thread(target=open_dearpygui)
        thread.start()

    AllInfo_button = tk.Button(main_frame, text="Real Time System Info", command=run_dearpygui_in_thread, bg="gray40", fg="cyan", bd=1)
    AllInfo_button.pack(pady=5)
    '''
    
    '''
    def BandNetworkMonitoring():
        def update_data():
            global last_received, last_sent, last_total, running
            
            while running:
                bytes_received = psutil.net_io_counters().bytes_recv
                bytes_sent = psutil.net_io_counters().bytes_sent
                bytes_total = bytes_received + bytes_sent
                
                new_received = bytes_received - last_received if 'last_received' in globals() else 0
                new_sent = bytes_sent - last_sent if 'last_sent' in globals() else 0
                new_total = bytes_total - last_total if 'last_total' in globals() else 0
                
                mb_new_received = new_received / 1024 / 1024
                mb_new_sent = new_sent / 1024 / 1024
                mb_new_total = new_total / 1024 / 1024
                
                # Actualizează textul în text area cu noile date
                text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                
                # Salvează datele în fișier
                with open("network_data.txt", "a") as file:
                    file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                
                print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                
                last_received = bytes_received
                last_sent = bytes_sent
                last_total = bytes_total
                
                time.sleep(1)

        def start():
            global running
            running = True
            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Crează un thread nou pentru actualizarea datelor
            data_thread = threading.Thread(target=update_data)
            data_thread.start()

        def stop():
            global running
            running = False

        # Inițializare variabile
        last_received = psutil.net_io_counters().bytes_recv
        last_sent = psutil.net_io_counters().bytes_sent
        last_total = last_received + last_sent
        running = False
        
        # Crează fereastra
        monitorband = tk.Tk()
        monitorband.title("Network Console")
        monitorband.resizable(False, False)
        monitorband.config(bg="gray20")

        # Creează un text area cu culoare de fundal și text personalizate
        text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
        text_area.pack(expand=True, fill=tk.BOTH)

        # Buton pentru pornirea monitorizării
        start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
        start_button.pack()

        # Buton pentru oprirea monitorizării
        stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
        stop_button.pack()

        # Pornirea buclei principale a interfeței grafice
        monitorband.mainloop()
    '''


    def BandNetworkMonitoring():
        import tkinter as tkj
        from psutil import net_io_counters
        REFRESH_DELAY = 1500  # Intervalul de actualizare pentru monitorizarea lățimii de bandă a rețelei în milisecunde

        class mnbd:
            def __init__(self):
                self.last_upload = 0
                self.last_download = 0
                self.upload_speed = 0
                self.down_speed = 0

                self.windowbd = tk.Tk()
                self.windowbd.title("Network Bandwidth Monitor")
                self.windowbd.geometry("400x400")
                self.windowbd.resizable(False, False)
                self.windowbd.config(bg="gray20")
                #self.image_icon24 = PhotoImage(file = "img/networklogo.png")
                #self.windowbd.iconphoto(False, self.image_icon24)

                # Crearea etichetelor
                self.label_total_upload_header = tkj.Label(self.windowbd, text="Total Upload:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_total_upload_header.pack()
                self.label_total_upload = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_total_upload.pack()

                self.label_total_download_header = tkj.Label(self.windowbd, text="Total Download:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_total_download_header.pack()
                self.label_total_download = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_total_download.pack()

                self.label_total_usage_header = tkj.Label(self.windowbd, text="Total Usage:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_total_usage_header.pack()
                self.label_total_usage = tkj.Label(self.windowbd, text="Calculating...\n", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_total_usage.pack()

                self.label_upload_header = tkj.Label(self.windowbd, text="Upload:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_upload_header.pack()
                self.label_upload = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_upload.pack()

                self.label_download_header = tkj.Label(self.windowbd, text="Download:", font="Quicksand 12 bold", bg="gray20", fg="#ccff66")
                self.label_download_header.pack()
                self.label_download = tkj.Label(self.windowbd, text="Calculating...", font="Quicksand 12", bg="gray20", fg="#ccff66")
                self.label_download.pack()

                self.attribution = tkj.Label(self.windowbd, text="\n~ Tudor Marmureanu ~", font="Quicksand 11 italic", bg="gray20", fg="#ccff66")
                self.attribution.pack()

            def size(self, B):
                KB = float(1024)
                MB = float(KB ** 2)
                GB = float(KB ** 3)
                TB = float(KB ** 4)

                B = float(B)
                if B < KB:
                    return f"{B} Bytes"
                elif KB <= B < MB:
                    return f"{B/KB:.2f} KB"
                elif MB <= B < GB:
                    return f"{B/MB:.2f} MB"
                elif GB <= B < TB:
                    return f"{B/GB:.2f} GB"
                elif TB <= B:
                    return f"{B/TB:.2f} TB"

            def update(self):
                counter = net_io_counters()

                upload = counter.bytes_sent
                download = counter.bytes_recv
                total = upload + download

                if self.last_upload > 0:
                    if upload < self.last_upload:
                        self.upload_speed = 0
                    else:
                        self.upload_speed = upload - self.last_upload

                if self.last_download > 0:
                    if download < self.last_download:
                        self.down_speed = 0
                    else:
                        self.down_speed = download - self.last_download

                self.last_upload = upload
                self.last_download = download
                
                self.label_total_upload["text"] = f"{self.size(upload)} ({upload} Bytes)"
                self.label_total_download["text"] = f"{self.size(download)} ({download} Bytes)"
                self.label_total_usage["text"] = f"{self.size(total)}\n"
                
                self.label_upload["text"] = self.size(self.upload_speed)
                self.label_download["text"] = self.size(self.down_speed)
                
                self.windowbd.after(REFRESH_DELAY, self.update)

            def start_monitoring(self):
                self.windowbd.after(REFRESH_DELAY, self.update)
                #self.windowbd.mainloop()
        monitorb = mnbd()
        monitorb.start_monitoring()
        def update_data():
            global last_received, last_sent, last_total, running
            
            while running:
                bytes_received = psutil.net_io_counters().bytes_recv
                bytes_sent = psutil.net_io_counters().bytes_sent
                bytes_total = bytes_received + bytes_sent
                
                new_received = bytes_received - last_received if 'last_received' in globals() else 0
                new_sent = bytes_sent - last_sent if 'last_sent' in globals() else 0
                new_total = bytes_total - last_total if 'last_total' in globals() else 0
                
                mb_new_received = new_received / 1024 / 1024
                mb_new_sent = new_sent / 1024 / 1024
                mb_new_total = new_total / 1024 / 1024
                
                # Actualizează textul în text area cu noile date
                text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                
                # Salvează datele în fișier
                with open("network_data.txt", "a") as file:
                    file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                
                print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                
                last_received = bytes_received
                last_sent = bytes_sent
                last_total = bytes_total
                
                time.sleep(1)

        def start():
            global running
            running = True
            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Crează un thread nou pentru actualizarea datelor
            data_thread = threading.Thread(target=update_data)
            data_thread.start()

        def stop():
            global running
            running = False

        def wifi_info():
            # Oprește executia butonului de Start
            stop()

            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Rulează comanda pentru a afișa rețelele Wi-Fi disponibile și parolele asociate lor
            '''
            try:
                output = subprocess.check_output(['netsh', 'wlan', 'show', 'all']).decode('utf-8')
                text_area.insert(tk.END, output)
            except subprocess.CalledProcessError as e:
                text_area.insert(tk.END, "Error: " + e.output.decode('utf-8'))
            '''
            try:
                output = subprocess.check_output(['netsh', 'wlan', 'show', 'all']).decode('utf-8')
                # Inserează output-ul în text_area
                text_area.insert(tk.END, output)
                # Salvează output-ul în fișierul wifi_info.txt
                with open('more_network_info.txt', 'w') as file:
                    file.write(output)
                print("Informațiile despre rețelele Wi-Fi au fost salvate în fișierul more_network_info.txt.")
            except subprocess.CalledProcessError as e:
                text_area.insert(tk.END, "Error: " + e.output.decode('utf-8'))
                print("Error: " + e.output.decode('utf-8'))

        def clear_wifi_passwords():
            # Oprește executia butonului de Start
            stop()
            
            # Șterge tot din text area
            text_area.delete(1.0, tk.END)

            # Șterge conținutul text area-ului la fiecare pornire######################
            text_area.delete(1.0, tk.END)
            # Rulează comanda pentru a afișa rețelele Wi-Fi și parolele asociate lor
            try:
                output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8')
                text_area.insert(tk.END, output)
            except subprocess.CalledProcessError as e:
                text_area.insert(tk.END, "Error: " + e.output.decode('utf-8'))########################
            
            # Salvează parolele Wi-Fi în fișierul Wifi_Passwords.txt
            with open("Wifi_Passwords.txt", "w") as file:
                data = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
                profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]
                for i in profiles:
                    results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', i, 'key=clear']).decode('utf-8').split('\n')
                    results = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
                    try:
                        file.write("{:<30}|  {:<}\n".format(i, results[0]))
                        text_area.insert(tk.END, "{:<30}|  {:<}\n".format(i, results[0]))
                    except IndexError:
                        file.write("{:<30}|  {:<}\n".format(i, ""))
                        text_area.insert(tk.END, "{:<30}|  {:<}\n".format(i, ""))
                    except:
                        file.write("Password Not Found\n")
                        text_area.insert(tk.END, "Password Not Found\n")

        def show_devices_on_network():
            stop()
            text_area.delete(1.0, tk.END)
            try:
                output_arp = subprocess.check_output(['arp', '-a']).decode('utf-8')  # modificare aici
                text_area.insert(tk.END, "Active devices on the network:\n" + output_arp + "\n\n\n")
            except subprocess.CalledProcessError as e_arp:
                text_area.insert(tk.END, "Error: " + str(e))  # modificare aici

            try:
                output_netstat = subprocess.check_output(['netstat', '-an']).decode('utf-8')
                text_area.insert(tk.END, "Network connections and open ports:\n" + output_netstat)
            except subprocess.CalledProcessError as e_netstat:
                text_area.insert(tk.END, "Error: " + str(e))  # modificare aici

            with open('devices_on_network.txt', 'w') as f:  # Deschide fișierul pentru scriere ('w' - write mode)
                f.write("Active devices on the network:\n" + output_arp + "\n\n\n" if 'output_arp' in locals() else "")
                f.write("Network connections and open ports:\n" + output_netstat if 'output_netstat' in locals() else "")

        def show_net_connections_for_device():
            try:
                subprocess.run(["control", "netconnections"])
            except Exception as e:
                print("Error:", e)

        # Inițializare variabile
        last_received = psutil.net_io_counters().bytes_recv
        last_sent = psutil.net_io_counters().bytes_sent
        last_total = last_received + last_sent
        running = False
        
        # Crează fereastra
        monitorband = tk.Tk()
        monitorband.title("Network Console")
        monitorband.resizable(False, False)
        monitorband.config(bg="gray20")
        #image_icon25 = PhotoImage(file = "img/networklogo.png")
        #monitorband.iconphoto(False, image_icon25)

        # Creează un text area cu culoare de fundal și text personalizate
        text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
        text_area.pack(expand=True, fill=tk.BOTH)

        # Buton pentru pornirea monitorizării
        start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
        start_button.pack()

        # Buton pentru oprirea monitorizării
        stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
        stop_button.pack()
        
        # Buton pentru afișarea parolelor WiFi
        wifi_passwords_button = tk.Button(monitorband, text="Wi-Fi Passwords", command=clear_wifi_passwords, bg="gray40", bd=10, fg="orange")
        wifi_passwords_button.pack()

        # Buton pentru afisarea informatiilor wifi
        more_info_button = tk.Button(monitorband, text="More Info", command=wifi_info, bg="gray40", bd=10, fg="lime green")
        more_info_button.pack()

        # Buton pentru a afisa dispozitivele conectate la retea
        dev_netw = tk.Button(monitorband, text="Who is on my network", command=show_devices_on_network, bg="gray40", fg="lime green", bd=10)
        dev_netw.pack()

        # Buton pentru a afisa dispozitivele conectate la retea
        net_cp = tk.Button(monitorband, text="Show connections", command=show_net_connections_for_device, bg="gray40", fg="lime green", bd=10)
        net_cp.pack()

        # Buton pentru EXIT
        EXIT_BTN = tk.Button(monitorband, text="EXIT", command=monitorband.destroy, bg="gray40", fg="red", bd=10)
        EXIT_BTN.pack()

        # Pornirea buclei principale a interfeței grafice
        monitorband.mainloop()
        
    bandmonitoring_button = tk.Button(main_frame, text="Network Console", command=BandNetworkMonitoring, bg="gray40", fg="lime green", bd=5)
    bandmonitoring_button.place(x=170,y=60)

    def AIChatbot():
        import tkinter as tk
        from tkinter import scrolledtext
        import re
        import subprocess
        import os
        from datetime import datetime

        class CommandProcessor:
            def __init__(self):
                self.info_text = """Daca nu poti copia, atunci verifica ca maparile sa fie facute si sa ai acces la ele si ca locatiile din fisierul tau txt sa corespunda locatiilor reale din PC si, astfel, copierea se realizeaza instant.
                Copierea se realizeaza mai eficient decat daca ai face manual tot procesul, deoarece locatiile sunt deja precompilate, deci este o maniera mai eficienta cu 20%.
                Daca bara de copiere nu este verde niciodata, atunci locatiile din fisierul tau txt nu corespund sau cuvantul inainte de : este modificat.
                Daca nu se copiaza nimic, atunci verifica maparile si asigura-te ca locatiile corespund cu fisierul txt.
                Acest tool sau program te ajuta sa faci si operatiuni diverse in reteaua ta, inclusiv sa scanezi porturile, sa vezi ce dispozitive se afla in retea sau in VLAN, sa executi diverse comenzi in retea, sa verifici proprietatile hardware ale sistemului tau in timp real, contine si functii care manipuleaza fisierele pdf si multe altele.
                Altceva ar mai fi ca poate sa compare 2 fisiere sau foldere, sa caute o secventa de text si sa o inlocuiasca, genereaza parole in diverse combinatii, ba chiar poate deschide un nou Terminal personalizat si sa cripteze fisiere.
                Licenta are scopul de a limita accesul neautorizat la fel cum este si in cazul conturilor create, adica fiecare cont are un rol predefinit.
                Contul dev nu poate fi accesat decat de Tudor Marmureanu, deoarece nimeni nu are acces full la tot ce contine tocmai din cauza ca se poate da peste cap tot sistemul sau se pot produce pagube in retea.
                Conturile deja predefinite inglobeaza celelalte functionalitati care nu se regasesc in contul it, in principal pentru ca nu au legatura cu procesul de copy.
                Sunt mai multe conturi si functionalitati, insa Tudor Marmureanu nu mi-a dat acces sa dezvalui toata informatia.
                Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale.
                Atat timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii."""

            def process_command(self, question):
                """Process user command and return response"""
                question_lower = question.lower()
                
                # Service Tag commands - Complete list from txt file
                if (question_lower == "open the servicetag" or question_lower == "show the servicetag" or 
                    question_lower == "display the servicetag" or question_lower == "open servicetag" or 
                    question_lower == "show servicetag" or question_lower == "display servicetag" or 
                    question_lower == "deschide-mi servicetagul" or question_lower == "deschide-mi servicetag-ul" or 
                    question_lower == "deschide servicetag-ul" or question_lower == "deschide-mi servicetag" or 
                    question_lower == "afiseaza-mi servicetag" or question_lower == "afiseaza-mi servicetagul" or 
                    question_lower == "deschide servicetagul" or question_lower == "deschide servicetag" or 
                    question_lower == "afiseaza servicetag" or question_lower == "afiseaza servicetagul" or 
                    question_lower == "afiseaza servicetag-ul" or question_lower == "afiseaza-mi servicetag-ul" or 
                    question_lower == "servicetag" or question_lower == "servicetag-ul" or question_lower == "servicetagul" or
                    question_lower == "afiseazami servicetag" or question_lower == "afiseazami servicetagul" or
                    question_lower == "deschidemi servicetagul" or question_lower == "deschidemi servicetag-ul"):
                    return self._get_service_tag()
                
                # Windows License Key commands - Complete list from txt file
                elif (question_lower == "open the windows key" or question_lower == "open the windows serial number" or 
                      question_lower == "open the product key" or question_lower == "open the product key on windows" or question_lower == "open the windows product key"or 
                      question_lower == "display the windows key" or question_lower == "display the windows serial number" or 
                      question_lower == "display the product key" or question_lower == "display the product key on windows" or 
                      question_lower == "show the windows key" or question_lower == "show the windows serial number" or 
                      question_lower == "show the product key" or question_lower == "show the product key on windows" or 
                      question_lower == "open windows key" or question_lower == "open windows serial number" or 
                      question_lower == "open product key" or question_lower == "open product key on windows" or 
                      question_lower == "display windows key" or question_lower == "display windows serial number" or 
                      question_lower == "display product key" or question_lower == "display product key on windows" or 
                      question_lower == "show windows key" or question_lower == "show windows serial number" or 
                      question_lower == "show product key" or question_lower == "show product key on windows" or 
                      question_lower == "deschide-mi licenta" or question_lower == "deschide-mi cheia de licenta" or 
                      question_lower == "afiseaza-mi licenta" or question_lower == "afiseaza-mi cheia de licenta" or 
                      question_lower == "deschide licenta" or question_lower == "deschide cheia de licenta" or 
                      question_lower == "afiseaza licenta" or question_lower == "afiseaza cheia de licenta" or 
                      question_lower == "deschidemi licenta" or question_lower == "deschidemi cheia de licenta" or 
                      question_lower == "afiseazami licenta" or question_lower == "afiseazami cheia de licenta" or 
                      question_lower == "arata-mi licenta" or question_lower == "aratami licenta" or question_lower == "arata licenta" or 
                      question_lower == "arata-mi cheia de licenta" or question_lower == "aratami cheia de licenta" or 
                      question_lower == "arata cheia de licenta" or question_lower == "vezi licenta" or question_lower == "vezi cheia de licenta" or 
                      question_lower == "vezi-mi licenta" or question_lower == "vezi-mi cheia de licenta" or 
                      question_lower == "vezimi licenta" or question_lower == "vezimi cheia de licenta" or 
                      question_lower == "licenta windows" or question_lower == "cheia de licenta windows" or 
                      question_lower == "cheie licenta" or question_lower == "cheia licenta" or question_lower == "key windows" or 
                      question_lower == "windows key" or question_lower == "product key" or question_lower == "windows product key" or 
                      question_lower == "serial windows" or question_lower == "windows serial" or question_lower == "cheie activare" or 
                      question_lower == "cheia de activare" or question_lower == "cod activare windows" or 
                      question_lower == "cod de activare windows" or question_lower == "cheie activare windows" or 
                      question_lower == "cheia de activare windows" or question_lower == "licenta de windows" or 
                      question_lower == "cheia din windows" or question_lower == "licenta din windows" or 
                      question_lower == "cheia de windows" or question_lower == "afiseaza cheia din windows" or 
                      question_lower == "afiseaza-mi cheia din windows" or question_lower == "afiseazami cheia din windows" or 
                      question_lower == "deschide cheia din windows" or question_lower == "deschide-mi cheia din windows" or 
                      question_lower == "deschidemi cheia din windows" or question_lower == "arata cheia din windows" or 
                      question_lower == "arata-mi cheia din windows" or question_lower == "aratami cheia din windows" or 
                      question_lower == "vezi cheia din windows" or question_lower == "vezi-mi cheia din windows" or 
                      question_lower == "vezimi cheia din windows" or question_lower == "cod de windows" or 
                      question_lower == "cod din windows" or question_lower == "serial de windows" or 
                      question_lower == "serial din windows" or question_lower == "key de windows" or question_lower == "key din windows" or
                      question_lower == "aratami cheia windows" or question_lower == "aratami cheia de windows" or
                      question_lower == "aratami cheia din windows" or question_lower == "arat-ami cheia windows" or
                      question_lower == "arata-mi cheia din windows" or question_lower == "arata-mi cheia de windows" or
                      question_lower == "obtain the windows key" or question_lower == "obtain windows key" or question_lower == "obtain product key" or
                      question_lower == "obtain the product key" or question_lower == "get the windows key" or question_lower == "get windows key" or
                      question_lower == "get product key" or question_lower == "get the product key" or question_lower == "find the windows key" or
                      question_lower == "find windows key" or question_lower == "find product key" or question_lower == "find the product key" or question_lower == "gaseste licenta" or
                      question_lower == "gaseste cheia de licenta" or question_lower == "gaseste-mi licenta" or question_lower == "gaseste-mi cheia de licenta" or
                      question_lower == "gasestemi licenta" or question_lower == "gasestemi cheia de licenta" or question_lower == "cauta licenta" or
                      question_lower == "cauta cheia de licenta" or question_lower == "cauta-mi licenta" or question_lower == "cauta-mi cheia de licenta" or
                      question_lower == "cautami licenta" or question_lower == "cautami cheia de licenta" or question_lower == "cheia licenta windows" or
                      question_lower == "cheia de licenta windows" or question_lower == "cheia licenta" or question_lower == "cheia de licenta" or
                      question_lower == "cautami cheia licenta" or question_lower == "cheie licenta windows" or
                      question_lower == "cheie de licenta windows" or question_lower == "cheie licenta" or question_lower == "cheie de licenta" or
                      question_lower == "cheia" or question_lower == "cheie" or question_lower == "cheia windows" or question_lower == "cheie windows" or
                      question_lower == "cheia de windows" or question_lower == "cheie de windows" or question_lower == "windows key" or question_lower == "key windows" or
                      question_lower == "key of windows" or question_lower == "key form windows" or question_lower == "key of the windows" or question_lower == "key from the windows" or
                      question_lower == "windovs product key" or question_lower == "windows license" or question_lower == "windows license key" or
                      question_lower == "afiseaza windows key" or question_lower == "afiseaza windows product key" or question_lower == "afiseaza windows license" or
                      question_lower == "afiseaza windows serial number" or question_lower == "cheia de la windows" or question_lower == "cheie de la windows" or
                      question_lower == "licenta de la windows" or question_lower == "serial number de la windows" or question_lower == "product key de la windows"):
                    return self._get_windows_key()
                
                # System management commands
                elif question_lower in ["lusrmgr.msc", "lusrmgr"]:
                    os.startfile("lusrmgr.msc")
                    return "Opening Local Users and Groups Manager..."
                
                elif question_lower in ["devmgmt.msc", "devmgmt", "device manager"]:
                    os.startfile("devmgmt.msc")
                    return "Opening Device Manager..."
                
                elif (question_lower == "edit power plan" or question_lower == "power plan" or question_lower == "battery" or 
                      question_lower == "battery plan" or question_lower == "batery" or question_lower == "batery plan"):
                    try:
                        subprocess.run(["control", "powercfg.cpl"])
                        return "Opening Power Options..."
                    except Exception as e:
                        return f"Error opening Power Options: {e}"
                
                elif (question_lower == "control panel apps" or question_lower == "control panel" or 
                      question_lower == "appwiz.cpl" or question_lower == "appwiz" or question_lower == "apwiz" or question_lower == "apwiz.cpl"):
                    os.startfile("appwiz.cpl")
                    return "Opening Programs and Features..."
                
                elif (question_lower == "sysdm" or question_lower == "sysdm.cpl" or question_lower == "windows domain" or 
                      question_lower == "domain" or question_lower == "domeniu" or question_lower == "windows domeniu" or question_lower == "domeniu windows"):
                    os.startfile("sysdm.cpl")
                    return "Opening System Properties..."
                
                # Power management commands - Complete list from txt file
                elif (question_lower == "shutdown" or question_lower == "shutdown pc" or question_lower == "inchide pc" or 
                      question_lower == "inchide acest pc" or question_lower == "inchide" or question_lower == "shutdown laptop" or 
                      question_lower == "inchide laptop" or question_lower == "inchide acest laptop"):
                    subprocess.call("shutdown /s /t 1")
                    return "Shutting down system..."
                
                elif (question_lower == "restart" or question_lower == "restart pc" or question_lower == "restarteaza pc" or 
                      question_lower == "restarteaza" or question_lower == "restart laptop" or question_lower == "restarteaza laptop" or 
                      question_lower == "restarteaza acest pc" or question_lower == "restarteaza acest laptop"):
                    subprocess.call("shutdown /r /t 1")
                    return "Restarting system..."
                
                elif (question_lower == "logout" or question_lower == "logout pc" or question_lower == "log out" or 
                      question_lower == "logout laptop" or question_lower == "log out pc" or question_lower == "log out laptop"):
                    subprocess.call("shutdown -l")
                    return "Logging out..."
                
                # System information - Complete list from txt file
                elif (question_lower == "system info" or question_lower == "system information" or 
                      question_lower == "display system info" or question_lower == "afiseaza informatiile sistemului" or 
                      question_lower == "afiseaza informatiile pc-ului" or question_lower == "afiseaza informatiile pcului" or 
                      question_lower == "afiseaza informatiile laptopului" or question_lower == "afiseaza informatiile" or 
                      question_lower == "afiseaza-mi informatiile sistemului" or question_lower == "afiseaza-mi informatiile pc-ului" or 
                      question_lower == "afiseaza-mi informatiile pcului" or question_lower == "afiseaza-mi informatiile laptopului" or 
                      question_lower == "afiseaza-mi informatiile" or
                      question_lower == "afiseazami informatiile sistemului" or question_lower == "afiseazami informatiile pc-ului" or 
                      question_lower == "afiseazami informatiile pcului" or question_lower == "afiseazami informatiile laptopului" or 
                      question_lower == "afiseazami informatiile" or
                      question_lower == "arata-mi informatiile sistemului" or question_lower == "arata-mi informatiile pc-ului" or 
                      question_lower == "arata-mi informatiile pcului" or question_lower == "arata-mi informatiile laptopului" or 
                      question_lower == "arata-mi informatiile" or
                      question_lower == "aratami informatiile sistemului" or question_lower == "aratami informatiile pc-ului" or 
                      question_lower == "aratami informatiile pcului" or question_lower == "aratami informatiile laptopului" or 
                      question_lower == "aratami informatiile"):
                    return self._get_system_info()
                
                # Network commands - Complete list from txt file
                elif (question_lower == "display the devices connected on my network" or 
                      question_lower == "display devices connected on my network" or 
                      question_lower == "display the devices on my network" or question_lower == "display devices on my network" or 
                      question_lower == "show the devices connected on my network" or 
                      question_lower == "show devices connected on my network" or 
                      question_lower == "show the devices on my network" or question_lower == "show devices on my network" or 
                      question_lower == "afiseaza device-urile conectate la retea" or 
                      question_lower == "afiseaza device-urile conectate la reteaua mea" or 
                      question_lower == "afiseaza deviceurile conectate la retea" or 
                      question_lower == "afiseaza deviceurile conectate la reteaua mea" or 
                      question_lower == "afiseaza-mi device-urile conectate la retea" or 
                      question_lower == "afiseaza-mi device-urile conectate la reteaua mea" or 
                      question_lower == "afiseaza-mi deviceurile conectate la retea" or 
                      question_lower == "afiseaza-mi deviceurile conectate la reteaua mea" or
                      question_lower == "afiseazami device-urile conectate la retea" or 
                      question_lower == "afiseazami device-urile conectate la reteaua mea" or 
                      question_lower == "afiseazami deviceurile conectate la retea" or 
                      question_lower == "afiseazami deviceurile conectate la reteaua mea" or
                      question_lower == "show devices on network" or question_lower == "arata device-urile conectate la retea" or 
                      question_lower == "arata device-urile conectate la reteaua mea" or 
                      question_lower == "arata deviceurile conectate la retea" or 
                      question_lower == "arata deviceurile conectate la reteaua mea" or 
                      question_lower == "arata-mi device-urile conectate la retea" or 
                      question_lower == "arata-mi device-urile conectate la reteaua mea" or 
                      question_lower == "arata-mi deviceurile conectate la retea" or 
                      question_lower == "arata-mi deviceurile conectate la reteaua mea" or
                      question_lower == "aratami device-urile conectate la retea" or 
                      question_lower == "aratami device-urile conectate la reteaua mea" or 
                      question_lower == "aratami deviceurile conectate la retea" or 
                      question_lower == "aratami deviceurile conectate la reteaua mea"):
                    return self._get_network_devices()
                
                # WiFi passwords - Complete list from txt file
                elif (question_lower == "afiseaza toate parolele wi-fi" or question_lower == "afiseaza toate parolele wifi" or 
                      question_lower == "afiseaza parolele wi-fi" or question_lower == "afiseaza parolele wifi" or 
                      question_lower == "afiseaza-mi toate parolele wi-fi" or question_lower == "afiseaza-mi toate parolele wifi" or 
                      question_lower == "afiseaza-mi parolele wi-fi" or question_lower == "afiseaza-mi parolele wifi" or 
                      question_lower == "afiseazami toate parolele wi-fi" or question_lower == "afiseazami toate parolele wifi" or 
                      question_lower == "afiseazami parolele wi-fi" or question_lower == "afiseazami parolele wifi" or 
                      question_lower == "arata toate parolele wi-fi" or question_lower == "arata toate parolele wifi" or 
                      question_lower == "arata parolele wi-fi" or question_lower == "arata parolele wifi" or 
                      question_lower == "arata-mi toate parolele wi-fi" or question_lower == "arata-mi toate parolele wifi" or 
                      question_lower == "aratami toate parolele wi-fi" or question_lower == "aratami toate parolele wifi" or 
                      question_lower == "arata-mi parolele wi-fi" or question_lower == "arata-mi parolele wifi" or 
                      question_lower == "aratami parolele wi-fi" or question_lower == "aratami parolele wifi" or 
                      question_lower == "show wifi passwords" or question_lower == "show all wifi passwords" or 
                      question_lower == "show the wifi passwords" or question_lower == "display all wifi passwords" or 
                      question_lower == "display the wifi passwords" or question_lower == "show wifi pass" or 
                      question_lower == "show the wifi pass" or question_lower == "show all wifi pass" or 
                      question_lower == "display all wifi pass" or question_lower == "display the wifi pass" or 
                      question_lower == "show wifi paswords" or question_lower == "show wifi pas" or 
                      question_lower == "show all wifi pas" or question_lower == "show the wifi pas" or 
                      question_lower == "display all wifi pas" or question_lower == "show wi-fi passwords" or 
                      question_lower == "show the wi-fi passwords" or question_lower == "show all wi-fi passwords" or 
                      question_lower == "display all wi-fi passwords" or question_lower == "display the wi-fi passwords" or 
                      question_lower == "show wi-fi pass" or question_lower == "show the wi-fi pass" or 
                      question_lower == "display wi-fi pass" or question_lower == "display the wi-fi pass" or 
                      question_lower == "show all wi-fi pass" or question_lower == "display all wi-fi pass" or 
                      question_lower == "show wi-fi paswords" or question_lower == "show wi-fi pas" or 
                      question_lower == "vreau sa imi afisezi parolele wifi" or question_lower == "vreau sa imi afisezi parolele wi-fi" or 
                      question_lower == "display the wi-fi password" or question_lower == "display the wifi password" or 
                      question_lower == "display the wi-fi passwords" or question_lower == "display the wifi passwords" or 
                      question_lower == "show the wi-fi password" or question_lower == "show the wifi password" or 
                      question_lower == "show the wi-fi passwords" or question_lower == "show the wifi passwords"):
                    return self._get_wifi_passwords()
                
                # Identity question - Complete list from txt file
                elif (question_lower == "cine esti" or question_lower == "ce esti" or question_lower == "cine esti tu" or 
                      question_lower == "ce esti tu" or question_lower == "cine esti?" or question_lower == "ce esti?" or 
                      question_lower == "cine esti tu?" or question_lower == "ce esti tu?" or question_lower == "who are you?" or question_lower == "who are you"):
                    return "Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale. Atata timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii."
                
                # Default response using keyword matching
                else:
                    return self._get_default_response(question)

            def _get_service_tag(self):
                """Get system service tag"""
                try:
                    output = subprocess.check_output(["wmic", "bios", "get", "serialnumber"]).decode().strip().split("\n")
                    service_tag = output[1].strip()
                    try:
                        with open("ServiceTag.txt", 'w') as file:
                            file.write(service_tag)
                        return f"Service Tag: {service_tag}\n(Saved to ServiceTag.txt)"
                    except Exception as e:
                        return f"Service Tag: {service_tag}\n(Error saving to file: {e})"
                except Exception as e:
                    return f"Error retrieving Service Tag: {e}"

            def _get_windows_key(self):
                """Get Windows license key"""
                try:
                    output = subprocess.check_output(["wmic", "path", "softwarelicensingservice", "get", "OA3xOriginalProductKey"]).decode().strip().split("\n")
                    # Handle the output parsing more carefully
                    license_key = ""
                    for line in output:
                        if line.strip() and "OA3xOriginalProductKey" not in line:
                            license_key = line.strip()
                            break
                    
                    if not license_key:
                        license_key = "No product key found"
                    
                    try:
                        with open("WindowsKey.txt", 'w') as file:
                            file.write(license_key)
                        return f"Windows License Key: {license_key}\n(Saved to WindowsKey.txt)"
                    except Exception as e:
                        return f"Windows License Key: {license_key}\n(Error saving to file: {e})"
                except Exception as e:
                    return f"Error retrieving Windows License Key: {e}"

            def _get_system_info(self):
                """Get system information"""
                try:
                    info = subprocess.check_output(['systeminfo']).decode('utf-8').split('\n')
                    formatted_info = [item.rstrip() for item in info if item.strip()]
                    try:
                        with open("SystemInfo.txt", 'w') as file:
                            file.write('\n'.join(formatted_info))
                        return f"System Information:\n" + '\n'.join(formatted_info[:10]) + f"\n\n(Full info saved to SystemInfo.txt - {len(formatted_info)} lines total)"
                    except Exception as e:
                        return f"System Information:\n" + '\n'.join(formatted_info[:10]) + f"\n\n(Error saving to file: {e})"
                except Exception as e:
                    return f"Error retrieving system information: {e}"

            def _get_network_devices(self):
                """Get network devices"""
                try:
                    output_arp = subprocess.check_output(['arp', '-a']).decode('utf-8')
                    output_netstat = subprocess.check_output(['netstat', '-an']).decode('utf-8')
                    
                    full_output = f"Active devices on the network:\n{output_arp}\n\nNetwork connections and open ports:\n{output_netstat}"
                    
                    with open('devices_on_network.txt', 'w') as f:
                        f.write(full_output)
                    
                    return f"{full_output}\n\n(Saved to devices_on_network.txt)"
                except Exception as e:
                    return f"Error retrieving network devices: {e}"

            def _get_wifi_passwords(self):
                """Get WiFi passwords"""
                try:
                    passwords = []
                    data = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
                    profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]
                    
                    for profile in profiles:
                        try:
                            results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear']).decode('utf-8').split('\n')
                            password_lines = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
                            password = password_lines[0] if password_lines else ""
                            passwords.append(f"{profile:<30} | {password}")
                        except:
                            passwords.append(f"{profile:<30} | Password not found")
                    
                    with open("Wifi_Passwords.txt", "w") as file:
                        file.write('\n'.join(passwords))
                    
                    return f"WiFi Passwords:\n" + '\n'.join(passwords) + "\n\n(Saved to Wifi_Passwords.txt)"
                except Exception as e:
                    return f"Error retrieving WiFi passwords: {e}"

            def _get_default_response(self, question):
                """Get default response using keyword matching with improved skip words"""
                if '?' in question:
                    question = question.replace('?', '')
                
                # Expanded skip words set (fără diacritice)
                skip_words = {
                    # Pronouns and basic words
                    "me", "it", "you", "he", "she", "we", "they", "i", "my", "your", "his", "her", "our", "their",
                    "eu", "tu", "el", "ea", "noi", "voi", "ei", "ele", "meu", "tau", "sau", "lui", "ei", "nostru", "vostru", "lor",
                    
                    # Verbs
                    "have", "has", "had", "am", "is", "are", "was", "were", "be", "been", "do", "does", "did", "will", "would", "could", "should",
                    "sunt", "esti", "este", "suntem", "sunteti", "eram", "erai", "era", "erام", "erati", "erau", "fac", "faci", "face", "facem", "faceti", "fac",
                    "am", "ai", "are", "avem", "aveti", "au", "aveam", "aveai", "avea", "aveام", "aveati", "aveau",
                    
                    # Prepositions and conjunctions  
                    "in", "on", "at", "by", "for", "with", "to", "from", "of", "off", "about", "and", "or", "but", "if", "when", "where", "how", "why", "what", "which", "that", "this", "these", "those",
                    "la", "in", "pe", "cu", "de", "din", "prin", "pentru", "despre", "si", "sau", "dar", "daca", "cand", "unde", "cum", "ce", "care", "care", "acest", "aceasta", "acestea", "acei", "acele",
                    
                    # Articles
                    "a", "an", "the", "un", "o", "niste",
                    
                    # Common adjectives/adverbs
                    "good", "bad", "big", "small", "fast", "slow", "new", "old", "hot", "cold", "here", "there", "now", "then", "today", "yesterday", "tomorrow",
                    "bun", "rau", "mare", "mic", "rapid", "lent", "nou", "vechi", "cald", "rece", "aici", "acolo", "acum", "atunci", "azi", "ieri", "maine",
                    
                    # Numbers
                    "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",
                    "unu", "doi", "trei", "patru", "cinci", "sase", "sapte", "opt", "noua", "zece",
                    
                    # Specific words that should be ignored
                    "scanezi", "place", "run", "not", "priveste", "privire", "voastre", "noastre", "mele", "tale", "ale",
                    "exista", "locatiilor", "locatii", "locatiile", "dns", "vlan", "vad", "vezi", "vazut", "cat", "deci", "asadar",
                    "cazul", "caz", "contrar", "alte", "altele", "altor", "construit", "parca", "prin", "intermediul", "ajutor",
                    "ajutorul", "ajutoare", "baza", "bazez", "bazezi", "bazam", "bazati", "puternic", "slab", "doar", "numai",
                    "intrucat", "incat", "soare", "frig", "furtuna", "ninge", "ploua", "stele", "rol", "faceau", "faceati", "faceam",
                    "situatie", "situatii", "niciodata", "aia", "acea", "aceea", "fisiere", "fisierele", "fisierelor", "fisier",
                    "fisierul", "directorul", "director", "directoare", "directoarele", "arhiva", "zip", "arhive", "arhivele",
                    "arhivelor", "cont", "conturi", "conturile", "conturilor", "fa", "mi", "ti", "le", "lor", "noastra", "voastra",
                    "voua", "va", "noua", "mie", "placea", "placut", "copi", "copii", "instant", "astfel", "altfel", "legatura",
                    "copierea", "inglobeaza", "principal", "procesul", "deja", "nicicand", "niciunde", "nici", "faca", "candva",
                    "cand", "putea", "chiar", "timp", "real", "realmente", "mult", "alt", "peste", "produce", "contine", "contin",
                    "cauza", "cap", "tot", "toti", "toate", "poate", "poti", "as", "merge", "functioneaza", "pentru", "deoarece",
                    "tocmai", "din", "avea", "aveai", "fi", "fost", "musai", "trebuie", "trebuia", "trebuit", "mai", "imi", "ne",
                    "ii", "cheie", "cheia", "chei", "mergea", "mers", "poate", "realiza", "nu", "pot", "poti", "nimic", "se", "putea", "prea",
                    "proces", "process", "nereusita", "nereusit",
                    
                    # Single characters and common punctuation-related
                    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
                    "-", "_", "mi", "ti", "l", "v", "m", "ar", "va"
                }
                
                unique_sentences = set()
                
                # Clean and split question into words
                words_in_question = []
                for word in re.split(r'\W+', question.lower()):
                    # Only include words that are longer than 2 characters and not in skip_words
                    if len(word) > 2 and word not in skip_words:
                        words_in_question.append(word)
                
                # If no meaningful words left, return default message
                if not words_in_question:
                    return "Imi pare rau, dar nu am fost antrenat sa raspund la aceasta cerere. Voi primi actualizari constante."
                
                # Search for sentences containing meaningful words
                sentences = [s.strip() for s in self.info_text.split('.') if s.strip()]
                
                for sentence in sentences:
                    sentence_words = set(re.split(r'\W+', sentence.lower()))
                    
                    # Check if any meaningful word from question is in sentence
                    if any(word in sentence_words for word in words_in_question):
                        # Additional check: make sure the sentence has some substantial content
                        sentence_meaningful_words = [w for w in sentence_words if len(w) > 2 and w not in skip_words]
                        if len(sentence_meaningful_words) >= 3:  # Sentence must have at least 3 meaningful words
                            unique_sentences.add(sentence.strip())
                
                # Return results or default message
                if unique_sentences:
                    return '. '.join(unique_sentences) + '.'
                else:
                    return "Imi pare rau, dar nu am fost antrenat sa raspund la aceasta cerere. Voi primi actualizari constante."

        class EfficientChatInterface:
            """Modern, efficient chat interface"""
            def __init__(self, master):
                self.master = master
                self.processor = CommandProcessor()
                self._setup_ui()

            def _setup_ui(self):
                """Setup user interface"""
                self.master.title("AI Chatbot - Muapmash model")
                self.master.configure(bg="gray20")
                self.master.geometry("900x700")
                
                # Main container
                main_frame = tk.Frame(self.master, bg="gray20")
                main_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
                
                # Title
                title_label = tk.Label(
                    main_frame,
                    text="AI Chatbot - Muapmash model",
                    bg="gray20",
                    fg="#00ff88",
                    font=("Roboto", 16, "bold")
                )
                title_label.pack(pady=(0, 15))
                
                # Chat history with better styling and proper wrapping
                chat_frame = tk.Frame(main_frame, bg="gray20")
                chat_frame.pack(fill=tk.BOTH, expand=True)
                
                self.chat_history = scrolledtext.ScrolledText(
                    chat_frame,
                    wrap=tk.WORD,  # This ensures text wraps at word boundaries
                    bg="gray10",
                    fg="#ccff66",
                    font=("Roboto", 10),
                    state=tk.DISABLED,
                    relief=tk.FLAT,
                    bd=0,
                    insertbackground="cyan",
                    selectbackground="gray40"
                )
                self.chat_history.pack(fill=tk.BOTH, expand=True)
                
                # Input frame
                input_frame = tk.Frame(main_frame, bg="gray20")
                input_frame.pack(fill=tk.X, pady=(15, 0))
                
                # Input label
                input_label = tk.Label(
                    input_frame,
                    text="Ask a question:",
                    bg="gray20",
                    fg="cyan",
                    font=("Roboto", 11, "bold")
                )
                input_label.pack(anchor="w", pady=(0, 5))
                
                # Input field container - Changed to Text widget for better wrapping
                entry_frame = tk.Frame(input_frame, bg="gray40", relief=tk.FLAT, bd=1)
                entry_frame.pack(fill=tk.X)
                
                # Replace Entry with Text widget for multi-line input with wrapping
                self.input_field = tk.Text(
                    entry_frame,
                    bg="gray40",
                    fg="#ccff66",
                    insertbackground="cyan",
                    font=("Roboto", 12),
                    relief=tk.FLAT,
                    bd=10,
                    highlightthickness=0,
                    wrap=tk.WORD,  # Enable word wrapping
                    height=3,  # Set initial height to 3 lines
                    undo=True,  # Enable undo functionality
                    maxundo=20
                )
                self.input_field.pack(fill=tk.BOTH, padx=2, pady=2)
                
                # Button frame
                button_frame = tk.Frame(input_frame, bg="gray20")
                button_frame.pack(fill=tk.X, pady=(10, 0))
                
                # Send button
                self.send_button = tk.Button(
                    button_frame,
                    text="Send",
                    command=self.send_message,
                    bg="#0066cc",
                    fg="white",
                    font=("Roboto", 11, "bold"),
                    relief=tk.FLAT,
                    bd=0,
                    padx=20,
                    pady=8,
                    cursor="hand2",
                    activebackground="#66ff66",
                    activeforeground="white"
                )
                self.send_button.pack(side=tk.LEFT)
                
                # Clear button
                clear_button = tk.Button(
                    button_frame,
                    text="Clear",
                    command=self.clear_chat,
                    bg="#cc3300",
                    fg="white",
                    font=("Roboto", 11, "bold"),
                    relief=tk.FLAT,
                    bd=0,
                    padx=20,
                    pady=8,
                    cursor="hand2",
                    activebackground="#66ff66",
                    activeforeground="white"
                )
                clear_button.pack(side=tk.LEFT, padx=(10, 0))
                
                # Status label
                self.status_label = tk.Label(
                    main_frame,
                    text="Ready - Type your question above",
                    bg="gray20",
                    fg="#66ff99",
                    font=("Arial", 9)
                )
                self.status_label.pack(pady=(10, 0))
                
                # Bind events
                self.input_field.bind('<Return>', self.on_enter_key)
                self.input_field.bind('<Control-Return>', self.insert_newline)
                self.master.bind('<F1>', lambda e: self.show_help())
                
                # Focus on input field
                self.input_field.focus_set()
                
                # Add welcome message
                self.add_to_chat("AI Assistant", "Hello! I'm your AI assistant. I can help you with system commands, network operations, and much more. Type your question and press Enter to send, or Ctrl+Enter for a new line.", "assistant")

            def on_enter_key(self, event):
                """Handle Enter key - send message if Shift not pressed"""
                if event.state & 0x1:  # Shift key pressed
                    return  # Allow normal newline
                else:
                    self.send_message()
                    return "break"  # Prevent default newline

            def insert_newline(self, event):
                """Insert newline when Ctrl+Enter is pressed"""
                self.input_field.insert(tk.INSERT, '\n')
                return "break"

            def send_message(self):
                """Send message and get response"""
                question = self.input_field.get("1.0", tk.END).strip()
                if not question:
                    return
                
                # Clear input field
                self.input_field.delete("1.0", tk.END)
                
                # Update status
                self.status_label.config(text="Processing...", fg="yellow")
                self.master.update()
                
                # Add user message to chat
                self.add_to_chat("You", question, "user")
                
                try:
                    # Process command
                    response = self.processor.process_command(question)
                    self.add_to_chat("AI Assistant", response, "assistant")
                    self.status_label.config(text="Response completed", fg="#66ff99")
                except Exception as e:
                    error_msg = f"Error processing command: {str(e)}"
                    self.add_to_chat("AI Assistant", error_msg, "error")
                    self.status_label.config(text="Error occurred", fg="#ff6666")

            def add_to_chat(self, sender, message, msg_type):
                """Add message to chat history with better formatting"""
                self.chat_history.config(state=tk.NORMAL)
                
                # Add timestamp
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                # Color scheme based on message type
                if msg_type == "user":
                    sender_color = "#66ccff"
                    text_color = "#ccff66"
                elif msg_type == "assistant":
                    sender_color = "#00ff88"
                    text_color = "#ffffff"
                else:  # error
                    sender_color = "#ff6666"
                    text_color = "#ffcccc"
                
                # Add sender with timestamp
                self.chat_history.insert(tk.END, f"\n[{timestamp}] {sender}:\n", "sender")
                
                # Add message content with proper wrapping
                self.chat_history.insert(tk.END, f"{message}\n", "message")
                
                # Configure tags for colors
                self.chat_history.tag_config("sender", foreground=sender_color, font=("Arial", 10, "bold"))
                self.chat_history.tag_config("message", foreground=text_color, font=("Consolas", 10))
                
                # Add separator
                self.chat_history.insert(tk.END, "─" * 80 + "\n", "separator")
                self.chat_history.tag_config("separator", foreground="gray50")
                
                # Auto-scroll to bottom
                self.chat_history.see(tk.END)
                self.chat_history.config(state=tk.DISABLED)

            def clear_chat(self):
                """Clear chat history"""
                self.chat_history.config(state=tk.NORMAL)
                self.chat_history.delete(1.0, tk.END)
                self.chat_history.config(state=tk.DISABLED)
                self.status_label.config(text="Chat cleared", fg="#66ff99")
                
                # Re-add welcome message
                self.add_to_chat("AI Assistant", "Chat cleared! Ready for new questions.", "assistant")

            def show_help(self):
                """Show help information"""
                help_text = """
    AVAILABLE COMMANDS:

    SYSTEM INFORMATION:
    • "servicetag" / "show servicetag" - Get system service tag
    • "windows key" / "product key" - Get Windows license key  
    • "system info" - Display system information

    POWER MANAGEMENT:
    • "shutdown" / "inchide pc" - Shutdown system
    • "restart" / "restarteaza" - Restart system
    • "logout" - Log out current user

    SYSTEM TOOLS:
    • "device manager" / "devmgmt" - Open Device Manager
    • "power plan" / "battery" - Open Power Options
    • "control panel" - Open Programs and Features
    • "domain" / "sysdm" - Open System Properties

    NETWORK:
    • "show devices on network" - Display network devices
    • "show wifi passwords" - Display all saved WiFi passwords

    GENERAL:
    • F1 - Show this help
    • Enter - Send message
    • Ctrl+Enter - New line in message
    • Clear button - Clear chat history

    Type your question in Romanian or English!
                """
                self.add_to_chat("AI Assistant", help_text, "assistant")

        # Create and run the application
        rootai = tk.Tk()
        app = EfficientChatInterface(rootai)
        
        try:
            rootai.mainloop()
        except KeyboardInterrupt:
            print("\nApplication closed by user")
        except Exception as e:
            print(f"Application error: {e}")


    AI_button = tk.Button(main_frame, text="AI Chatbot", command=AIChatbot, bg="gray40", fg="#ccff66", bd=5)
    AI_button.place(x=170,y=5)

    def ReadMe():
        # Funcția pentru închiderea ferestrei
        def inchide_fereastra():
            readme.destroy()
        
        # Crearea ferestrei principale
        readme = tk.Toplevel()
        readme.title("Working procedure (Copy App)")
        readme.geometry("700x350")
        readme.config(bg="gray20")  # Setare culoare fundal gri închis
        #image_icon50 = PhotoImage(file = "img/complogo.png")
        #readme.iconphoto(False, image_icon50)
        
        # Crearea obiectului Text și inserarea textului
        text = scrolledtext.ScrolledText(readme, wrap="word", height=10, width=40)
        text.insert(tk.END, "To avoid potential errors, it is recommended to run the program as the corresponding domain user. Additionally, there must be a network location mapping, and you should have access to that location, of course. You need to manually configure the paths.txt and profiles.json files (according to the example).\n")
        text.configure(state="disabled")  # Textul nu poate fi editat
        text.pack(expand=True, fill="both", padx=10, pady=10)
        
        # Butonul pentru închiderea ferestrei
        buton_inchide = tk.Button(readme, text="Close", command=inchide_fereastra, bg="gray40", fg="white", bd=10)
        buton_inchide.pack(pady=5)


        # Funcția pentru închiderea ferestrei
        def inchide_fereastra1():
            readme1.destroy()
     
        # Crearea ferestrei principale
        readme1 = tk.Toplevel()
        readme1.title("About the application (licensed version)")
        readme1.geometry("700x350")
        readme1.config(bg="gray20")  # Setare culoare fundal gri închis
        #image_icon27 = PhotoImage(file = "img/complogo.png")
        #readme1.iconphoto(False, image_icon27)
     
        # Crearea obiectului Text și inserarea textului
        text1 = scrolledtext.ScrolledText(readme1, wrap="word", height=10, width=40)
        text1.insert(tk.END, "- Explorer Mode: Allow manual exploration of the paths and record them in the corresponding .txt files, and enable copying them to the manually selected location (this process occurs automatically after the copy buttons are pressed).\n")
        text1.insert(tk.END, "- Get MAC & IP: Display the MAC address and the IP address of the computer.\n")
        text1.insert(tk.END, "- Port Scanner: Scan the ports of a device on the network either through its IP address or hostname.\n")
        text1.insert(tk.END, "- Ping Tool: Send a ping command to all devices within the given range and display all available ports. Also, show the network data of your computer.\n")
        text1.insert(tk.END, "- Comparator: Compare 2 files to see the differences, as well as 2 folders, and display all differences.\n")
        text1.insert(tk.END, "- Find & Replace: Search for a character sequence in a text and replace the text sequence with the string entered in the respective field.\n")
        text1.insert(tk.END, "- Open the Equipment Sheet: The Excel file can be opened using the application interface, and any sheet from that file can be accessed.\n")
        text1.insert(tk.END, "- Text Editor: Advanced Notepad.\n")
        text1.insert(tk.END, "- Whiteboard: Mini Paint tool.\n")
        text1.insert(tk.END, "- PDF to Word: Convert a .pdf file to .docx, and the images from its content can be saved in a folder named Imagini.\n")
        text1.insert(tk.END, "- PDF Tools: Various tools for manipulating a PDF.")
        text1.insert(tk.END, "- Backup Utility: Perform a backup of data that is sensitive or might undergo major changes; the user should consider why it is important to create a backup.\n")
        text1.insert(tk.END, "- Rename Utility: Rename certain files in a selected folder.\n")
        text1.insert(tk.END, "- System Info: Display information about your computer, such as the service tag and Windows license key, in a special console. Additionally, you can perform operations such as shutdown, restart, and logout, along with many other commands from the Command Prompt.\n")
        text1.insert(tk.END, "- Network Console: Display confidential information such as real-time data traffic to view, for example, how quickly data is being copied from the current network (in the Copy application), information about stored Wi-Fi network passwords, and details regarding drivers, internet or Wi-Fi connections, routers, or devices that were registered on the computer when a hotspot was created, along with many other details.\n")
        text1.insert(tk.END, "- Dev Console: It is a console where you can debug this program and more; you can edit a multitude of functionalities of this program and create or implement nearly any functionality much faster than writing classic code. Therefore, access is restricted regardless of whether the user has a product key or not.\n")
        text1.configure(state="disabled")  # Textul nu poate fi editat
        text1.pack(expand=True, fill="both", padx=10, pady=10)
     
        # Butonul pentru închiderea ferestrei
        buton_inchide1 = tk.Button(readme1, text="Close", command=inchide_fereastra1, bg="gray40", fg="white", bd=10)
        buton_inchide1.pack(pady=5)
     
     
    readme_button = tk.Button(main_frame, text="Read me first", command=ReadMe, bg="gray40", fg="cyan", bd=5)
    readme_button.place(x=400, y=5)


    def DebuggingConsoleFunc():
        IDE = Tk()
        IDE.title("Dev Console")
        IDE.geometry("1280x720+10+10")
        IDE.configure(bg="gray20")
        IDE.resizable(False, False)
        #image_icon28 = PhotoImage(file = "img/devlogo.png")
        #IDE.iconphoto(False, image_icon28)

        label = Label(IDE, bg="gray20")
        label.place(x=180, y=0)

        file_path = ''

        def set_file_path(path):
            nonlocal file_path
            file_path = path

        def open_file():
            nonlocal file_path
            path = askopenfilename(filetypes=[('Python Files)', '*.py')])
            if path:
                with open(path, 'r') as file:
                    code = file.read()
                    code_input.delete('1.0', END)
                    code_input.insert('1.0', code)
                    file_path = path

                file_name = os.path.basename(path)
                label.config(text=file_name)
                label.config(bg="#ccff66")

        def save():
            nonlocal file_path
            if file_path == '':
                path = asksaveasfilename(filetypes=[('Python Files)', '*.py')])
            else:
                path = file_path

            if path:
                with open(path, 'w') as file:
                    code = code_input.get('1.0', END)
                    file.write(code)
                    set_file_path(path)

                file_name = os.path.basename(path)
                label.config(text=file_name)
                label.config(bg="#ccff66")

        def run():
            nonlocal file_path
            if file_path == '':
                messagebox.showerror("Dev Console Request Window", "Please save your code before running.")
                return

            def run_process():
                command = f'python {file_path}'
                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
                output, error = process.communicate()
                code_output.delete('1.0', END)
                code_output.insert('1.0', output.decode())
                code_output.insert('1.0', error.decode())

                path = file_path
                file_name = os.path.basename(path)
                label.config(text=file_name)
                label.config(bg="#ccff66")

            threading.Thread(target=run_process).start()

        def on_closing():
            if messagebox.askyesnocancel("Dev Console Request Window", "Do you want to save your work before exiting?"):
                save()
            IDE.destroy()

        def open_whiteboard():
            whiteboard = Toplevel(IDE)
            whiteboard.title("Whiteboard")
            whiteboard.geometry("800x600+700+100")
            whiteboard.resizable(False, False)
            #image_icon29 = PhotoImage(file = "img/complogo.png")
            #whiteboard.iconphoto(False, image_icon29)

            canvas = Canvas(whiteboard, bg="white")
            canvas.place(x=0, y=0, width=800, height=600)

            def draw(event):
                x, y = event.x, event.y
                canvas.create_line(x, y, x + 1, y + 1)

            canvas.bind("<B1-Motion>", draw)

        def open_text_editor():
            text_editor = Toplevel(IDE)
            text_editor.title("Text Editor")
            text_editor.geometry("500x500+18+50")
            #image_icon30 = PhotoImage(file = "img/complogo.png")
            #text_editor.iconphoto(False, image_icon30)

            text_area = Text(text_editor)
            text_area.pack(fill='both', expand=True)

            save_button = Button(text_editor, text="Save", background="lightgreen", activebackground="#ccff66",
                                 command=lambda: save_file_TE(text_area))
            save_button.pack(side='right')

        def save_file_TE(text_area):
            file = filedialog.asksaveasfile(mode = 'w', defaultextension = ".txt")
            if file is None:
                return
            text = text_area.get("1.0", "end-1c")
            file.write(text)
            file.close()

        def on_closing1():
            if messagebox.askokcancel("Warning Window", "Do you want to quit?"):
                IDE.destroy()

        def highlight_line(event):
            code_input.tag_remove("active_line", 1.0, "end")
            code_input.tag_add("active_line", "insert linestart", "insert lineend+1c")
            code_input.tag_config("active_line", background="#262626")

        def update_line_numbers(event):
            txt = event.widget
            txt.update_idletasks()
            lineno = txt.index("@0,0").split(".")[0]
            lineend = txt.index("end-1c")
            lines = int(lineend.split(".")[0]) - int(lineno)
            line_number_bar.config(state="normal")
            line_number_bar.delete("1.0", "end")
            line_number_bar.insert("end", "\n".join(str(i) for i in range(1, lines + 1)))
            line_number_bar.config(state="disabled")

        def NEW():
            nonlocal file_path
            code_input.delete('1.0', END)
            code_output.delete('1.0', END)
            file_path = ''
            label.config(text="")
            label.config(bg="gray20")

        def calculator():
            calcroot = Tk()
            calcroot.title("Scientific Calculator")
            calcroot.configure(background = 'white')
            calcroot.resizable(width=False, height=False)
            calcroot.geometry("480x568+450+90")
            #image_icon31 = PhotoImage(file = "img/calculatorlogo.png")
            #calcroot.iconphoto(False, image_icon31)
            calc = Frame(calcroot)
            calc.grid()

            class Calc():
                def __init__(self):
                    self.total=0
                    self.current=''
                    self.input_value=True
                    self.check_sum=False
                    self.op=''
                    self.result=False

                def numberEnter(self, num):
                    self.result=False
                    firstnum=txtDisplay.get()
                    secondnum=str(num)
                    if self.input_value:
                        self.current = secondnum
                        self.input_value=False
                    else:
                        if secondnum == '.':
                            if secondnum in firstnum:
                                return
                        self.current = firstnum+secondnum
                    self.display(self.current)

                def sum_of_total(self):
                    self.result=True
                    self.current=float(self.current)
                    if self.check_sum==True:
                        self.valid_function()
                    else:
                        self.total=float(txtDisplay.get())

                def display(self, value):
                    txtDisplay.delete(0, END)
                    txtDisplay.insert(0, value)

                def valid_function(self):
                    if self.op == "add":
                        self.total += self.current
                    if self.op == "sub":
                        self.total -= self.current
                    if self.op == "multi":
                        self.total *= self.current
                    if self.op == "divide":
                        self.total /= self.current
                    if self.op == "mod":
                        self.total %= self.current
                    self.input_value=True
                    self.check_sum=False
                    self.display(self.total)

                def operation(self, op):
                    self.current = float(self.current)
                    if self.check_sum:
                        self.valid_function()
                    elif not self.result:
                        self.total=self.current
                        self.input_value=True
                    self.check_sum=True
                    self.op=op
                    self.result=False

                def Clear_Entry(self):
                    self.result = False
                    self.current = "0"
                    self.display(0)
                    self.input_value=True

                def All_Clear_Entry(self):
                    self.Clear_Entry()
                    self.total=0

                def pi(self):
                    self.result = False
                    self.current = math.pi
                    self.display(self.current)

                def tau(self):
                    self.result = False
                    self.current = math.tau
                    self.display(self.current)

                def e(self):
                    self.result = False
                    self.current = math.e
                    self.display(self.current)

                def mathPM(self):
                    self.result = False
                    self.current = -(float(txtDisplay.get()))
                    self.display(self.current)

                def squared(self):
                    self.result = False
                    self.current = math.sqrt(float(txtDisplay.get()))
                    self.display(self.current)

                def cos(self):
                    self.result = False
                    self.current = math.cos(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def cosh(self):
                    self.result = False
                    self.current = math.cosh(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def tan(self):
                    self.result = False
                    self.current = math.tan(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def tanh(self):
                    self.result = False
                    self.current = math.tanh(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def sin(self):
                    self.result = False
                    self.current = math.sin(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def sinh(self):
                    self.result = False
                    self.current = math.sinh(math.radians(float(txtDisplay.get())))
                    self.display(self.current)

                def log(self):
                    self.result = False
                    self.current = math.log(float(txtDisplay.get()))
                    self.display(self.current)

                def exp(self):
                    self.result = False
                    self.current = math.exp(float(txtDisplay.get()))
                    self.display(self.current)

                def acosh(self):
                    self.result = False
                    self.current = math.acosh(float(txtDisplay.get()))
                    self.display(self.current)

                def asinh(self):
                    self.result = False
                    self.current = math.asinh(float(txtDisplay.get()))
                    self.display(self.current)

                def expm1(self):
                    self.result = False
                    self.current = math.expm1(float(txtDisplay.get()))
                    self.display(self.current)

                def lgamma(self):
                    self.result = False
                    self.current = math.lgamma(float(txtDisplay.get()))
                    self.display(self.current)

                def degrees(self):
                    self.result = False
                    self.current = math.degrees(float(txtDisplay.get()))
                    self.display(self.current)

                def log2(self):
                    self.result = False
                    self.current = math.log2(float(txtDisplay.get()))
                    self.display(self.current)

                def log10(self):
                    self.result = False
                    self.current = math.log10(float(txtDisplay.get()))
                    self.display(self.current)

                def log1p(self):
                    self.result = False
                    self.current = math.log1p(float(txtDisplay.get()))
                    self.display(self.current)

            added_value = Calc()

            txtDisplay = Entry(calc, font=('Helvetica',20,'bold'),
                            bg='black',fg='white',
                            bd=30,width=28,justify=RIGHT)
            txtDisplay.grid(row=0,column=0, columnspan=4, pady=1)
            txtDisplay.insert(0,"0")

            numberpad = "789456123"
            i=0
            btn = []
            for j in range(2,5):
                for k in range(3):
                    btn.append(Button(calc, width=6, height=2,
                                    bg='black',fg='white',
                                    font=('Helvetica',20,'bold'),
                                    bd=4,text=numberpad[i]))
                    btn[i].grid(row=j, column= k, pady = 1)
                    btn[i]["command"]=lambda x=numberpad[i]:added_value.numberEnter(x)
                    i+=1
                
            btnClear = Button(calc, text=chr(67),width=6,
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold')
                            ,bd=4, command=added_value.Clear_Entry
                            ).grid(row=1, column= 0, pady = 1)

            btnAllClear = Button(calc, text=chr(67)+chr(69),
                                width=6, height=2,
                                bg='powder blue', 
                                font=('Helvetica',20,'bold'),
                                bd=4,
                                command=added_value.All_Clear_Entry
                                ).grid(row=1, column= 1, pady = 1)

            btnsq = Button(calc, text="\u221A",width=6, height=2,
                        bg='powder blue', font=('Helvetica',
                                                20,'bold'),
                        bd=4,command=added_value.squared
                        ).grid(row=1, column= 2, pady = 1)

            btnAdd = Button(calc, text="+",width=6, height=2,
                            bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("add")
                            ).grid(row=1, column= 3, pady = 1)

            btnSub = Button(calc, text="-",width=6,
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("sub")
                            ).grid(row=2, column= 3, pady = 1)

            btnMul = Button(calc, text="x",width=6, 
                            height=2,bg='powder blue', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("multi")
                            ).grid(row=3, column= 3, pady = 1)

            btnDiv = Button(calc, text="/",width=6, 
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("divide")
                            ).grid(row=4, column= 3, pady = 1)

            btnZero = Button(calc, text="0",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.numberEnter(0)
                            ).grid(row=5, column= 0, pady = 1)

            btnDot = Button(calc, text=".",width=6,
                            height=2,bg='powder blue', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.numberEnter(".")
                            ).grid(row=5, column= 1, pady = 1)
            btnPM = Button(calc, text=chr(177),width=6, 
                        height=2,bg='powder blue', font=('Helvetica',20,'bold'),
                        bd=4,command=added_value.mathPM
                        ).grid(row=5, column= 2, pady = 1)

            btnEquals = Button(calc, text="=",width=6,
                            height=2,bg='powder blue',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.sum_of_total
                            ).grid(row=5, column= 3, pady = 1)
            # ROW 1 :
            btnPi = Button(calc, text="pi",width=6,
                        height=2,bg='black',fg='white', 
                        font=('Helvetica',20,'bold'),
                        bd=4,command=added_value.pi
                        ).grid(row=1, column= 4, pady = 1)

            btnCos = Button(calc, text="Cos",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.cos
                        ).grid(row=1, column= 5, pady = 1)

            btntan = Button(calc, text="tan",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.tan
                        ).grid(row=1, column= 6, pady = 1)

            btnsin = Button(calc, text="sin",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.sin
                        ).grid(row=1, column= 7, pady = 1)

            # ROW 2 :
            btn2Pi = Button(calc, text="2pi",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.tau
                        ).grid(row=2, column= 4, pady = 1)

            btnCosh = Button(calc, text="Cosh",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.cosh
                            ).grid(row=2, column= 5, pady = 1)

            btntanh = Button(calc, text="tanh",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.tanh
                            ).grid(row=2, column= 6, pady = 1)

            btnsinh = Button(calc, text="sinh",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.sinh
                            ).grid(row=2, column= 7, pady = 1)

            # ROW 3 :
            btnlog = Button(calc, text="log",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log
                        ).grid(row=3, column= 4, pady = 1)

            btnExp = Button(calc, text="exp",width=6, height=2,
                            bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.exp
                        ).grid(row=3, column= 5, pady = 1)

            btnMod = Button(calc, text="Mod",width=6,
                            height=2,bg='black',fg='white', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=lambda:added_value.operation("mod")
                            ).grid(row=3, column= 6, pady = 1)

            btnE = Button(calc, text="e",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.e
                        ).grid(row=3, column= 7, pady = 1)

            # ROW 4 :
            btnlog10 = Button(calc, text="log10",width=6, 
                            height=2,bg='black',fg='white', 
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log10
                            ).grid(row=4, column= 4, pady = 1)

            btncos = Button(calc, text="log1p",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log1p
                            ).grid(row=4, column= 5, pady = 1)

            btnexpm1 = Button(calc, text="expm1",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd = 4,command=added_value.expm1
                            ).grid(row=4, column= 6, pady = 1)

            btngamma = Button(calc, text="gamma",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.lgamma
                            ).grid(row=4, column= 7, pady = 1)
            # ROW 5 :
            btnlog2 = Button(calc, text="log2",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.log2
                            ).grid(row=5, column= 4, pady = 1)

            btndeg = Button(calc, text="deg",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.degrees
                        ).grid(row=5, column= 5, pady = 1)

            btnacosh = Button(calc, text="acosh",width=6,
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.acosh
                            ).grid(row=5, column= 6, pady = 1)

            btnasinh = Button(calc, text="asinh",width=6, 
                            height=2,bg='black',fg='white',
                            font=('Helvetica',20,'bold'),
                            bd=4,command=added_value.asinh
                            ).grid(row=5, column= 7, pady = 1)

            lblDisplay = Label(calc, text = "Scientific Calculator",
                            font=('Helvetica',30,'bold'),
                            bg='black',fg='white',justify=CENTER)

            lblDisplay.grid(row=0, column= 4,columnspan=4)

            def iExit():
                iExit = tkinter.messagebox.askyesno("Scientific Calculator",
                                                    "Do you want to exit ?")
                if iExit>0:
                    calcroot.destroy()
                    return

            def Scientific():
                calcroot.resizable(width=False, height=False)
                calcroot.geometry("944x568+0+0")


            def Standard():
                calcroot.resizable(width=False, height=False)
                calcroot.geometry("480x568+0+0")

            menubar = Menu(calc)

            # ManuBar 1 :
            filemenu = Menu(menubar, tearoff = 0)
            menubar.add_cascade(label = 'File', menu = filemenu)
            filemenu.add_command(label = "Standard", command = Standard)
            filemenu.add_command(label = "Scientific", command = Scientific)
            filemenu.add_separator()
            filemenu.add_command(label = "Exit", command = iExit)

            # ManuBar 2 :
            editmenu = Menu(menubar, tearoff = 0)
            menubar.add_cascade(label = 'Edit', menu = editmenu)
            editmenu.add_command(label = "Cut")
            editmenu.add_command(label = "Copy")
            editmenu.add_separator()
            editmenu.add_command(label = "Paste")

            calcroot.config(menu=menubar)

            calcroot.mainloop()


        code_input = Text(IDE, bg="black", fg="lime green", wrap="word", insertbackground="white")
        code_input.place(x=180, y=20, width=680, height=720)

        code_output = Text(IDE, font="consolas 15", bg="gray20", fg="#ccff66", insertbackground="white")
        code_output.place(x=860, y=0, width=420, height=720)

        Button(IDE, bd=5, bg="gray40", fg="cyan", text="Open File", command=open_file).place(x=30, y=30)
        Button(IDE, bd=5, bg="gray40", fg="orange", text="Save", command=save).place(x=30, y=70)
        Button(IDE, bd=5, bg="gray40", fg="lime green", text="Run", command=run).place(x=30, y=110)
        Button(IDE, bd=5, bg="gray40", fg="cyan", text="Calculator", command=calculator).place(x=30, y=320)
        Button(IDE, bd=5, bg="gray40", fg="red", text="EXIT", command=on_closing).place(x=30, y=380)
        Button(IDE, bd=5, bg="gray40", fg="white", text="Whiteboard", command=open_whiteboard).place(x=30, y=210)
        Button(IDE, bd=5, bg="gray40", fg="white", text="Text Editor", command=open_text_editor).place(x=30, y=170)
        Button(IDE, bd=5, bg="gray40", fg="lime green", text="NEW", command=NEW).place(x=30, y=270)

        IDE.protocol("WM_DELETE_WINDOW", on_closing1)

        code_input.bind("<Motion>", highlight_line)
        code_input.bind("<Key>", highlight_line)

        scrollbar = Scrollbar(IDE, command=code_input.yview)
        scrollbar.pack(side="left", fill="y")
        code_input.config(yscrollcommand=scrollbar.set)

        line_number_bar = Text(IDE, width=10000, bg="#595959", state="disabled", fg="#ccff66")
        line_number_bar.pack(side="left", fill="y")
        line_number_bar.place(x=147, y=20, width=30, height=720)

        code_input.bind("<Any-KeyRelease>", update_line_numbers)
        code_input.bind("<Button-1>", update_line_numbers)

        IDE.mainloop()

    def activate_debugging_button():
        if adminT != False and c == 3:
            Debugging_button.config(state="normal")

    Debugging_button = tk.Button(main_frame, text="Dev Console", command=DebuggingConsoleFunc, bg="black", fg="#ff8080", bd=5, state="disabled")
    Debugging_button.place(x=400, y=60)
    adminT = Debugging_button

    
    save_location = tk.StringVar()

    if adminT != False:
        activate_debugging_button()
     
    root.mainloop()
############################################################################################################################################
def main2():
    messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
    if key_is_valid == False:
        validation.destroy()  # Închide fereastra de validare
    class FileCopyApp:
        def __init__(self, root):
            self.root = root
            self.root.title("Copy App")
            self.root.geometry("400x400")
            self.root.config(bg="gray20")

            # Directorul destinație
            self.current_user = os.getenv('USERNAME')
            self.destination_path = rf'C:\KIT'

            # Verifică dacă calea de destinație există
            if not os.path.exists(self.destination_path):
                try:
                    # Creează calea de destinație dacă nu există
                    os.makedirs(self.destination_path)
                    print("Director successfully created:", self.destination_path)
                except OSError as e:
                    print("Error creating directory:", e)

            # Dicționarul cu programe și direcțiile lor sursă
            self.program_paths = {}
            
            # Deschide fișierul pentru citire
            with open("paths.txt", "r") as file:
                for line in file:
                    key, value = line.strip().split(":")
                    self.program_paths[key.strip()] = value.strip()

            # Frame-uri pentru fiecare jumătate a ferestrei
            self.left_frame = tk.Frame(root, bg="gray20")
            self.left_frame.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.BOTH, expand=True)

            self.right_frame = tk.Frame(root, bg="gray20")
            self.right_frame.pack(side=tk.RIGHT, padx=5, pady=5, fill=tk.Y)

            # Canvas pentru lista de programe cu scrollbar
            self.canvas = tk.Canvas(self.left_frame, bg="gray20", highlightthickness=0)
            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.scrollbar = ttk.Scrollbar(self.right_frame, orient="vertical", command=self.canvas.yview)
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.canvas.configure(yscrollcommand=self.scrollbar.set)
            self.canvas.bind('<Configure>', self.on_canvas_configure)

            self.program_frame = tk.Frame(self.canvas, bg="gray20")
            self.canvas.create_window((0, 0), window=self.program_frame, anchor='nw')

            # Funcție pentru actualizarea culorii textului în funcție de starea checkbox-ului
            def update_fg_color(*args):
                for program, var in self.program_vars.items():
                    if var.get() == 1:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="cyan")
                    else:
                        chk = self.program_checkboxes[program]
                        chk.config(fg="white")

            # Checkbox-uri și progres bar-uri pentru programe
            self.program_vars = {}
            self.program_checkboxes = {}
            self.progress_bars = {}

            # Frame pentru butoanele de selecție a checkbox-urilor
            self.checkbox_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.checkbox_button_frame.pack(pady=10, padx=10)

            # Încarcă profilele și creează butoanele
            self.load_profiles_and_create_buttons()

            col_count = 2  # Numărul de coloane dorit
            row_count = -(-len(self.program_paths) // col_count)  # Calculul numărului de rânduri necesare
            program_index = 0  # Variabilă pentru a ține evidența indexului programului
         
            for i in range(row_count):
                for j in range(col_count):
                    if program_index >= len(self.program_paths):
                        break
                    program = list(self.program_paths.keys())[program_index]
                    var = tk.IntVar()
                    chk = tk.Checkbutton(self.program_frame, text=program, variable=var, bg="gray20", selectcolor="green", activebackground="pale green")
                    chk.grid(row=i, column=j*2, sticky="w")
                    self.program_vars[program] = var
                    self.program_checkboxes[program] = chk
                    chk.config(fg="white")
                    var.trace_add("write", update_fg_color)
         
                    # Creează progres bar-ul pentru fiecare program și îl pune sub checkbox
                    self.progress_bars[program] = ttk.Progressbar(self.program_frame, orient="horizontal", length=200, mode="determinate", style="custom.Horizontal.TProgressbar")
                    self.progress_bars[program].grid(row=i, column=j*2+1, sticky="ew", padx=10, pady=2)
         
                    program_index += 1
         
            # Stilizare progres bar personalizat
            self.style = ttk.Style()
            self.style.theme_use('default')
            self.style.configure("custom.Horizontal.TProgressbar", troughcolor='gray', background='green', borderwidth=0)

            # Frame pentru butonul de copiere
            self.copy_button_frame = tk.Frame(self.right_frame, bg="gray20")
            self.copy_button_frame.pack(pady=10, padx=10)

            # Plasează butonul de copiere direct în self.right_frame
            self.copy_button = tk.Button(self.right_frame, text="Copy Files", command=self.copy_files, bg="cyan", fg="black", bd=6)
            self.copy_button.pack(pady=10, padx=10)

            # Buton stergere campuri checkbox
            self.delete_button = tk.Button(self.right_frame, text="Delete checkboxes", command=self.delete_checkboxes, bg="red", fg="black", bd=6)
            self.delete_button.pack(pady=10, padx=10)

            self.bandmonitoring_button = tk.Button(self.right_frame, text="Network Console", command=self.band_network_monitoring, bg="gray40", fg="lime green", bd=5)
            self.bandmonitoring_button.pack(pady=5)
                
            # Butonul pentru a ieși din aplicație
            self.button_exit = tk.Button(self.checkbox_button_frame, text="EXIT", command=self.exit_application, bg="red", fg="white", bd=10)
            self.button_exit.pack(pady=20)

            self.last_received = 0
            self.last_sent = 0
            self.last_total = 0
            self.running = False

        def load_profiles_and_create_buttons(self):
            # Încarcă profilurile din JSON
            with open("profiles.json", "r") as f:
                self.profiles = json.load(f)

            # Creează butoanele pentru fiecare profil
            for profile_name in self.profiles:
                button = tk.Button(self.checkbox_button_frame, text=profile_name,
                                command=lambda p=profile_name: self.select_profile_checkboxes(p),
                                bg="gray40", fg="white", bd=1)
                button.pack(pady=5, padx=10)

        def select_profile_checkboxes(self, profile_name):
            # Resetează toate checkbox-urile
            for program in self.program_vars:
                self.program_vars[program].set(0)

            # Resetează barele de progres
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0

            # Resetează textul checkbox-urilor care se termină cu " (done)"
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                if current_text.endswith(" (done)"):
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)

            # Verifică dacă profilul există
            if profile_name in self.profiles:
                profile_checkboxes = self.profiles[profile_name]["checkboxes"]
                for program in profile_checkboxes:
                    if program in self.program_vars:
                        self.program_vars[program].set(1)
    ##############################################################################################################################################################    
                
         
        def exit_application(self):
            if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
                root.destroy()
         
    ###############################################################################
        def band_network_monitoring(self):
            def update_data():
                while self.running:
                    bytes_received = psutil.net_io_counters().bytes_recv
                    bytes_sent = psutil.net_io_counters().bytes_sent
                    bytes_total = bytes_received + bytes_sent
                        
                    new_received = bytes_received - self.last_received if hasattr(self, 'last_received') else 0
                    new_sent = bytes_sent - self.last_sent if hasattr(self, 'last_sent') else 0
                    new_total = bytes_total - self.last_total if hasattr(self, 'last_total') else 0
                  
                    mb_new_received = new_received / 1024 / 1024
                    mb_new_sent = new_sent / 1024 / 1024
                    mb_new_total = new_total / 1024 / 1024
                        
                    # Actualizează textul în text area cu noile date
                    text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                    text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                        
                    # Salvează datele în fișier
                    with open("network_data.txt", "a") as file:
                        file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        
                    print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                        
                    self.last_received = bytes_received
                    self.last_sent = bytes_sent
                    self.last_total = bytes_total
                        
                    time.sleep(1)

            def start():
                self.running = True
                # Șterge conținutul text area-ului la fiecare pornire
                text_area.delete(1.0, tk.END)
                # Crează un thread nou pentru actualizarea datelor
                data_thread = threading.Thread(target=update_data)
                data_thread.start()

            def stop():
                self.running = False

            # Crează fereastra
            monitorband = tk.Toplevel()
            monitorband.title("Network Console")
            monitorband.resizable(False, False)
            monitorband.config(bg="gray20")
            #image_icon44 = PhotoImage(file = "img/networklogo.png")
            #monitorband.iconphoto(False, image_icon44)

            # Creează un text area cu culoare de fundal și text personalizate
            text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
            text_area.pack(expand=True, fill=tk.BOTH)

            # Buton pentru pornirea monitorizării
            start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
            start_button.pack()

            # Buton pentru oprirea monitorizării
            stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
            stop_button.pack()

            # Inițializare variabile
            self.last_received = psutil.net_io_counters().bytes_recv
            self.last_sent = psutil.net_io_counters().bytes_sent
            self.last_total = self.last_received + self.last_sent
            self.running = False

            # Pornirea buclei principale a interfeței grafice
            #monitorband.mainloop()
    ###############################################################################
         
        def delete_checkboxes(self):
            for program in self.program_vars:
                self.program_vars[program].set(0)
            #self.program_vars[""].set(0)
            for progress_bar in self.progress_bars.values():
                progress_bar["value"] = 0
            for program in self.program_checkboxes:
                current_text = self.program_checkboxes[program].cget("text")
                # Verificăm dacă textul se termină cu " (done)"
                if current_text.endswith(" (done)"):
                    # Eliminăm ultimele 77 caractere din textul curent și actualizăm textul checkbox-ului
                    updated_text = current_text[:-7]
                    self.program_checkboxes[program].config(text=updated_text)
         
        def on_canvas_configure(self, event):
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
         
        def copy_files(self):
            self.copy_button.config(state="disabled")  # Dezactivează butonul de copiere
            #self.select_Director_button.config(state="disabled")
            selected_programs = [program for program, var in self.program_vars.items() if var.get() == 1]
            if not selected_programs:
                messagebox.showwarning("No program selected", "Please select at least one program to copy the files.")
                self.copy_button.config(state="normal")  # Activează butonul de copiere
                #self.select_Director_button.config(state="normal")
                return
         
            # Funcție pentru a actualiza textul checkbox-urilor cu "done"
            def update_checkbox_text():
                for program in selected_programs:
                    checkbox = self.program_checkboxes[program]
                    checkbox.config(text=program + " (done)")
         
            # Funcție pentru a realiza copierea fișierelor într-un fir de execuție separat
            def copy_files_thread():
                try:
                    for program in selected_programs:
                        program_source = self.program_paths[program]
                        if os.path.exists(program_source):
                            # Crează un director pentru a stoca fișierele copiate
                            save_directory = os.path.join(self.destination_path, os.path.basename(program_source))
                            os.makedirs(save_directory, exist_ok=True)
                            if os.path.isdir(program_source):
                                # Dacă sursa este un director, copiază întregul director
                                total_files = sum(len(files) for _, _, files in os.walk(program_source))  # Calculăm numărul total de fișiere
                                files_copied = 0  # Inițializăm contorul pentru fișierele copiate
                                for root, dirs, files in os.walk(program_source):
                                    for dir in dirs:
                                        src = os.path.join(root, dir)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        os.makedirs(dest, exist_ok=True)
                                    for file in files:
                                        src = os.path.join(root, file)
                                        dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                        # Verificăm dacă fișierul de destinație există deja
                                        if not os.path.exists(dest):
                                            shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                        # Actualizăm progresul
                                        files_copied += 1
                                        progress_value = (files_copied / total_files) * 100
                                        self.progress_bars[program]["value"] = progress_value
                                        self.root.update_idletasks()  # Actualizează interfața grafică
         
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                            else:
                                # Dacă sursa este un fișier, copiază doar fișierul
                                total_files = 1  # Avem un singur fișier de copiat
                                files_copied = 0
                                file_name = os.path.basename(program_source)
                                src = program_source
                                dest = os.path.join(save_directory, file_name)
                                # Verificăm dacă fișierul de destinație există deja
                                if not os.path.exists(dest):
                                    shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                files_copied += 1
                                progress_value = (files_copied / total_files) * 100
                                self.progress_bars[program]["value"] = progress_value
                                self.root.update_idletasks()  # Actualizează interfața grafică
                                # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                self.program_checkboxes[program].config(text=program + " (done)")
         
                    # Afisăm mesajul de finalizare a copierii
                    self.root.after(0, self.show_copy_success)
        
                except Exception as ex:
                    # Afisăm mesaj de eroare dacă apare o excepție
                    self.root.after(0, lambda e=ex: self.show_copy_error(e))
        
                finally:
                    # Activează butonul de copiere după finalizarea copierii
                    self.root.after(0, self.enable_copy_button)
         
            # Pornim firul de execuție pentru copierea fișierelor
            threading.Thread(target=copy_files_thread).start()
         
         
        def show_copy_success(self):
            messagebox.showinfo("Copy completed", "The files have been successfully copied.")
         
        def show_copy_error(self, error_message):
            messagebox.showerror("Error copying", f"An error occurred while copying the files: {str(error_message)}")
         
        def enable_copy_button(self):
            self.copy_button.config(state="normal")
         
    def browse_folder():
        folder_path = filedialog.askdirectory()
        if folder_path:
            folder_path = folder_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("folder_paths.txt", "a") as file:
                file.write(folder_path + "\n")
         
    def browse_file():
        file_path = filedialog.askopenfilename()
        if file_path:
            file_path = file_path.replace("/", "\\")  # înlocuim '/' cu '\'
            with open("file_paths.txt", "a") as file:
                file.write(file_path + "\n")
         
    def copy_file():
        with open("file_paths.txt", "r") as file:
            file_paths = file.readlines()
        for file_path in file_paths:
            file_path = file_path.strip()  # Eliminăm caracterele de nouă linie și spații suplimentare
            shutil.copy2(file_path, save_location.get())
         
    def copy_folder():
        with open("folder_paths.txt", "r") as file:
            folder_paths = file.readlines()
        for folder_path in folder_paths:
            folder_path = folder_path.strip()
            save_path = os.path.join(save_location.get(), os.path.basename(folder_path))
            try:
                shutil.copytree(folder_path, save_path)
            except PermissionError:
                messagebox.showerror("Error", "Access to the source folder is denied.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {str(e)}")
         
    def update_buttons_state():
        if save_location.get():
            button_copy_file.config(state="normal")
            button_copy_folder.config(state="normal")
        else:
            button_copy_file.config(state="disabled")
            button_copy_folder.config(state="disabled")
         
    def select_save_location():
        save_location.set(filedialog.askdirectory())
        update_buttons_state()
         
    def open_copy_window():
        global button_copy_file, button_copy_folder
        copy_window = tk.Toplevel(root)
        copy_window.title("Copy Files/Folders")
        copy_window.config(bg="gray20")  # Setare culoare fundal gri închis
        copy_window.resizable(False, False)
        #image_icon46 = PhotoImage(file = "img/downloadlogo.png")
        #copy_window.iconphoto(False, image_icon46)
         
        frame = tk.Frame(copy_window)
        frame.pack(padx=20, pady=20)
        
        button_copy_file = tk.Button(frame, text="Copy Files", command=copy_file, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_file.pack(padx=10, pady=5)
         
        button_copy_folder = tk.Button(frame, text="Copy Folders", command=copy_folder, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_copy_folder.pack(padx=10, pady=5)
         
        button_select_location = tk.Button(frame, text="Select Save Location", command=select_save_location, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_select_location.pack(padx=10, pady=5)
         
        update_buttons_state()
         
        copy_window.mainloop()
         
    def open_file_explorer_window():
        file_explorer_window = tk.Toplevel(root)
        file_explorer_window.title("Browse in File Explorer")
        file_explorer_window.config(bg="gray20")  # Setare culoare fundal gri închis
        file_explorer_window.resizable(False, False)
        #image_icon47 = PhotoImage(file = "img/downloadlogo.png")
        #file_explorer_window.iconphoto(False, image_icon47)
         
        frame = tk.Frame(file_explorer_window, bg="gray20")  # Setare culoare fundal gri închis
        frame.pack(padx=20, pady=20)
         
        button_folder = tk.Button(frame, text="Select a Folder", command=browse_folder, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordura
        button_folder.pack(padx=10, pady=5)
         
        button_file = tk.Button(frame, text="Select a File", command=browse_file, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_file.pack(padx=10, pady=5)
         
        button_open_copy_window = tk.Button(frame, text="Open Copy Window", command=open_copy_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_open_copy_window.pack(padx=10, pady=5)
         
    def open_file_copy_app_window():
        file_copy_app_window = tk.Toplevel(root)
        file_copy_app_window.title("Copy App Defaults")
        file_copy_app_window.config(bg="gray20")  # Setare culoare fundal gri închis
        # Dezactivarea posibilității de redimensionare a ferestrei
        file_copy_app_window.resizable(False, False)
        #image_icon48 = PhotoImage(file = "img/downloadlogo.png")
        #file_copy_app_window.iconphoto(False, image_icon48)
        # Maximizarea ferestrei
        file_copy_app_window.state("zoomed")
        app = FileCopyApp(file_copy_app_window)
     
    def ExecuteIPandMAC():
        pass
     
    root = tk.Tk()
    root.title("Menu")
    root.geometry("300x790+10+10")
    root.config(bg="gray20")  # Setare culoare fundal gri închis
    root.resizable(False, False)
    #image_icon39 = PhotoImage(file = "img/appslogo.png")
    #root.iconphoto(False, image_icon39)
     
    main_frame = tk.Frame(root, bg="gray20")  # Setare culoare fundal gri închis
    main_frame.pack(padx=20, pady=20)
     
    button_open_file_explorer = tk.Button(main_frame, text="Explorer Mode", command=open_file_explorer_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
    button_open_file_explorer.pack(padx=10, pady=5)
     
    button_open_file_copy_app = tk.Button(main_frame, text="Copy App", command=open_file_copy_app_window, bg="gray40", fg="white", bd=1)  # Schimbare scris negru
    button_open_file_copy_app.pack(padx=10, pady=5)
     
    button_network = tk.Button(main_frame, text="Get Ip & MAC", command=ExecuteIPandMAC, bg="black", fg="white", bd=1, state="disabled")  # Schimbare scris negru + gray40
    button_network.pack(padx=10, pady=5)
     
    # ==== Scanning Functions ====
    def PortScanner():
        pass
     
    button_portscanner = tk.Button(main_frame, text="Port Scanner", command=PortScanner, bg="black", fg="white", bd=1, state="disabled")
    button_portscanner.pack(padx=10, pady=5)
     
    def PingTool():
        pass
     
    button_ping = tk.Button(main_frame, text="Ping Tool", command=PingTool, bg="black", fg="white", bd=1, state="disabled") #gray40
    button_ping.pack(padx=10, pady=5)
     
    def Comparator():
        pass
     
    button_pydiff = tk.Button(main_frame, text="Comparator", command=Comparator, bg="black", fg="white", bd=1, state="disabled") #gray40
    button_pydiff.pack(padx=10, pady=5)
     
    def ReplAndFind():
        pass

    button_findrepl = tk.Button(main_frame, text="Find & Replace text", command=ReplAndFind, bg="black", fg="white", bd=1, state="disabled") #black
    button_findrepl.pack(padx=10, pady=5) 

    def ScreenRec():
        pass

    scrrec_button = tk.Button(main_frame, text="Screen Events", command=ScreenRec, bg="black", fg="white", bd=1, state="disabled") #black
    scrrec_button.pack(padx=10, pady=5)

    def ZIPF():
        pass

    button_zip = tk.Button(main_frame, text="Create/Extract ZIP", command=ZIPF, bg="black", fg="white", bd=1, state="disabled") #black
    button_zip.pack(padx=10, pady=5)
     
    def open_excel_and_display_table():
        pass
     
    def display_table(wb, sheet_name):
        pass
     
     
    # Creating a button to open the Excel file and display the table
    open_button = tk.Button(main_frame, text="Open the Equipment Sheet", command=open_excel_and_display_table, bg="black", fg="white", bd=1, state="disabled") #gray40
    open_button.pack(pady=5)
     
    def OpenNotepad():
        pass

    open_notepad_button = tk.Button(main_frame, text="Text Editor", command=OpenNotepad, bg="black", fg="white", bd=1, state="disabled") #gray40
    open_notepad_button.pack(pady=5)
    
    def OpenPaint():
        pass
    
    open_paint_button = Button(main_frame, text="Whiteboard", command=OpenPaint, bg="black", fg="white", bd=1, state="disabled") #gray40
    open_paint_button.pack(pady=5)    
    
    def PDFToWordConv():
        pass
        
    WP = tk.Button(main_frame, text="PDF to Word", command=PDFToWordConv, bg="black", fg="white", bd=1, state="disabled") #bg=gray40
    WP.pack(pady=5)

    def pdftools():
        pass

    pdftools_button = tk.Button(main_frame, text="PDF Tools", command=pdftools, bg="Black", fg="white", bd=1, state="disabled") #bg=black
    pdftools_button.pack(pady=5) 

    def BackupRestore():
        pass
    
    bkr_button = tk.Button(main_frame, text="Backup Utility", command=BackupRestore, bg="black", fg="white", bd=1, state="disabled") #bg=gray40
    bkr_button.pack(pady=5)  
    
    def Renamer():
        pass

    rn_button = tk.Button(main_frame, text="Rename Utility", command=Renamer, bg="black", fg="white", bd=1, state="disabled") #bg=gray40
    rn_button.pack(pady=5) 

    def SystemInfoFunc():
        pass

    SystemInfo_button = tk.Button(main_frame, text="System Info", command=SystemInfoFunc, bg="black", fg="white", bd=1, state="disabled")
    SystemInfo_button.pack(pady=5)

    '''
    def run_dearpygui_in_thread():
        pass

    AllInfo_button = tk.Button(main_frame, text="Real Time System Info", command=run_dearpygui_in_thread, bg="black", fg="white", bd=1, state="disabled") #gray40
    AllInfo_button.pack(pady=5)
    '''

    def BandNetworkMonitoring():
        def update_data():
            global last_received, last_sent, last_total, running
            
            while running:
                bytes_received = psutil.net_io_counters().bytes_recv
                bytes_sent = psutil.net_io_counters().bytes_sent
                bytes_total = bytes_received + bytes_sent
                
                new_received = bytes_received - last_received if 'last_received' in globals() else 0
                new_sent = bytes_sent - last_sent if 'last_sent' in globals() else 0
                new_total = bytes_total - last_total if 'last_total' in globals() else 0
                
                mb_new_received = new_received / 1024 / 1024
                mb_new_sent = new_sent / 1024 / 1024
                mb_new_total = new_total / 1024 / 1024
                
                # Actualizează textul în text area cu noile date
                text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                
                # Salvează datele în fișier
                with open("network_data.txt", "a") as file:
                    file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                
                print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                
                last_received = bytes_received
                last_sent = bytes_sent
                last_total = bytes_total
                
                time.sleep(1)

        def start():
            global running
            running = True
            # Șterge conținutul text area-ului la fiecare pornire
            text_area.delete(1.0, tk.END)
            # Crează un thread nou pentru actualizarea datelor
            data_thread = threading.Thread(target=update_data)
            data_thread.start()

        def stop():
            global running
            running = False

        # Inițializare variabile
        last_received = psutil.net_io_counters().bytes_recv
        last_sent = psutil.net_io_counters().bytes_sent
        last_total = last_received + last_sent
        running = False
        
        # Crează fereastra
        monitorband = tk.Tk()
        monitorband.title("Network Console")
        monitorband.resizable(False, False)
        monitorband.config(bg="gray20")
        #image_icon40 = PhotoImage(file = "img/networklogo.png")
        #monitorband.iconphoto(False, image_icon40)

        # Creează un text area cu culoare de fundal și text personalizate
        text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
        text_area.pack(expand=True, fill=tk.BOTH)

        # Buton pentru pornirea monitorizării
        start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
        start_button.pack()

        # Buton pentru oprirea monitorizării
        stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
        stop_button.pack()

        # Pornirea buclei principale a interfeței grafice
        monitorband.mainloop()
        
    bandmonitoring_button = tk.Button(main_frame, text="Network Console", command=BandNetworkMonitoring, bg="black", fg="white", bd=1, state="disabled") #gray40
    bandmonitoring_button.pack(pady=1)

    def AIChatbot():
        pass

    AI_button = tk.Button(main_frame, text="AI Chatbot", command=AIChatbot, bg="black", fg="white", bd=1, state="disabled")
    AI_button.pack(pady=5)

    def ReadMe():
        # Funcția pentru închiderea ferestrei
        def inchide_fereastra():
            readme.destroy()
     
        # Crearea ferestrei principale
        readme = tk.Toplevel()
        readme.title("Working procedure (Copy App)")
        readme.geometry("700x350")
        readme.config(bg="gray20")  # Setare culoare fundal gri închis
        #image_icon50 = PhotoImage(file = "img/complogo.png")
        #readme.iconphoto(False, image_icon50)
        
        # Crearea obiectului Text și inserarea textului
        text = scrolledtext.ScrolledText(readme, wrap="word", height=10, width=40)
        text.insert(tk.END, "To avoid potential errors, it is recommended to run the program as the corresponding domain user. Additionally, there must be a network location mapping, and you should have access to that location, of course. You need to manually configure the paths.txt and profiles.json files (according to the example).\n")
        text.configure(state="disabled")  # Textul nu poate fi editat
        text.pack(expand=True, fill="both", padx=10, pady=10)
     
     
    readme_button = tk.Button(main_frame, text="Read me first", command=ReadMe, bg="gray40", fg="cyan", bd=5)
    readme_button.pack(pady=7)

    def DebuggingConsoleFunc():
        pass

    Debugging_button = tk.Button(main_frame, text="Dev Console", command=ReadMe, bg="black", fg="#ff8080", bd=5, state="disabled")
    Debugging_button.pack(pady=7)
     
    save_location = tk.StringVar()
     
    root.mainloop()


'''
# Definirea cheii de validare
KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"

def validate_key(event=None):
    # Funcția pentru validarea cheii
    if text_box.get("1.0", "end-1c").strip() == KEY:
        validate_button.config(state=tk.NORMAL)
        no_key_button.config(state=tk.DISABLED)
    else:
        validate_button.config(state=tk.DISABLED)
        no_key_button.config(state=tk.NORMAL)

# Crearea ferestrei principale pentru validare
validation = tk.Tk()
validation.title("Product key validation")
validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
validation.config(bg="gray20")

# Crearea obiectului Text editabil
text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
text_box.config(bd=4)
text_box.pack(pady=10)
text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

# Crearea butonului "I don't have a product key"
no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=main2)
no_key_button.pack(pady=5)

# Crearea butonului "Validate key"
validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=main1, state=tk.DISABLED)
validate_button.pack(pady=5)

# Rularea buclei principale
validation.mainloop()
'''

if show_validation == True:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")

    # Execută codul de validare doar dacă nu există o cheie validă
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass


        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon42 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon42)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=main2)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=main1, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    else:
        main1()

elif trmn != 2 and passfig != 4 and passfig1 != 5 and hardvar != 6 and screenvar != 7 and zipvar != 8 and compvar != 9 and pdfvar != 10 and replfindvar != 11 and testvarr != 12 and testvarr2 != 122 and pdfvwvar != 13 and netwvar != 14 and crpvar2 != 155 and aivar != 20 and notepadvar != 21 and paintvar != 22 and Adm1var != 30 and  Adm2var != 40 and zippassvar != 60 and bkvar != 700 and rnvar != 710 and kbvar != 1000 and passmngrr != 2000 and pausevar != 10000 and taskmngrvar != 1000000 and show_validation == False and junkvar != 77777 and wbpvar != 123456789 and cmvar != 3333 and pingalivevar != 5566 and launchervar != 1990 and launchervar_admin != 1991 and excelvar != 1992 and readervar != 1993 and hardmvar != 1994 and fetchervar != 1995 and shellvar != 1996 and w95var != 1997 and sqllvar != 22222 and diagramvar != 2345432 and termadm != 6745 and commandervar != 88888888 and calendarvar != 999000 and allmonitorvar != 999001 and eventvval != 44445555 and assemblyvar != 333333333 and kbbbvar != 5189 and proc_varr != 67766776 and xmleditorvar != 111444555 and MDvar != 777666111 and archVar != 777666012 and expensevar != 777666013 and scrpVar != 777666014 and recoveryVarr != 777666090 and fishervar != 777666091 and muapdash != 777666092 and mindmapvar != 7776660999 and multifilevar != 77766609999 and safevar != 444555000888 and trafficvar != 333344440099 and dosboxvar != 3333444400999 and vscodevar != 999955550000 and pdfviewervar != 3333444400997676:
    def main3():
        class FileCopyApp:
            def __init__(self, root):
                self.root = root
                self.root.title("Copy App")
                self.root.geometry("400x400")
                self.root.config(bg="gray20")

                # Directorul destinație
                self.current_user = os.getenv('USERNAME')
                self.destination_path = rf'C:\KIT'

                # Verifică dacă calea de destinație există
                if not os.path.exists(self.destination_path):
                    try:
                        # Creează calea de destinație dacă nu există
                        os.makedirs(self.destination_path)
                        print("Director successfully created:", self.destination_path)
                    except OSError as e:
                        print("Error creating directory:", e)

                # Dicționarul cu programe și direcțiile lor sursă
                self.program_paths = {}

                # Deschide fișierul pentru citire
                with open("paths.txt", "r") as file:
                    for line in file:
                        key, value = line.strip().split(":")
                        self.program_paths[key.strip()] = value.strip()

                # Frame-uri pentru fiecare jumătate a ferestrei
                self.left_frame = tk.Frame(root, bg="gray20")
                self.left_frame.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.BOTH, expand=True)

                self.right_frame = tk.Frame(root, bg="gray20")
                self.right_frame.pack(side=tk.RIGHT, padx=5, pady=5, fill=tk.Y)

                # Canvas pentru lista de programe cu scrollbar
                self.canvas = tk.Canvas(self.left_frame, bg="gray20", highlightthickness=0)
                self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

                self.scrollbar = ttk.Scrollbar(self.right_frame, orient="vertical", command=self.canvas.yview)
                self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

                self.canvas.configure(yscrollcommand=self.scrollbar.set)
                self.canvas.bind('<Configure>', self.on_canvas_configure)

                self.program_frame = tk.Frame(self.canvas, bg="gray20")
                self.canvas.create_window((0, 0), window=self.program_frame, anchor='nw')

                # Funcție pentru actualizarea culorii textului în funcție de starea checkbox-ului
                def update_fg_color(*args):
                    for program, var in self.program_vars.items():
                        if var.get() == 1:
                            chk = self.program_checkboxes[program]
                            chk.config(fg="cyan")
                        else:
                            chk = self.program_checkboxes[program]
                            chk.config(fg="white")

                # Checkbox-uri și progres bar-uri pentru programe
                self.program_vars = {}
                self.program_checkboxes = {}
                self.progress_bars = {}

                # Frame pentru butoanele de selecție a checkbox-urilor
                self.checkbox_button_frame = tk.Frame(self.right_frame, bg="gray20")
                self.checkbox_button_frame.pack(pady=10, padx=10)

                # Încarcă profilele și creează butoanele
                self.load_profiles_and_create_buttons()

                col_count = 2  # Numărul de coloane dorit
                row_count = -(-len(self.program_paths) // col_count)  # Calculul numărului de rânduri necesare
                program_index = 0  # Variabilă pentru a ține evidența indexului programului
         
                for i in range(row_count):
                    for j in range(col_count):
                        if program_index >= len(self.program_paths):
                            break
                        program = list(self.program_paths.keys())[program_index]
                        var = tk.IntVar()
                        chk = tk.Checkbutton(self.program_frame, text=program, variable=var, bg="gray20", selectcolor="green", activebackground="pale green")
                        chk.grid(row=i, column=j*2, sticky="w")
                        self.program_vars[program] = var
                        self.program_checkboxes[program] = chk
                        chk.config(fg="white")
                        var.trace_add("write", update_fg_color)
         
                        # Creează progres bar-ul pentru fiecare program și îl pune sub checkbox
                        self.progress_bars[program] = ttk.Progressbar(self.program_frame, orient="horizontal", length=200, mode="determinate", style="custom.Horizontal.TProgressbar")
                        self.progress_bars[program].grid(row=i, column=j*2+1, sticky="ew", padx=10, pady=2)
         
                        program_index += 1
         
                # Stilizare progres bar personalizat
                self.style = ttk.Style()
                self.style.theme_use('default')
                self.style.configure("custom.Horizontal.TProgressbar", troughcolor='gray', background='green', borderwidth=0)

                # Frame pentru butonul de copiere
                self.copy_button_frame = tk.Frame(self.right_frame, bg="gray20")
                self.copy_button_frame.pack(pady=10, padx=10)

                # Plasează butonul de copiere direct în self.right_frame
                self.copy_button = tk.Button(self.right_frame, text="Copy Files", command=self.copy_files, bg="cyan", fg="black", bd=6)
                self.copy_button.pack(pady=10, padx=10)

                # Buton stergere campuri checkbox
                self.delete_button = tk.Button(self.right_frame, text="Delete checkboxes", command=self.delete_checkboxes, bg="red", fg="black", bd=6)
                self.delete_button.pack(pady=10, padx=10)

                self.bandmonitoring_button = tk.Button(self.right_frame, text="Network Console", command=self.band_network_monitoring, bg="gray40", fg="lime green", bd=5)
                self.bandmonitoring_button.pack(pady=5)
                
                # Butonul pentru a ieși din aplicație
                self.button_exit = tk.Button(self.checkbox_button_frame, text="EXIT", command=self.exit_application, bg="red", fg="white", bd=10)
                self.button_exit.pack(pady=20)

                self.last_received = 0
                self.last_sent = 0
                self.last_total = 0
                self.running = False

            def load_profiles_and_create_buttons(self):
                # Încarcă profilurile din JSON
                with open("profiles.json", "r") as f:
                    self.profiles = json.load(f)

                # Creează butoanele pentru fiecare profil
                for profile_name in self.profiles:
                    button = tk.Button(self.checkbox_button_frame, text=profile_name,
                                    command=lambda p=profile_name: self.select_profile_checkboxes(p),
                                    bg="gray40", fg="white", bd=1)
                    button.pack(pady=5, padx=10)

            def select_profile_checkboxes(self, profile_name):
                # Resetează toate checkbox-urile
                for program in self.program_vars:
                    self.program_vars[program].set(0)

                # Resetează barele de progres
                for progress_bar in self.progress_bars.values():
                    progress_bar["value"] = 0

                # Resetează textul checkbox-urilor care se termină cu " (done)"
                for program in self.program_checkboxes:
                    current_text = self.program_checkboxes[program].cget("text")
                    if current_text.endswith(" (done)"):
                        updated_text = current_text[:-7]
                        self.program_checkboxes[program].config(text=updated_text)

                # Verifică dacă profilul există
                if profile_name in self.profiles:
                    profile_checkboxes = self.profiles[profile_name]["checkboxes"]
                    for program in profile_checkboxes:
                        if program in self.program_vars:
                            self.program_vars[program].set(1)
        ##############################################################################################################################################################    
                
         
            def exit_application(self):
                if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
                    root.destroy()
         
        ###############################################################################
            def band_network_monitoring(self):
                def update_data():
                    while self.running:
                        bytes_received = psutil.net_io_counters().bytes_recv
                        bytes_sent = psutil.net_io_counters().bytes_sent
                        bytes_total = bytes_received + bytes_sent
                        
                        new_received = bytes_received - self.last_received if hasattr(self, 'last_received') else 0
                        new_sent = bytes_sent - self.last_sent if hasattr(self, 'last_sent') else 0
                        new_total = bytes_total - self.last_total if hasattr(self, 'last_total') else 0
                        
                        mb_new_received = new_received / 1024 / 1024
                        mb_new_sent = new_sent / 1024 / 1024
                        mb_new_total = new_total / 1024 / 1024
                        
                        # Actualizează textul în text area cu noile date
                        text_area.insert(tk.END, f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        text_area.see(tk.END)  # Asigură că textul nou adăugat este vizibil
                        
                        # Salvează datele în fișier
                        with open("network_data.txt", "a") as file:
                            file.write(f"{mb_new_received:.2f} MB received, {mb_new_sent:.2f} MB sent, {mb_new_total:.2f} MB total.\n")
                        
                        print(f"{mb_new_received: .2f} MB received, {mb_new_sent: .2f} MB sent, {mb_new_total: .2f} MB total.")
                        
                        self.last_received = bytes_received
                        self.last_sent = bytes_sent
                        self.last_total = bytes_total
                        
                        time.sleep(1)

                def start():
                    self.running = True
                    # Șterge conținutul text area-ului la fiecare pornire
                    text_area.delete(1.0, tk.END)
                    # Crează un thread nou pentru actualizarea datelor
                    data_thread = threading.Thread(target=update_data)
                    data_thread.start()

                def stop():
                    self.running = False

                # Crează fereastra
                monitorband = tk.Toplevel()
                monitorband.title("Network Console")
                monitorband.resizable(False, False)
                monitorband.config(bg="gray20")
                #image_icon44 = PhotoImage(file = "img/networklogo.png")
                #monitorband.iconphoto(False, image_icon44)

                # Creează un text area cu culoare de fundal și text personalizate
                text_area = tk.Text(monitorband, bg="black", fg="lime green", highlightbackground="gray40", highlightthickness=10, bd=20)
                text_area.pack(expand=True, fill=tk.BOTH)

                # Buton pentru pornirea monitorizării
                start_button = tk.Button(monitorband, text="Start", command=start, bg="gray40", bd=10, fg="lime green")
                start_button.pack()

                # Buton pentru oprirea monitorizării
                stop_button = tk.Button(monitorband, text="Stop", command=stop, bg="gray40", bd=10, fg="red")
                stop_button.pack()

                # Inițializare variabile
                self.last_received = psutil.net_io_counters().bytes_recv
                self.last_sent = psutil.net_io_counters().bytes_sent
                self.last_total = self.last_received + self.last_sent
                self.running = False

                # Pornirea buclei principale a interfeței grafice
                #monitorband.mainloop()
        ###############################################################################
         
            def delete_checkboxes(self):
                for program in self.program_vars:
                    self.program_vars[program].set(0)
                #self.program_vars[""].set(0)
                for progress_bar in self.progress_bars.values():
                    progress_bar["value"] = 0
                for program in self.program_checkboxes:
                    current_text = self.program_checkboxes[program].cget("text")
                    # Verificăm dacă textul se termină cu " (done)"
                    if current_text.endswith(" (done)"):
                        # Eliminăm ultimele 77 caractere din textul curent și actualizăm textul checkbox-ului
                        updated_text = current_text[:-7]
                        self.program_checkboxes[program].config(text=updated_text)
         
            def on_canvas_configure(self, event):
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))
         
            def copy_files(self):
                self.copy_button.config(state="disabled")  # Dezactivează butonul de copiere
                #self.select_Director_button.config(state="disabled")
                selected_programs = [program for program, var in self.program_vars.items() if var.get() == 1]
                if not selected_programs:
                    messagebox.showwarning("No program selected", "Please select at least one program to copy the files.")
                    self.copy_button.config(state="normal")  # Activează butonul de copiere
                    #self.select_Director_button.config(state="normal")
                    return
         
                # Funcție pentru a actualiza textul checkbox-urilor cu "done"
                def update_checkbox_text():
                    for program in selected_programs:
                        checkbox = self.program_checkboxes[program]
                        checkbox.config(text=program + " (done)")
         
                # Funcție pentru a realiza copierea fișierelor într-un fir de execuție separat
                def copy_files_thread():
                    try:
                        for program in selected_programs:
                            program_source = self.program_paths[program]
                            if os.path.exists(program_source):
                                # Crează un director pentru a stoca fișierele copiate
                                save_directory = os.path.join(self.destination_path, os.path.basename(program_source))
                                os.makedirs(save_directory, exist_ok=True)
                                if os.path.isdir(program_source):
                                    # Dacă sursa este un director, copiază întregul director
                                    total_files = sum(len(files) for _, _, files in os.walk(program_source))  # Calculăm numărul total de fișiere
                                    files_copied = 0  # Inițializăm contorul pentru fișierele copiate
                                    for root, dirs, files in os.walk(program_source):
                                        for dir in dirs:
                                            src = os.path.join(root, dir)
                                            dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                            os.makedirs(dest, exist_ok=True)
                                        for file in files:
                                            src = os.path.join(root, file)
                                            dest = os.path.join(save_directory, os.path.relpath(src, program_source))
                                            # Verificăm dacă fișierul de destinație există deja
                                            if not os.path.exists(dest):
                                                shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                            # Actualizăm progresul
                                            files_copied += 1
                                            progress_value = (files_copied / total_files) * 100
                                            self.progress_bars[program]["value"] = progress_value
                                            self.root.update_idletasks()  # Actualizează interfața grafică
         
                                    # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                    self.program_checkboxes[program].config(text=program + " (done)")
         
                                else:
                                    # Dacă sursa este un fișier, copiază doar fișierul
                                    total_files = 1  # Avem un singur fișier de copiat
                                    files_copied = 0
                                    file_name = os.path.basename(program_source)
                                    src = program_source
                                    dest = os.path.join(save_directory, file_name)
                                    # Verificăm dacă fișierul de destinație există deja
                                    if not os.path.exists(dest):
                                        shutil.copy(src, dest)  # Copiază fișierul doar dacă nu există deja
         
                                    files_copied += 1
                                    progress_value = (files_copied / total_files) * 100
                                    self.progress_bars[program]["value"] = progress_value
                                    self.root.update_idletasks()  # Actualizează interfața grafică
                                    # Actualizăm textul checkbox-ului cu "done" după ce programul a fost copiat
                                    self.program_checkboxes[program].config(text=program + " (done)")
         
                        # Afisăm mesajul de finalizare a copierii
                        self.root.after(0, self.show_copy_success)
         
                    except Exception as ex:
                        # Afisăm mesaj de eroare dacă apare o excepție
                        self.root.after(0, lambda e=ex: self.show_copy_error(e))
         
                    finally:
                        # Activează butonul de copiere după finalizarea copierii
                        self.root.after(0, self.enable_copy_button)
         
                # Pornim firul de execuție pentru copierea fișierelor
                threading.Thread(target=copy_files_thread).start()
         
         
            def show_copy_success(self):
                messagebox.showinfo("Copy completed", "The files have been successfully copied.")
         
            def show_copy_error(self, error_message):
                messagebox.showerror("Error copying", f"An error occurred while copying the files: {str(error_message)}")
         
            def enable_copy_button(self):
                self.copy_button.config(state="normal")
         
        def browse_folder():
            folder_path = filedialog.askdirectory()
            if folder_path:
                folder_path = folder_path.replace("/", "\\")  # înlocuim '/' cu '\'
                with open("folder_paths.txt", "a") as file:
                    file.write(folder_path + "\n")
         
        def browse_file():
            file_path = filedialog.askopenfilename()
            if file_path:
                file_path = file_path.replace("/", "\\")  # înlocuim '/' cu '\'
                with open("file_paths.txt", "a") as file:
                    file.write(file_path + "\n")
         
        def copy_file():
            with open("file_paths.txt", "r") as file:
                file_paths = file.readlines()
            for file_path in file_paths:
                file_path = file_path.strip()  # Eliminăm caracterele de nouă linie și spații suplimentare
                shutil.copy2(file_path, save_location.get())
         
        def copy_folder():
            with open("folder_paths.txt", "r") as file:
                folder_paths = file.readlines()
            for folder_path in folder_paths:
                folder_path = folder_path.strip()
                save_path = os.path.join(save_location.get(), os.path.basename(folder_path))
                try:
                    shutil.copytree(folder_path, save_path)
                except PermissionError:
                    messagebox.showerror("Error", "Access to the source folder is denied.")
                except Exception as e:
                    messagebox.showerror("Error", f"An error occurred: {str(e)}")
         
        def update_buttons_state():
            if save_location.get():
                button_copy_file.config(state="normal")
                button_copy_folder.config(state="normal")
            else:
                button_copy_file.config(state="disabled")
                button_copy_folder.config(state="disabled")
         
        def select_save_location():
            save_location.set(filedialog.askdirectory())
            update_buttons_state()
         
        def open_copy_window():
            global button_copy_file, button_copy_folder
            copy_window = tk.Toplevel(root)
            copy_window.title("Copy Files/Folders")
            copy_window.config(bg="gray20")  # Setare culoare fundal gri închis
            copy_window.resizable(False, False)
            #image_icon46 = PhotoImage(file = "img/downloadlogo.png")
            #copy_window.iconphoto(False, image_icon46)
         
            frame = tk.Frame(copy_window)
            frame.pack(padx=20, pady=20)
         
            button_copy_file = tk.Button(frame, text="Copy Files", command=copy_file, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_copy_file.pack(padx=10, pady=5)
         
            button_copy_folder = tk.Button(frame, text="Copy Folders", command=copy_folder, state="disabled", bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_copy_folder.pack(padx=10, pady=5)
         
            button_select_location = tk.Button(frame, text="Select Save Location", command=select_save_location, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_select_location.pack(padx=10, pady=5)
         
            update_buttons_state()
         
            copy_window.mainloop()
         
        def open_file_explorer_window():
            file_explorer_window = tk.Toplevel(root)
            file_explorer_window.title("Browse in File Explorer")
            file_explorer_window.config(bg="gray20")  # Setare culoare fundal gri închis
            file_explorer_window.resizable(False, False)
            #image_icon47 = PhotoImage(file = "img/downloadlogo.png")
            #file_explorer_window.iconphoto(False, image_icon47)
         
            frame = tk.Frame(file_explorer_window, bg="gray20")  # Setare culoare fundal gri închis
            frame.pack(padx=20, pady=20)
         
            button_folder = tk.Button(frame, text="Select a Folder", command=browse_folder, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordura
            button_folder.pack(padx=10, pady=5)
         
            button_file = tk.Button(frame, text="Select a File", command=browse_file, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_file.pack(padx=10, pady=5)
         
            button_open_copy_window = tk.Button(frame, text="Open Copy Window", command=open_copy_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
            button_open_copy_window.pack(padx=10, pady=5)
         
        def open_file_copy_app_window():
            file_copy_app_window = tk.Toplevel(root)
            file_copy_app_window.title("Copy App Defaults")
            file_copy_app_window.config(bg="gray20")  # Setare culoare fundal gri închis
            # Dezactivarea posibilității de redimensionare a ferestrei
            file_copy_app_window.resizable(False, False)
            #image_icon48 = PhotoImage(file = "img/downloadlogo.png")
            #file_copy_app_window.iconphoto(False, image_icon48)
            # Maximizarea ferestrei
            file_copy_app_window.state("zoomed")
            app = FileCopyApp(file_copy_app_window)
         
        root = tk.Tk()
        root.title("Menu")
        root.geometry("200x200")
        root.config(bg="gray20")  # Setare culoare fundal gri închis
        root.resizable(False, False)
        #image_icon49 = PhotoImage(file = "img/appslogo.png")
        #root.iconphoto(False, image_icon49)
         
        main_frame = tk.Frame(root, bg="gray20")  # Setare culoare fundal gri închis
        main_frame.pack(padx=20, pady=20)
        
        button_open_file_explorer = tk.Button(main_frame, text="Explorer Mode", command=open_file_explorer_window, bg="gray40", fg="white", bd=1)  # Stilizare culori și eliminare bordură
        button_open_file_explorer.pack(padx=10, pady=5)
         
        button_open_file_copy_app = tk.Button(main_frame, text="Copy App", command=open_file_copy_app_window, bg="gray40", fg="white", bd=1)  # Schimbare scris negru
        button_open_file_copy_app.pack(padx=10, pady=5)
        
        def ReadMe():
            # Funcția pentru închiderea ferestrei
            def inchide_fereastra():
                readme.destroy()
         
            # Crearea ferestrei principale
            readme = tk.Toplevel()
            readme.title("Working procedure (Copy App)")
            readme.geometry("700x350")
            readme.config(bg="gray20")  # Setare culoare fundal gri închis
            #image_icon50 = PhotoImage(file = "img/complogo.png")
            #readme.iconphoto(False, image_icon50)
            
            # Crearea obiectului Text și inserarea textului
            text = scrolledtext.ScrolledText(readme, wrap="word", height=10, width=40)
            text.insert(tk.END, "To avoid potential errors, it is recommended to run the program as the corresponding domain user. Additionally, there must be a network location mapping, and you should have access to that location, of course. You need to manually configure the paths.txt and profiles.json files (according to the example).\n")
            text.configure(state="disabled")  # Textul nu poate fi editat
            text.pack(expand=True, fill="both", padx=10, pady=10)
         
            # Butonul pentru închiderea ferestrei
            buton_inchide = tk.Button(readme, text="Close", command=inchide_fereastra, bg="gray40", fg="white", bd=10)
            buton_inchide.pack(pady=5)
         
         
        readme_button = tk.Button(main_frame, text="Read me first", command=ReadMe, bg="gray40", fg="cyan", bd=5)
        readme_button.pack(pady=20)
         
        save_location = tk.StringVar()
         
        root.mainloop()
    main3()

if trmn == 2:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    from tkinter import font
    from tkinter.font import Font
    from tkinter import colorchooser
    import tkinter.messagebox

    import trace
    import traceback
    import threading
    import subprocess
    import os
    import sys
    import json
    from abc import ABC, abstractmethod
    import platform
    import webbrowser

    sys.path.append("..")

    class Interpreter():

        MAPPINGS = {
            "sh"        : "/bin/sh",
            "bash"      : "/bin/bash",
            "windows"   : None
        }

        BACKENDS = {}

        _ICONS = {}

        DEFAULT_SHELL = ""

        @staticmethod
        def add_interpreter(name, backend, icon=None, set_default=False):
            """ Add new interpreter """

            assert(not name in Interpreter.MAPPINGS.keys())
            assert(not name in Interpreter.BACKENDS.keys())

            Interpreter.MAPPINGS[name] = None
            Interpreter.BACKENDS[name] = backend

            if set_default:
                Interpreter.DEFAULT_SHELL = name

            Interpreter._ICONS[name] = icon

        @staticmethod
        def init_backends():
            """ Initialise interpreter backends """

            Interpreter.BACKENDS.clear()

            for name, path in Interpreter.MAPPINGS.items():
                Interpreter.BACKENDS[name] = InterpreterShell(path)

            # Set default interpreter based on operating system
            if (os.name == 'nt'):
                Interpreter.DEFAULT_SHELL = "windows"
            else:
               Interpreter.DEFAULT_SHELL = "bash"

            Interpreter._ICONS.clear()

            Interpreter._ICONS["sh"]        = PhotoImage(file=get_absolute_path(__file__, "img/linux.png"))
            Interpreter._ICONS["bash"]      = PhotoImage(file=get_absolute_path(__file__, "img/linux.png"))
            Interpreter._ICONS["windows"]   = PhotoImage(file=get_absolute_path(__file__, "img/windows.png"))

        @staticmethod
        def get_backends():
            """ Return Interpreter backends """

            return Interpreter.BACKENDS

        @staticmethod
        def get_interpreter(name):
            """ Get interpreter instance by name """

            assert(name in Interpreter.BACKENDS.keys())
            return Interpreter.BACKENDS[name]

        @staticmethod
        def get_default_shell():
            """ Get default shell based on operating system """

            return Interpreter.DEFAULT_SHELL

        @staticmethod
        def get_icon(name):
            # assert (name in Interpreter._ICONS.keys())

            if name in Interpreter._ICONS.keys():
                return Interpreter._ICONS[name]
            else:
                return Interpreter._ICONS["bash"]

    class ExitDiaglogBox():

        def __init__(self, master, icon):

            self.master = master
            self.master.protocol("WM_DELETE_WINDOW", self._diaglog_box)
            self.iconMaster = icon
            self.iconWarn = tk.PhotoImage(file=get_absolute_path(__file__, "img/warn.png"))

        def _diaglog_box(self):

            self.top = tk.Toplevel()
            self.top.iconphoto(False, self.iconMaster)
            self.top.title("Close this terminal?")
            self.top.resizable(False, False)

            width = 320
            height = 130

            # Set dialog box geometry
            self.top.geometry("{}x{}".format(width, height))

            # Get master current position
            root_x = self.master.winfo_x()
            root_y = self.master.winfo_y()

            # Get master width and height
            root_width = self.master.winfo_width()
            root_height = self.master.winfo_height()

            # Work out the new center coordinate
            x = root_x + (root_width/2) - (width/2)
            y = root_y + (root_height/2) - (height/2)

            # Position dialog box to center
            self.top.geometry("+%d+%d" % (x, y))

            # Make top a subwindow on root window
            self.top.transient(self.master)

            # Stop user interacting with other windows
            self.top.grab_set()

            self.top.focus_set()

            ########################################################################
            ## Create dialog box
            ########################################################################

            self.frameWrap = tk.Frame(self.top, bg=TkTermConfig.CONFIG["bg"])
            self.frameWrap.pack(fill=BOTH, expand=True)

            frameBody = tk.Frame(self.frameWrap, bg=TkTermConfig.CONFIG["bg"])
            frameBody.pack(side=TOP, ipadx=20, ipady=20)

            frameButton = tk.Frame(self.frameWrap, bg=TkTermConfig.CONFIG["bg"], bd=0)
            frameButton.pack(side=BOTTOM, fill=X)

            buttonOptions = {
                "relief"                : FLAT,
                "bd"                    : 0,
                "height"                : 2,
                "highlightthickness"    : 0,
                "font"                  : ("Helvetica", 8)
            }

            buttonCancel = tk.Button(frameButton, text="Cancel", bg=TkTermConfig.CONFIG["bg"], fg="white", **buttonOptions , command=self._cancel)
            buttonCancel.pack(side=LEFT, pady=0, padx=0, fill=X, expand=True)

            buttonExit = tk.Button(frameButton, text="Exit Terminal", bg="orange", **buttonOptions , command=self._exit)
            buttonExit.pack(side=LEFT, pady=0, padx=0, fill=X, expand=True)

            # Fixes for Windows
            if os.name == "nt":
                buttonCancel.bind("<Enter>", lambda e: buttonCancel.config(fg="black", bg="#ececec"))
                buttonCancel.bind("<Leave>", lambda e: buttonCancel.config(fg="white", bg=TkTermConfig.CONFIG["bg"]))

                buttonExit.bind("<Enter>", lambda e: buttonExit.config(fg="black", bg="#ececec"))
                buttonExit.bind("<Leave>", lambda e: buttonExit.config(fg="black", bg="orange"))
            else:
                buttonCancel["activebackground"] = "#ececec"
                buttonCancel["activeforeground"] = "black"

                buttonExit["activebackground"] = "#ececec"
                buttonExit["activeforeground"] = "black"

            # self.warningIcon = tk.PhotoImage(file=WARNING_ICON_PATH)
            icon = tk.Label(frameBody, image=self.iconWarn, bg=TkTermConfig.CONFIG["bg"])
            icon.pack(side=LEFT, padx=10)

            label = tk.Label(frameBody, text="Are you sure you want to exit the terminal\nand close all tabs?", bg=TkTermConfig.CONFIG["bg"], fg="white", font=("Helvetica", 8))
            label.pack(side=LEFT, padx=10)

            # Wait until top closes before return to root
            self.master.wait_window(self.top)

        def _exit(self):
            self.master.destroy()

        def _cancel(self):
            self.top.destroy()

    class TkTermConfig():

        # Default config
        DEFAULT_CONFIG = {
            "fg"                : "#00A79D",
            "bg"                : "#282C34",
            "insertbackground"  : "white",
            "error"             : "red",
            "output"            : "#E6E6E6",
            "basename"          : "#0080ff",
            "cursorshape"       : "bar",
            "selectbackground"  : "#464E5E",
            "fontfamily"        : "Cascadia Code SemiLight",
            "fontsize"          : 9
        }

        # Curernt config
        CONFIG = {}

        # Configuration filename
        CONFIG_FILE = os.path.abspath(os.path.join(os.path.dirname(__file__), "Term_settings.json"))

        @staticmethod
        def get_default(key=None):
            if key:
                assert(key in TkTermConfig.DEFAULT_CONFIG.keys())
                return TkTermConfig.DEFAULT_CONFIG[key]

            return TkTermConfig.DEFAULT_CONFIG.copy()

        @staticmethod
        def set_default(config):
            TkTermConfig.DEFAULT_CONFIG = config.copy()

        @staticmethod
        def get_config(key=None):
            if key:
                assert(key in TkTermConfig.CONFIG)
                return TkTermConfig.CONFIG[key]

            return TkTermConfig.CONFIG.copy()

        @staticmethod
        def set_config(config):
            TkTermConfig.CONFIG = config

        @staticmethod
        def set_config_key(key, value):
            assert(key in TkTermConfig.CONFIG.keys())
            TkTermConfig.CONFIG[key] = value

        @staticmethod
        def get_config_file():
            return TkTermConfig.CONFIG_FILE

    def get_last_line(widget):
        """ Get the position of the last line from Text Widget"""

        pos = widget.index("end linestart")
        pos = float(pos) - 1
        return pos

    def get_absolute_path(root, *args):
        """ Get absolute path given a root """

        return os.path.join(os.path.dirname(os.path.abspath(root)), *args)

    class Tooltip(object):
        '''
        create a tooltip for a given widget
        '''
        def __init__(self, widget, text='widget info', manual=False, delay=False):
            self.widget = widget
            self.text = text
            self.delay = delay

            self.tw = None

            self.manual = manual

            if not manual:
                self.widget.bind("<Enter>", self.enter)
                self.widget.bind("<Leave>", self.close)

        def enter(self, event=None):
            # if self.delay:
            #     self.widget.winfo_toplevel().after(600, self.create)
            # else:
            #     self.create()
            # else:
            #     self.close()

            self.create()

        def create(self):
            x = y = 0
            x, y, cx, cy = self.widget.bbox("insert")

            if self.manual:
                x += self.widget.winfo_rootx() - 1
                y += self.widget.winfo_rooty() + 20
            else:
                x += self.widget.winfo_rootx() + 25
                y += self.widget.winfo_rooty() + 30

            # creates a toplevel window
            self.tw = tk.Toplevel(self.widget)
            # Leaves only the label and removes the app window
            self.tw.wm_overrideredirect(True)
            self.tw.wm_geometry("+%d+%d" % (x, y))
            label = tk.Label(self.tw, text=self.text, justify='left',
                           relief='solid', borderwidth=1, wraplength=150,
                           font=("Helvetica", "7", "normal"))

            label.pack(ipadx=1)

        def close(self, *args):

            if self.tw:
                self.tw.destroy()
                self.tw = None


    class InterpreterInterface(ABC):

        def __init__(self, *kwargs):
            # super().__init__()

            self.stdout = None
            self.stderr = None
            self.exit_code = None

        @abstractmethod
        def execute(self, command):
            pass

        @abstractmethod
        def terminate(self, processThread):
            pass
    # Add to system path
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))

    __version__ = "1.0.2"

    class InterpreterShell(InterpreterInterface):

        def __init__(self, interpreter_path=None):
            super().__init__()

            self.history = []

            self.process_options = {
                "shell"                 : True,
                "stdout"                : subprocess.PIPE,
                "stderr"                : subprocess.PIPE,
                "universal_newlines"    : True
            }

            # Ignore utf-8 decode error which sometimes happens on early terminating
            if os.name != "nt":
                self.process_options["errors"] = "ignore"

            if interpreter_path:
                self.process_options['executable'] = interpreter_path

        def execute(self, command):
            return subprocess.Popen(command, cwd=os.getcwd(), **self.process_options)

        def terminate(self, processThread):

            stdout = ""
            stderr = ""

            if (os.name == 'nt'):
                process = subprocess.Popen(
                    "TASKKILL /F /PID {} /T".format(processThread.pid),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    universal_newlines=True
                )

                for line in process.stdout:
                    stdout += line
                for line in process.stderr:
                    stderr += line

            else:

                try:
                    os.system("pkill -TERM -P %s" % processThread.pid)
                    os.system("kill -2 {}".format(processThread.pid))
                    os.system("kill -9 {}".format(processThread.pid))
                except:
                    pass

            processThread.wait()

            return (stdout, stderr)

        def get_return_code(self, process):
            return process.poll()

        def get_prompt(self):
            return os.getcwd() + ">> "

        def get_history(self):
            return self.history

        def __repr__(self):
            return "<InterpreterShell object: {}>".format(self.process_options['executable'])

    class KThread(threading.Thread):
      """
      A subclass of threading.Thread, with a kill() method.
      """

      def __init__(self, *args, **keywords):
        threading.Thread.__init__(self, *args, **keywords)
        self.killed = False

      def start(self):
        """Start the thread."""
        self.__run_backup = self.run
        self.run = self.__run      # Force the Thread to install our trace.
        threading.Thread.start(self)

      def __run(self):
        """Hacked run function, which installs the trace."""
        sys.settrace(self.globaltrace)
        self.__run_backup()
        self.run = self.__run_backup

      def globaltrace(self, frame, why, arg):
        if why == 'call':
          return self.localtrace
        else:
          return None

      def localtrace(self, frame, why, arg):
        if self.killed:
          if why == 'line':
            raise SystemExit()
        return self.localtrace

      def kill(self):
        self.killed = True

    '''
    from src.TerminalTab import TerminalTab
    from src.Interpreter import Interpreter
    from src.ExitDiaglogBox import ExitDiaglogBox
    from src.Utils import get_absolute_path
    from src.Config import TkTermConfig
    '''

    class Terminal(tk.Frame):
        """ Terminal widget """

        def __init__(self, parent, text=None, *args, **kwargs):

            super().__init__(parent, *args, **kwargs)

            self.splashText = text

            # Initialised all interpreter backends
            Interpreter.init_backends()

            ########################################################################
            # Load setting profile
            ########################################################################
            self.TerminalConfig = TkTermConfig.get_default()

            if "Cascadia Code SemiLight" in font.families():
                self.TerminalConfig["fontfamily"] = "Cascadia Code SemiLight"
            else:
                self.TerminalConfig["fontfamily"] = "Consolas"

            TkTermConfig.set_default(self.TerminalConfig)

            # Load settings from file
            if os.path.isfile(TkTermConfig.CONFIG_FILE):
                with open(TkTermConfig.CONFIG_FILE, "r") as f:
                    try:
                        data = json.load(f)

                        for k in data.keys():
                            if k in self.TerminalConfig.keys():
                                self.TerminalConfig[k] = data[k]
                    except:
                        pass

            TkTermConfig.set_config(self.TerminalConfig)

            ########################################################################
            # Create terminal tabs using notebook
            ########################################################################
            self.notebook = TerminalTab(self, self.splashText)
            self.notebook.pack(expand=True, fill=BOTH)

        def add_interpreter(self, *args, **kwargs):
            """ Add a new interpreter and optionally set as default """

            Interpreter.add_interpreter(*args, **kwargs)

        def run_command(self, cmd):
            """ Run command on current terminal tab """

            # Get the selected tab
            tab_id = self.notebook.select()

            # Get the associated terminal widget
            terminal = self.notebook.nametowidget(tab_id)
            terminal.run_command(cmd)

        def on_resize(self, event):
            """Auto scroll to bottom when resize event happens"""

            first_visible_line = self.TerminalScreen.index("@0,0")

            if self.scrollbar.get()[1] >= 1:
                self.TerminalScreen.see(END)
            # elif float(first_visible_line) >  1.0:
            #     self.TerminalScreen.see(float(first_visible_line)-1)

            # self.statusText.set(self.TerminalScreen.winfo_height())

    class TerminalTab(ttk.Notebook):

        def __init__(self, parent, splashText):

            ttk.Notebook.__init__(self, parent)

            self.parent = parent
            self.splashText = splashText

            ########################################################################
            # Bind keys
            ########################################################################
            self.bind("<B1-Motion>", self._reorder_tab)
            self.bind("<ButtonRelease-2>", lambda e: self._close_tab(event=e))
            self.bind("<<NotebookTabChanged>>", self._tab_clicked)
            self.bind('<Double-Button-1>', self._tab_rename)

            ########################################################################
            # Add default tabs
            # This will automatically create a tab and an add tab button
            ########################################################################
            self.iconPlus = PhotoImage(file=get_absolute_path(__file__, "img/plus.png"))
            self.add(tk.Frame(self.parent), image=self.iconPlus)

            # Set color profile for notebook
            self.init_style()

            ########################################################################
            # Create menu button
            ########################################################################
            self.frameNav = tk.Frame(self.parent)
            self.frameNav.place(rely=0, relx=1.0, x=-10, y=17, anchor="e")

            self.iconHamburger  = PhotoImage(file=get_absolute_path(__file__, "img/hamburger.png"))
            self.iconSearch     = PhotoImage(file=get_absolute_path(__file__, "img/search.png"))
            self.iconNewTab     = PhotoImage(file=get_absolute_path(__file__, "img/new_tab.png"))
            self.iconNextTab    = PhotoImage(file=get_absolute_path(__file__, "img/next_tab.png"))
            self.iconPrevTab    = PhotoImage(file=get_absolute_path(__file__, "img/prev_tab.png"))
            self.iconCloseTab   = PhotoImage(file=get_absolute_path(__file__, "img/close_tab.png"))

            self.renameCloseButton  = PhotoImage(file=get_absolute_path(__file__, "img/close.png"))
            self.iconApp            = PhotoImage(file=get_absolute_path(__file__, "img/app_icon.png"))

            self.buttonTabList = tk.Button(
                self.frameNav,
                # text="\u2630",
                image=self.iconHamburger,
                width=30,
                height=25,
                bd=0,
                relief=FLAT,
                highlightbackground="#414755",
                bg="#414755",
                fg="#9da5b4",
                activebackground="#495162",
                activeforeground="#9da5b4"
            )

            self.buttonTabList.pack()

            self.buttonTabList.bind("<ButtonRelease-1>", self._tab_menu)

            if os.name == "nt":
                self.buttonTabList.bind("<Enter>", lambda e: e.widget.config(bg="#495162"))
                self.buttonTabList.bind("<Leave>", self._tab_menu_on_leave)

        def init_style(self):
            """ Style the notebook """

            s = ttk.Style()
            s.theme_use('default')
            s.configure('Terminal.TNotebook',
                background="#414755",
                bd=0,
                borderwidth=0,
                padding=[0,0,0,0],
                tabmargins=[7, 7, 50, 0],
                # tabposition='wn'
            )

            s.configure('Terminal.TNotebook.Tab',
                borderwidth=0,
                padding=[10,5],
                # width=15,
                height=1,
                background="#495162",
                foreground="#9da5b4",
                font=('Helvetica','8'),
                focuscolor=TkTermConfig.get_config("bg")
            )

            s.map("Terminal.TNotebook.Tab",
                background=[("selected", TkTermConfig.get_config("bg")), ("active", TkTermConfig.get_config("bg"))],
                foreground=[("selected", "white"), ("active", "white")],
                font=[("selected", ('Helvetica 8 bold'))],
                # expand=[("selected", [0, 3])]
            )

            self.configure(style="Terminal.TNotebook")

        def set_color_style(self):
            """ Set color style for all terminal tabs and notebook """

            for tab in self.tabs()[:-1]:
                terminal = self.nametowidget(tab)

                terminal.set_color_style()

            self.init_style()

        def _tab_menu_on_leave(self, event):
            """ Set effect when mouse cursor leave menu button """

            if event.widget["state"] == "normal":
                event.widget.config(bg="#414755")

        def _tab_menu(self, event):
            """ Create menu for menu button """

            self.tabListMenu = Menu(self,
                tearoff=0,
                bg="white",
                bd=1,
                activebackground="#2c313a",
                activeforeground="white",
                selectcolor="red",
                activeborderwidth=1,
                relief=GROOVE,
                font="Helvetica 10"
            )

            # Add list of currently opened tabs to menu
            for tab in self.tabs()[:-1]:

                self.tabListMenu.add_command(
                    label="   " + self.tab(tab, option="text"),
                    image=self.tab(tab, option="image"),
                    compound=LEFT,
                    command= lambda temp=tab: self.select(temp)
                )

            self.tabListMenu.add_separator()

            self.tabListMenu.add_command(
                label="   Search",
                accelerator="Ctrl+F",
                image=self.iconSearch, compound=LEFT,
                command=lambda : self.nametowidget(self.select()).event_generate("<Control-f>")
            )

            self.tabListMenu.add_command(
                label="   New tab",
                accelerator="Ctrl+T",
                command=self._insert_new_tab,
                image=self.iconNewTab, compound=LEFT
            )

            # Number of opened tabs (minus add tab button)
            num_tabs = len(self.tabs()) - 1

            if num_tabs == 1:
                state = "disabled"
            else:
                state = "normal"

            self.tabListMenu.add_command(
                label="   Go to next tab",
                accelerator="Ctrl+Tab",
                command=lambda: self._cycle_through_tabs(True),
                image=self.iconNextTab, compound=LEFT,
                state=state
            )

            self.tabListMenu.add_command(
                label="   Go to prev tab",
                accelerator="Shift+Tab",
                command=lambda: self._cycle_through_tabs(False),
                image=self.iconPrevTab, compound=LEFT,
                state=state
            )

            self.tabListMenu.add_command(
                label="   Close this tab",
                accelerator="Middle-click" + "{}".format("" if os.name == "nt" else "  "),
                image=self.iconCloseTab, compound=LEFT,
                command=lambda : self._close_tab(index=self.index(self.select())),
                state=state
            )

            self.tabListMenu.add_separator()

            self.tabListMenu.add_command(label="About Everything Console ...", command=self._about_page)

            self.tabListMenu.bind("<FocusOut>", lambda e: (
                e.widget.destroy(),
                event.widget.config(bg="#414755")
            ))

            ########################################################################
            # Create popup event
            ########################################################################

            try:
                event.widget.config(fg="#9da5b4", bg="#495162")
                self.tabListMenu.tk_popup(event.widget.winfo_rootx(), event.widget.winfo_rooty()+30)
                # self.tabListMenu.focus_set()
            finally:
                self.tabListMenu.grab_release()

                if os.name == "nt":
                    event.widget.config(bg="#414755")

        def _tab_clicked(self, *event):
            """ Monitor tab change event """

            # Fake the last tab as insert new tab
            if self.select() == self.tabs()[-1]:
                self._insert_new_tab()

        def _insert_new_tab(self):
            """ Insert new tab event """

            terminal = TerminalWidget(self.parent)

            if self.splashText:
                terminal.update_shell(print_basename=False)
                terminal.stdout.write(self.splashText)

            terminal.update_shell()

            # Attach search bar to terminal
            terminal.searchBar = SearchBar(terminal)

            # Attach right click context menu
            terminal.contextMenu = RightClickContextMenu(self, terminal)

            # Insert new tab before the add button
            index = len(self.tabs()) - 1
            self.insert(index, terminal, text=f"Terminal {len(self.tabs())}", image=terminal.icon, compound=LEFT)
            self.select(index)

            # Bind event for each terminal instance
            tab_id = self.select()
            terminal.bind("<<eventUpdateShell>>",   lambda e : self._update_icon(tab_id))
            terminal.bind("<<eventNewTab>>",        lambda e : self._insert_new_tab())
            terminal.bind("<<eventCycleNextTab>>",  lambda e : self._cycle_through_tabs(traverse_next=True))
            terminal.bind("<<eventCyclePrevTab>>",  lambda e : self._cycle_through_tabs(traverse_next=False))

        def _cycle_through_tabs(self, traverse_next=True):
            """ Cycle through opened tabs """

            # Number of opened tabs (minus add tab button)
            num_tabs = len(self.tabs()) - 1

            # Get current tab id and its index
            tab_id = self.select()
            index = self.index(tab_id)

            # Work out new tab index
            if traverse_next:
                if (index >= num_tabs - 1): index = 0
                else:                       index += 1
            else:
                if index == 0:              index = num_tabs - 1
                else:                       index -= 1

            # Select new tab
            self.select(index)

            # Set focus on the terminal
            new_tab_id = self.select()
            terminal = self.nametowidget(new_tab_id)
            terminal.TerminalScreen.focus_set()

        def _update_icon(self, tab_id):
            """ Update icon on tab """

            terminal = self.nametowidget(tab_id)
            self.tab(tab_id, image=terminal.icon)

        def _reorder_tab(self, event):
            """ Drag to reorder tab """

            try:
                index = self.index(f"@{event.x},{event.y}")

                if index >= len(self.tabs()) - 1:
                    return

                self.insert(index, child=self.select())

            except tk.TclError:
                pass

        def _close_tab(self, index=None, event=None):
            """ Close tab event """

            try:

                if event:
                    index = self.index(f"@{event.x},{event.y}")

                # Do nothing if it is the last tab (add tab button)
                if index >= len(self.tabs()) - 1:
                    return

                # Do nothing if there are 2 tabs left
                if len(self.tabs()) == 2:
                    return

                # When closing the last tab, immediately switch to the tab before
                if index == len(self.tabs()) - 2:
                    self.select(len(self.tabs()) - 3)

                terminal = self.nametowidget(self.tabs()[index])

                # TODO: Error on closing tabs if there are processes running
                # If process still running just kill it
                terminal.terminate()

                del terminal.searchBar
                del terminal.contextMenu

                for child in terminal.winfo_children():
                    child.destroy()

                terminal.destroy()

                # self.event_generate("<<NotebookTabClosed>>")

            except Exception:
                pass

        def _tab_rename(self, event):
            """ Rename a tab """

            def _accept_change(event):
                """ Accept a change """

                self.tab(tab_id, text=field.get())
                _focus_out()

            def _focus_out(*event):
                """ On focus out destroy all created widgets """

                buttonClose.destroy()
                entry.destroy()
                frameInner.destroy()
                frame.destroy()

                terminal.TerminalScreen.focus_set()

            def _on_enter(event):
                event.widget["bg"] = INNER_BG
                event.widget["activebackground"] = INNER_BG

            def _on_leave(event):
                event.widget["bg"] = OUTER_BG

            try:

                # Define colors
                OUTER_BG = "#212224"
                INNER_BG = "#414755"

                # Get the selected tab
                index = self.index(f"@{event.x},{event.y}")
                self.select(index)
                tab_id = self.select()

                # Get the associated terminal widget
                terminal = self.nametowidget(tab_id)

                # Create a popup frame attached to terminal
                frame = tk.Frame(terminal, bg=OUTER_BG)
                frame.place(rely=0, x=event.x, y=13, anchor="w")

                frameInner = tk.Frame(frame, bg=OUTER_BG)
                frameInner.pack(expand=True, fill=BOTH, padx=5, pady=5)

                field = StringVar()

                entry = tk.Entry(
                    frameInner,
                    textvariable=field,
                    bd=0,
                    width=10,
                    bg=INNER_BG,
                    fg="white",
                    insertbackground="white",
                    borderwidth=0,
                    font="Helvetica 9"
                )

                entry.pack(side=LEFT, expand=True, fill=BOTH)

                buttonClose = tk.Button(
                    frameInner,
                    image=self.renameCloseButton,
                    bg=OUTER_BG,
                    relief=FLAT,
                    bd=0,
                    height=15,
                    highlightbackground=OUTER_BG,
                    command=_focus_out
                )

                buttonClose.pack(side=LEFT, padx=(5, 0))

                # Get the tab label
                field.set(self.tab(tab_id, option="text"))

                # Set focus to Entry box and select all text by default
                entry.focus()
                entry.select_range(0, END)

                # Bind keys
                entry.bind("<Return>", _accept_change)
                entry.bind("<FocusOut>", _focus_out)
                entry.bind("<Escape>", _focus_out)

                buttonClose.bind("<Enter>", _on_enter)
                buttonClose.bind("<Leave>", _on_leave)

            except tk.TclError:
                pass

        def _about_page(self):
            """ About page """

            def _focus_out(*event):
                """ On focus out destroy all created widgets """

                background.destroy()
                #button1.destroy()
                button2.destroy()
                frameButton.destroy()
                labelAbout.destroy()
                labelIcon.destroy()
                frameInner.destroy()
                frame.destroy()

                tab_id = self.select()
                terminal = self.nametowidget(tab_id)
                terminal.TerminalScreen.focus_set()

            # Define colors
            OUTER_BG = "#9da5b4"
            INNER_BG = "#414755"

            # Get screen dimension
            root_width = self.parent.winfo_width()
            root_height = self.parent.winfo_height()

            # Fill background to cover whole screen
            background = tk.Label(self.parent, bg=OUTER_BG, width=root_width, height=root_height)
            background.place(x=0, y=0)

            # Create a popup frame
            frame = tk.Frame(self.parent, bg=INNER_BG)
            frame.place(relx=0.5, rely=0.5, anchor="center")

            # Inner frame
            frameInner = tk.Frame(frame, bg=INNER_BG)
            frameInner.pack(expand=True, fill=BOTH, padx=20, pady=20)

            about_text = f"""
    Terminal Emulator.
    Version: {__version__}

    Created by Tudor Marmureanu

    """

            labelIcon = tk.Label(frameInner, image=self.iconApp, bg=INNER_BG)
            labelIcon.pack(side=TOP)

            labelAbout = tk.Label(frameInner, text=about_text, bg=INNER_BG, fg="white")
            labelAbout.pack(side=TOP)

            # Area for buttons
            frameButton = tk.Frame(frameInner, bg=INNER_BG)
            frameButton.pack(side=TOP)

            #button1 = ttk.Button(frameButton, text="Visit github", takefocus=0, command=lambda : webbrowser.open("https://github.com/dhanoosu/TkTerm"))
            #button1.pack(side=LEFT, expand=True, padx=5, ipadx=10)

            button2 = ttk.Button(frameButton, text="OK", takefocus=0, command=_focus_out)
            button2.pack(side=LEFT, expand=True, padx=5)

            # Bind keys
            frame.bind("<FocusOut>", _focus_out)
            background.bind("<ButtonRelease-1>", _focus_out)

    class TerminalWidget(tk.Frame):

        SHELL_MAPPINGS = Interpreter.MAPPINGS

        def __init__(self, parent, **kwargs):
            tk.Frame.__init__(self, parent, **kwargs)

            self.parent = parent

            self.basename = ""
            self.commandIndex = -1
            self.commandHistory = []

            # get the root after
            self.after = self.winfo_toplevel().after

            self.currentInterpreter = None

            self.TerminalColors = TkTermConfig.get_config()

            self.caretHandling = False
            self.pendingKeys = ""

            self.icon = None

            ########################################################################
            ## Terminal screen
            ########################################################################
            self.frameTerminal = tk.Frame(self, borderwidth=0, relief=FLAT, bg=self.TerminalColors["bg"])

            self.TerminalScreen = tk.Text(
                self.frameTerminal,
                bg=self.TerminalColors["bg"],
                fg=self.TerminalColors["fg"],
                insertbackground="white",
                highlightthickness=0,
                borderwidth=0,
                insertwidth=1,
                undo=False
            )

            self.stdout = Redirect(self, stream="stdout")
            self.stderr = Redirect(self, stream="stderr")

            self.frameScrollbar = Frame(self.frameTerminal, borderwidth=0, width=14, bg=self.TerminalColors["bg"])
            # tell frame not to let its children control its size
            self.frameScrollbar.pack_propagate(0)

            self.scrollbar = ttk.Scrollbar(self.frameScrollbar, style="Terminal.Vertical.TScrollbar", orient="vertical")
            self.scrollbar.pack(anchor=E, side=RIGHT, fill=Y, expand=True, padx=(0,3))

            self.TerminalScreen['yscrollcommand'] = self.scrollbar.set
            self.scrollbar['command'] = self.TerminalScreen.yview

            self.scrollTimer = 0
            self.frameScrollbar.bind("<Enter>", self.on_scrollbar_enter)
            self.frameScrollbar.bind("<Leave>", self.on_scrollbar_leave)

            # Initially map as leave event
            self.frameScrollbar.bind("<Map>", self.on_scrollbar_leave)

            # Flag to indicate if user enters scrollbar area
            self.isScrollbarEnterEvent = False

            ########################################################################
            ## Status bar
            ########################################################################
            self.frameStatusBar = ttk.Frame(self, style="Status.TFrame")

            self.returnCodeLabel = Label(self.frameStatusBar, text="RC: 0", fg="white", bg="green", font=("Helvetica", 8), anchor=W, width=8)
            self.returnCodeLabel.pack(side=LEFT)

            self.statusText = StringVar()
            self.statusText.set("Status: IDLE")
            self.statusLabel = Label(self.frameStatusBar, textvariable=self.statusText, font=("Helvetica", 8), relief=FLAT)
            self.statusLabel.pack(side=LEFT)

            ########################################################################
            ## Style configure for ttk widgets
            ########################################################################
            style_combobox = {
                "relief"                : FLAT,
                "borderwidth"           : 0,
                "highlightthickness"    : 0
            }

            self.style = ttk.Style(self)
            self.style.theme_use('default')
            self.style.configure("Shell.TCombobox", **style_combobox)
            self.style.configure("Terminal.Vertical.TScrollbar",
                background="#3A3E48",
                borderwidth=0,
                relief=FLAT
            )

            self.style.configure("Status.TFrame", background="#21252B", borderwidth=0, relief=FLAT)

            # following are style option for the drop down combobox listbox
            self.option_add('*TCombobox*Listbox*Background', '#21252B')
            self.option_add('*TCombobox*Listbox*Foreground', "#9DA5B4")
            self.option_add('*TCombobox*Listbox.font', ("Helvetica", 8))

            self.shellComboBox = ttk.Combobox(self.frameStatusBar, style="Shell.TCombobox", state="readonly", width=8, font=("Helvetica", 8))
            self.shellComboBox.pack(side=RIGHT, padx=0)
            self.shellComboBox['values'] = list(Interpreter.MAPPINGS.keys())

            # Set default shell
            self.shellComboBox.set(Interpreter.DEFAULT_SHELL)

            self.shellComboBox.bind("<<ComboboxSelected>>", self.update_shell)
            # self.shellComboBox.bind("<Button-1>", self.do_leftClick)
            self.shellComboBox.bind("<Escape>", self.do_leftClickRelease, add="+")


            ########################################################################
            ## Set style colours
            ########################################################################
            self.set_color_style()

            ########################################################################
            ## Packing
            ########################################################################

            # Need to pack these last otherwise a glitch happens
            # where scrollbar disappear when window resized
            self.frameStatusBar.pack(side=BOTTOM, fill=X)
            self.frameTerminal.pack(side=TOP, fill=BOTH, expand=True)
            self.frameScrollbar.pack(side=RIGHT, fill=Y)
            self.TerminalScreen.pack(side=LEFT, fill=BOTH, expand=True, padx=(4,0), pady=(4,0))

            ########################################################################
            ## Key bindings
            ########################################################################
            self.TerminalScreen.bind('<MouseWheel>', self.rollWheel)
            self.frameScrollbar.bind('<MouseWheel>', self.rollWheel)
            self.scrollbar.bind('<MouseWheel>', self.rollWheel)

            self.TerminalScreen.bind('<Control-c>', self.do_cancel)
            self.TerminalScreen.bind("<Control-t>", lambda e: self.event_generate("<<eventNewTab>>") or "break")
            self.TerminalScreen.bind('<Control-Tab>', lambda e: self.event_generate("<<eventCycleNextTab>>") or "break")

            # Windows or Mac
            if (platform.system() == "Windows") or (platform.system() == "Darwin"):
                self.TerminalScreen.bind('<Shift-Tab>', lambda e: self.event_generate("<<eventCyclePrevTab>>") or "break")
            else:
                self.TerminalScreen.bind('<ISO_Left_Tab>', lambda e: self.event_generate("<<eventCyclePrevTab>>") or "break")

            self.bind_keys()

            # Bind all other key press
            self.TerminalScreen.bind("<KeyPress>", self.do_keyPress)

            self.insertionIndex = self.TerminalScreen.index("end")
            self.count = 0

            self.terminalThread = None
            self.processTerminated = False

            # Caret handling and multiline commands
            self.multilineCommand = ""

            # Automatically set focus to Terminal screen when initialised
            self.TerminalScreen.focus_set()

        def terminate(self):
            """ Terminate this terminal instance """

            if (self.terminalThread is not None) and (self.terminalThread.is_alive()):
                self.TerminalScreen.event_generate("<Control-c>")
                self.stdout = sys.stdout
                self.stderr = sys.stderr

                self.check_process_terminate()

        def check_process_terminate(self):

            if (self.terminalThread is not None) and (self.terminalThread.is_alive()):
                self.after(100, self.check_process_terminate)


        def reset(self):

            # Caret handling and multiline commands
            self.multilineCommand = ""
            self.caretHandling = False

        def set_color_style(self):
            """
            Set coloring style for widgets
            """

            TerminalColors = TkTermConfig.get_config()

            self.TerminalScreen["bg"]               = TerminalColors["bg"]
            self.TerminalScreen["fg"]               = TerminalColors["fg"]
            self.TerminalScreen["selectbackground"] = TerminalColors["selectbackground"]

            self.frameTerminal["bg"] = TerminalColors["bg"]
            self.frameScrollbar["bg"] = TerminalColors["bg"]

            ########################################################################
            ## Font
            ########################################################################

            terminalFont = Font(family=TerminalColors["fontfamily"], size=TerminalColors["fontsize"])
            self.TerminalScreen["font"] = terminalFont

            boldFont = Font(font=terminalFont)
            boldFont.configure(weight="bold")

            self.TerminalScreen.tag_config("basename", foreground=TerminalColors["basename"], font=boldFont)
            self.TerminalScreen.tag_config("error", foreground=TerminalColors["error"])
            self.TerminalScreen.tag_config("output", foreground=TerminalColors["output"])

            ########################################################################
            ## Scrollbar
            ########################################################################

            self.style.configure("Terminal.Vertical.TScrollbar", troughcolor=TerminalColors["bg"])
            self.style.configure("Terminal.Vertical.TScrollbar", arrowcolor=TerminalColors["bg"])

            self.style.map('Terminal.Vertical.TScrollbar',
                background=[
                    ('pressed', "#9DA5B4"),
                    ('disabled', TerminalColors["bg"])
                ],
                arrowcolor=[
                    ('disabled', TerminalColors["bg"]),
                    ('active', TerminalColors["bg"])
                ]
            )

            ########################################################################
            ## Shell selection combobox
            ########################################################################

            self.style.map('Shell.TCombobox', background=[('hover', "#2F333D")])
            self.style.map('Shell.TCombobox', fieldbackground=[('hover', "#2F333D")])
            self.style.map('Shell.TCombobox', arrowcolor=[('readonly', '#9DA5B4')])

            self.style.configure("Shell.TCombobox", fieldbackground="#21252B") # current field background
            self.style.configure("Shell.TCombobox", background="#21252B") # arrow box background
            self.style.configure("Shell.TCombobox", foreground="#9DA5B4") # current field foreground

            ########################################################################
            ## Status bar
            ########################################################################

            self.statusLabel["bg"] = "#21252B"
            self.statusLabel["fg"] = "#9DA5B4"

            # Use i-beam cursor
            if TerminalColors["cursorshape"] == "bar":
                self.TerminalScreen['blockcursor'] = False
                self.TerminalScreen['insertwidth'] = 1

            # Use block cursor
            elif TerminalColors["cursorshape"] == "block":
                self.TerminalScreen['blockcursor'] = True
                self.TerminalScreen['insertwidth'] = 0


        def on_scrollbar_enter(self, event):
            """
            On focus on scrollbar increase width of scrollbar
            """

            self.isScrollbarEnterEvent = True

            # self.style.configure("Terminal.Vertical.TScrollbar",
            #     width=10,
            #     arrowsize=10
            # )

            self._scrollbar_animation()

        def on_scrollbar_leave(self, eventL):
            """
            On focus off from scrollbar decrease width of scrollbar
            """

            self.isScrollbarEnterEvent = False

            # self.style.configure("Terminal.Vertical.TScrollbar",
            #     width=5,

            #     # hack to make arrow invisible
            #     arrowsize=-10
            # )

            self._scrollbar_animation()

        def _scrollbar_animation(self):

            if self.isScrollbarEnterEvent:
                self.scrollTimer += 3

                if self.scrollTimer <= 12:
                    self.after(100, self._scrollbar_animation)
                else:
                    self.style.configure("Terminal.Vertical.TScrollbar", arrowsize=10)
                    self.style.map('Terminal.Vertical.TScrollbar',
                        background=[('active', "#9DA5B4"), ('pressed', "#9DA5B4"), ('disabled', TkTermConfig.CONFIG["bg"])]
                    )
                    self.style.configure("Terminal.Vertical.TScrollbar", background="#9DA5B4")

            else:
                self.scrollTimer -= 1

                if self.scrollTimer >= 0:
                    self.after(100, self._scrollbar_animation)
                else:
                    self.style.configure("Terminal.Vertical.TScrollbar", arrowsize=-10)
                    self.style.configure("Terminal.Vertical.TScrollbar", width=5)
                    self.style.map('Terminal.Vertical.TScrollbar',
                        background=[('active', "#3A3E48"), ('disabled', TkTermConfig.CONFIG["bg"])]
                    )
                    self.style.configure("Terminal.Vertical.TScrollbar", background="#3A3E48")

        def bind_keys(self):
            self.TerminalScreen.bind("<FocusOut>",          self.focus_out)

            self.TerminalScreen.bind("<Return>",            self.do_keyReturn)
            self.TerminalScreen.bind("<Up>",                self.do_keyUpArrow)
            self.TerminalScreen.bind("<Down>",              self.do_keyDownArrow)
            self.TerminalScreen.bind("<BackSpace>",         self.do_keyBackspace)
            self.TerminalScreen.bind("<Delete>",            lambda event: "")
            self.TerminalScreen.bind("<End>",               lambda event: "")
            self.TerminalScreen.bind("<Left>",              self.do_keyLeftArrow)
            self.TerminalScreen.bind("<Right>",             lambda event: "")
            self.TerminalScreen.bind("<Button-1>",          self.do_leftClick)
            self.TerminalScreen.bind("<ButtonRelease-1>",   self.do_leftClickRelease)
            self.TerminalScreen.bind("<ButtonRelease-2>",   self.do_middleClickRelease)
            self.TerminalScreen.bind("<Tab>",               self.do_keyTab)
            self.TerminalScreen.bind("<Home>",              self.do_keyHome)
            self.TerminalScreen.unbind("<B1-Motion>")

        def unbind_keys(self):
            self.TerminalScreen.bind("<Return>",            lambda event: "break")
            self.TerminalScreen.bind("<Up>",                lambda event: "break")
            self.TerminalScreen.bind("<Down>",              lambda event: "break")
            self.TerminalScreen.bind("<BackSpace>",         lambda event: "break")
            self.TerminalScreen.bind("<Delete>",            lambda event: "break")
            self.TerminalScreen.bind("<End>",               lambda event: "break")
            self.TerminalScreen.bind("<Left>",              lambda event: "break")
            self.TerminalScreen.bind("<Right>",             lambda event: "break")
            self.TerminalScreen.bind("<Button-1>",          lambda event: "break")
            self.TerminalScreen.bind("<ButtonRelease-1>",   lambda event: "break")
            self.TerminalScreen.bind("<ButtonRelease-2>",   lambda event: "break")
            self.TerminalScreen.bind("<Tab>",               lambda event: "break")
            self.TerminalScreen.bind("<Home>",              lambda event: "break")
            self.TerminalScreen.bind("<B1-Motion>",         lambda event: "break")

        def rollWheel(self, event):
            direction = 0
            if event.num == 5 or event.delta == -120:
                direction = 3
            if event.num == 4 or event.delta == 120:
                direction = -3
            self.TerminalScreen.yview_scroll(direction, UNITS)

            return "break"

        def focus_out(self, event):
            """When out of focus, store the last insertion index """

            self.insertionIndex = self.TerminalScreen.index("insert")

        def do_keyPress(self, event):

            import string

            # The obvious information
            c = event.keysym
            s = event.state

            # Manual way to get the modifiers
            ctrl  = (s & 0x4) != 0
            alt   = (s & 0x8) != 0 or (s & 0x80) != 0
            shift = (s & 0x1) != 0

            if ctrl:
                return "break"


            char = event.char

            if self.terminalThread:
                self.pendingKeys += char
            elif char in list(string.printable):
                self.pendingKeys = ""
                self.TerminalScreen.insert("insert", char)
                self.TerminalScreen.see(END)

            return "break"

        def update_shell(self, print_basename=True, *args):

            # Update current interpreter
            self.currentInterpreter = Interpreter.get_interpreter(self.shellComboBox.get())
            self.shellComboBox.selection_clear()
            self.TerminalScreen.focus()

            # Update icon
            self.icon = Interpreter.get_icon(self.shellComboBox.get())

            # Generate event
            self.event_generate("<<eventUpdateShell>>")

            if print_basename:
                # When new shell is selected from the list we want to add new line
                # and print basename in case the prompt changes
                self.insert_new_line()
                self.print_basename()

        def do_cancel(self, *args):

            import signal

            # Kill current running process if there is any
            if (self.terminalThread is not None) and (self.terminalThread.is_alive()):

                # Signals TerminalPrint to immediately stops any printout
                self.processTerminated = True

                self.stdout.write("^C")

                (stdout, stderr) = self.currentInterpreter.terminate(self.terminalThread.process)

                self.stdout.write(stdout, end='')
                self.stderr.write(stderr, end='')

            else:

                # Clear multiline commands
                if self.multilineCommand != "":
                    self.multilineCommand = ""

                if self.caretHandling:
                    # Always clear caret handle
                    self.caretHandling = False

                # Clear commands
                self.insert_new_line()
                self.print_basename()

        class TerminalPrint(KThread):

            def __init__(self, top, cmd):

                KThread.__init__(self)
                # super().__init__(parent, *args, **kwargs)

                self.daemon = True
                self.cmd = cmd
                self.returnCode = 0

                self.process = None

                # Attach outer class instance
                self.top = top

            def run(self):

                # Modify shell executable based on selected shell combobox variable
                shellSelected = self.top.shellComboBox.get()

                # Set current interpreter based on shell selected
                # self.top.currentInterpreter = Interpreter.get_interpreter(shellSelected)

                if self.cmd != "":

                    try:

                        # with subprocess.Popen(self.cmd, **process_options) as self.process:
                        with self.top.currentInterpreter.execute(self.cmd) as self.process:

                            # if hasattr(self.process, "stdout") and hasattr(self.process, "stderr"):
                            for line in self.process.stdout:

                                # if self.top.processTerminated:
                                #     break

                                self.top.stdout.write(line, end='')

                            for line in self.process.stderr:
                                self.top.stderr.write(line, end='')


                        self.returnCode = self.top.currentInterpreter.get_return_code(self.process)

                    except Exception:
                        self.top.stderr.write(traceback.format_exc())
                        self.returnCode = -1

                # Always print basename on a newline
                insert_pos = self.top.TerminalScreen.index("insert")
                if insert_pos.split('.')[1] != '0':
                    self.top.insert_new_line()

                self.top.print_basename()
                self.top.processTerminated = False

        def clear_screen(self):
            """ Clear screen and print basename """

            self.TerminalScreen.delete("1.0", END)
            self.print_basename()

        def print_basename(self):
            """ Print basename on Terminal """

            self.stdout.write(self.get_basename(), end='')
            self.stdout.write(self.pendingKeys, end='')

            self.pendingKeys = ""

        def get_basename(self):
            """ Get full basename comtaining newline characters """

            if self.caretHandling:
                return "> "
            else:
                return self.currentInterpreter.get_prompt()

        def get_last_basename(self):
            """ Get the basename after the last newline character """

            basename = self.get_basename()

            if "\n" in basename:
                return basename.split("\n")[-1]

            return basename


        def do_keyHome(self, *args):
            """ Press HOME to return to the start position of command """

            pos = self.get_pos_after_basename()

            self.TerminalScreen.mark_set("insert", pos)
            return "break"

        def get_pos_after_basename(self):
            """ Return starting position of the command """

            pos = get_last_line(self.TerminalScreen)
            pos_integral = str(pos).split('.')[0]
            offset = '.' + str(len(self.get_last_basename()))
            new_pos = pos_integral + offset

            return new_pos

        def get_cmd(self):
            """ Return command after the basename """

            pos = self.get_pos_after_basename()
            return self.TerminalScreen.get(pos, "end-1c")

        def delete_cmd(self):
            """ Delete command after basename """

            pos = self.get_pos_after_basename()
            self.TerminalScreen.delete(pos, END)

        def do_keyTab(self, *args):
            """ Tab completion """

            # Windows uses backward slash
            # Unix uses forward slash
            slash = os.sep

            raw_cmd = self.get_cmd()
            cmd = raw_cmd

            # Always focus on the last command
            # E.g., "cd folder" : only focus on the last command "folder"
            # Get the last space-separated command
            if cmd == "":
                last_cmd = ""
            elif cmd[-1] == " ":
                last_cmd = ""
            else:
                last_cmd = cmd.split()[-1]

            # Create a pattern to be match with glob
            match_pattern = last_cmd+'*'

            import glob

            cd_children = sorted(glob.glob(match_pattern))
            cd_children = [f+slash if os.path.isdir(f) else f for f in cd_children]

            import re
            import fnmatch

            # glob on Windows are case insensitive - below is a hack to match case-sensitive path
            match = re.compile(fnmatch.translate(match_pattern)).match
            cd_children = [pth for pth in cd_children if match(pth)]

            common_path = os.path.commonprefix(cd_children)

            return_cmd = raw_cmd

            # If common prefix path is not found this is our final command
            # Concatenate with the previous "last command"
            if common_path != "":
                self.delete_cmd()
                return_cmd += common_path[len(last_cmd):]

                self.stdout.write(return_cmd, end='')

            # Also print the files and folders that matched the pattern only if
            # the results have more than one entry
            if len(cd_children) > 1:
                self.insert_new_line()
                self.stdout.write('\n'.join(cd_children))

                self.print_basename()
                self.stdout.write(return_cmd, end='')

            return "break"

        def do_leftClickRelease(self, *args):

            # Unhide cursor
            self.TerminalScreen["insertwidth"] = 1
            self.TerminalScreen["insertbackground"] = "white"

            self.TerminalScreen.focus_set()
            self.TerminalScreen.mark_set("insert", self.insertionIndex)

        def do_middleClickRelease(self, *args):

            try:
                selected = self.TerminalScreen.selection_get()
            except Exception as e:
                selected = ""

            current_pos = self.TerminalScreen.index(INSERT)
            self.TerminalScreen.insert(current_pos, selected)

            return "break"

        def do_leftClick(self, *args):

            # Hide cursor
            self.TerminalScreen["insertwidth"] = 0
            self.TerminalScreen["insertbackground"] = self.TerminalColors["selectbackground"]

            self.insertionIndex = self.TerminalScreen.index("insert")
            # self.TerminalScreen.mark_set("insert", self.insertionIndex)
            # return "break"
            pass

        def do_keyReturn(self, *args):
            """ On pressing Return, execute the command """

            # Caret character differs on Windows and Unix
            if os.name == "nt":
                CARET = "^"
            else:
                CARET = "\\"

            cmd = self.get_cmd()
            cmd = cmd.strip()

            # Empty command - pass
            if cmd == "":
                self.insert_new_line()
                self.print_basename()
                pass

            # Multiline command
            elif cmd.endswith(CARET):

                # Add to command history
                if cmd in self.commandHistory:
                    self.commandHistory.pop(self.commandIndex)

                self.commandIndex = -1
                self.commandHistory.insert(0, cmd)

                # Construct multiline command
                self.multilineCommand += cmd.rstrip(CARET)

                # Set caret handling
                if not self.caretHandling:
                    self.caretHandling = True

                self.insert_new_line()
                self.print_basename()

            # Valid command
            else:

                # Add to command history
                if cmd in self.commandHistory:
                    self.commandHistory.pop(self.commandIndex)

                self.commandIndex = -1
                self.commandHistory.insert(0, cmd)

                # Merge all multiline command and disable caret handling
                if self.multilineCommand != "":
                    cmd = self.multilineCommand + cmd
                    self.multilineCommand = ""

                    self.caretHandling = False

                if cmd == "clear" or cmd == "reset":
                    self.clear_screen()

                elif "cd" in cmd.split()[0]:
                    path = ' '.join(cmd.split()[1:])
                    path = os.path.expanduser(path)

                    if os.path.isdir(path):
                        os.chdir(path)

                        # Insert new line
                        self.insert_new_line()
                        self.set_returnCode(0)
                    else:
                        self.insert_new_line()
                        self.stderr.write("cd: no such file or directory: {}".format(path))
                        self.set_returnCode(1)

                    self.print_basename()
                else:
                    self.insert_new_line()

                    self.terminalThread = self.TerminalPrint(self, cmd)
                    self.terminalThread.start()

                    self.count = 0
                    self.unbind_keys()
                    self.monitor(self.terminalThread)


            return 'break'

        def do_keyBackspace(self, *args):
            """ Delete a character until the basename """

            index = self.TerminalScreen.index("insert-1c")

            if int(str(index).split('.')[1]) >= len(self.get_last_basename()):
                self.TerminalScreen.delete(index)

            return "break"

        def do_keyLeftArrow(self, *args):
            """ Moves cursor to the left until it reaches the basename """

            index = self.TerminalScreen.index("insert-1c")

            if int(str(index).split('.')[1]) < len(self.get_last_basename()):
                return "break"

        def do_keyUpArrow(self, *args):
            """ Press UP arrow to get previous command in history """

            if self.commandIndex < len(self.commandHistory) - 1:
                self.commandIndex += 1

                self.delete_cmd()

                cmd = self.commandHistory[self.commandIndex]
                self.stdout.write(cmd, end='')

            return 'break'

        def do_keyDownArrow(self, *args):
            """ Press Down arrow to get the next command in history """

            if self.commandIndex >= 1:
                self.commandIndex -= 1

                self.delete_cmd()

                cmd = self.commandHistory[self.commandIndex]
                self.stdout.write(cmd, end='')

            elif self.commandIndex == 0:
                self.commandIndex = -1

                self.delete_cmd()

            return 'break'

        def insert_new_line(self):
            """ Insert a newline in Terminal """
            self.TerminalScreen.insert(END, "\n")
            self.TerminalScreen.mark_set("insert", END)

        def monitor(self, progress_thread):
            """ Monitor running process and update RC and Status on status bar """

            seq1 = ["⢿", "⣻", "⣽", "⣾", "⣷", "⣯", "⣟", "⡿"]
            seq2 = ["∙∙∙∙∙∙∙", "●∙∙∙∙∙∙", "∙●∙∙∙∙∙", "∙∙●∙∙∙∙", "∙∙∙●∙∙∙", "∙∙∙∙●∙∙", "∙∙∙∙∙●∙", "∙∙∙∙∙∙●"]

            if progress_thread.is_alive():

                string = "{} Status: Working {}".format(seq1[self.count], seq2[self.count])
                self.count = (self.count + 1) % 8
                self.statusText.set(string)

                self.after(100, lambda: self.monitor(progress_thread))

            else:
                self.set_returnCode(progress_thread.returnCode)
                self.statusText.set("Status: IDLE")
                self.terminalThread = None

                self.bind_keys()

        def set_returnCode(self, rc):
            """ Set return code on status bar """

            if(rc != 0):
                self.returnCodeLabel.configure(bg="red")
            else:
                self.returnCodeLabel.configure(bg="green")

            self.returnCodeLabel['text'] = "RC: {}".format(rc)

        def run_command(self, cmd):
            """ Print and execute command on terminal """

            while self.terminalThread: pass

            self.stdout.write(cmd, end='')
            self.do_keyReturn()

    class SearchBar():

        def __init__(self, parent):
            self.TerminalScreen = parent.TerminalScreen
            self.frameTerminal = parent.frameTerminal
            self._init()

        def _init(self):

            ## Bind keys
            self.TerminalScreen.bind('<Control-f>', self.open_searchbar)
            self.TerminalScreen.bind('<Escape>', self.close_searchbar)

            self.foundList = []
            self._reset()

            self.click_close    = PhotoImage(file=get_absolute_path(__file__, 'img/close.png'))
            self.click_next     = PhotoImage(file=get_absolute_path(__file__, 'img/next.png'))
            self.click_prev     = PhotoImage(file=get_absolute_path(__file__, 'img/prev.png'))
            self.click_regex    = PhotoImage(file=get_absolute_path(__file__, 'img/regex.png'))
            self.click_case     = PhotoImage(file=get_absolute_path(__file__, 'img/case.png'))


        def _reset(self):
            """ Reset attributes """

            self.searchIsOpen = False
            self.searchCaseSensitive = False
            self.searchRegex = False

            self.foundList.clear()
            self.currentSearchIndex = 0
            self.searchFoundCount = 0
            self.frameSearchBar = None
            self.searchRegexTooltip = None

        def open_searchbar(self, event):

            self.search_config = {
                "bd"        : 0,
                "fg"        : "white",
                "bg"        : "#21252B",
                "relief"    : FLAT,
                "font"      : ("Helvetica", 8)
            }

            if not self.searchIsOpen:

                ## Create searchbar frame
                self.frameSearchBar = tk.Frame(self.frameTerminal, width=20, height=50, borderwidth=0, bg="#21252B", relief=FLAT)

                self.searchFieldText = StringVar()

                self.searchField = Entry(
                    self.frameSearchBar,
                    textvariable = self.searchFieldText,
                    fg="#b2b2b3",
                    bg="#1d1f23",
                    insertbackground="white",
                    relief=FLAT,
                    highlightbackground="#1d1f23",
                    font=("Helvetica", 8)
                )

                self.searchField.pack(side=LEFT, padx=(5,0), pady=(5))

                # Bind keys
                self.searchField.bind("<Return>",       lambda event: self.do_search_next_or_prev(isNext=True))
                self.searchField.bind("<Shift-Return>", lambda event: self.do_search_next_or_prev(isNext=False))
                self.searchField.bind('<Escape>',       self.close_searchbar)

                self.searchFieldText.trace("w", self.do_search)

                self.searchResultText = StringVar()
                self.searchResultText.set("No results")

                def toggle_searchRegex():
                    self.searchRegex = not self.searchRegex

                    bg = "red" if self.searchRegex else "#1d1f23"
                    self.searchRegexButton.configure(bg=bg)

                    self.do_search()

                def toggle_searchCaseSensitive():
                    self.searchCaseSensitive = not self.searchCaseSensitive

                    bg = "red" if self.searchCaseSensitive else "#1d1f23"
                    self.searchCaseButton.configure(bg=bg)

                    self.do_search()

                self.searchCaseButton = Button(self.frameSearchBar, cursor="hand2", image=self.click_case, bg="#1d1f23", relief=FLAT, bd=0, highlightbackground="#1d1f23", command=toggle_searchCaseSensitive)
                self.searchCaseButton.pack(side=LEFT, fill=Y, pady=5)
                Tooltip(self.searchCaseButton, text="Match Case", delay=1)

                self.searchRegexButton = Button(self.frameSearchBar, cursor="hand2", image=self.click_regex, bg="#1d1f23", relief=FLAT, bd=0, highlightbackground="#1d1f23", command=toggle_searchRegex)
                self.searchRegexButton.pack(side=LEFT, fill=Y, pady=5)
                Tooltip(self.searchRegexButton, text="Use Regular Expression", delay=1)

                self.searchResult   = Label(self.frameSearchBar, textvariable=self.searchResultText, width=8, anchor=W, **self.search_config)
                self.searchResult.pack(side=LEFT, padx=(5), fill=Y)

                self.searchPrev     = Button(self.frameSearchBar, cursor="hand2", image=self.click_prev, width=30, highlightbackground= "#21252B", command= lambda: self.do_search_next_or_prev(False), **self.search_config)
                self.searchPrev.pack(side=LEFT, padx=(2), fill=Y)
                Tooltip(self.searchPrev, text="Previous Match (Shift+Enter)", delay=1)

                self.searchNext     = Button(self.frameSearchBar, cursor="hand2", image=self.click_next, width=30, highlightbackground= "#21252B", command= lambda: self.do_search_next_or_prev(True), **self.search_config)
                self.searchNext.pack(side=LEFT, padx=(2), fill=Y)
                Tooltip(self.searchNext, text="Next Match (Enter)", delay=1)

                self.searchClose = Button(
                    self.frameSearchBar,
                    cursor="hand2",
                    image=self.click_close,
                    highlightbackground="#21252B",
                    width=30,
                    command=self.close_searchbar,
                    **self.search_config
                )

                self.searchClose.pack(side=LEFT, padx=(2), fill=Y)

                ## Create extra binding event on top of what Tooltip had (add="+")
                self.searchPrev.bind("<Enter>", self.on_enter, add="+")
                self.searchPrev.bind("<Leave>", self.on_leave, add="+")

                self.searchNext.bind("<Enter>", self.on_enter, add="+")
                self.searchNext.bind("<Leave>", self.on_leave, add="+")

                self.searchClose.bind("<Enter>", self.on_enter, add="+")
                self.searchClose.bind("<Leave>", self.on_leave, add="+")

                self.frameSearchBar.place(rely=0, relx=1.0, x=-14, y=14, anchor="e")
                self.searchField.focus_set()
                self.searchIsOpen = True

            ## Destroy searchbar frame
            else:
                self.close_searchbar()

        def on_enter(self, e):
            e.widget["bg"] = "black"

            # Set activebackground
            e.widget["activebackground"] = "black"

        def on_leave(self, e):
            e.widget["bg"] = self.search_config["bg"]

        def close_searchbar(self, *args):

            if self.frameSearchBar:

                for child in self.frameSearchBar.winfo_children():
                    child.destroy()

                self.frameSearchBar.destroy()

                self._reset()

                self.TerminalScreen.tag_remove("found", "1.0", END)
                self.TerminalScreen.tag_remove("found_selected", "1.0", END)

                self.TerminalScreen.focus_set()

            self.frameSearchBar = None

        def do_search(self, *args):

            value = self.searchFieldText.get()

            self.TerminalScreen.tag_remove("found", "1.0", END)
            self.TerminalScreen.tag_remove("found_selected", "1.0", END)
            self.searchResultText.set("No results")

            self.foundList.clear()

            if not self.searchRegexTooltip:
                self.searchRegexTooltip = Tooltip(self.searchField, "", manual=True)
            else:
                self.searchRegexTooltip.close()

            self.searchField.configure(bg = "#1d1f23")

            if value:

                idx = "1.0"
                self.searchFoundCount = 0
                self.currentSearchIndex = 0

                while True:

                    try:
                        idx = self.TerminalScreen.search(value, idx, nocase=(not self.searchCaseSensitive), stopindex=END, regexp=self.searchRegex)
                        self.searchField.configure(bg = "#1d1f23")
                    except Exception as err:
                        # self.searchField.configure(borderwidth= 2)
                        self.searchField.configure(bg = "red")
                        self.searchRegexTooltip.text = err
                        self.searchRegexTooltip.create()
                        break

                    if not idx:
                        self.searchResult['fg'] = "#f4875b" if self.searchFoundCount == 0 else "#b2b2b3"
                        break

                    lastidx = "{}+{}c".format(idx, len(value))

                    self.foundList.append((idx, lastidx))

                    self.TerminalScreen.tag_add("found", idx, lastidx)
                    idx = lastidx

                    self.TerminalScreen.tag_config("found", background="green")
                    self.searchFoundCount += 1


                if self.foundList:
                    self.searchResultText.set("{} of {}".format(1, self.searchFoundCount))
                    self.TerminalScreen.tag_add("found_selected", self.foundList[0][0], self.foundList[0][1])
                    self.TerminalScreen.see(self.foundList[0][0])

                self.TerminalScreen.tag_config("found_selected", background="orange")

        def do_search_next_or_prev(self, isNext):

            self.TerminalScreen.tag_remove("found_selected", "1.0", END)

            if self.foundList:

                if isNext:
                    self.currentSearchIndex = (self.currentSearchIndex + 1) % self.searchFoundCount
                else:
                    self.currentSearchIndex = (self.currentSearchIndex - 1) % self.searchFoundCount

                self.searchResultText.set("{} of {}".format(self.currentSearchIndex + 1, self.searchFoundCount))
                self.TerminalScreen.tag_add("found_selected", self.foundList[self.currentSearchIndex][0], self.foundList[self.currentSearchIndex][1])


                self.TerminalScreen.see(self.foundList[self.currentSearchIndex][0])

    class RightClickContextMenu:

        def __init__(self, top_level, terminal):

            self.top = top_level
            self.terminal = terminal

            self.bind_menu()

            self.setting_win_top = False

        def bind_menu(self):
            self.menu = tk.Menu(self.terminal,
                tearoff=0,
                bg="#1D1F23",
                # bg="white",
                fg="white",
                # borderwidth=0,
                bd=1,
                relief=FLAT,
                activebackground="#2c313a",
                activeforeground="white",
                selectcolor="red",
                activeborderwidth=0,
            )

            self.menu.add_command(label ="Copy", accelerator=" "*10, command=self._copyClipboard)
            self.menu.add_command(label ="Paste", command=self._pasteClipboard)
            self.menu.add_command(label ="Reload", command=self._reloadScreen)
            self.menu.add_separator()
            self.menu.add_command(label="Settings...", command=self._showSettings)

            self.terminal.TerminalScreen.bind("<ButtonRelease-3>", self._popup)
            self.menu.bind('<FocusOut>', self.on_focusout_popup)

        def on_focusout_popup(self, event=None):
            self.menu.unpost()

        def _popup(self, event):

            try:
                # self.menu.tk_popup(event.x_root+1, event.y_root+1)
                self.menu.post(event.x_root+1, event.y_root+1)
                self.menu.focus_set()
            finally:
                self.menu.grab_release()

        def _copyClipboard(self):

            try:
                selected = self.terminal.TerminalScreen.selection_get()
            except Exception as e:
                selected = ""

            self.top.parent.clipboard_clear()
            self.top.parent.clipboard_append(selected)

        def _pasteClipboard(self):
            data = self.top.parent.clipboard_get()

            current_pos = self.terminal.TerminalScreen.index(INSERT)
            self.terminal.TerminalScreen.insert(current_pos, data)

        def _reloadScreen(self):
            self.terminal.clear_screen()

        def _showSettings(self):

            def _init():

                fieldTexts["background"].set(TkTermConfig.get_config("bg"))
                fieldTexts["foreground"].set(TkTermConfig.get_config("fg"))
                fieldTexts["basename"].set(TkTermConfig.get_config("basename"))
                fieldTexts["error"].set(TkTermConfig.get_config("error"))
                fieldTexts["output"].set(TkTermConfig.get_config("output"))
                fieldTexts["selectbackground"].set(TkTermConfig.get_config("selectbackground"))

                mappings = dict(zip(cursorShapeMappings.values(), cursorShapeMappings.keys()))
                cursorCombobox.set(mappings[TkTermConfig.get_config("cursorshape")])

                fontFamilyCombobox.set(TkTermConfig.get_config("fontfamily"))
                fontSizeFieldText.set(TkTermConfig.get_config("fontsize"))

            def _do_restoreDefault():

                # self.top.TerminalColors = self.top.DefaultTerminalColors.copy()
                TkTermConfig.set_config(TkTermConfig.get_default())
                _init()

            def _init_sample():

                sampleTerminal["state"] = "normal"

                try:

                    isError = False

                    sample_font = Font(family=fontFamilyCombobox.get(), size=int(fontSizeFieldText.get()))

                    sampleTerminal["bg"] = fieldTexts["background"].get()
                    sampleTerminal["selectbackground"] = fieldTexts["selectbackground"].get()
                    sampleTerminal["font"] = sample_font

                    sampleTerminal.delete("1.0", END)

                    boldFont = Font(font=sample_font)
                    boldFont.configure(weight="bold")

                    sampleTerminal.insert(END, "basename>>")
                    sampleTerminal.tag_add("basename", get_last_line(sampleTerminal), sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("basename", foreground=fieldTexts["basename"].get(), font=boldFont)

                    sampleTerminal.insert(END, " ")

                    start_pos = sampleTerminal.index("insert")

                    sampleTerminal.insert(END, "command")
                    sampleTerminal.tag_add("command", start_pos, sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("command", foreground=fieldTexts["foreground"].get())

                    sampleTerminal.insert(END, "\n")

                    start_pos = sampleTerminal.index("insert")

                    output_text = """\
    This is a sample output message from a given command
    Second line ...
    Third line ...
    ^C
    """
                    sampleTerminal.insert(END, output_text)
                    sampleTerminal.tag_add("output", start_pos, sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("output", foreground=fieldTexts["output"].get())


                    start_pos = sampleTerminal.index("insert")

                    error_text = "Terminate.\nAn error has occurred"
                    sampleTerminal.insert(END, error_text)
                    sampleTerminal.tag_add("error", start_pos, sampleTerminal.index("insert"))
                    sampleTerminal.tag_config("error", foreground=fieldTexts["error"].get())

                except:
                    isError = True

                sampleTerminal["state"] = "disabled"


            def _populate_color_fields(name, row, color="white"):

                label = tk.Label(frameSettings, text=name)

                field = StringVar()
                field.set(color)

                entry = tk.Entry(frameSettings, textvariable=field, relief=FLAT)
                button = tk.Button(frameSettings, width=2, height=1, relief=FLAT, cursor="hand2", command= lambda: _choose_color(field))

                field.trace("w", lambda *args: _update_color(button, field))

                label.grid(sticky="W", padx=(0,10), row=row, column=0)
                entry.grid(sticky="W", row=row, column=1)
                button.grid(sticky="W", padx=10, row=row, column=2)

                fieldTexts[name] = field

            def _update_color(entry, field):
                try:
                    entry["text"] = ""
                    entry["bg"] = field.get()
                    entry["activebackground"] = field.get()
                except:
                    entry["text"] = "Err"
                    entry["bg"] = "white"
                    entry["fg"] = "red"

                _init_sample()

            def _choose_color(field):

                try:
                    result = colorchooser.askcolor(title="Color Chooser", parent=self.setting_win_top, initialcolor=field.get())
                except:
                    result = colorchooser.askcolor(title="Color Chooser", parent=self.setting_win_top)

                field.set(result[1])

                _init_sample()

            def _do_ok():

                result = _do_apply()

                if result:
                    self.setting_win_top.destroy()
                else:
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()

            def _do_apply():

                try:
                    TkTermConfig.CONFIG["bg"]               = fieldTexts["background"].get()
                    TkTermConfig.CONFIG["fg"]               = fieldTexts["foreground"].get()
                    TkTermConfig.CONFIG["cursorshape"]      = cursorShapeMappings[cursorCombobox.get()]
                    TkTermConfig.CONFIG["fontfamily"]       = fontFamilyCombobox.get()
                    TkTermConfig.CONFIG["fontsize"]         = fontSizeFieldText.get()
                    TkTermConfig.CONFIG["output"]           = fieldTexts["output"].get()
                    TkTermConfig.CONFIG["error"]            = fieldTexts["error"].get()
                    TkTermConfig.CONFIG["basename"]         = fieldTexts["basename"].get()
                    TkTermConfig.CONFIG["selectbackground"] = fieldTexts["selectbackground"].get()

                    self.top.set_color_style()

                except:
                    tkinter.messagebox.showerror(title="Invalid input", message="Found invalid input. Please check your settings")
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()
                    return False

                return True

            def _update_cursorShapeSelected(*args):
                cursorCombobox.selection_clear()

                _init_sample()

            def _do_saveConfig():

                result = _do_apply()

                if result:
                    with open(TkTermConfig.CONFIG_FILE, "w") as f:
                        f.write(json.dumps(TkTermConfig.get_config(), indent = 4))

                        tkinter.messagebox.showinfo(title="Configuration saved", message="Successfully saved configuration to file.\n{}".format(f.name))

                else:
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()

            def _update_FontFamilySelected(*args):

                fontFamilyCombobox.selection_clear()
                _init_sample()

            def _change_font_size(mode):

                assert(mode in ["decrease", "increase"])

                if mode == "decrease":
                    fontSizeFieldText.set(int(fontSizeFieldText.get()) - 1)
                elif mode == "increase":
                    fontSizeFieldText.set(int(fontSizeFieldText.get()) + 1)

            #
            # If popup window existed, bring it up
            #
            if self.setting_win_top:
                try:
                    self.setting_win_top.lift()
                    self.setting_win_top.focus_set()
                    return
                except:
                    pass

            #
            # Create new popup window
            #
            self.setting_win_top = Toplevel(self.top.winfo_toplevel())
            self.setting_win_top.geometry("750x500")
            self.setting_win_top.resizable(False, False)

            self.setting_win_top.title("Settings")
            self.setting_win_top.focus_set()

            ########################################################################
            # Notebook
            ########################################################################

            tabControl = ttk.Notebook(self.setting_win_top)

            tab1 = tk.Frame(tabControl)
            tab1.pack(expand=True, fill=BOTH)

            ########################################################################
            # Tabs
            ########################################################################

            tabControl.pack(expand=True, fill=BOTH)
            tabControl.add(tab1, text ='Appearance')

            ########################################################################
            # Frames
            ########################################################################

            frameWrap = tk.Frame(tab1)
            frameWrap.pack(expand=True, fill=BOTH, padx=10, pady=10)

            frameTop = tk.Frame(frameWrap)
            frameTop.pack(expand=True, fill=X)

            frameSettings = tk.Frame(frameTop)
            frameSettings.pack(side=LEFT)

            frameSample = tk.Frame(frameTop, height=300, width=500)
            frameSample.pack_propagate(False)
            frameSample.pack(side=LEFT, padx=(10, 0))

            frameBottom = tk.Frame(tab1, relief=RAISED, bd=1, height=5)
            frameBottom.pack(side=BOTTOM, fill=X, ipadx=10, ipady=10)

            ########################################################################
            # Sample terminal
            ########################################################################

            sampleTerminal = tk.Text(frameSample)
            sampleTerminal.pack(expand=True, fill=BOTH)

            ########################################################################
            #
            ########################################################################

            fieldTexts = {}
            isError = False

            label_terminal = tk.Label(frameSettings, text="Terminal", font="Helvetica 16 bold")
            label_cursor = tk.Label(frameSettings, text="Cursor", font="Helvetica 16 bold")
            label_font = tk.Label(frameSettings, text="Font", font="Helvetica 16 bold")

            label_cusor_shape = tk.Label(frameSettings, text="Cursor shape")

            label_font_size = tk.Label(frameSettings, text="Font size")
            label_font_family = tk.Label(frameSettings, text="Font family")

            cursorShapeMappings = {
                "Bar ( | )" : "bar",
                "Block ( █ )" : "block"
            }


            fontSizeFieldText = IntVar()

            frameFontSize = tk.Frame(frameSettings)
            buttonFontSizeMinus = tk.Button(frameFontSize, text=" - ", relief=GROOVE, command= lambda:_change_font_size(mode="decrease")).pack(side=LEFT)
            entry_font_size = tk.Entry(frameFontSize, textvariable=fontSizeFieldText, relief=FLAT, justify=CENTER, width=5).pack(side=LEFT, ipady=3)
            buttonFontSizePlus = tk.Button(frameFontSize, text=" + ", relief=GROOVE, command= lambda:_change_font_size(mode="increase")).pack(side=LEFT)

            label_terminal.grid(sticky="W", ipady=10, row=2)

            _populate_color_fields(name="background", row=3)
            _populate_color_fields(name="foreground", row=4)
            _populate_color_fields(name="selectbackground", row=5)
            _populate_color_fields(name="basename", row=6)
            _populate_color_fields(name="output", row=7)
            _populate_color_fields(name="error", row=8)

            label_cursor.grid(sticky="W", ipady=10, row=9)
            label_cusor_shape.grid(sticky="W", row=10, column=0)

            cursorCombobox = ttk.Combobox(frameSettings, state="readonly", width=15, font=("Helvetica", 8))
            cursorCombobox['values'] = list(cursorShapeMappings.keys())
            cursorCombobox.bind("<<ComboboxSelected>>", _update_cursorShapeSelected)
            cursorCombobox.grid(sticky="W", ipady=3, row=10, column=1)

            label_font.grid(sticky="W", ipady=10, row=11)
            label_font_size.grid(sticky="W", row=12, column=0)
            frameFontSize.grid(sticky="W", row=12, column=1)

            label_font_family.grid(sticky="W", row=13, column=0)

            fontFamilyCombobox = ttk.Combobox(frameSettings, state="readonly", width=25)
            fontFamilyCombobox["values"] = list(font.families())
            fontFamilyCombobox.bind("<<ComboboxSelected>>", _update_FontFamilySelected)
            fontFamilyCombobox.grid(sticky="W", ipady=3, row=13, column=1)

            ttk.Button(frameBottom, style="Settings.TButton", text="Restore default", command=_do_restoreDefault).pack(side=LEFT, expand=True)

            ttk.Button(frameBottom, style="Settings.TButton", text="OK", command=_do_ok).pack(side=LEFT)
            ttk.Button(frameBottom, style="Settings.TButton", text="Apply", command=_do_apply).pack(side=LEFT)

            ttk.Button(frameBottom, style="Settings.TButton", text="Save config", command=_do_saveConfig).pack(side=LEFT, expand=True)

            s = ttk.Style()
            s.map('Settings.TButton',
                background=[('disabled','#d9d9d9'), ('active','#ececec')],
                foreground=[('disabled','#a3a3a3')])


            fontSizeFieldText.trace("w", lambda *args: _init_sample())


            _init()
            _init_sample()

    class Redirect():
        """ Redirect stdout and stderr to be written to Text widget """

        def __init__(self, widget, autoscroll=True, stream="stdout"):
            self.app = widget
            self.TerminalScreen = widget.TerminalScreen
            self.autoscroll = autoscroll
            self.stream = stream

        def write(self, text, end="\n"):

            text = text + end

            # Keep line limit for Terminal to 5000 lines
            limit_diff = int(get_last_line(self.TerminalScreen)) - 5000
            for i in range(limit_diff):
                self.TerminalScreen.delete("1.0", "2.0")

            # Work out if the current line is a command or output
            start_pos = get_last_line(self.TerminalScreen)
            line = self.TerminalScreen.get(start_pos, END)
            isCmd = True if line.startswith(self.app.get_last_basename()) else False

            self.TerminalScreen.insert("end", text)

            if self.autoscroll:
                self.TerminalScreen.see("end")

            ########################################################################
            ## Adding color tags
            ########################################################################

            # Error output
            # would have added a newline, so start_pos needs -1
            if self.stream == "stderr":
                start_pos = get_last_line(self.TerminalScreen) - 1
                end_pos = self.TerminalScreen.index("insert")
                self.TerminalScreen.tag_add("error", start_pos, end_pos)

                # Clear caret handling on invalid commands
                if self.app.caretHandling:
                    self.app.caretHandling = False

            # Normal output
            else:
                # Basename
                if text.startswith(self.app.get_basename()):

                    # Handle custom basename that contains newlines characters
                    last_line_pos = get_last_line(self.TerminalScreen)

                    # Start position needs to minus the number of newline characters found
                    start_pos = last_line_pos - text.count("\n")
                    end_pos = str(last_line_pos).split('.')[0] + '.' + str(len(self.app.get_last_basename()))

                    if self.app.caretHandling:
                        self.TerminalScreen.tag_add("command", start_pos, end_pos)
                    else:
                        self.TerminalScreen.tag_add("basename", start_pos, end_pos)

                # Normal output - could be command or its output
                # needs start_pos - 1
                elif not isCmd:
                    # start_pos = get_last_line(self.TerminalScreen) - 1
                    end_pos = self.TerminalScreen.index("insert")
                    self.TerminalScreen.tag_add("output", start_pos, end_pos)

            # Gives slightly smoother print out and reduces CPU stress
            # time.sleep(0.0001)




    def main():
        """ Main function """

        rootterm = tk.Tk()
        rootterm.title("Terminal Emulator")
        rootterm.geometry("700x400")

        terminal = Terminal(rootterm)
        terminal.pack(expand=True, fill=BOTH)

        icon = PhotoImage(file=get_absolute_path(__file__, "img/icon.png"))
        rootterm.iconphoto(False, icon)

        ExitDiaglogBox(rootterm, icon)
        rootterm.mainloop()

    if __name__ == "__main__":
        main()

if passfig == 4:
    import random
    import pyperclip
    from tkinter import *
    from tkinter.ttk import *

    def low():
        entrypass.delete(0, END)
        lengthpass = var1.get()
        passwordpass = ""
        
        if custom_check.get() == 1:  # If custom option is selected
            chars = custom_entry.get()  # Get custom characters
        else:
            if varpass.get() == 1:  # if strength selected is low
                chars = "abcdefghijklmnopqrstuvwxyz"
            elif varpass.get() == 0:  # if strength selected is medium
                chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
            elif varpass.get() == 3:  # if strength selected is strong
                chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !@#$%^&*()"
            else:
                print("Please choose an option")

        for i in range(0, lengthpass):
            passwordpass = passwordpass + random.choice(chars)
        return passwordpass


    def save_to_file(passwordpass):
        with open("passwords.txt", "a") as file:
            file.write(passwordpass + "\n")

    def generate():
        password1 = low()
        entrypass.insert(10, password1)
        save_to_file(password1)


    def copy1():
        random_password = entrypass.get()
        pyperclip.copy(random_password)

    def enable_custom_entry():
        custom_entry.config(state=NORMAL if custom_check.get() == 1 else DISABLED)

    passroot = Tk()
    passroot.resizable(False, False)
    varpass = IntVar()
    var1 = IntVar()
    custom_check = IntVar()

    passroot.title("Random Password Generator")
    #image_icon53 = PhotoImage(file = "img/passlogo.png")
    #passroot.iconphoto(False, image_icon53)

    Random_password = Label(passroot, text="Password")
    Random_password.grid(row=0)
    entrypass = Entry(passroot)
    entrypass.grid(row=0, column=1)

    c_label = Label(passroot, text="Length")
    c_label.grid(row=1)

    copy_buttonpass = Button(passroot, text="Copy", command=copy1)
    copy_buttonpass.grid(row=0, column=2)
    generate_buttonpass = Button(passroot, text="Generate", command=generate)
    generate_buttonpass.grid(row=0, column=3)

    radio_low = Radiobutton(passroot, text="Low", variable=varpass, value=1, command=enable_custom_entry)
    radio_low.grid(row=1, column=2, sticky='E')
    radio_middle = Radiobutton(passroot, text="Medium", variable=varpass, value=0, command=enable_custom_entry)
    radio_middle.grid(row=1, column=3, sticky='E')
    radio_strong = Radiobutton(passroot, text="Strong", variable=varpass, value=3, command=enable_custom_entry)
    radio_strong.grid(row=1, column=4, sticky='E')

    custom_entry_label = Label(passroot, text="Custom Characters")
    custom_entry_label.grid(row=2)
    custom_entry = Entry(passroot, state=DISABLED)
    custom_entry.grid(row=2, column=1)

    custom_checkbutton = Checkbutton(passroot, text="Custom", variable=custom_check, command=enable_custom_entry)
    custom_checkbutton.grid(row=2, column=2)

    combopass = Combobox(passroot, textvariable=var1)
    combopass['values'] = (8, 9, 10, 11, 12, 13, 14, 15, 16,
                           17, 18, 19, 20, 21, 22, 23, 24, 25,
                           26, 27, 28, 29, 30, 31, 32, "Length")
    combopass.current(0)
    combopass.bind('<<ComboboxSelected>>')
    combopass.grid(column=1, row=1)

    passroot.mainloop()

if passfig1 == 5:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    import tkinter as tk
    from tkinter import ttk
    import random
    import string
    from PIL import Image, ImageTk
    import tkinter.messagebox
    import json

    class Settings:
        def __init__(self, filename="settings.json"):
            self.filename = filename
            self.defaults = {
                "password_length": 12,
                "include_uppercase": False,
                "include_numbers": False,
                "include_special_chars": False
            }
            self.load_settings()

        def load_settings(self):
            try:
                with open(self.filename, "r") as file:
                    self.settings = json.load(file)
            except FileNotFoundError:
                self.settings = self.defaults

        def save_settings(self):
            with open(self.filename, "w") as file:
                json.dump(self.settings, file)

        def get_setting(self, key):
            return self.settings.get(key, self.defaults.get(key))

        def set_setting(self, key, value):
            self.settings[key] = value

    class PasswordGeneratorApp:
        def __init__(self, rootpassgen):
            self.rootpassgen = rootpassgen
            self.rootpassgen.title("Password Generator")
            self.rootpassgen.geometry("750x620") 
            self.rootpassgen.resizable(False, False) 
            #self.image_icon55 = PhotoImage(file = "img/passlogo.png")
            #self.rootpassgen.iconphoto(False, self.image_icon55)

            self.settings = Settings()
            self.settings.load_settings()
            
            self.settings_button = ttk.Button(self.rootpassgen, text="Settings", command=self.open_settings)
            self.settings_button.pack(anchor="ne", padx=10, pady=10)

            self.main_frame = ttk.Frame(rootpassgen)
            self.main_frame.pack(pady=10)

            self.options_frame = ttk.Frame(self.main_frame)
            self.options_frame.pack(side=tk.LEFT)

            self.length_label = ttk.Label(self.options_frame, text="Password Length:")
            self.length_label.pack(pady=10)

            self.length_var = tk.IntVar(value=12)
            self.length_scale = ttk.Scale(self.options_frame, from_=6, to=50, variable=self.length_var, orient=tk.HORIZONTAL, length=200, command=self.update_length_label)
            self.length_scale.pack()

            self.length_display = ttk.Label(self.options_frame, text="Length: 12")
            self.length_display.pack(pady=10)

            self.uppercase_var = tk.IntVar(value=0)
            self.uppercase_check = ttk.Checkbutton(self.options_frame, text="Include Uppercase Letters", variable=self.uppercase_var)
            self.uppercase_check.pack(pady=5)

            self.numbers_var = tk.IntVar(value=0)
            self.numbers_check = ttk.Checkbutton(self.options_frame, text="Include Numbers", variable=self.numbers_var)
            self.numbers_check.pack(pady=5)

            self.special_chars_var = tk.IntVar(value=0)
            self.special_chars_check = ttk.Checkbutton(self.options_frame, text="Include Special Characters", variable=self.special_chars_var)
            self.special_chars_check.pack(pady=10)

            self.generate_button = ttk.Button(self.options_frame, text="Generate Password", command=self.generate_password)
            self.generate_button.pack(pady=15)

            self.password_frame = ttk.Frame(self.options_frame)
            self.password_frame.pack(pady=10)

            self.password_entry = ttk.Entry(self.password_frame, width=30, font=("Arial", 12), state='readonly')
            self.password_entry.pack(side=tk.LEFT)

            self.copy_button = ttk.Button(self.password_frame, text="Copy", command=self.copy_password)
            self.copy_button.pack(side=tk.LEFT)

            self.complexity_label = ttk.Label(self.options_frame, text="Complexity:")
            self.complexity_label.pack()
            self.complexity_display = ttk.Label(self.options_frame, text="", font=("Arial", 12))
            self.complexity_display.pack()

            self.black_bar = ttk.Separator(self.main_frame, orient=tk.VERTICAL)
            self.black_bar.pack(side=tk.LEFT, fill=tk.Y, padx=20)

            self.history_frame = ttk.Frame(self.main_frame)
            self.history_frame.pack(side=tk.LEFT)

            self.history_label = ttk.Label(self.history_frame, text="Password History:")
            self.history_label.pack()

            self.history_scrollbar = ttk.Scrollbar(self.history_frame)
            self.history_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            self.history_listbox = tk.Listbox(self.history_frame, width=30, yscrollcommand=self.history_scrollbar.set)
            self.history_listbox.pack(pady=5)

            self.history_scrollbar.config(command=self.history_listbox.yview)

            self.copy_history_button = ttk.Button(self.history_frame, text="Copy", command=self.copy_selected_password)
            self.copy_history_button.pack(pady=5)

            self.delete_selected_button = ttk.Button(self.history_frame, text="Delete Selected", command=self.delete_selected_history)
            self.delete_selected_button.pack(pady=5)

            self.delete_full_button = ttk.Button(self.history_frame, text="Delete Full History", command=self.delete_full_history)
            self.delete_full_button.pack(pady=5)

            self.load_password_history()

            self.apply_settings()

        def generate_password(self):
            length = self.length_var.get()
            uppercase = bool(self.uppercase_var.get())
            numbers = bool(self.numbers_var.get())
            special_chars = bool(self.special_chars_var.get())

            selected_characters = [string.ascii_lowercase]

            if uppercase:
                selected_characters.append(string.ascii_uppercase)
            if numbers:
                selected_characters.append(string.digits)
            if special_chars:
                selected_characters.append(string.punctuation)

            random.shuffle(selected_characters)

            password = ''.join(random.choice(chars) for chars in selected_characters for _ in range(length // len(selected_characters)))
            password += ''.join(random.choice(chars) for chars in selected_characters[:length % len(selected_characters)])

            password_list = list(password)
            random.shuffle(password_list)
            password = ''.join(password_list)

            self.password_entry.configure(state='normal')
            self.password_entry.delete(0, tk.END)
            self.password_entry.insert(0, password)
            self.password_entry.configure(state='readonly')

            complexity = self.check_complexity(password)
            self.update_complexity_display(complexity)

            if password not in self.history_listbox.get(0, tk.END):
                self.add_password_to_history(password)

        def check_complexity(self, password):
            complexity = 0

            if any(c in string.ascii_uppercase for c in password):
                complexity += 1
            if any(c in string.digits for c in password):
                complexity += 1
            if any(c in string.punctuation for c in password):
                complexity += 1

            if len(password) >= 14 and complexity >= 3 or len(password) >= 15 and complexity >= 2 or len(password) >= 16 and complexity >= 1 or len(password) >= 20:
                return "Complex"
            elif len(password) >= 10 and complexity >= 3 or len(password) >= 11 and complexity >= 2 or len(password) >= 12 and complexity >= 1 or len(password) >= 15:
                return "Medium"
            else:
                return "Weak"

        def update_complexity_display(self, complexity):
            if complexity == "Complex":
                self.complexity_display.configure(text=complexity, foreground="green")
            elif complexity == "Medium":
                self.complexity_display.configure(text=complexity, foreground="orange")
            else:
                self.complexity_display.configure(text=complexity, foreground="red")

        def update_length_label(self, event=None):
            length = self.length_var.get()
            self.length_display.configure(text=f"Length: {length}")

        def copy_password(self):
            password = self.password_entry.get()
            if password:
                self.rootpassgen.clipboard_clear()
                self.rootpassgen.clipboard_append(password)
                self.rootpassgen.update()
                tkinter.messagebox.showinfo("Password Copied", "Password copied to clipboard!")

        def copy_selected_password(self):
            selected_index = self.history_listbox.curselection()
            if selected_index:
                selected_password = self.history_listbox.get(selected_index)
                self.rootpassgen.clipboard_clear()
                self.rootpassgen.clipboard_append(selected_password)
                self.rootpassgen.update()
                tkinter.messagebox.showinfo("Password Copied", "Password copied to clipboard!")

        def load_password_history(self):
            try:
                with open("password_history.txt", "r") as file:
                    passwords = file.readlines()
                    for password in passwords:
                        password = password.strip()
                        if password not in self.history_listbox.get(0, tk.END):
                            self.add_password_to_history(password)
            except FileNotFoundError:
                pass

        def add_password_to_history(self, password):
            self.history_listbox.insert(tk.END, password)
            self.history_listbox.yview(tk.END)

            with open("password_history.txt", "a") as file:
                file.write(password + "\n")

        def delete_selected_history(self):
            selected_indices = self.history_listbox.curselection()
            if selected_indices:
                for index in reversed(selected_indices):
                    self.history_listbox.delete(index)
                self.save_password_history()

        def delete_full_history(self):
            self.history_listbox.delete(0, tk.END)
            self.save_password_history()

        def save_password_history(self):
            with open("password_history.txt", "w") as file:
                for password in self.history_listbox.get(0, tk.END):
                    file.write(password + "\n")

        def apply_settings(self):
            self.length_var.set(self.settings.get_setting("password_length"))
            self.uppercase_var.set(self.settings.get_setting("include_uppercase"))
            self.numbers_var.set(self.settings.get_setting("include_numbers"))
            self.special_chars_var.set(self.settings.get_setting("include_special_chars"))
            self.update_length_label()

            # New objects for custom characters and enabling/disabling text entry
            self.custom_chars_var = tk.StringVar(value="")
            self.custom_chars_entry = ttk.Entry(self.options_frame, textvariable=self.custom_chars_var)
            self.custom_chars_entry.pack(pady=10)

            self.custom_chars_checkbox_var = tk.BooleanVar(value=False)
            self.custom_chars_checkbox = ttk.Checkbutton(self.options_frame, text="Use Custom Characters", variable=self.custom_chars_checkbox_var, command=self.toggle_custom_characters)
            self.custom_chars_checkbox.pack(pady=5)

        def toggle_custom_characters(self):
            if self.custom_chars_checkbox_var.get():
                self.custom_chars_entry.config(state="normal")
                self.uppercase_check.config(state="disabled")
                self.numbers_check.config(state="disabled")
                self.special_chars_check.config(state="disabled")
            else:
                self.custom_chars_entry.config(state="disabled")
                self.uppercase_check.config(state="normal")
                self.numbers_check.config(state="normal")
                self.special_chars_check.config(state="normal")

        def generate_password(self):
            if self.custom_chars_checkbox_var.get():
                custom_chars = self.custom_chars_var.get()
                password = ''.join(random.choice(custom_chars) for _ in range(self.length_var.get()))
            else:
                length = self.length_var.get()
                uppercase = bool(self.uppercase_var.get())
                numbers = bool(self.numbers_var.get())
                special_chars = bool(self.special_chars_var.get())

                selected_characters = [string.ascii_lowercase]

                if uppercase:
                    selected_characters.append(string.ascii_uppercase)
                if numbers:
                    selected_characters.append(string.digits)
                if special_chars:
                    selected_characters.append(string.punctuation)

                random.shuffle(selected_characters)

                password = ''.join(random.choice(chars) for chars in selected_characters for _ in range(length // len(selected_characters)))
                password += ''.join(random.choice(chars) for chars in selected_characters[:length % len(selected_characters)])

                password_list = list(password)
                random.shuffle(password_list)
                password = ''.join(password_list)

            self.password_entry.configure(state='normal')
            self.password_entry.delete(0, tk.END)
            self.password_entry.insert(0, password)
            self.password_entry.configure(state='readonly')

            complexity = self.check_complexity(password)
            self.update_complexity_display(complexity)

            if password not in self.history_listbox.get(0, tk.END):
                self.add_password_to_history(password)

        # Function to load settings on the main window
        def load_settings(self):
            self.length_var.set(self.settings.get_setting("password_length"))
            self.uppercase_var.set(self.settings.get_setting("include_uppercase"))
            self.numbers_var.set(self.settings.get_setting("include_numbers"))
            self.special_chars_var.set(self.settings.get_setting("include_special_chars"))

            # Reconfigure the main window based on the new settings
            self.update_length_label()

        # Function to save the settings to file and update the main window
        def save_settings_and_update_main_window(self):
            # Update the settings object with the new settings from the settings window
            self.settings.set_setting("password_length", self.password_length_var.get())
            self.settings.set_setting("include_uppercase", self.include_uppercase_var.get())
            self.settings.set_setting("include_numbers", self.include_numbers_var.get())
            self.settings.set_setting("include_special_chars", self.include_special_chars_var.get())

            # Save the settings to file
            self.settings.save_settings()

            # Apply the new settings to the main window
            self.load_settings()

            # Message box to confirm settings have been saved
            tkinter.messagebox.showinfo("Settings Saved", "Your settings have been saved!")
        
        # Function to open the settings window
        def open_settings(self):
            settings_window = tk.Toplevel(self.rootpassgen)
            settings_window.title("Settings")
            settings_window.resizable(False, False)
            #image_icon57 = PhotoImage(file = "img/settingslogo.png")
            #settings_window.iconphoto(False, image_icon57)

            # Set the application icon for the settings window
            #settings_window.iconbitmap("Logo_Tool.ico")

            # Load settings from the main window
            self.load_settings()

            self.password_length_label = ttk.Label(settings_window, text="Default Password Length:")
            self.password_length_label.pack(pady=5)

            self.password_length_var = tk.IntVar(value=self.settings.get_setting("password_length"))

            # Create a frame to contain the slider and its value display
            slider_frame = ttk.Frame(settings_window)
            slider_frame.pack()

            # Create a slider for password length
            self.password_length_slider = ttk.Scale(slider_frame, from_=6, to=50, variable=self.password_length_var, orient=tk.HORIZONTAL, length=120, command=self.update_password_length_slider)
            self.password_length_slider.pack()

            # Display the selected value of the slider
            self.password_length_display = ttk.Label(slider_frame, textvariable=self.password_length_var)
            self.password_length_display.pack()

            self.include_uppercase_var = tk.BooleanVar(value=self.settings.get_setting("include_uppercase"))
            self.include_uppercase_check = ttk.Checkbutton(settings_window, text="Include Uppercase Letters", variable=self.include_uppercase_var)
            self.include_uppercase_check.pack(pady=5)

            self.include_numbers_var = tk.BooleanVar(value=self.settings.get_setting("include_numbers"))
            self.include_numbers_check = ttk.Checkbutton(settings_window, text="Include Numbers", variable=self.include_numbers_var)
            self.include_numbers_check.pack(pady=5)

            self.include_special_chars_var = tk.BooleanVar(value=self.settings.get_setting("include_special_chars"))
            self.include_special_chars_check = ttk.Checkbutton(settings_window, text="Include Special Characters", variable=self.include_special_chars_var)
            self.include_special_chars_check.pack(pady=10)

            self.save_settings_button = ttk.Button(settings_window, text="Save Settings", command=self.save_settings_and_update_main_window)
            self.save_settings_button.pack(pady=10)
            
        def update_password_length_slider(self, value):
        # Round the value to the nearest integer and update the IntVar
            self.password_length_var.set(round(float(value)))

    if __name__ == "__main__":
        rootpassgen = tk.Tk()
        app = PasswordGeneratorApp(rootpassgen)
        rootpassgen.mainloop()

if hardvar == 6:
    """
        SYSIG - System Information Gatherer

        Simple GUI tool to gather system information in your computer
    """

    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    from datetime import datetime

    import time
    import platform
    import socket
    import threading
    import subprocess
    import dearpygui.dearpygui as dpg
    from cpuinfo import get_cpu_info
    import GPUtil
    import psutil
    import humanize


    # Check for AMD support and conditionally import pyadl
    AMD_SUPPORTED = False
    try:
        import pyadl
        _ = pyadl.ADLManager.getInstance().getDevices()
        AMD_SUPPORTED = True
    except ImportError:
        pass
    except Exception as amd_error:
        # Only print the AMD error if no NVIDIA GPUs are detected
        if not GPUtil.getGPUs():
            print(f"Unexpected error while checking for AMD support: {amd_error}")

    # Check for Windows and conditionally import winreg
    if platform.system() == 'Windows':
        import winreg
    else:
        winreg = None

    gci = get_cpu_info()
    WIN_WIDTH = 800
    WIN_HEIGHT = 400

    dpg.create_context()

    gpu_temp_texts = {}  # Store NVIDIA GPU temp text IDs
    amd_gpu_temp_texts = {}  # Store AMD GPU temp text IDs
    gpu_progress_bars = {}  # Store NVIDIA GPU progress bar IDs

    # Get CPU Total Utilization
    def get_cpu_util():
        """Get CPU Total Utilization"""

        while True:
            cpu_val = psutil.cpu_percent(interval=1, percpu=False)
            dpg.set_value(cpu_progress_bar, 1.0 / 100.0 * cpu_val)
            dpg.configure_item(cpu_progress_bar, overlay=f"{cpu_val}%")


    # entry
    with dpg.window(
            label=f"Computer Name: {platform.node()}",
            no_close=True,
            no_resize=True,
            no_move=True,
            width=WIN_WIDTH - 18,
            height=WIN_HEIGHT
    ) as main_window:
        with dpg.collapsing_header(label="Processor"):
            with dpg.group(horizontal=True):
                dpg.add_text(f"{gci['brand_raw']} @", bullet=True)
                dpg.add_text(f"{gci['hz_actual_friendly']}")
            with dpg.group(horizontal=True):
                dpg.add_text("CPU Utilization(Total):", bullet=True)
                threading.Thread(target=get_cpu_util, args=(), daemon=True).start()
                cpu_progress_bar = dpg.add_progress_bar(default_value=0.0, overlay="0.0%", width=200)
            dpg.add_text(f"{gci['count']} Total Core/s", bullet=True)
            dpg.add_text(f"{gci['arch']} Architecture", bullet=True)
            with dpg.tree_node(label="Cache/s"):
                try:
                    l1_i = humanize.naturalsize(gci['l1_instruction_cache_size'], gnu=True)
                    dpg.add_text(f"L1 Instruction Cache Size: {l1_i}")
                except KeyError:
                    dpg.add_text("L1 Instruction Cache Size: Can't determine")

                try:
                    l1_d = humanize.naturalsize(gci['l1_data_cache_size'], gnu=True)
                    dpg.add_text(f"L1 Data Cache Size: {l1_d}")
                except KeyError:
                    dpg.add_text("L1 Data Cache Size: Can't determine")

                try:
                    l2 = humanize.naturalsize(gci['l2_cache_size'], gnu=True)
                    dpg.add_text(f"L2 Cache Size: {l2}")
                except KeyError:
                    dpg.add_text("L2 Cache Size: Can't determine")

                try:
                    l3 = humanize.naturalsize(gci['l3_cache_size'], gnu=True)
                    dpg.add_text(f"L3 Cache Size: {l3}")
                except KeyError:
                    dpg.add_text("L3 Cache Size: Can't determine")

            with dpg.tree_node(label="Flags"):
                with dpg.table(
                    header_row=False,
                    resizable=True,
                    policy=dpg.mvTable_SizingStretchProp,
                    row_background=True,
                    borders_outerV=True,
                    borders_innerV=True,
                    borders_outerH=True,
                    borders_innerH=True,
                    delay_search=True
                ):
                    COL = 11
                    FLAG = 0
                    flags = gci['flags']

                    for _ in range(COL):
                        dpg.add_table_column()

                    # https://github.com/hoffstadt/DearPyGui/discussions/1918#discussioncomment-3960795
                    rows = int(len(flags) / COL) + 1
                    for row in range(rows):
                        with dpg.table_row():
                            for col in range(COL):
                                FLAG = row * COL + col
                                if FLAG >= len(flags):
                                    dpg.add_text("---")
                                else:
                                    dpg.add_text(f"{flags[FLAG]}")

        with dpg.collapsing_header(label="Graphics"):
            gpu_temp_placeholder = dpg.add_group(horizontal=False)
            gpu_list = []

            def handle_nvidia_gpus():
                """handle NVIDIA GPUs"""
                gpus = GPUtil.getGPUs()
                for gpu in gpus:
                    if gpu.id not in gpu_temp_texts:
                        dpg.add_text(
                            f"Graphics Name: {gpu.name}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        with dpg.group(horizontal=True, parent=gpu_temp_placeholder):
                            dpg.add_text("GPU Utilization:", bullet=True)
                            gpu_progress_bar = dpg.add_progress_bar(
                                default_value=0.0,
                                overlay="0.0%",
                                width=200
                            )
                            gpu_progress_bars[gpu.id] = gpu_progress_bar

                        gpu_temp_text_id = dpg.add_text(
                            f"Temperature: {gpu.temperature}°C",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        gpu_temp_texts[gpu.id] = gpu_temp_text_id
                    else:
                        dpg.set_value(
                            gpu_temp_texts[gpu.id],
                            f"Temperature: {gpu.temperature}°C"
                        )

            def handle_amd_gpus():
                """handle AMD GPUs"""
                if not AMD_SUPPORTED:
                    return

                amd_manager = pyadl.ADLManager.getInstance()
                devices = amd_manager.getDevices()
                for device in devices:
                    temperature_data = device.getCurrentTemperature()
                    if temperature_data is not None:
                        if device.adapterName not in amd_gpu_temp_texts:
                            dpg.add_text(
                            f"AMD GPU {device.adapterName}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        amd_gpu_temp_text_id = dpg.add_text(
                            f"Temperature: {temperature_data}°C",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                        amd_gpu_temp_texts[device.adapterName] = amd_gpu_temp_text_id
                    else:
                        dpg.set_value(
                            amd_gpu_temp_texts[device.adapterName],
                            f"Temperature: {temperature_data}°C"
                        )

            def update_gpu_temperature():
                """Get GPU Temperature and Util Updates"""
                while True:
                    try:
                        handle_nvidia_gpus()
                    except ImportError as import_error:
                        dpg.add_text(
                            f"Error importing GPUtil: {import_error}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )
                    except Exception as general_exception:
                        dpg.add_text(
                            f"Error fetching NVIDIA GPU information: {general_exception}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )

                    try:
                        handle_amd_gpus()
                    except Exception as general_exception:
                        dpg.add_text(
                            f"Error fetching AMD GPU temperature: {general_exception}",
                            bullet=True,
                            parent=gpu_temp_placeholder
                        )

                    time.sleep(1)

            # Get GPU Utilization
            def get_gpu_util():
                """Get GPU Utilization"""
                while True:
                    try:
                        gpus = GPUtil.getGPUs()
                        for gpu in gpus:
                            gpu_val = gpu.load * 100
                            dpg.set_value(gpu_progress_bars[gpu.id], 1.0 / 100.0 * gpu_val)
                            dpg.configure_item(gpu_progress_bars[gpu.id], overlay=f"{gpu_val:.2f}%")
                    except (ImportError, Exception) as general_exception:
                        print(f"An error occurred: {general_exception}")
                    time.sleep(1)

        with dpg.collapsing_header(label="Memory"):
            mem = psutil.virtual_memory()
            mem_used = humanize.naturalsize(mem.used)
            mem_percent = mem.percent
            mem_avail = humanize.naturalsize(mem.available)
            mem_total = humanize.naturalsize(mem.total)
            dpg.add_text("MAIN MEMORY", color=(0, 255, 0))
            dpg.add_text(f"Used Memory: {mem_used}({mem_percent}%)", bullet=True)
            dpg.add_text(f"Available Memory: {mem_avail}", bullet=True)
            dpg.add_text(f"Total Memory: {mem_total}", bullet=True)

            swap = psutil.swap_memory()
            swap_used = humanize.naturalsize(swap.used)
            swap_percent = swap.percent
            swap_free = humanize.naturalsize(swap.free)
            swap_total = humanize.naturalsize(swap.total)
            dpg.add_text("SWAP MEMORY", color=(0, 255, 0))
            dpg.add_text(f"Used Swap Memory: {swap_used}({swap_percent}%)", bullet=True)
            dpg.add_text(f"Free Swap Memory: {swap_free}", bullet=True)
            dpg.add_text(f"Total Swap Memory: {swap_total}", bullet=True)

        with dpg.collapsing_header(label="Disk"):
            with dpg.table(
                resizable=True,
                policy=dpg.mvTable_SizingStretchProp,
                borders_outerV=True,
                borders_innerV=True,
                borders_outerH=True,
                borders_innerH=True,
                delay_search=True
            ):
                dpg.add_table_column(label="Device")
                dpg.add_table_column(label="Mount point")
                dpg.add_table_column(label="File System type")
                dpg.add_table_column(label="Used")
                dpg.add_table_column(label="Free")
                dpg.add_table_column(label="Total")

                prts = psutil.disk_partitions()
                for prt in prts:
                    with dpg.table_row():
                        for row in range(8):
                            dpg.add_text(f"{prt.device}", color=(0, 255, 0))
                            dpg.add_text(f"{prt.mountpoint}")
                            dpg.add_text(f"{prt.fstype}")
                            try:
                                usage = psutil.disk_usage(prt.mountpoint)
                            except PermissionError:
                                dpg.add_text("Can't determine")
                                continue
                            dpg.add_text(f"{humanize.naturalsize(usage.used)}({usage.percent}%)")
                            dpg.add_text(f"{humanize.naturalsize(usage.free)}")
                            dpg.add_text(f"{humanize.naturalsize(usage.total)}")

        with dpg.collapsing_header(label="Network"):
            addr_list = psutil.net_if_addrs()
            for name, addresses in addr_list.items():
                with dpg.group(horizontal=True):
                    dpg.add_text("Interface Name: ")
                    dpg.add_text(f"{name}", color=(0, 255, 0))
                for address in addresses:
                    if address.family == socket.AF_INET:
                        dpg.add_text(f"IP Address: {address.address}", bullet=True)
                        dpg.add_text(f"Subnet Mask: {address.netmask}", bullet=True)
                    if address.family == psutil.AF_LINK:
                        dpg.add_text(f"MAC Address: {address.address}", bullet=True)

        with dpg.collapsing_header(label="Operating System"):
            if platform.system() == 'Windows':
                try:
                    BRAND = subprocess.check_output('wmic csproduct get vendor', shell=True)
                    BRAND = BRAND.decode('utf-8').strip().split('\n')[1]
                    MODEL = subprocess.check_output('wmic csproduct get name', shell=True)
                    MODEL = MODEL.decode('utf-8').strip().split('\n')[1]

                    dpg.add_text(f"Brand: {BRAND}", bullet=True)
                    dpg.add_text(f"Model: {MODEL}", bullet=True)
                except subprocess.CalledProcessError:
                    dpg.add_text("Brand: Can't determine", bullet=True)
                    dpg.add_text("Model: Can't determine", bullet=True)

            elif platform.system() == 'Linux':
                try:
                    BRAND = subprocess.check_output('dmidecode -s system-manufacturer', shell=True)
                    BRAND = BRAND.decode('utf-8').strip()
                    MODEL = subprocess.check_output('dmidecode -s system-product-name', shell=True)
                    MODEL = MODEL.decode('utf-8').strip()

                    dpg.add_text(f"Brand: {BRAND}", bullet=True)
                    dpg.add_text(f"Model: {MODEL}", bullet=True)
                except subprocess.CalledProcessError:
                    dpg.add_text("Brand: Can't determine", bullet=True)
                    dpg.add_text("Model: Can't determine", bullet=True)

            uname = platform.uname()
            dpg.add_text(f"System: {uname.system}", bullet=True)
            if uname.system == "Windows":
                if int(uname.version[5:]) > 22000:
                    dpg.add_text("Version: 11", bullet=True)
            dpg.add_text(f"Machine: {uname.machine}", bullet=True)

            timestamp = psutil.boot_time()
            bt = datetime.fromtimestamp(timestamp)
            boot = bt.strftime("%m/%d/%Y %I:%M:%S %p")
            dpg.add_text(f"Last boot timestamp: {boot}", bullet=True)

            if platform.system() == "Windows":
                with dpg.tree_node(label="BIOS"):
                    bios = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\DESCRIPTION\System\BIOS")
                    vendor = winreg.QueryValueEx(bios, "BIOSVendor")
                    version = winreg.QueryValueEx(bios, "BIOSVersion")

                    dpg.add_text(f"Vendor: {vendor[0]}", bullet=True)
                    dpg.add_text(f"Version: {version[0]}", bullet=True)

    threading.Thread(target=update_gpu_temperature, daemon=True).start()
    threading.Thread(target=get_gpu_util, daemon=True).start()

    dpg.create_viewport(
        title="System Information Gatherer",
        #small_icon="res/icon.ico",
        #large_icon="res/icon.ico",
        resizable=False,
        max_width=WIN_WIDTH,
        max_height=WIN_HEIGHT
    )
    dpg.setup_dearpygui()
    dpg.set_primary_window(main_window, True)
    dpg.show_viewport()
    dpg.start_dearpygui()
    dpg.destroy_context()

if screenvar == 7:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    def ScreenRec():
        from datetime import datetime
        class ScreenRecorderApp:
            def __init__(self, master):
                self.master = master
                self.master.title("Screen Recorder")
                #self.image_icon60 = PhotoImage(file = "img/reclogo.png")
                #self.master.iconphoto(False, self.image_icon60)

                self.recording = False

                # Butonul de start înregistrare
                self.record_button = tk.Button(master, text="Start Recording", command=self.toggle_recording, bg="gray40", fg="lime green", bd=7)
                self.record_button.pack(pady=10)

                # Butonul de oprire înregistrare
                self.stop_button = tk.Button(master, text="Stop Recording", command=self.stop_recording, bg="black", fg="red", bd=7, state=tk.DISABLED)
                self.stop_button.pack(pady=5)

                # Butonul de captură de ecran
                self.capture_button = tk.Button(master, text="Capture Screen", command=self.capture_screen, bg="gray40", fg="lime green", bd=7)
                self.capture_button.pack(pady=5)

            def start_recording(self):
                self.recording = True
                self.master.iconify()  # Minimizează fereastra Tkinter
                self.record_button.config(text="Recording...", bg="black", fg="white", state=tk.DISABLED)
                self.stop_button.config(bg="gray40", fg="red", state=tk.NORMAL)
                threading.Thread(target=self.record_screen).start()

            def stop_recording(self):
                self.recording = False
                self.master.deiconify()  # Restaurează fereastra Tkinter
                self.record_button.config(text="Start Recording", bg="gray40", fg="lime green", state=tk.NORMAL)
                self.stop_button.config(bg="black", fg="white", state=tk.DISABLED)

            def toggle_recording(self):
                if self.recording:
                    self.stop_recording()
                else:
                    self.start_recording()

            def record_screen(self):
                # Set up video writer
                width, height = pyautogui.size()
                fourcc = cv2.VideoWriter_fourcc(*'XVID')
                
                # Get current time
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                
                out = cv2.VideoWriter(f'screen_record_{current_time}.avi', fourcc, 20.0, (width, height))

                while self.recording:
                    # Capture screen
                    screenshot = pyautogui.screenshot()
                    frame = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                    out.write(frame)

                # Release video writer
                out.release()

            def capture_screen(self):
                self.master.iconify()  # Minimizează fereastra Tkinter
                
                # Capture screen
                screenshot = pyautogui.screenshot()
                current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                screenshot.save(f'screenshot_{current_time}.png')
                
                self.master.deiconify()  # Restaurează fereastra Tkinter

        scrrec = tk.Tk()
        app = ScreenRecorderApp(scrrec)
        scrrec.resizable(False, False)
        scrrec.config(bg="gray20")
        scrrec.geometry("150x150")
        scrrec.mainloop()

    ScreenRec()

if zipvar == 8:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    def ZIPF():
        import os
        import subprocess
        import tkinter as tk
        from tkinter import filedialog, messagebox, ttk
        import zipfile
        from tkinter import simpledialog



        class Window:
            def __init__(self, master):
                self.file_sel = ""
                master.title("Create/Extract ZIP files")
                master.resizable(False, False)
                #image_icon62 = PhotoImage(file = "img/complogo.png")
                #master.iconphoto(False, image_icon62)
                self.frame1 = ttk.LabelFrame(master, height=100, width=400, text="Actions")
                self.frame1.pack(padx=10, pady=10)
                self.frame2 = ttk.LabelFrame(master, height=100, width=400, text="Information about zip file")
                self.frame2.pack(padx=10, pady=10)
                self.frame3 = ttk.LabelFrame(master, height=100, width=400, text="List of files and folders inside zip file")
                self.frame3.pack(padx=10, pady=10)

                self.button1 = ttk.Button(self.frame1, text="Browse zip file", command=self.button_file)
                self.button1.pack(side=tk.LEFT, padx=10, pady=10)

                self.button2 = ttk.Button(self.frame1, text="Unzip directory", command=self.change_dir)
                self.button2.pack(side=tk.LEFT, padx=10, pady=10)

                self.button3 = ttk.Button(self.frame1, text="Extract All", command=self.button_extract_all)
                self.button3.pack(side=tk.LEFT, padx=10, pady=10)

                self.button4 = ttk.Button(self.frame1, text="Extract Selection", command=self.button_extract_sel)
                self.button4.pack(side=tk.LEFT, padx=10, pady=10)
                
                self.button5 = ttk.Button(self.frame1, text="Create ZIP", command=self.button_create_zip)
                self.button5.pack(side=tk.LEFT, padx=10, pady=10)

                self.label_frame_2 = ttk.Label(self.frame2, text="Select a zip file", width=100)
                self.label_frame_2.pack(padx=10, pady=10)

                self.treeview = ttk.Treeview(self.frame3, show="tree", selectmode="extended")
                self.treeview.pack(padx=10, pady=10)
                self.treeview["column"] = ("one")
                self.treeview.column("one", width=400)
                self.treeview.bind("<<TreeviewSelect>>", self.callback)

                self.label1 = ttk.Label(master)
                self.label1.pack()
                
            def button_create_zip(self):
                dir_path = filedialog.askdirectory()
                if dir_path:
                    zip_file_path = filedialog.asksaveasfilename(defaultextension=".zip", filetypes=[("ZIP files", "*.zip")])
                    if zip_file_path:
                        with zipfile.ZipFile(zip_file_path, 'w') as z:
                            for root, _, files in os.walk(dir_path):
                                for file in files:
                                    file_path = os.path.join(root, file)
                                    rel_path = os.path.relpath(file_path, dir_path)
                                    z.write(file_path, rel_path)
                        messagebox.showinfo("Success", "ZIP archive created successfully.")



            def callback(self, event):
                self.button4.config(state="enabled")
                print(self.treeview.selection())

            def button_file(self):
                self.file_sel = self.find_file("file")
                if self.is_zip(self.file_sel):
                    zip1 = ZipData(self.file_sel)
                    self.update_label(1)
                    self.label_frame_2.config(text="You have selected the zip file " + self.file_sel + "\n" + str(zip1.len_zip()) + " items found in the zip file")
                    self.button3.config(state="enabled")
                    for elt in zip1.info():
                        elt_split = elt.split("/")
                        if "" in elt_split:
                            elt_split.remove("")
                        if len(elt_split) == 1:
                            parent = ""
                        else:
                            parent = "/".join(elt_split[:-1])

                        if not self.treeview.exists(parent):
                            self.treeview.insert("", "end", parent, text=elt_split[0])

                        self.treeview.insert(parent, "end", "/".join(elt_split), text=elt_split[-1])

            def button_extract_all(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_all()
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def button_extract_sel(self):
                if self.file_sel != "":
                    zip1 = ZipData(self.file_sel)
                    zip1.extract_sel(self.treeview.selection())
                    self.clean_window()
                else:
                    messagebox.showerror("Zip file missing", "You need to select a zip file")

            def clean_window(self):
                self.update_label(2)
                self.label_frame_2.config(text="")
                for i in self.treeview.get_children():
                    self.treeview.delete(i)
                subprocess.Popen("explorer " + os.getcwd())

            @staticmethod
            def find_file(f_type):
                f_name = ""
                if f_type == "file":
                    file_name = filedialog.askopenfile()
                    if file_name:
                        f_name = file_name.name
                return f_name

            @staticmethod
            def is_zip(zip_path):
                if zip_path[-4:] != ".zip":
                    messagebox.showerror("Type file error", "You need to select a zip file")
                    return False
                else:
                    return True

            def change_dir(self):
                """ Change the current directory """
                dir_path = filedialog.askdirectory()
                if dir_path:
                    os.chdir(dir_path)
                    self.update_label(1)


            def update_label(self, val):
                if val == 1:
                    self.label1.config(text="The zip file will be extracted in the directory " + self.find_dir())
                if val == 2:
                    self.label1.config(text="Zip file successfully extracted")

            @staticmethod
            def find_dir():
                cwd = os.getcwd()
                return cwd


        class ZipData:
            def __init__(self, file):
                self.file = file

            def extract_all(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    z.extractall()

            def extract_sel(self, file_name):
                with zipfile.ZipFile(self.file, 'r') as z:
                    for f_name in file_name:
                        z.extract(f_name)

            def len_zip(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    nb_items = len(z.namelist())
                    return nb_items

            def info(self):
                with zipfile.ZipFile(self.file, 'r') as z:
                    return z.namelist()


        if __name__ == "__main__":
            ziproot = tk.Tk()
            win = Window(ziproot)
            ziproot.mainloop()

    ZIPF()

if compvar == 9:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    # Importuri standard
    import argparse
    import sys
    import os
    import difflib
    import mimetypes
    import filecmp

    # Importuri pentru interfața grafică
    try:
        from tkinter import *
        from tkinter.filedialog import askopenfilename, askdirectory
        from tkinter.simpledialog import askstring
        from tkinter.messagebox import showerror
        from tkinter import font
        from tkinter import ttk
        from tkinter.ttk import Treeview
    except ImportError:    # Python 2 fallback
        from Tkinter import *
        from tkFileDialog import askopenfilename, askdirectory
        from tkSimpleDialog import askstring
        from tkMessageBox import showerror
        from tkFont import Font
        import ttk
        from ttk import Treeview

    class DiffCode:
        SIMILAR = 0         # starts with '  '
        RIGHTONLY = 1       # starts with '+ '
        LEFTONLY = 2        # starts with '- '
        CHANGED = 3         # either three or four lines with the prefixes ('-', '+', '?'), ('-', '?', '+') or ('-', '?', '+', '?') respectively

    class DifflibParser:
        def __init__(self, text1, text2):
            self.__text1 = text1
            self.__text2 = text2
            self.__diff = list(difflib.ndiff(text1, text2))
            self.__currentLineno = 0

        def __iter__(self):
            return self

        def __next__(self):  # python3
            result = {}
            if self.__currentLineno >= len(self.__diff):
                raise StopIteration
            currentLine = self.__diff[self.__currentLineno]
            code = currentLine[:2]
            line = currentLine[2:]
            result['line'] = line
            if code == '  ':
                result['code'] = DiffCode.SIMILAR
            elif code == '- ':
                incrementalChange = self.__tryGetIncrementalChange(self.__currentLineno)
                if not incrementalChange:
                    result['code'] = DiffCode.LEFTONLY
                else:
                    result['code'] = DiffCode.CHANGED
                    result['leftchanges'] = incrementalChange['left'] if 'left' in incrementalChange else None
                    result['rightchanges'] = incrementalChange['right'] if 'right' in incrementalChange else None
                    result['newline'] = incrementalChange['newline']
                    self.__currentLineno += incrementalChange['skiplines']
            elif code == '+ ':
                result['code'] = DiffCode.RIGHTONLY
            self.__currentLineno += 1
            return result

        next = __next__  # for Python 2
        
        def __tryGetIncrementalChange(self, lineno):
            lineOne = self.__diff[lineno] if lineno < len(self.__diff) else None
            lineTwo = self.__diff[lineno + 1] if lineno + 1 < len(self.__diff) else None
            lineThree = self.__diff[lineno + 2] if lineno + 2 < len(self.__diff) else None
            lineFour = self.__diff[lineno + 3] if lineno + 3 < len(self.__diff) else None

            changes = {}
            # ('-', '?', '+', '?') case
            if lineOne and lineOne[:2] == '- ' and \
               lineTwo and lineTwo[:2] == '? ' and \
               lineThree and lineThree[:2] == '+ ' and \
               lineFour and lineFour[:2] == '? ':
                changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                changes['right'] = [i for (i,c) in enumerate(lineFour[2:]) if c in ['+', '^']]
                changes['newline'] = lineThree[2:]
                changes['skiplines'] = 3
                return changes
            # ('-', '+', '?')
            elif lineOne and lineOne[:2] == '- ' and \
               lineTwo and lineTwo[:2] == '+ ' and \
               lineThree and lineThree[:2] == '? ':
                changes['right'] = [i for (i,c) in enumerate(lineThree[2:]) if c in ['+', '^']]
                changes['left'] = []
                changes['newline'] = lineTwo[2:]
                changes['skiplines'] = 2
                return changes
            # ('-', '?', '+')
            elif lineOne and lineOne[:2] == '- ' and \
               lineTwo and lineTwo[:2] == '? ' and \
               lineThree and lineThree[:2] == '+ ':
                changes['right'] = []
                changes['left'] = [i for (i,c) in enumerate(lineTwo[2:]) if c in ['-', '^']]
                changes['newline'] = lineThree[2:]
                changes['skiplines'] = 2
                return changes
            # no incremental change
            else:
                return None
        
    class SearchTextDialog(Frame):

        def __init__(self, parent, textwidgets, searchButtonCallback):
            Frame.__init__(self, parent)

            self.parent = parent
            self.__searchCallback = searchButtonCallback
            self.__textwidgets = textwidgets
            self.__searchStr = None
            self.initUI()

        def initUI(self):
            self.searchTextFrame = Frame(self.parent)

            self.searchTextEntry = Entry(self)
            self.searchTextEntry.pack(fill=BOTH, expand=True, side=LEFT)

            self.__matchCaseVar = IntVar()
            self.__matchCaseVar.set(0)
            self.searchTextCheckbutton = Checkbutton(self, text='Match case', variable=self.__matchCaseVar, command=lambda *x: self.clearSearch())
            self.searchTextCheckbutton.pack(side=LEFT, padx=10)

            self.searchTextButton = Button(self, text='Find', command=self.nextResult)
            self.searchTextButton.pack(side=LEFT)

            self.searchTextEntry.bind('<Return>', self.nextResult)
            self.searchTextButton.bind('<Return>', self.nextResult)
            self.__curSearchResult = {'term': None, 'indices': ['0.0'] * len(self.__textwidgets)}
            self.__insession = False

        def getSearchTerm(self):
            return self.searchTextEntry.get()

        def focus(self):
            self.searchTextEntry.focus_set()
            self.searchTextEntry.select_range(0, END)
            self.__insession = True

        def nextResult(self, *args):
            if not self.__insession: return

            searchStr = self.searchTextEntry.get()

            if not self.__searchStr or self.__searchStr != searchStr:
                self.__searchStr = searchStr
                self.__curSearchResult = {'term': searchStr, 'indices': ['0.0'] * len(self.__textwidgets)}

            if searchStr in ['', None]: return

            countVar = StringVar()
            for i,t in enumerate(self.__textwidgets):
                if self.__curSearchResult['indices'][i] == -1: continue
                nextIdx = float(self.__curSearchResult['indices'][i]) + 1
                pos = t.search(self.__searchStr, nextIdx, END, nocase=self.__matchCaseVar.get() == 0)
                self.__curSearchResult['indices'][i] = pos if pos else -1

            self.__searchCallback(self.__curSearchResult)

        def clearSearch(self):
            self.__curSearchResult['indices'] = ['0.0'] * len(self.__textwidgets)

        def unfocus(self):
            self.clearSearch()
            self.__insession = False

    class MainWindowUI:

    # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |
    # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |                                     menu bar                                                  |
    # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |               |                                     search bar                                |
    # |               |          search entry                                                 | button|
    # |               +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |   treeview    |                                       |                                       |
    # |               |              text area 1              |               text area 2             |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # |               |                                       |                                       |
    # +-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+
    # |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |

        # Rows
        fileTreeRow = filePathLabelsRow = 0
        searchTextRow = 1
        uniScrollbarRow = lineNumbersRow = textAreasRow = 2
        horizontalScrollbarRow = 3

        # Columns
        fileTreeCol = 0
        fileTreeScrollbarCol = 1
        leftLineNumbersCol = leftFilePathLabelsCol = 2    # should span at least two columns
        leftTextAreaCol = leftHorizontalScrollbarCol = 3
        uniScrollbarCol = 4
        rightLineNumbersCol = rightFilePathLabelsCol = 5  # should span at least two columns
        rightTextAreaCol = rightHorizontalScrollbarCol = 6

        # Colors
        whiteColor = '#ffffff'
        redColor = '#ffc4c4'
        darkredColor = '#ff8282'
        grayColor = '#dddddd'
        lightGrayColor = '#eeeeee'
        greenColor = '#c9fcd6'
        darkgreenColor = '#50c96e'
        yellowColor = '#f0f58c'
        darkYellowColor = '#ffff00'
        purpleLight = '#F5EBFC'

        def __init__(self, window):
            self.main_window = window
            self.main_window.grid_rowconfigure(self.filePathLabelsRow, weight=0)
            self.main_window.grid_rowconfigure(self.searchTextRow, weight=0)
            self.main_window.grid_rowconfigure(self.textAreasRow, weight=1)

            self.main_window.grid_columnconfigure(self.fileTreeCol, weight=0)
            self.main_window.grid_columnconfigure(self.fileTreeScrollbarCol, weight=0)
            self.main_window.grid_columnconfigure(self.leftLineNumbersCol, weight=0)
            self.main_window.grid_columnconfigure(self.leftTextAreaCol, weight=1)
            self.main_window.grid_columnconfigure(self.uniScrollbarCol, weight=0)
            self.main_window.grid_columnconfigure(self.rightLineNumbersCol, weight=0)
            self.main_window.grid_columnconfigure(self.rightTextAreaCol, weight=1)
            self.menubar = Menu(self.main_window)
            self.menus = {}
            self.text_area_font = 'TkFixedFont'

        # Center window and set its size
        def center_window(self):
            sw = self.main_window.winfo_screenwidth()
            sh = self.main_window.winfo_screenheight()

            w = 0.7 * sw
            h = 0.7 * sh

            x = (sw - w)/2
            y = (sh - h)/2
            self.main_window.geometry('%dx%d+%d+%d' % (w, h, x, y))
            self.main_window.minsize(int(0.3 * sw), int(0.3 * sh))

        # Menu bar
        def add_menu(self, menuName, commandList):
            self.menus[menuName] = Menu(self.menubar,tearoff=0)
            for c in commandList:
                if 'separator' in c: self.menus[menuName].add_separator()
                else: self.menus[menuName].add_command(label=c['name'], command=c['command'], accelerator=c['accelerator'] if 'accelerator' in c else '')
            self.menubar.add_cascade(label=menuName, menu=self.menus[menuName])
            self.main_window.config(menu=self.menubar)

        # Labels
        def create_file_path_labels(self):
            self.leftFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
            self.leftFileLabel.grid(row=self.filePathLabelsRow, column=self.leftFilePathLabelsCol, columnspan=2)
            self.rightFileLabel = Label(self.main_window, anchor='center', width=1000, background=self.lightGrayColor)
            self.rightFileLabel.grid(row=self.filePathLabelsRow, column=self.rightFilePathLabelsCol, columnspan=2)

        # Search text entry
        def create_search_text_entry(self, searchButtonCallback):
            self.searchTextDialog = SearchTextDialog(self.main_window, [self.leftFileTextArea, self.rightFileTextArea], searchButtonCallback)
            self.searchTextDialog.grid(row=self.searchTextRow, column=self.leftFilePathLabelsCol, columnspan=5, sticky=EW)

            self.searchTextDialog.grid_remove()

        # File treeview
        def create_file_treeview(self):
            self.fileTreeView = Treeview(self.main_window)
            self.fileTreeYScrollbar = Scrollbar(self.main_window, orient='vertical', command=self.fileTreeView.yview)
            self.fileTreeXScrollbar = Scrollbar(self.main_window, orient='horizontal', command=self.fileTreeView.xview)
            self.fileTreeView.configure(yscroll=self.fileTreeYScrollbar.set, xscroll=self.fileTreeXScrollbar.set)

            self.fileTreeView.grid(row=self.fileTreeRow, column=self.fileTreeCol, sticky=NS, rowspan=3)
            self.fileTreeYScrollbar.grid(row=self.fileTreeRow, column=self.fileTreeScrollbarCol, sticky=NS, rowspan=3)
            self.fileTreeXScrollbar.grid(row=self.horizontalScrollbarRow, column=self.fileTreeCol, sticky=EW)

            self.fileTreeView.tag_configure('red', background=self.redColor)
            self.fileTreeView.tag_configure('green', background=self.greenColor)
            self.fileTreeView.tag_configure('yellow', background=self.yellowColor)
            self.fileTreeView.tag_configure('purpleLight', background=self.purpleLight)

            # hide it until needed
            self.fileTreeView.grid_remove()
            self.fileTreeYScrollbar.grid_remove()
            self.fileTreeXScrollbar.grid_remove()

        # Text areas
        def create_text_areas(self):
            self.leftFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
            self.leftFileTextArea.grid(row=self.textAreasRow, column=self.leftTextAreaCol, sticky=NSEW)
            self.leftFileTextArea.config(font=self.text_area_font)
            self.leftFileTextArea.config(wrap='none')

            self.rightFileTextArea = Text(self.main_window, padx=5, pady=5, width=1, height=1, bg=self.grayColor)
            self.rightFileTextArea.grid(row=self.textAreasRow, column=self.rightTextAreaCol, sticky=NSEW)
            self.rightFileTextArea.config(font=self.text_area_font)
            self.rightFileTextArea.config(wrap='none')

            # configuring highlight tags
            self.leftFileTextArea.tag_configure('red', background=self.redColor)
            self.leftFileTextArea.tag_configure('darkred', background=self.darkredColor)
            self.leftFileTextArea.tag_configure('gray', background=self.grayColor)
            self.leftFileTextArea.tag_configure('search', background=self.darkYellowColor)
            self.rightFileTextArea.tag_configure('green', background=self.greenColor)
            self.rightFileTextArea.tag_configure('darkgreen', background=self.darkgreenColor)
            self.rightFileTextArea.tag_configure('gray', background=self.grayColor)
            self.rightFileTextArea.tag_configure('search', background=self.darkYellowColor)
            self.rightFileTextArea.tag_configure('purpleLight', background=self.purpleLight)

            # disable the text areas
            self.leftFileTextArea.config(state=DISABLED)
            self.rightFileTextArea.config(state=DISABLED)

        # Line numbers
        def create_line_numbers(self):
            self.leftLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
            self.leftLinenumbers.grid(row=self.lineNumbersRow, column=self.leftLineNumbersCol, sticky=NS)
            self.leftLinenumbers.config(font=self.text_area_font)
            self.leftLinenumbers.tag_configure('line', justify='right')

            self.rightLinenumbers = Text(self.main_window, width=3, padx=5, pady=5, height=1, bg=self.lightGrayColor)
            self.rightLinenumbers.grid(row=self.lineNumbersRow, column=self.rightLineNumbersCol, sticky=NS)
            self.rightLinenumbers.config(font=self.text_area_font)
            self.rightLinenumbers.tag_configure('line', justify='right')

            # disable the line numbers
            self.leftLinenumbers.config(state=DISABLED)
            self.rightLinenumbers.config(state=DISABLED)

        # Scroll bars
        def scrollBothY(self, action, position, type=None):
            self.leftFileTextArea.yview_moveto(position)
            self.rightFileTextArea.yview_moveto(position)
            self.leftLinenumbers.yview_moveto(position)
            self.rightLinenumbers.yview_moveto(position)

        def updateScrollY(self, first, last, type=None):
            self.leftFileTextArea.yview_moveto(first)
            self.rightFileTextArea.yview_moveto(first)
            self.leftLinenumbers.yview_moveto(first)
            self.rightLinenumbers.yview_moveto(first)
            self.uniScrollbar.set(first, last)

        def scrollBothX(self, action, position, type=None):
            self.leftFileTextArea.xview_moveto(position)
            self.rightFileTextArea.xview_moveto(position)

        def updateScrollX(self, first, last, type=None):
            self.leftFileTextArea.xview_moveto(first)
            self.rightFileTextArea.xview_moveto(first)
            self.leftHorizontalScrollbar.set(first, last)
            self.rightHorizontalScrollbar.set(first, last)

        def create_scroll_bars(self):
            self.uniScrollbar = Scrollbar(self.main_window)
            self.uniScrollbar.grid(row=self.uniScrollbarRow, column=self.uniScrollbarCol, sticky=NS)
            self.uniScrollbar.config(command=self.scrollBothY)
            self.leftFileTextArea.config(yscrollcommand=self.updateScrollY)
            self.rightFileTextArea.config(yscrollcommand=self.updateScrollY)
            self.leftLinenumbers.config(yscrollcommand=self.updateScrollY)
            self.rightLinenumbers.config(yscrollcommand=self.updateScrollY)

            self.leftHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
            self.leftHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.leftHorizontalScrollbarCol, sticky=EW)
            self.leftHorizontalScrollbar.config(command=self.scrollBothX)
            self.leftFileTextArea.config(xscrollcommand=self.updateScrollX)

            self.rightHorizontalScrollbar = Scrollbar(self.main_window, orient=HORIZONTAL)
            self.rightHorizontalScrollbar.grid(row=self.horizontalScrollbarRow, column=self.rightHorizontalScrollbarCol, sticky=EW)
            self.rightHorizontalScrollbar.config(command=self.scrollBothX)
            self.rightFileTextArea.config(xscrollcommand=self.updateScrollX)

    class MainWindow:
        def start(self, leftpath = None, rightpath = None):
            self.main_window = Tk()
            self.main_window.title('Comparator')
            self.__main_window_ui = MainWindowUI(self.main_window)
            #self.image_icon64 = PhotoImage(file = "img/complogo.png")
            #self.main_window.iconphoto(False, self.image_icon64)

            self.leftFile = ''
            self.rightFile = ''

            self.__main_window_ui.center_window()
            self.__main_window_ui.create_file_path_labels()
            self.__main_window_ui.create_text_areas()
            self.__main_window_ui.create_search_text_entry(self.__findNext)
            self.__main_window_ui.create_line_numbers()
            self.__main_window_ui.create_scroll_bars()
            self.__main_window_ui.create_file_treeview()
            path_to_my_project = os.getcwd()
            self.__main_window_ui.add_menu('File', [
                {'name': 'Compare Files', 'command': self.__browse_files},
                {'name': 'Compare Directories', 'command': self.__browse_directories},
                {'separator'},
                {'name': 'Exit', 'command': self.__exit, 'accelerator': 'Alt+F4'}
                ])
            self.__main_window_ui.add_menu('Edit', [
                {'name': 'Find', 'command': self.__startFindText, 'accelerator': 'Ctrl+F'},
                {'separator'},
                {'name': 'Cut', 'command': self.__cut, 'accelerator': 'Ctrl+X'},
                {'name': 'Copy', 'command': self.__copy, 'accelerator': 'Ctrl+C'},
                {'name': 'Paste', 'command': self.__paste, 'accelerator': 'Ctrl+P'},
                {'separator'},
                {'name': 'Go To Line', 'command': self.__goToLine, 'accelerator': 'Ctrl+G'}
                ])
            self.__main_window_ui.fileTreeView.bind('<<TreeviewSelect>>', lambda *x:self.treeViewItemSelected())

            if (leftpath and os.path.isdir(leftpath)) or (rightpath and os.path.isdir(rightpath)):
                self.__load_directories(leftpath, rightpath)
            else:
                self.leftFile = leftpath if leftpath else ''
                self.rightFile = rightpath if rightpath else ''
                self.filesChanged()

            self.__bind_key_shortcuts()

            self.main_window.mainloop()

        def __bind_key_shortcuts(self):
            self.main_window.bind('<Control-f>', lambda *x: self.__startFindText())
            self.main_window.bind('<Control-g>', lambda *x: self.__goToLine())
            self.main_window.bind('<Escape>', lambda *x: self.__endFindText())
            self.main_window.bind('<F3>', self.__main_window_ui.searchTextDialog.nextResult)

        def __browse_files(self):
            self.__load_file('left')
            self.__load_file('right')
            self.filesChanged()
            self.__main_window_ui.fileTreeView.grid_remove()
            self.__main_window_ui.fileTreeYScrollbar.grid_remove()
            self.__main_window_ui.fileTreeXScrollbar.grid_remove()

        # Load directories into the treeview
        def __browse_directories(self):
            leftDir = self.__load_directory('left')
            rightDir = self.__load_directory('right')
            self.__load_directories(leftDir, rightDir)

        def __load_directories(self, leftDir, rightDir):
            if leftDir and rightDir:
                self.__main_window_ui.fileTreeView.grid()
                self.__main_window_ui.fileTreeYScrollbar.grid()
                self.__main_window_ui.fileTreeXScrollbar.grid()
                self.__main_window_ui.fileTreeView.delete(*self.__main_window_ui.fileTreeView.get_children())
                self.__browse_process_directory('', leftDir, rightDir)

        # Recursive method to fill the treevie with given directory hierarchy
        def __browse_process_directory(self, parent, leftPath, rightPath):
            if parent == '':
                leftPath = leftPath.rstrip('/')
                rightPath = rightPath.rstrip('/')
                leftDirName = os.path.basename(leftPath)
                rightDirName = os.path.basename(rightPath)
                self.__main_window_ui.fileTreeView.heading('#0', text=leftDirName + ' / ' + rightDirName, anchor=W)
            leftListing = os.listdir(leftPath)
            rightListing = os.listdir(rightPath)
            mergedListing = list(set(leftListing) | set(rightListing))
            painted = FALSE
            for l in mergedListing:
                newLeftPath = leftPath + '/' + l
                newRightPath = rightPath + '/' + l
                bindValue = (newLeftPath, newRightPath)
                # Item in left dir only
                if l in leftListing and l not in rightListing:
                    self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('red','simple'))
                    painted = TRUE
                # Item in right dir only
                elif l in rightListing and l not in leftListing:
                    self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('green','simple'))
                    painted = TRUE
                # Item in both dirs
                else:
                    # If one of the diffed items is a file and the other is a directory, show in yellow indicating a difference
                    if (not os.path.isdir(newLeftPath) and os.path.isdir(newRightPath)) or (os.path.isdir(newLeftPath) and not os.path.isdir(newRightPath)):
                        self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                        painted = TRUE
                    else:
                        # If both are directories, show in white and recurse on contents
                        if os.path.isdir(newLeftPath) and os.path.isdir(newRightPath):
                            oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, open=False)
                            painted = self.__browse_process_directory(oid, newLeftPath, newRightPath)
                            if painted:
                                self.__main_window_ui.fileTreeView.item(oid, tags=('purpleLight', 'simple'))
                        else:
                            # Both are files. diff the two files to either show them in white or yellow
                            if (filecmp.cmp(newLeftPath, newRightPath)):
                                oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('simple'))
                            else:
                                oid = self.__main_window_ui.fileTreeView.insert(parent, 'end', text=l, value=bindValue, open=False, tags=('yellow','simple'))
                                painted = TRUE
            return painted

        def __load_file(self, pos):
            fname = askopenfilename()
            if fname:
                if pos == 'left':
                    self.leftFile = fname
                else:
                    self.rightFile = fname
                return fname
            else:
                return None

        def __load_directory(self, pos):
            dirName = askdirectory()
            if dirName:
                if pos == 'left':
                    self.__main_window_ui.leftFileLabel.config(text=dirName)
                else:
                    self.__main_window_ui.rightFileLabel.config(text=dirName)
                return dirName
            else:
                return None

        # Callback for changing a file path
        def filesChanged(self):
            self.__main_window_ui.leftLinenumbers.grid_remove()
            self.__main_window_ui.rightLinenumbers.grid_remove()

            if not self.leftFile or not self.rightFile:
                self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.grayColor)
                self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.grayColor)
                return

            if os.path.exists(self.leftFile):
                self.__main_window_ui.leftFileLabel.config(text=self.leftFile)
                self.__main_window_ui.leftFileTextArea.config(background=self.__main_window_ui.whiteColor)
                self.__main_window_ui.leftLinenumbers.grid()
            else:
                self.__main_window_ui.leftFileLabel.config(text='')

            if os.path.exists(self.rightFile):
                self.__main_window_ui.rightFileLabel.config(text=self.rightFile)
                self.__main_window_ui.rightFileTextArea.config(background=self.__main_window_ui.whiteColor)
                self.__main_window_ui.rightLinenumbers.grid()
            else:
                self.__main_window_ui.rightFileLabel.config(text='')

            self.diff_files_into_text_areas()

        def treeViewItemSelected(self):
            item_id = self.__main_window_ui.fileTreeView.focus()
            paths = self.__main_window_ui.fileTreeView.item(item_id)['values']
            if paths == None or len(paths) == 0:
                return
            self.leftFile = paths[0]
            self.rightFile = paths[1]
            self.filesChanged()

        # Insert file contents into text areas and highlight differences
        def diff_files_into_text_areas(self):
            try:
                leftFileContents = open(self.leftFile).read()
            except:
                leftFileContents = ''
            try:
                rightFileContents = open(self.rightFile).read()
            except:
                rightFileContents = ''

            diff = DifflibParser(leftFileContents.splitlines(), rightFileContents.splitlines())

            # enable text area edits so we can clear and insert into them
            self.__main_window_ui.leftFileTextArea.config(state=NORMAL)
            self.__main_window_ui.rightFileTextArea.config(state=NORMAL)
            self.__main_window_ui.leftLinenumbers.config(state=NORMAL)
            self.__main_window_ui.rightLinenumbers.config(state=NORMAL)

            # clear all text areas
            self.__main_window_ui.leftFileTextArea.delete(1.0, END)
            self.__main_window_ui.rightFileTextArea.delete(1.0, END)
            self.__main_window_ui.leftLinenumbers.delete(1.0, END)
            self.__main_window_ui.rightLinenumbers.delete(1.0, END)

            leftlineno = rightlineno = 1
            for line in diff:
                if line['code'] == DiffCode.SIMILAR:
                    self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n')
                    self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n')
                elif line['code'] == DiffCode.RIGHTONLY:
                    self.__main_window_ui.leftFileTextArea.insert('end', '\n', 'gray')
                    self.__main_window_ui.rightFileTextArea.insert('end', line['line'] + '\n', 'green')
                elif line['code'] == DiffCode.LEFTONLY:
                    self.__main_window_ui.leftFileTextArea.insert('end', line['line'] + '\n', 'red')
                    self.__main_window_ui.rightFileTextArea.insert('end', '\n', 'gray')
                elif line['code'] == DiffCode.CHANGED:
                    for (i,c) in enumerate(line['line']):
                        self.__main_window_ui.leftFileTextArea.insert('end', c, 'darkred' if i in line['leftchanges'] else 'red')
                    for (i,c) in enumerate(line['newline']):
                        self.__main_window_ui.rightFileTextArea.insert('end', c, 'darkgreen' if i in line['rightchanges'] else 'green')
                    self.__main_window_ui.leftFileTextArea.insert('end', '\n')
                    self.__main_window_ui.rightFileTextArea.insert('end', '\n')

                if line['code'] == DiffCode.LEFTONLY:
                    self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                    self.__main_window_ui.rightLinenumbers.insert('end', '\n', 'line')
                    leftlineno += 1
                elif line['code'] == DiffCode.RIGHTONLY:
                    self.__main_window_ui.leftLinenumbers.insert('end', '\n', 'line')
                    self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                    rightlineno += 1
                else:
                    self.__main_window_ui.leftLinenumbers.insert('end', str(leftlineno) + '\n', 'line')
                    self.__main_window_ui.rightLinenumbers.insert('end', str(rightlineno) + '\n', 'line')
                    leftlineno += 1
                    rightlineno += 1

            # calc width of line numbers texts and set it
            self.__main_window_ui.leftLinenumbers.config(width=len(str(leftlineno)))
            self.__main_window_ui.rightLinenumbers.config(width=len(str(rightlineno)))

            # disable text areas to prevent further editing
            self.__main_window_ui.leftFileTextArea.config(state=DISABLED)
            self.__main_window_ui.rightFileTextArea.config(state=DISABLED)
            self.__main_window_ui.leftLinenumbers.config(state=DISABLED)
            self.__main_window_ui.rightLinenumbers.config(state=DISABLED)

        def __cut(self):
            area = self.__getActiveTextArea()
            if area:
                area.event_generate("<<Cut>>")

        def __copy(self):
            area = self.__getActiveTextArea()
            if area:
                area.event_generate("<<Copy>>")

        def __paste(self):
            area = self.__getActiveTextArea()
            if area:
                area.event_generate("<<Paste>>")

        def __getActiveTextArea(self):
            if self.main_window.focus_get() == self.__main_window_ui.leftFileTextArea:
                return self.__main_window_ui.leftFileTextArea
            elif self.main_window.focus_get() == self.__main_window_ui.rightFileTextArea:
                return self.__main_window_ui.rightFileTextArea
            else:
                return None

        def __goToLine(self):
            line = askstring('Go to line', 'Enter line number:')
            if line:
                try:
                    linenumber = int(line)
                    self.__main_window_ui.leftFileTextArea.see(float(linenumber) + 5)
                except:
                    pass

        def __startFindText(self):
            self.__main_window_ui.searchTextDialog.grid()
            self.__main_window_ui.searchTextDialog.focus()

        def __endFindText(self):
            self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
            self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
            self.__main_window_ui.searchTextDialog.unfocus()
            self.__main_window_ui.searchTextDialog.grid_remove()

        def __findNext(self, searchresult):
            term,leftpos,rightpos = searchresult['term'], searchresult['indices'][0], searchresult['indices'][1]
            if leftpos != -1:
                self.__main_window_ui.leftFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.leftFileTextArea.tag_add('search', leftpos, '%s + %sc' % (leftpos, len(term)))
                # scroll to position plus five lines for visibility
                self.__main_window_ui.leftFileTextArea.see(float(leftpos) + 5)
            if rightpos != -1:
                self.__main_window_ui.rightFileTextArea.tag_remove('search', 1.0, END)
                self.__main_window_ui.rightFileTextArea.tag_add('search', rightpos, '%s + %sc' % (rightpos, len(term)))
                # scroll to position plus five lines for visibility
                self.__main_window_ui.rightFileTextArea.see(float(rightpos) + 5)

        def __exit(self):
            self.main_window.destroy()

    class FileIO:
        def load_file_to_text_area(self, fname, textArea):
            textArea.config(state=NORMAL)
            try:
                text = open(fname).read()
                textArea.delete(1.0, END) 
                textArea.insert(1.0, text)
            except Exception as e:
                showerror('Open Source File', 'Failed to read file\n"%s". Error: %s' % (fname, e))
            finally:
                textArea.config(state=DISABLED)

    parser = argparse.ArgumentParser(description="pydiff - Tkinter GUI tool based on Python's difflib")
    parser.add_argument('-p', '--paths', metavar=('path1', 'path2'), nargs=2, help='Two paths to compare', required=False)

    args = parser.parse_args()

    leftpath = args.paths[0] if args.paths else None
    rightpath = args.paths[1] if args.paths else None

    main_window = MainWindow()
    main_window.start(leftpath, rightpath)

if pdfvar == 10:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    gpath = ""

    def openfile():
        tb.delete(0, END)
        global gpath
        filterex = [('PDF File', '*.pdf'), ('All Files', '*.*')]
        userfile = fd.askopenfile(title="Open PDF", filetypes=filterex)
        if userfile:
            tb.insert(0, userfile.name)
            gpath = userfile.name

    def convert_to_word():
        global gpath
        if gpath:
            pdf_document = aw.Document(gpath)
            pdf_document.save("pdf.docx")
            mb.showinfo("Succes", "The file has been converted to Word.")
        else:
            mb.showerror("Error", "No PDF file has been selected.")

    def convert_to_word_and_extract_images():
        global gpath
        if gpath:
            # Converting selected PDF file to Word DOCX format
            pdf_document = aw.Document(gpath)
            pdf_document.save("pdf.docx")

            # Opening the converted DOCX file
            doc = Document("pdf.docx")

            # Retrieving all shapes (images) from the DOCX file
            shapes = doc.get_child_nodes(aw.NodeType.SHAPE, True)
            imageIndex = 0

            # Folder path to save images
            folder_path = "images_from_pdf/"

            # Create the folder if it doesn't exist
            if not os.path.exists(folder_path):
                os.makedirs(folder_path)

            # Looping through the shapes (images)
            for shape in shapes:
                shape = shape.as_shape()
                if shape.has_image:
                    # Setting the image file's name
                    imageFileName = f"{folder_path}Image.ExportImages.{imageIndex}_{aw.FileFormatUtil.image_type_to_extension(shape.image_data.image_type)}"

                    # Saving the image
                    shape.image_data.save(imageFileName)
                    imageIndex += 1

            mb.showinfo("Succes", "The file was converted to Word and the images were extracted.")
        else:
            mb.showerror("Error", "No PDF file has been selected.")

    W = Tk()
    W.title("PDF in Word Converter")
    W.geometry("640x400")
    W.config(bg="gray20")
    W.resizable(FALSE, FALSE)
    #image_icon66 = PhotoImage(file = "img/complogo.png")
    #W.iconphoto(False, image_icon66)
    lb = Label(W, text="Select PDF file", bg="gray40", fg="cyan", bd=1)
    lb.grid(row=1, column=0)
    tb = Entry(W, width=80)
    tb.grid(row=2, column=0)
    tb.focus()

    bt_browse = Button(W, text="Browse", bg="gray40", fg="cyan", width=15, bd=1, command=openfile)
    bt_browse.grid(row=2, column=1, ipady=3)

    bt_convert_to_word = Button(W, text="Convert in Word", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word)
    bt_convert_to_word.grid(row=3, column=0, columnspan=2, pady=5)

    bt_convert_with_images = Button(W, text="Convert in Word and extract images", width=30, bg="gray40", fg="cyan", bd=1, command=convert_to_word_and_extract_images)
    bt_convert_with_images.grid(row=4, column=0, columnspan=2, pady=5)

    W.mainloop()

if replfindvar == 11:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    def ReplAndFind():
        # to create a window
        repl = Tk()
        repl.resizable(False, False)
        repl.title("Find & Replace")
        repl.config(bg="gray20")
        #image_icon68 = PhotoImage(file = "img/complogo.png")
        #repl.iconphoto(False, image_icon68)
        # root window is the parent window
        framrepl = Frame(repl, bg="gray20")

        # Creating Label, Entry Box, Button
        # and packing them adding label to
        # search box
        Label(framrepl, text='Find', bg="gray20", fg="lime green").pack(side=LEFT)

        # adding of single line text box
        edit = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        # positioning of text box
        edit.pack(side=LEFT, fill=BOTH, expand=1)
        # setting focus
        edit.focus_set()

        # adding of search button
        Find = Button(framrepl, text='Find', bg="gray40", fg="cyan", bd=5)
        Find.pack(side=LEFT)

        Label(framrepl, text="Replace With ", bg="gray20", fg="lime green", bd=1).pack(side=LEFT)

        edit2 = Entry(framrepl, bg="#404040", bd=5, fg="white", insertbackground="white")
        edit2.pack(side=LEFT, fill=BOTH, expand=1)
        edit2.focus_set()

        replace = Button(framrepl, text='FindNReplace', bg="gray40", fg="cyan", bd=5)
        replace.pack(side=LEFT)

        refresh = Button(framrepl, text='Refresh', bg="gray40", fg="cyan", bd=5)
        refresh.pack(side=LEFT)

        framrepl.pack(side=TOP)

        # text box in root window
        textrepl = Text(repl, width=120, height=40, bg="#999999")

        # text input area at index 1 in text window
        textrepl.insert('1.0', '''Type your text here''')
        textrepl.pack(side=BOTTOM)


        # function to search string in text
        def find(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()

            if (s):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)

                    if not idx: break
                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))
                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()


        def findNreplace(*args):
            # remove tag 'found' from index 1 to END
            textrepl.tag_remove('found', '1.0', END)

            # returns to widget currently in focus
            s = edit.get()
            r = edit2.get()

            if (s and r):
                idx = '1.0'
                while 1:
                    # searches for desried string from index 1
                    idx = textrepl.search(s, idx, nocase=1,
                                      stopindex=END)
                    print(idx)
                    if not idx: break

                    # last index sum of current index and
                    # length of text
                    lastidx = '% s+% dc' % (idx, len(s))

                    textrepl.delete(idx, lastidx)
                    textrepl.insert(idx, r)

                    lastidx = '% s+% dc' % (idx, len(r))

                    # overwrite 'Found' at idx
                    textrepl.tag_add('found', idx, lastidx)
                    idx = lastidx

                # mark located string as green and bg = ''yellow
                textrepl.tag_config('found', foreground='black', background='#ccff66')
            edit.focus_set()

        def refresh_func():
            textrepl.tag_delete('found')

        # add commands to button
        Find.config(command=find)
        replace.config(command=findNreplace)
        refresh.config(command=refresh_func)
        # binding entry boxes ...
        edit.bind('<Return>',find)
        edit2.bind('<Return>',findNreplace)

        # mainloop function calls the endless
        # loop of the window, so the window will
        # wait for any user interaction till we
        # close it
        repl.mainloop()

    ReplAndFind()

if testvarr == 12:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    from tkinter import *
    from tkinter import ttk
    from tkinter import messagebox
    import sqlite3
    import random

    def Delete_question(questionid, tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DELETE FROM "+tablename+" WHERE questionid="+questionid
        cur.execute(querry)
        sql.commit()
        sql.close()
    def SelectAll_Tables():
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
        data = cur.fetchall()
        sql.commit()
        sql.close()
        return data

    def Create_Quiz_Set(id):
        try:
            sql = sqlite3.connect("quiz.db")
            cur = sql.cursor()
            querry = "CREATE TABLE " + id + "(questionid INTEGER PRIMARY KEY,question TEXT NOT NULL, op1 TEXT, op2 TEXT, op3 TEXT, op4 TEXT, answer TEXT NOT NULL)"
            print(querry)
            cur.execute(querry)
            print("table created")
            cur.close()
            sql.commit()
            sql.close()
            return "Success"
        except sqlite3.OperationalError:

            return "sqlite3.OperationalError"

    def InsertValue(questionname, op1, op2, op3, op4, answer, databasename):
        questionid = random.randrange(1000, 1000000000)
        print(questionid)
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        #querry = "INSERT INTO {}(questionid, question, op1, op2, op3, op4, answer) VALUES({},{},{},{},{},{},{})".format(databasename, questionid,questionname, op1, op2, op3, op4, answer)
        #print("INSERT INTO ?(question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?)",(databasename, questionname, op1, op2, op3, op4, answer))
        cur.execute("INSERT INTO "+databasename+"(questionid, question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?,?)",(questionid,questionname, op1, op2, op3, op4, answer))
        cur.close()
        sql.commit()
        sql.close()
        print("data inserted")

    def GetQuistions(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT * FROM "+tablename)
        datas = cur.fetchall()
        cur.close()
        sql.commit()
        sql.close()
        return datas

    def DeleteTable(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DROP TABLE "+tablename
        cur.execute(querry)
        sql.commit()
        sql.close()
        print("table deleted")


    class main_window:
        def Deleteq(self):
            tablename = self.Quizing_Name.get()
            questionid = self.deletequestion_field.get()
            Delete_question(questionid, tablename)
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.Create_Quiz_Set1()
        def Create_Quiz_Set1(self):
            self.Create_Quiz_Frame.destroy()
            self.CreateQuiz_Frame = Frame(self.Recent_Quiz, height=70, width=1000, bd=2, bg="lightblue")
            self.CreateQuiz_Frame.pack()

            self.Quizing_Name = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="lightblue")
            self.Quizing_Name.place(x=20, y=20)
            self.Quizing_Name.insert(0, self.id)
            self.deletequestion_field = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="white")
            self.deletequestion_field.place(y = 20, x = 250)
            self.deletequestion_field.insert(0, "Enter Question Id")
            self.cancel1 = Button(self.CreateQuiz_Frame, text="Cancel", width=6, font=("arial", 12), bg="red",
                                  fg="white", command=self.Cancel_QuizFrame)
            self.cancel1.place(y=20, x=910)

            self.Refresh = Button(self.CreateQuiz_Frame, text="Delete", width=6, font=("arial", 12), bg="tomato", command=self.Deleteq)
            self.Refresh.place(y=20, x=820)
            self.Add_Quiz = Button(self.CreateQuiz_Frame, text="Add Quiz", width=10, font=("arial", 12), bg="green",
                                   fg="white", command=self.Createquitions)
            self.Add_Quiz.place(y=20, x=710)

            self.CreateQuiz_Frame1 = Frame(self.Recent_Quiz, height=500, width=1000, bg="yellow")
            self.CreateQuiz_Frame1.pack(fill=BOTH)

            self.my_canvas = Canvas(self.CreateQuiz_Frame1, height=530)
            self.my_canvas.pack(side=LEFT, fill=BOTH, expand=1)

            self.my_scrollbar = ttk.Scrollbar(self.CreateQuiz_Frame1, orient=VERTICAL, command=self.my_canvas.yview)
            self.my_scrollbar.pack(side=RIGHT, fill=Y)

            self.my_canvas.configure(yscrollcommand=self.my_scrollbar.set)
            self.my_canvas.bind('<Configure>',
                                lambda e: self.my_canvas.configure(scrollregion=self.my_canvas.bbox("all")))

            self.s_frame = Frame(self.my_canvas)

            self.my_canvas.create_window((0, 0), window=self.s_frame, anchor=NW)

            datas = GetQuistions(self.Quizing_Name.get())
            j = 1
            print(datas)
            for data in datas:
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                questionid = Label(f, text=f"{data[0]}")
                questionid.place(x = 800, y = 0)
                t = data[1].split(":")
                text = ""
                for i in t:
                    text += i + " "
                l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {data[2]}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {data[3]}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {data[4]}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {data[5]}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {data[6]}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                j += 1
        def Create_Quiz_Set(self):
            self.id = self.Quiz_Set_Id.get()
            print(self.id)
            if self.id != "":
                datas = SelectAll_Tables()
                d = []
                for data in datas:
                    d.append(str(data[0]))
                print(d)
                if self.id in d:
                    self.Create_Quiz_Set1()
                else:
                    messagebox.showinfo("Warning", "Question is not exists. If you want to create click Create")


        def Addquition(self):
            quition = self.Type_Quitions_Entry.get()
            quition = quition.split(" ")
            quiz = ""
            for i in quition:
                quiz = quiz + i + ":"

            option1 = self.Options1.get()
            option2 = self.Options2.get()
            option3 = self.Options3.get()
            option4 = self.Options4.get()
            answer = self.Answer_Field.get()
            tablename = self.Quizing_Name.get()

            if quition != "" and option1 != "" and option2 != "" and option3 != "" and option4 != "" and answer != "":
                InsertValue(quiz, option1, option2, option3, option4, answer, tablename)
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                datas = GetQuistions(tablename)
                data = datas[0][0]
                texts = quiz.split(":")
                text = ""
                for t in texts:
                    text += t + " "
                questionid = Label(f, text=f"{data}")
                questionid.place(x=800, y=0)
                l = Label(f, text=f"1 . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {option1}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {option2}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {option3}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {option4}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {answer}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                self.Adquestion_Destroy()
            else:
                messagebox.showwarning("Error", "Please enter all field.")
        def Createquitions(self):
            self.Add_quitions_frame = Frame(self.CreateQuiz_Frame, height=160, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Add_quitions_frame.pack()
            self.Type_Quitions_Label = Label(self.Add_quitions_frame, text="Type Question :", font=("arial", 15), bg="lightgreen")
            self.Type_Quitions_Label.place(x = 10, y = 10)
            self.Type_Quitions_Entry = Entry(self.Add_quitions_frame, font=("arial", 15), width=70)
            self.Type_Quitions_Entry.place(x = 200, y = 10)
            self.Options_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Options :", bg="lightgreen")
            self.Options_Label.place(x = 10, y = 60)
            self.Options1 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options1.place(x = 200, y = 60)
            self.Options2 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options2.place(x=320, y=60)
            self.Options3 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options3.place(x=440, y=60)
            self.Options4 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options4.place(x=560, y=60)
            self.Answer_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Answer :", bg="lightgreen")
            self.Answer_Label.place(x = 10, y = 110)
            self.Answer_Field = Entry(self.Add_quitions_frame, font=("arial", 15))
            self.Answer_Field.place(x = 200, y = 110)

            self.Add_Quitionbtn = Button(self.Add_quitions_frame, text="Add Quiz", width=10, font=("arial", 12), bg="green", fg="white", command=self.Addquition)
            self.Add_Quitionbtn.place(x = 700, y = 110)
            self.Cancel_Quitionbtn = Button(self.Add_quitions_frame, text="Cancel", width=10, font=("arial", 12), bg="red",
                                         fg="white", command=self.Adquestion_Destroy)
            self.Cancel_Quitionbtn.place(x=850, y=110)

        def Adquestion_Destroy(self):
            self.Add_quitions_frame.destroy()
            self.CreateQuiz_Frame.configure(height=70)



        def Cancel_QuizFrame(self):
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz)
            self.Create_Quizbtn.place(x=850, y=13)
        def Cancel_QuizFrame1(self):
            self.Create_Quiz_Frame.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz)
            self.Create_Quizbtn.place(x=850, y=13)
        def Create_Quiz(self):
            self.Recent_Quiz1.destroy()
            self.Create_Quizbtn.destroy()
            self.Create_Quiz_Frame = Frame(self.Recent_Quiz, height=150, width=1000, relief=GROOVE, bd=2)
            self.Create_Quiz_Frame.pack()
            self.Quiz_Id = Label(self.Create_Quiz_Frame, text="Quiz Set Name: ", font=("arial", 15))
            self.Quiz_Id.place(x = 10, y = 10)
            self.Quiz_Set_Id = Entry(self.Create_Quiz_Frame, font=("arial", 15))
            self.Quiz_Set_Id.place(x = 160, y = 10)


            self.Create_Setbtn = Button(self.Create_Quiz_Frame, text="Create", font=("arial", 15), bg="green", fg="white", command=self.Create_Quiz_Set2)
            self.Create_Setbtn.place(x = 800, y = 100)
            self.Cancel_Setbtn = Button(self.Create_Quiz_Frame, text="Cancel", font=("arial", 15), bg="red", fg="white", command=self.Cancel_QuizFrame1)
            self.Cancel_Setbtn.place(x=900, y=100)

        def Create_Quiz_Set2(self):
            if self.Quiz_Set_Id.get() != "":
                Create_Quiz_Set(self.Quiz_Set_Id.get())
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def DeleteQuistion(self):
            data = self.textentry.get()
            if data != "":
                DeleteTable(data)
            else:
                messagebox.showwarning("Error", "Please enter question name")
        def ReRun(self):
            self.Result_Frame.destroy()
            self.CreateMain_Window()

        def Your_Result(self, result, text, q):
            self.Test_Frame.destroy()
            self.Result_Frame = Frame(self.window, height=400, width=800, bd=2, relief=GROOVE)
            self.Result_Frame.pack(pady=50)
            self.Result_Frame.propagate(0)
            self.test_name = Label(self.Result_Frame, text=text, font=("arial", 17))
            self.test_name.pack(pady=10)
            self.result_label = Label(self.Result_Frame, text=f"Your Result : {result}/{q}", font=("arial", 17))
            self.result_label.pack(pady=10)
            percentage = (result/q)*100
            self.percentage_label = Label(self.Result_Frame, text=f"Your Percentage : {percentage}", font=("arial", 17))
            self.percentage_label.pack(pady=10)
            if(percentage <= 59):
                self.percentage_label.configure(fg="red")
            else:
                self.percentage_label.configure(fg="green")
            self.Ok_Button = Button(self.Result_Frame, text="Exit",width=20, font=("arial", 15), command=self.ReRun)
            self.Ok_Button.pack(pady=10)

        def Test_Result(self):
            tablename1 = self.Testname.cget("text")
            tablename2 = tablename1.split(":")
            tablename3 = tablename2[1].split(" ")
            data = GetQuistions(tablename3[1])
            self.Answer_Set = []
            self.Result = 0
            for i in range(1, len(data)+1):
                v = f"answer{i}"
                self.Answer_Set.append(vars(self)[v].get())

            for k in range(0, len(data)):
                print(self.Answer_Set[k],"==",data[k][6])
                if self.Answer_Set[k] == data[k][6]:
                    self.Result += 1
                else:
                    self.Result += 0
            self.Your_Result(self.Result, tablename1, len(data))
        def PlayQuition(self):
            d = self.textentry.get()
            if d != "":
                datas = GetQuistions(d)
                self.Toolbar.destroy()
                self.Recent_Quiz.destroy()
                self.Test_Frame = Frame(self.window, bg="lightpink", height=700)
                self.Test_Frame.pack(fill=BOTH)
                self.min = 0
                self.sec = 0
                def runtime():
                    self.time = f"{self.min}:{self.sec}"
                    self.Testtime.configure(text = f"Time : {self.time}")
                    if(self.sec==60):
                        self.min += 1
                        self.sec = 0
                    else:
                        self.sec += 1

                    self.Testtime.after(1000, runtime)
                self.Testtime = Label(self.Test_Frame, text="Time : ", font=("arial", 20), bg="lightpink")
                self.Testtime.pack()
                self.Testname = Label(self.Test_Frame, text=f"Test Name : {d}", font=("arial", 20), bg="lightpink")
                self.Testname.place(x = 20, y = 0)
                self.Test_Frame1 = Frame(self.Test_Frame, height=600)
                self.Test_Frame1.pack(fill=BOTH)
                self.Test_Canvas = Canvas(self.Test_Frame1, height=600, width=950, bg="white")
                self.Test_Canvas.pack(side=LEFT, expand=1, pady=20)

                self.my_scrollbar2 = ttk.Scrollbar(self.Test_Frame1, orient=VERTICAL, command=self.Test_Canvas.yview)
                self.my_scrollbar2.pack(side=RIGHT, fill=Y)

                self.Test_Canvas.configure(yscrollcommand=self.my_scrollbar2.set)
                self.Test_Canvas.bind('<Configure>',
                                 lambda e: self.Test_Canvas.configure(scrollregion=self.Test_Canvas.bbox("all")))

                self.s_frame2 = Frame(self.Test_Canvas, bg="white")

                self.Test_Canvas.create_window((0, 0), window=self.s_frame2, anchor=NW)

                j = 1

                for data in datas:
                    f = Frame(self.s_frame2, height=200, width=950, relief=GROOVE, bd=5)
                    f.pack(pady=5)
                    f.propagate(0)
                    t = data[1].split(":")
                    text = ""
                    for i in t:
                        text += i + " "

                    l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                    l.place(x=5, y=0)
                    op1 = Label(f, text=f"A. {data[2]}", font=("arial", 15), height=1, width=10)
                    op1.place(x=50, y=60)
                    op2 = Label(f, text=f"B. {data[3]}", font=("arial", 15), height=1, width=10)
                    op2.place(x=250, y=60)
                    op3 = Label(f, text=f"C. {data[4]}", font=("arial", 15), height=1, width=10)
                    op3.place(x=450, y=60)
                    op4 = Label(f, text=f"D. {data[5]}", font=("arial", 15), height=1, width=10)
                    op4.place(x=650, y=60)
                    v = f"answer{j}"
                    label = Label(f, text="Answer : ", font=("arial", 15))
                    label.place(x = 50, y = 120)
                    vars(self)[v] = Entry(f, font=("arial", 15))
                    vars(self)[v].place(x = 150, y = 120)

                    j += 1

                self.Submit_Test = Button(self.s_frame2, text="Submit",width=50, bg="lightgreen", font=("arial", 15), command= self.Test_Result)
                self.Submit_Test.pack(pady=30)


                runtime()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")

        def EditQuition(self):
            string = self.textentry.get()
            if string != "":
                self.Create_Quizbtn.invoke()
                self.Quiz_Set_Id.insert(0,string)
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def ReRecent_Quize(self):
            self.Recent_Quiz1 = Frame(self.Recent_Quiz, height=630, width=1000, relief=GROOVE, bg="lightgreen")
            self.Recent_Quiz1.pack()
            self.Recent_Quiz1.propagate(0)
            self.my_canvas1 = Canvas(self.Recent_Quiz1, height=680, width=950, bg="white")
            self.my_canvas1.pack(side=LEFT, expand=1, pady=50)

            self.my_scrollbar1 = ttk.Scrollbar(self.Recent_Quiz1, orient=VERTICAL, command=self.my_canvas1.yview)
            self.my_scrollbar1.pack(side=RIGHT, fill=Y)

            self.my_canvas1.configure(yscrollcommand=self.my_scrollbar1.set)
            self.my_canvas1.bind('<Configure>',
                                 lambda e: self.my_canvas1.configure(scrollregion=self.my_canvas1.bbox("all")))

            self.s_frame1 = Frame(self.my_canvas1, bg="white")

            self.my_canvas1.create_window((0, 0), window=self.s_frame1, anchor=NW)
            self.Recent_Quiz.pack_propagate(0)
            datas = SelectAll_Tables()
            self.textentry = Entry(self.Recent_Quiz1, font=("arial", 15), width=50)
            self.textentry.place(x = 10, y = 10)
            self.playbtn = Button(self.Recent_Quiz1, text="Test", font=("arial", 11), width=10, bg="lightpink",command = self.PlayQuition)
            self.playbtn.place(x=650, y=10)
            self.editbtn = Button(self.Recent_Quiz1, text="Edit", font=("arial", 11), width=10, bg="lightblue", command= self.EditQuition)
            self.editbtn.place(x = 760, y = 10)
            self.deletebtn = Button(self.Recent_Quiz1, text="Delete", font=("arial", 11), width=10, bg="tomato",
                                    command=self.DeleteQuistion)
            self.deletebtn.place(x=870, y=10)
            for data in datas:
                self.frame = Frame(self.s_frame1, height=50, width=950, bg="lightblue", relief=GROOVE, bd=2)
                self.frame.pack(pady=10)
                self.label = Label(self.frame, bg="lightblue",text=f"{data[0]}", font=("arial", 15))
                self.label.place(x=30, y=10)



        def __init__(self, window):

            self.window = window
            self.CreateMain_Window()
            self.window.mainloop()

        def CreateMain_Window(self):
            self.Toolbar = Frame(self.window, height=70, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Toolbar.pack()
            self.Title = Label(self.Toolbar, text="Quiz Application", font=("arial", 22), bg="lightgreen")
            self.Title.place(x=20, y=13)
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("arial", 15), command=self.Create_Quiz)
            self.Create_Quizbtn.place(x=850, y=13)

            self.Recent_Quiz = Frame(self.window, height=630, width=1000, relief=GROOVE, bd=2, bg="white")
            self.Recent_Quiz.pack()

            self.ReRecent_Quize()


    window = Tk()
    window.geometry("1000x700")
    window.resizable(False, False)
    #image_icon70 = PhotoImage(file = "img/quizlogo.png")
    #window.iconphoto(False, image_icon70)
    main_window(window)

if testvarr2 == 122:
    '''
    # Definirea numele fișierului pentru salvarea cheii
    FILE_NAME = "product_key.txt"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"

    def validate_key(event=None):
        # Funcția pentru validarea cheii
        global xx
        if text_box.get("1.0", "end-1c").strip() == KEY:
            xx = 2
            validate_button.config(state=tk.NORMAL)
            no_key_button.config(state=tk.DISABLED)
            
            # Salvarea cheii în fișier text
            with open(FILE_NAME, "w") as file:
                file.write(KEY)
            try:
                if not os.path.exists("file_paths.txt"):
                    with open("file_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file file_paths.txt: {e}")

            try:
                if not os.path.exists("folder_paths.txt"):
                    with open("folder_paths.txt", "w") as file:
                        file.write("")
            except Exception as e:
                print(f"An error occurred while creating the file folder_paths.txt: {e}")
        else:
            xx = 0
            validate_button.config(state=tk.DISABLED)
            no_key_button.config(state=tk.NORMAL)

    def load_key():
        try:
            # Încărcarea cheii din fișier text
            with open(FILE_NAME, "r") as file:
                key = file.read().strip()
                text_box.delete("1.0", "end")
                text_box.insert("1.0", key)
                validate_key()  # Validarea automată a cheii încărcate
        except FileNotFoundError:
            pass

    def nokey():
        sys.exit()

    def valkey():
        validation.destroy()

    def on_closing():
        #pass
        messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

    # Crearea ferestrei principale pentru validare
    validation = tk.Tk()
    validation.protocol("WM_DELETE_WINDOW", on_closing)
    validation.title("Product key validation")
    validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
    validation.config(bg="gray20")

    # Crearea obiectului Text editabil
    text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
    text_box.config(bd=4)
    text_box.pack(pady=10)
    text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

    # Crearea butonului "I don't have a product key"
    no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
    no_key_button.pack(pady=5)

    # Crearea butonului "Validate key"
    validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
    validate_button.pack(pady=5)

    # Încărcarea cheii la deschiderea programului (dacă există)
    load_key()

    # Rularea buclei principale
    validation.mainloop()
    '''

    from tkinter import *
    from tkinter import ttk
    from tkinter import messagebox
    import sqlite3
    import random

    def Delete_question(questionid, tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DELETE FROM "+tablename+" WHERE questionid="+questionid
        cur.execute(querry)
        sql.commit()
        sql.close()
    def SelectAll_Tables():
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
        data = cur.fetchall()
        sql.commit()
        sql.close()
        return data

    def Create_Quiz_Set(id):
        try:
            sql = sqlite3.connect("quiz.db")
            cur = sql.cursor()
            querry = "CREATE TABLE " + id + "(questionid INTEGER PRIMARY KEY,question TEXT NOT NULL, op1 TEXT, op2 TEXT, op3 TEXT, op4 TEXT, answer TEXT NOT NULL)"
            print(querry)
            cur.execute(querry)
            print("table created")
            cur.close()
            sql.commit()
            sql.close()
            return "Success"
        except sqlite3.OperationalError:

            return "sqlite3.OperationalError"

    def InsertValue(questionname, op1, op2, op3, op4, answer, databasename):
        questionid = random.randrange(1000, 1000000000)
        print(questionid)
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        #querry = "INSERT INTO {}(questionid, question, op1, op2, op3, op4, answer) VALUES({},{},{},{},{},{},{})".format(databasename, questionid,questionname, op1, op2, op3, op4, answer)
        #print("INSERT INTO ?(question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?)",(databasename, questionname, op1, op2, op3, op4, answer))
        cur.execute("INSERT INTO "+databasename+"(questionid, question, op1, op2, op3, op4, answer) VALUES(?,?,?,?,?,?,?)",(questionid,questionname, op1, op2, op3, op4, answer))
        cur.close()
        sql.commit()
        sql.close()
        print("data inserted")

    def GetQuistions(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        cur.execute("SELECT * FROM "+tablename)
        datas = cur.fetchall()
        cur.close()
        sql.commit()
        sql.close()
        return datas

    def DeleteTable(tablename):
        sql = sqlite3.connect("quiz.db")
        cur = sql.cursor()
        querry = "DROP TABLE "+tablename
        cur.execute(querry)
        sql.commit()
        sql.close()
        print("table deleted")


    class main_window:
        def Deleteq(self):
            tablename = self.Quizing_Name.get()
            questionid = self.deletequestion_field.get()
            Delete_question(questionid, tablename)
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.Create_Quiz_Set1()
        def Create_Quiz_Set1(self):
            self.Create_Quiz_Frame.destroy()
            self.CreateQuiz_Frame = Frame(self.Recent_Quiz, height=70, width=1000, bd=2, bg="lightblue")
            self.CreateQuiz_Frame.pack()

            self.Quizing_Name = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="lightblue")
            self.Quizing_Name.place(x=20, y=20)
            self.Quizing_Name.insert(0, self.id)
            self.deletequestion_field = Entry(self.CreateQuiz_Frame, font=("arial", 15), bg="white")
            self.deletequestion_field.place(y = 20, x = 250)
            self.deletequestion_field.insert(0, "Enter Question Id")
            self.cancel1 = Button(self.CreateQuiz_Frame, text="Cancel", width=6, font=("arial", 12), bg="red",
                                  fg="white", command=self.Cancel_QuizFrame)
            self.cancel1.place(y=20, x=910)

            self.Refresh = Button(self.CreateQuiz_Frame, text="Delete", width=6, font=("arial", 12), bg="tomato", command=self.Deleteq)
            self.Refresh.place(y=20, x=820)
            self.Add_Quiz = Button(self.CreateQuiz_Frame, text="Add Quiz", width=10, font=("arial", 12), bg="green",
                                   fg="white", command=self.Createquitions)
            self.Add_Quiz.place(y=20, x=710)

            self.CreateQuiz_Frame1 = Frame(self.Recent_Quiz, height=500, width=1000, bg="yellow")
            self.CreateQuiz_Frame1.pack(fill=BOTH)

            self.my_canvas = Canvas(self.CreateQuiz_Frame1, height=530)
            self.my_canvas.pack(side=LEFT, fill=BOTH, expand=1)

            self.my_scrollbar = ttk.Scrollbar(self.CreateQuiz_Frame1, orient=VERTICAL, command=self.my_canvas.yview)
            self.my_scrollbar.pack(side=RIGHT, fill=Y)

            self.my_canvas.configure(yscrollcommand=self.my_scrollbar.set)
            self.my_canvas.bind('<Configure>',
                                lambda e: self.my_canvas.configure(scrollregion=self.my_canvas.bbox("all")))

            self.s_frame = Frame(self.my_canvas)

            self.my_canvas.create_window((0, 0), window=self.s_frame, anchor=NW)

            datas = GetQuistions(self.Quizing_Name.get())
            j = 1
            print(datas)
            for data in datas:
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                questionid = Label(f, text=f"{data[0]}")
                questionid.place(x = 800, y = 0)
                t = data[1].split(":")
                text = ""
                for i in t:
                    text += i + " "
                l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {data[2]}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {data[3]}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {data[4]}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {data[5]}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {data[6]}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                j += 1
        def Create_Quiz_Set(self):
            self.id = self.Quiz_Set_Id.get()
            print(self.id)
            if self.id != "":
                datas = SelectAll_Tables()
                d = []
                for data in datas:
                    d.append(str(data[0]))
                print(d)
                if self.id in d:
                    self.Create_Quiz_Set1()
                else:
                    messagebox.showinfo("Warning", "Question is not exists. If you want to create click Create")


        def Addquition(self):
            quition = self.Type_Quitions_Entry.get()
            quition = quition.split(" ")
            quiz = ""
            for i in quition:
                quiz = quiz + i + ":"

            option1 = self.Options1.get()
            option2 = self.Options2.get()
            option3 = self.Options3.get()
            option4 = self.Options4.get()
            answer = self.Answer_Field.get()
            tablename = self.Quizing_Name.get()

            if quition != "" and option1 != "" and option2 != "" and option3 != "" and option4 != "" and answer != "":
                InsertValue(quiz, option1, option2, option3, option4, answer, tablename)
                f = Frame(self.s_frame, height=200, width=950, relief=GROOVE, bd=5)
                f.pack(pady=5)
                f.propagate(0)
                datas = GetQuistions(tablename)
                data = datas[0][0]
                texts = quiz.split(":")
                text = ""
                for t in texts:
                    text += t + " "
                questionid = Label(f, text=f"{data}")
                questionid.place(x=800, y=0)
                l = Label(f, text=f"1 . {text}", font=("arial", 15))
                l.place(x=5, y=0)
                op1 = Label(f, text=f"A). {option1}", font=("arial", 15))
                op1.place(x=50, y=60)
                op2 = Label(f, text=f"B). {option2}", font=("arial", 15))
                op2.place(x=250, y=60)
                op3 = Label(f, text=f"C). {option3}", font=("arial", 15))
                op3.place(x=450, y=60)
                op4 = Label(f, text=f"D). {option4}", font=("arial", 15))
                op4.place(x=650, y=60)
                answer = Label(f, text=f"Answer : {answer}", font=("arial", 15), fg="green")
                answer.place(x=50, y=100)
                self.Adquestion_Destroy()
            else:
                messagebox.showwarning("Error", "Please enter all field.")
        def Createquitions(self):
            self.Add_quitions_frame = Frame(self.CreateQuiz_Frame, height=160, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Add_quitions_frame.pack()
            self.Type_Quitions_Label = Label(self.Add_quitions_frame, text="Type Question :", font=("arial", 15), bg="lightgreen")
            self.Type_Quitions_Label.place(x = 10, y = 10)
            self.Type_Quitions_Entry = Entry(self.Add_quitions_frame, font=("arial", 15), width=70)
            self.Type_Quitions_Entry.place(x = 200, y = 10)
            self.Options_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Options :", bg="lightgreen")
            self.Options_Label.place(x = 10, y = 60)
            self.Options1 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options1.place(x = 200, y = 60)
            self.Options2 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options2.place(x=320, y=60)
            self.Options3 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options3.place(x=440, y=60)
            self.Options4 = Entry(self.Add_quitions_frame, font=("arial", 15), width=10)
            self.Options4.place(x=560, y=60)
            self.Answer_Label = Label(self.Add_quitions_frame, font=("arial", 15), text="Answer :", bg="lightgreen")
            self.Answer_Label.place(x = 10, y = 110)
            self.Answer_Field = Entry(self.Add_quitions_frame, font=("arial", 15))
            self.Answer_Field.place(x = 200, y = 110)

            self.Add_Quitionbtn = Button(self.Add_quitions_frame, text="Add Quiz", width=10, font=("arial", 12), bg="green", fg="white", command=self.Addquition, state="disabled")
            self.Add_Quitionbtn.place(x = 700, y = 110)
            self.Cancel_Quitionbtn = Button(self.Add_quitions_frame, text="Cancel", width=10, font=("arial", 12), bg="red",
                                         fg="white", command=self.Adquestion_Destroy)
            self.Cancel_Quitionbtn.place(x=850, y=110)

        def Adquestion_Destroy(self):
            self.Add_quitions_frame.destroy()
            self.CreateQuiz_Frame.configure(height=70)



        def Cancel_QuizFrame(self):
            self.CreateQuiz_Frame.destroy()
            self.CreateQuiz_Frame1.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz, state="disabled")
            self.Create_Quizbtn.place(x=850, y=13)
        def Cancel_QuizFrame1(self):
            self.Create_Quiz_Frame.destroy()
            self.ReRecent_Quize()
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("airla", 15), command=self.Create_Quiz, state="disabled")
            self.Create_Quizbtn.place(x=850, y=13)
        def Create_Quiz(self):
            self.Recent_Quiz1.destroy()
            self.Create_Quizbtn.destroy()
            self.Create_Quiz_Frame = Frame(self.Recent_Quiz, height=150, width=1000, relief=GROOVE, bd=2)
            self.Create_Quiz_Frame.pack()
            self.Quiz_Id = Label(self.Create_Quiz_Frame, text="Quiz Set Name: ", font=("arial", 15))
            self.Quiz_Id.place(x = 10, y = 10)
            self.Quiz_Set_Id = Entry(self.Create_Quiz_Frame, font=("arial", 15))
            self.Quiz_Set_Id.place(x = 160, y = 10)


            self.Create_Setbtn = Button(self.Create_Quiz_Frame, text="Create", font=("arial", 15), bg="green", fg="white", command=self.Create_Quiz_Set2, state="disabled")
            self.Create_Setbtn.place(x = 800, y = 100)
            self.Cancel_Setbtn = Button(self.Create_Quiz_Frame, text="Cancel", font=("arial", 15), bg="red", fg="white", command=self.Cancel_QuizFrame1)
            self.Cancel_Setbtn.place(x=900, y=100)

        def Create_Quiz_Set2(self):
            if self.Quiz_Set_Id.get() != "":
                Create_Quiz_Set(self.Quiz_Set_Id.get())
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def DeleteQuistion(self):
            data = self.textentry.get()
            if data != "":
                DeleteTable(data)
            else:
                messagebox.showwarning("Error", "Please enter question name")
        def ReRun(self):
            self.Result_Frame.destroy()
            self.CreateMain_Window()

        def Your_Result(self, result, text, q):
            self.Test_Frame.destroy()
            self.Result_Frame = Frame(self.window, height=400, width=800, bd=2, relief=GROOVE)
            self.Result_Frame.pack(pady=50)
            self.Result_Frame.propagate(0)
            self.test_name = Label(self.Result_Frame, text=text, font=("arial", 17))
            self.test_name.pack(pady=10)
            self.result_label = Label(self.Result_Frame, text=f"Your Result : {result}/{q}", font=("arial", 17))
            self.result_label.pack(pady=10)
            percentage = (result/q)*100
            self.percentage_label = Label(self.Result_Frame, text=f"Your Percentage : {percentage}", font=("arial", 17))
            self.percentage_label.pack(pady=10)
            if(percentage <= 59):
                self.percentage_label.configure(fg="red")
            else:
                self.percentage_label.configure(fg="green")
            self.Ok_Button = Button(self.Result_Frame, text="Exit",width=20, font=("arial", 15), command=self.ReRun)
            self.Ok_Button.pack(pady=10)

        def Test_Result(self):
            tablename1 = self.Testname.cget("text")
            tablename2 = tablename1.split(":")
            tablename3 = tablename2[1].split(" ")
            data = GetQuistions(tablename3[1])
            self.Answer_Set = []
            self.Result = 0
            for i in range(1, len(data)+1):
                v = f"answer{i}"
                self.Answer_Set.append(vars(self)[v].get())

            for k in range(0, len(data)):
                print(self.Answer_Set[k],"==",data[k][6])
                if self.Answer_Set[k] == data[k][6]:
                    self.Result += 1
                else:
                    self.Result += 0
            self.Your_Result(self.Result, tablename1, len(data))
        def PlayQuition(self):
            d = self.textentry.get()
            if d != "":
                datas = GetQuistions(d)
                self.Toolbar.destroy()
                self.Recent_Quiz.destroy()
                self.Test_Frame = Frame(self.window, bg="lightpink", height=700)
                self.Test_Frame.pack(fill=BOTH)
                self.min = 0
                self.sec = 0
                def runtime():
                    self.time = f"{self.min}:{self.sec}"
                    self.Testtime.configure(text = f"Time : {self.time}")
                    if(self.sec==60):
                        self.min += 1
                        self.sec = 0
                    else:
                        self.sec += 1

                    self.Testtime.after(1000, runtime)
                self.Testtime = Label(self.Test_Frame, text="Time : ", font=("arial", 20), bg="lightpink")
                self.Testtime.pack()
                self.Testname = Label(self.Test_Frame, text=f"Test Name : {d}", font=("arial", 20), bg="lightpink")
                self.Testname.place(x = 20, y = 0)
                self.Test_Frame1 = Frame(self.Test_Frame, height=600)
                self.Test_Frame1.pack(fill=BOTH)
                self.Test_Canvas = Canvas(self.Test_Frame1, height=600, width=950, bg="white")
                self.Test_Canvas.pack(side=LEFT, expand=1, pady=20)

                self.my_scrollbar2 = ttk.Scrollbar(self.Test_Frame1, orient=VERTICAL, command=self.Test_Canvas.yview)
                self.my_scrollbar2.pack(side=RIGHT, fill=Y)

                self.Test_Canvas.configure(yscrollcommand=self.my_scrollbar2.set)
                self.Test_Canvas.bind('<Configure>',
                                 lambda e: self.Test_Canvas.configure(scrollregion=self.Test_Canvas.bbox("all")))

                self.s_frame2 = Frame(self.Test_Canvas, bg="white")

                self.Test_Canvas.create_window((0, 0), window=self.s_frame2, anchor=NW)

                j = 1

                for data in datas:
                    f = Frame(self.s_frame2, height=200, width=950, relief=GROOVE, bd=5)
                    f.pack(pady=5)
                    f.propagate(0)
                    t = data[1].split(":")
                    text = ""
                    for i in t:
                        text += i + " "

                    l = Label(f, text=f"{j} . {text}", font=("arial", 15))
                    l.place(x=5, y=0)
                    op1 = Label(f, text=f"A. {data[2]}", font=("arial", 15), height=1, width=10)
                    op1.place(x=50, y=60)
                    op2 = Label(f, text=f"B. {data[3]}", font=("arial", 15), height=1, width=10)
                    op2.place(x=250, y=60)
                    op3 = Label(f, text=f"C. {data[4]}", font=("arial", 15), height=1, width=10)
                    op3.place(x=450, y=60)
                    op4 = Label(f, text=f"D. {data[5]}", font=("arial", 15), height=1, width=10)
                    op4.place(x=650, y=60)
                    v = f"answer{j}"
                    label = Label(f, text="Answer : ", font=("arial", 15))
                    label.place(x = 50, y = 120)
                    vars(self)[v] = Entry(f, font=("arial", 15))
                    vars(self)[v].place(x = 150, y = 120)

                    j += 1

                self.Submit_Test = Button(self.s_frame2, text="Submit",width=50, bg="lightgreen", font=("arial", 15), command= self.Test_Result)
                self.Submit_Test.pack(pady=30)


                runtime()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")

        def EditQuition(self):
            string = self.textentry.get()
            if string != "":
                self.Create_Quizbtn.invoke()
                self.Quiz_Set_Id.insert(0,string)
                self.Create_Quiz_Set()
            else:
                messagebox.showwarning("Error", "Please enter Question name.")
        def ReRecent_Quize(self):
            self.Recent_Quiz1 = Frame(self.Recent_Quiz, height=630, width=1000, relief=GROOVE, bg="lightgreen")
            self.Recent_Quiz1.pack()
            self.Recent_Quiz1.propagate(0)
            self.my_canvas1 = Canvas(self.Recent_Quiz1, height=680, width=950, bg="white")
            self.my_canvas1.pack(side=LEFT, expand=1, pady=50)

            self.my_scrollbar1 = ttk.Scrollbar(self.Recent_Quiz1, orient=VERTICAL, command=self.my_canvas1.yview)
            self.my_scrollbar1.pack(side=RIGHT, fill=Y)

            self.my_canvas1.configure(yscrollcommand=self.my_scrollbar1.set)
            self.my_canvas1.bind('<Configure>',
                                 lambda e: self.my_canvas1.configure(scrollregion=self.my_canvas1.bbox("all")))

            self.s_frame1 = Frame(self.my_canvas1, bg="white")

            self.my_canvas1.create_window((0, 0), window=self.s_frame1, anchor=NW)
            self.Recent_Quiz.pack_propagate(0)
            datas = SelectAll_Tables()
            self.textentry = Entry(self.Recent_Quiz1, font=("arial", 15), width=50)
            self.textentry.place(x = 10, y = 10)
            self.playbtn = Button(self.Recent_Quiz1, text="Test", font=("arial", 11), width=10, bg="lightpink",command = self.PlayQuition)
            self.playbtn.place(x=650, y=10)
            self.editbtn = Button(self.Recent_Quiz1, text="Edit", font=("arial", 11), width=10, bg="lightblue", command= self.EditQuition, state="disabled")
            self.editbtn.place(x = 760, y = 10)
            self.deletebtn = Button(self.Recent_Quiz1, text="Delete", font=("arial", 11), width=10, bg="tomato",
                                    command=self.DeleteQuistion, state="disabled")
            self.deletebtn.place(x=870, y=10)
            for data in datas:
                self.frame = Frame(self.s_frame1, height=50, width=950, bg="lightblue", relief=GROOVE, bd=2)
                self.frame.pack(pady=10)
                self.label = Label(self.frame, bg="lightblue",text=f"{data[0]}", font=("arial", 15))
                self.label.place(x=30, y=10)



        def __init__(self, window):

            self.window = window
            self.CreateMain_Window()
            self.window.mainloop()

        def CreateMain_Window(self):
            self.Toolbar = Frame(self.window, height=70, width=1000, relief=GROOVE, bd=2, bg="lightgreen")
            self.Toolbar.pack()
            self.Title = Label(self.Toolbar, text="Quiz Application", font=("arial", 22), bg="lightgreen")
            self.Title.place(x=20, y=13)
            self.Create_Quizbtn = Button(self.Toolbar, text="Create Quiz", font=("arial", 15), command=self.Create_Quiz, state="disabled")
            self.Create_Quizbtn.place(x=850, y=13)

            self.Recent_Quiz = Frame(self.window, height=630, width=1000, relief=GROOVE, bd=2, bg="white")
            self.Recent_Quiz.pack()

            self.ReRecent_Quize()


    window = Tk()
    window.geometry("1000x700")
    window.resizable(False, False)
    #image_icon71 = PhotoImage(file = "img/quizlogo.png")
    #window.iconphoto(False, image_icon71)
    main_window(window)

if pdfvwvar == 13:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    '''
    from tkinter import Tk
    import setuptools
    import os
    from tkinter import *
    from PIL import ImageTk
    from tkinter import *
    from PIL import Image, ImageTk
    import io
    import pdfplumber
    import PyPDF2
    #import pytesseract
    from tkinter import *
    from tkinter import filedialog, simpledialog, messagebox
    from PIL import Image



    ROOT_PATH = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
    BACKGROUND_COLOR = '#303030'
    HIGHLIGHT_COLOR = '#558de8'

    class DisplayCanvas(Frame):

        def __init__(self, master, page_height, page_width, **kw):
            Frame.__init__(self, master, **kw)
            self.x = self.y = 0

            self.canvas = Canvas(self, height=page_height, width=page_width, bg='#404040', highlightbackground='#353535')

            self.sbarv = Scrollbar(self, orient=VERTICAL, bg='#404040', highlightbackground='#353535')
            self.sbarh = Scrollbar(self, orient=HORIZONTAL, bg='#404040', highlightbackground='#353535')
            self.sbarv.config(command=self.canvas.yview)
            self.sbarh.config(command=self.canvas.xview)

            self.canvas.config(yscrollcommand=self.sbarv.set)
            self.canvas.config(xscrollcommand=self.sbarh.set)

            self.canvas.grid(row=0, column=0, sticky=N+S+E+W)
            self.sbarv.grid(row=0, column=1, stick=N+S)
            self.sbarh.grid(row=1, column=0, sticky=E+W)

            top = self.winfo_toplevel()
            top.bind('<Left>', self.on_left)
            top.bind('<Right>', self.on_right)
            top.bind('<Up>', self.on_up)
            top.bind('<Down>', self.on_down)

            self.canvas.bind("<ButtonPress-1>", self.on_button_press)
            self.canvas.bind("<B1-Motion>", self.on_move_press)
            self.canvas.bind("<ButtonRelease-1>", self.on_button_release)

            self.rect = None
            self.image = None
            self.image_obj = None
            self.pil_image = None
            self.draw = False

            self.start_x = None
            self.start_y = None

            self.canvas.config(scrollregion=self.canvas.bbox("all"))

        def on_button_press(self, event):
            self.start_x = self.canvas.canvasx(event.x)
            self.start_y = self.canvas.canvasy(event.y)

            if not self.rect and self.draw:
                self.rect = self.canvas.create_rectangle(self.x, self.y, 1, 1, outline='red')

        def on_move_press(self, event):
            cur_x = self.canvas.canvasx(event.x)
            cur_y = self.canvas.canvasy(event.y)

            w, h = self.canvas.winfo_width(), self.canvas.winfo_height()
            if event.x > 0.9*w:
                self.on_right()
            elif event.x < 0.1*w:
                self.on_left()
            if event.y > 0.9*h:
                self.on_down()
            elif event.y < 0.1*h:
                self.on_up()

            if self.draw:
                self.canvas.coords(self.rect, self.start_x, self.start_y, cur_x, cur_y)

        def on_left(self, event=None):
            self.canvas.xview_scroll(-1, 'units')

        def on_right(self, event=None):
            self.canvas.xview_scroll(1, 'units')

        def on_up(self, event=None):
            self.canvas.yview_scroll(-1, 'units')

        def on_down(self, event=None):
            self.canvas.yview_scroll(1, 'units')

        def on_button_release(self, event):
            pass

        def update_image(self, image):
            self.pil_image = image
            self.image = ImageTk.PhotoImage(image)
            if self.image_obj is None:
                self.image_obj = self.canvas.create_image(1, 1, image=self.image, anchor=CENTER)
            else:
                self.canvas.itemconfig(self.image_obj, image=self.image)
            self.sbarv.config(command=self.canvas.yview)
            self.sbarh.config(command=self.canvas.xview)
            self.canvas.config(scrollregion=self.canvas.bbox("all"))
            self.canvas.xview_moveto(0.0)
            self.canvas.yview_moveto(0.0)

        def reset(self):
            self.canvas.delete("all")
            self.image_obj = self.canvas.create_image(1, 1, image=self.image, anchor=CENTER)
            self.sbarv.config(command=self.canvas.yview)
            self.sbarh.config(command=self.canvas.xview)
            self.canvas.config(yscrollcommand=self.sbarv.set)
            self.canvas.config(xscrollcommand=self.sbarh.set)
            self.canvas.config(scrollregion=self.canvas.bbox("all"))
            self.rect = None

        def clear(self):
            self.canvas.delete("all")
            self.image_obj = None

        def get_rect(self):
            w, h = self.pil_image.size
            x0, y0 = self.canvas.coords(self.image_obj)
            minx = x0 - w/2.0
            miny = y0 - h/2.0
            if self.rect:
                rect = self.canvas.coords(self.rect)
                rect = [rect[0] + abs(minx), rect[1] + abs(miny), rect[2] + abs(minx), rect[3] + abs(miny)]
                return rect
            else:
                return None
                
                
    class HelpBox(Frame):

        def __init__(self, master, **kw):
            Frame.__init__(self, master, **kw)
            self.columnconfigure(0, weight=1)
            self.rowconfigure(0, weight=0)
            self.rowconfigure(1, weight=0)
            self.rowconfigure(2, weight=0)

            Label(self, text="Meet PDFViewer!", anchor='nw', width=100,
                  font="OpenSans 22 bold", fg='white', bg=BACKGROUND_COLOR, bd=2).grid(row=0, column=0, padx=20, pady=20)

            Label(self, text="Made by Tudor Marmureanu", anchor='nw', width=100,
                  font="OpenSans 10 bold", fg='white', bg=BACKGROUND_COLOR, bd=2).grid(row=2, column=0, padx=20, pady=20)

            text_frame = Frame(self, height=440, width=550, bg=BACKGROUND_COLOR, bd=2, relief=SUNKEN)
            text_frame.grid(row=1, column=0)

            text_frame.grid_propagate(False)

            text_frame.grid_rowconfigure(0, weight=1)
            text_frame.grid_columnconfigure(0, weight=1)

            text_box = Text(text_frame, borderwidth=3, relief="sunken", bg=BACKGROUND_COLOR,
                            fg='white', font="OpenSans 12", wrap='word')

            with open('help.txt', 'r') as infile:
                texts = infile.read()
            texts = [text + '\n\n\n' for text in texts.split('\n\n\n')]

            text_box.insert('1.0', texts[0])
            texts = texts[1:]

            paths = ['open_filepdf.png', 'open_dirpdf.png', 'clearpdf.png',
                     'searchpdf.png', 'extractpdf.png', 'ocrpdf.png']
            self.images = [ImageTk.PhotoImage(Image.open(os.path.join('widgets', path))) for path in paths]

            for text, image in zip(texts, self.images):
                text_box.image_create(END, image=image)
                text_box.insert(END, ' ' + text)

            self.images.extend([ImageTk.PhotoImage(Image.open(os.path.join('widgets', path)))
                                for path in ['prev_filepdf.png', 'next_filepdf.png']])

            text_box.image_create(END, image=self.images[-2])
            text_box.image_create(END, image=self.images[-1])
            text_box.insert(END, ' ' + texts[-2])

            text_box.insert(END, texts[-1].split('\n\n')[0] + '\n')
            self.images.append(ImageTk.PhotoImage(Image.open(os.path.join('toolbarpdf.png'))))
            text_box.image_create(END, image=self.images[-1])
            text_box.insert(END, '\n\n' + '\n\n'.join(texts[-1].split('\n\n')[1:]))

            text_box.config(state=DISABLED)
            text_box.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)

            scroll_bar = Scrollbar(text_frame, command=text_box.yview, bg=BACKGROUND_COLOR)
            scroll_bar.grid(row=0, column=1, sticky='nsew')

            text_box['yscrollcommand'] = scroll_bar.set
            
    class HoverButton(Button):

        def __init__(self, master, tool_tip=None, image_path=None, keep_pressed=False, **kw):
            Button.__init__(self, master=master, **kw)
            self.defaultBackground = self["background"]
            self.bind("<Enter>", self.on_enter)
            self.bind("<Leave>", self.on_leave)
            if keep_pressed:
                self.bind("<Button-1>", self.on_click)
            if image_path:
                self.image = ImageTk.PhotoImage(Image.open(image_path))
                self.configure(image=self.image)
            if tool_tip:
                ToolTip(self, text=tool_tip)

        def on_click(self, e):
            if self['background'] == self.defaultBackground:
                self['background'] = self['activebackground']
            else:
                self['background'] = self.defaultBackground

        def on_enter(self, e):
            self['background'] = self['activebackground']

        def on_leave(self, e):
            self['background'] = self.defaultBackground
            
    class MenuBox(Frame):

        def __init__(self, master=None, image_path=None, **kw):
            Frame.__init__(self, master, **kw)

            self.menu_button = Menubutton(self, width=50, height=50, bg=BACKGROUND_COLOR, bd=0,
                                          highlightthickness=0, activebackground=HIGHLIGHT_COLOR)

            if image_path:
                self.image = ImageTk.PhotoImage(Image.open(image_path))
                self.menu_button.configure(image=self.image)

            self.menu = Menu(self.menu_button, tearoff=False, bg='#404040',
                             fg='white', bd=2, activebackground=HIGHLIGHT_COLOR)

            self.menu_button.config(menu=self.menu)
            self.menu_button.pack(side=LEFT)

            self.menu_button.bind("<Button-1>", lambda e: self.menu_button.event_generate('<<Invoke>>'))

        def add_item(self, title, func, seperator=False):
            self.menu.add_command(label=title, command=func)
            if seperator:
                self.menu.add_separator()
                
    class PDFViewer(Frame):

        def __init__(self, master=None, **kw):
            Frame.__init__(self, master, **kw)
            self.pdf = None
            self.page = None
            self.paths = list()
            self.pathidx = -1
            self.total_pages = 0
            self.pageidx = 0
            self.scale = 1.0
            self.rotate = 0
            self.save_path = None
            self._init_ui()

        def _init_ui(self):
            ws = self.master.winfo_screenwidth()
            hs = self.master.winfo_screenheight()
            h = hs - 100
            w = int(h / 1.414) + 100
            x = (ws / 2) - (w / 2)
            y = (hs / 2) - (h / 2)
            self.master.geometry('%dx%d+%d+%d' % (w, h, x, y))
            self.master.title("PDFViewer")

            self.master.rowconfigure(0, weight=0)
            self.master.rowconfigure(0, weight=0)

            self.rowconfigure(0, weight=1)
            self.columnconfigure(0, weight=0)
            self.columnconfigure(1, weight=0)

            self.configure(bg=BACKGROUND_COLOR, bd=0)

            tool_frame = Frame(self, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            pdf_frame = Frame(self, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)

            tool_frame.grid(row=0, column=0, sticky='news')
            pdf_frame.grid(row=0, column=1, sticky='news')

            # Tool Frame
            tool_frame.columnconfigure(0, weight=1)
            tool_frame.rowconfigure(0, weight=0)
            tool_frame.rowconfigure(1, weight=1)
            tool_frame.rowconfigure(2, weight=0)
            tool_frame.rowconfigure(3, weight=2)

            options = MenuBox(tool_frame, image_path=os.path.join('optionspdf.png'))
            options.grid(row=0, column=0)

            options.add_item('Open Files...', self._open_file)
            options.add_item('Open Directory...', self._open_dir, seperator=True)
            options.add_item('Next File', self._next_file)
            options.add_item('Previous File', self._prev_file, seperator=True)
            options.add_item('Help...', self._help, seperator=True)
            options.add_item('Exit', self.master.quit)

            tools = Frame(tool_frame, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            tools.grid(row=2, column=0)

            HoverButton(tools, image_path=os.path.join('clearpdf.png'), command=self._clear,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Clear",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('open_filepdf.png'), command=self._open_file,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Open Files",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('open_dirpdf.png'), command=self._open_dir,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Open Directory",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('searchpdf.png'), command=self._search_text,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Search Text",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('extractpdf.png'), command=self._extract_text,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Extract Text", keep_pressed=True,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)
            HoverButton(tools, image_path=os.path.join('ocrpdf.png'), command=self._run_ocr,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Run OCR",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(pady=2)

            file_frame = Frame(tools, width=50, height=50, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            file_frame.pack(pady=2)

            file_frame.columnconfigure(0, weight=1)
            file_frame.columnconfigure(1, weight=1)

            HoverButton(file_frame, image_path=os.path.join('prev_filepdf.png'), command=self._prev_file,
                        width=25, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Previous File",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).grid(row=0, column=0)
            HoverButton(file_frame, image_path=os.path.join('next_filepdf.png'), command=self._next_file,
                        width=25, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Next File",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).grid(row=0, column=1)

            HoverButton(tool_frame, image_path=os.path.join('helppdf.png'), command=self._help,
                        width=50, height=50, bg=BACKGROUND_COLOR, bd=0, tool_tip="Help",
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).grid(row=3, column=0, sticky='s')

            # PDF Frame
            pdf_frame.columnconfigure(0, weight=1)
            pdf_frame.rowconfigure(0, weight=0)
            pdf_frame.rowconfigure(1, weight=0)

            page_tools = Frame(pdf_frame, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            page_tools.grid(row=0, column=0, sticky='news')

            page_tools.rowconfigure(0, weight=1)
            page_tools.columnconfigure(0, weight=1)
            page_tools.columnconfigure(1, weight=0)
            page_tools.columnconfigure(2, weight=2)
            page_tools.columnconfigure(3, weight=0)
            page_tools.columnconfigure(4, weight=1)

            nav_frame = Frame(page_tools, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            nav_frame.grid(row=0, column=1, sticky='ns')

            HoverButton(nav_frame, image_path=os.path.join('firstpdf.png'),
                        command=self._first_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)
            HoverButton(nav_frame, image_path=os.path.join('prevpdf.png'),
                        command=self._prev_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)

            self.page_label = Label(nav_frame, bg=BACKGROUND_COLOR, bd=0, fg='white', font='Arial 8',
                                    text="Page {} of {}".format(self.pageidx, self.total_pages))
            self.page_label.pack(side=LEFT, expand=True)

            HoverButton(nav_frame, image_path=os.path.join('nextpdf.png'),
                        command=self._next_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)
            HoverButton(nav_frame, image_path=os.path.join('lastpdf.png'),
                        command=self._last_page, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=LEFT, expand=True)

            zoom_frame = Frame(page_tools, bg=BACKGROUND_COLOR, bd=0, relief=SUNKEN)
            zoom_frame.grid(row=0, column=3, sticky='ns')

            HoverButton(zoom_frame, image_path=os.path.join('rotatepdf.png'),
                        command=self._rotate, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)
            HoverButton(zoom_frame, image_path=os.path.join('fullscreenpdf.png'),
                        command=self._fit_to_screen, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)

            self.zoom_label = Label(zoom_frame, bg=BACKGROUND_COLOR, bd=0, fg='white', font='Arial 8',
                                    text="Zoom {}%".format(int(self.scale * 100)))
            self.zoom_label.pack(side=RIGHT, expand=True)

            HoverButton(zoom_frame, image_path=os.path.join('zoomoutpdf.png'),
                        command=self._zoom_out, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)
            HoverButton(zoom_frame, image_path=os.path.join('zoominpdf.png'),
                        command=self._zoom_in, bg=BACKGROUND_COLOR, bd=0,
                        highlightthickness=0, activebackground=HIGHLIGHT_COLOR).pack(side=RIGHT, expand=True)

            canvas_frame = Frame(pdf_frame, bg=BACKGROUND_COLOR, bd=1, relief=SUNKEN)
            canvas_frame.grid(row=1, column=0, sticky='news')

            self.canvas = DisplayCanvas(canvas_frame, page_height=h-42, page_width=w-70)
            self.canvas.pack()

            self.grid(row=0, column=0, sticky='news')

            self.master.minsize(height=h, width=w)
            self.master.maxsize(height=h, width=w)

        def _reject(self):
            if self.pdf is None:
                return
            self.pathidx = min(self.pathidx + 1, len(self.paths))
            if self.pathidx == len(self.paths):
                self._reset()
                return
            self._load_file()

        def _reset(self):
            self.canvas.clear()
            self.pdf = None
            self.page = None
            self.paths = list()
            self.pathidx = -1
            self.total_pages = 0
            self.pageidx = 0
            self.scale = 1.0
            self.rotate = 0
            self.page_label.configure(text="Page {} of {}".format(self.pageidx, self.total_pages))
            self.zoom_label.configure(text="Zoom {}%".format(int(self.scale * 100)))
            self.master.title("PDFViewer")

        def _clear(self):
            if self.pdf is None:
                return
            self.canvas.reset()
            self._update_page()

        def _zoom_in(self):
            if self.pdf is None:
                return
            if self.scale == 2.5:
                return
            self.scale += 0.1
            self._update_page()

        def _zoom_out(self):
            if self.pdf is None:
                return
            if self.scale == 0.1:
                return
            self.scale -= 0.1
            self._update_page()

        def _fit_to_screen(self):
            if self.pdf is None:
                return
            if self.scale == 1.0:
                return
            self.scale = 1.0
            self._update_page()

        def _rotate(self):
            if self.pdf is None:
                return
            self.rotate = (self.rotate - 90) % 360
            self._update_page()

        def _next_page(self):
            if self.pdf is None:
                return
            if self.pageidx == self.total_pages:
                return
            self.pageidx += 1
            self._update_page()

        def _prev_page(self):
            if self.pdf is None:
                return
            if self.pageidx == 1:
                return
            self.pageidx -= 1
            self._update_page()

        def _last_page(self):
            if self.pdf is None:
                return
            if self.pageidx == self.total_pages:
                return
            self.pageidx = self.total_pages
            self._update_page()

        def _first_page(self):
            if self.pdf is None:
                return
            if self.pageidx == 1:
                return
            self.pageidx = 1
            self._update_page()

        def _next_file(self):
            if self.pdf is None:
                return
            if self.pathidx == len(self.paths) - 1:
                messagebox.showwarning("Warning", "Reached the end of list")
                return
            self.pathidx += 1
            self._load_file()

        def _prev_file(self):
            if self.pdf is None:
                return
            if self.pathidx == 0:
                messagebox.showwarning("Warning", "Reached the end of list")
                return
            self.pathidx -= 1
            self._load_file()

        def _update_page(self):
            page = self.pdf.pages[self.pageidx - 1]
            self.page = page.to_image(resolution=int(self.scale * 80))
            image = self.page.original.rotate(self.rotate)
            self.canvas.update_image(image)
            self.page_label.configure(text="Page {} of {}".format(self.pageidx, self.total_pages))
            self.zoom_label.configure(text="Zoom {}%".format(int(self.scale * 100)))

        def _search_text(self):
            if self.pdf is None:
                return
            text = simpledialog.askstring('Search Text', 'Enter text to search:')
            if text == '' or text is None:
                return
            page = self.pdf.pages[self.pageidx - 1]
            image = page.to_image(resolution=int(self.scale * 80))
            words = [w for w in page.extract_words() if text.lower() in w['text'].lower()]
            image.draw_rects(words)
            image = image.annotated.rotate(self.rotate)
            self.canvas.update_image(image)

        def _extract_text(self):
            if self.pdf is None:
                return
            if not self.canvas.draw:
                self.canvas.draw = True
                self.canvas.configure(cursor='cross')
                return
            self.canvas.draw = False
            self.canvas.configure(cursor='')
            rect = self.canvas.get_rect()
            if rect is None:
                return
            self._clear()
            rect = self._reproject_bbox(rect)
            page = self.pdf.pages[self.pageidx - 1]
            words = page.extract_words()
            min_x = 1000000
            r = None
            for word in words:
                diff = abs(float(word['x0'] - rect[0])) + abs(float(word['top'] - rect[1])) \
                       + abs(float(word['x1'] - rect[2])) + abs(float(word['bottom'] - rect[3]))
                if diff < min_x:
                    min_x = diff
                    r = word
            image = page.to_image(resolution=int(self.scale * 80))
            image.draw_rect(r)
            image = image.annotated.rotate(self.rotate)
            self.canvas.update_image(image)
            simpledialog.askstring("Extract Text", "Text Extracted:", initialvalue=r['text'])

        def _reproject_bbox(self, bbox):
            bbox = [self.page.decimalize(x) for x in bbox]
            x0, y0, x1, y1 = bbox
            px0, py0 = self.page.page.bbox[:2]
            rx0, ry0 = self.page.root.bbox[:2]
            _x0 = (x0 / self.page.scale) - rx0 + px0
            _y0 = (y0 / self.page.scale) - ry0 + py0
            _x1 = (x1 / self.page.scale) - rx0 + px0
            _y1 = (y1 / self.page.scale) - ry0 + py0
            return [_x0, _y0, _x1, _y1]

        def _run_ocr(self):
            if self.pdf is None:
                return
            pdf_pages = list()
            for page in self.pdf.pages:
                image = page.to_image(resolution=100)
                pdf = pytesseract.image_to_pdf_or_hocr(image.original, extension='pdf')
                pdf_pages.append(pdf)

            pdf_writer = PyPDF2.PdfFileWriter()
            for page in pdf_pages:
                pdf = PyPDF2.PdfFileReader(io.BytesIO(page))
                pdf_writer.addPage(pdf.getPage(0))

            dirname = os.path.dirname(self.paths[self.pathidx])
            filename = os.path.basename(self.paths[self.pathidx])

            path = filedialog.asksaveasfilename(title='Save OCR As', defaultextension='.pdf',
                                                initialdir=dirname, initialfile=filename,
                                                filetypes=[('PDF files', '*.pdf'), ('all files', '.*')])
            if path == '' or path is None:
                return

            with open(path, 'wb') as out:
                pdf_writer.write(out)

            self.paths[self.pathidx] = path
            self._load_file()

        @staticmethod
        def _image_to_pdf(path):
            image = Image.open(path)
            pdf = pytesseract.image_to_pdf_or_hocr(image, extension='pdf')

            filename = '.'.join(os.path.basename(path).split('.')[:-1]) + '.pdf'
            dirname = os.path.dirname(path)

            path = filedialog.asksaveasfilename(title='Save Converted PDF As', defaultextension='.pdf',
                                                initialdir=dirname, initialfile=filename,
                                                filetypes=[('PDF files', '*.pdf'), ('all files', '.*')])
            if path == '' or path is None:
                return
            with open(path, 'wb') as out:
                out.write(pdf)
            return path

        def _load_file(self):
            self._clear()
            path = self.paths[self.pathidx]
            filename = os.path.basename(path)
            if filename.split('.')[-1].lower() in ['jpg', 'png']:
                path = self._image_to_pdf(path)
            try:
                self.pdf = pdfplumber.open(path)
                self.total_pages = len(self.pdf.pages)
                self.pageidx = 1
                self.scale = 1.0
                self.rotate = 0
                self._update_page()
                self.master.title("PDFViewer : {}".format(path))
            except (IndexError, IOError, TypeError):
                self._reject()

        def _open_file(self):
            paths = filedialog.askopenfilenames(filetypes=[('PDF files', '*.pdf'),
                                                           ('JPG files', '*.jpg'),
                                                           ('PNG files', '*.png'),
                                                           ('all files', '.*')],
                                                initialdir=os.getcwd(),
                                                title="Select files", multiple=True)
            if not paths or paths == '':
                return
            paths = [path for path in paths if os.path.basename(path).split('.')[-1].lower() in ['pdf', 'jpg', 'png']]
            self.paths = self.paths[:self.pathidx + 1] + list(paths) + self.paths[self.pathidx + 1:]
            self.total_pages = len(self.paths)
            self.pathidx += 1
            self._load_file()

        def _open_dir(self):
            dir_name = filedialog.askdirectory(initialdir=os.getcwd(), title="Select Directory Containing Invoices")
            if not dir_name or dir_name == '':
                return
            paths = os.listdir(dir_name)
            paths = [os.path.join(dir_name, path) for path in paths
                     if os.path.basename(path).split('.')[-1].lower() in ['pdf', 'jpg', 'png']]
            self.paths.extend(paths)
            if not self.paths:
                return
            self.total_pages = len(self.paths)
            self.pathidx += 1
            self._load_file()

        def _help(self):
            ws = self.master.winfo_screenwidth()
            hs = self.master.winfo_screenheight()
            w, h = 600, 600
            x = (ws / 2) - (w / 2)
            y = (hs / 2) - (h / 2)
            help_frame = Toplevel(self)
            help_frame.title("Help")
            help_frame.configure(width=w, height=h, bg=BACKGROUND_COLOR, relief=SUNKEN)
            help_frame.geometry('%dx%d+%d+%d' % (w, h, x, y))
            help_frame.minsize(height=h, width=w)
            help_frame.maxsize(height=h, width=w)
            help_frame.rowconfigure(0, weight=1)
            help_frame.columnconfigure(0, weight=1)
            HelpBox(help_frame, width=w, height=h, bg=BACKGROUND_COLOR, relief=SUNKEN).grid(row=0, column=0)
            
    class ToolTip(object):

        def __init__(self, widget, text):
            self.waittime = 500
            self.wraplength = 180
            self.widget = widget
            self.text = text
            self.widget.bind("<Enter>", self.enter)
            self.widget.bind("<Leave>", self.leave)
            self.widget.bind("<ButtonPress>", self.leave)
            self.idx = None
            self.tw = None

        def enter(self, event=None):
            self.schedule()

        def leave(self, event=None):
            self.unschedule()
            self.hidetip()

        def schedule(self):
            self.unschedule()
            self.idx = self.widget.after(self.waittime, self.showtip)

        def unschedule(self):
            idx = self.idx
            self.idx = None
            if idx:
                self.widget.after_cancel(idx)

        def showtip(self, event=None):
            x, y, cx, cy = self.widget.bbox("insert")
            x += self.widget.winfo_rootx() + 25
            y += self.widget.winfo_rooty() + 20
            self.tw = Toplevel(self.widget)
            self.tw.wm_overrideredirect(True)
            self.tw.wm_geometry("+%d+%d" % (x, y))
            label = Label(self.tw, text=self.text, justify='left',
                          background="#ffffff", relief='solid', borderwidth=1,
                          wraplength=self.wraplength)
            label.pack(ipadx=1)

        def hidetip(self):
            tw = self.tw
            self.tw = None
            if tw:
                tw.destroy()

    rootpdf = Tk()
    PDFViewer()
    rootpdf.mainloop()
    '''
    import tkinter as tk
    from tkinter import filedialog, messagebox
    import os
    import pikepdf
    from PIL import Image
    import fitz

    def get_file_path():
        file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
        return file_path

    def encrypt_decrypt():
        def process_pdf(action):
            password = password_entry.get()
            input_file = get_file_path()

            if action == "Encrypt":
                output_file = "encrypted_" + os.path.basename(input_file)
                encryption = pikepdf.Encryption(owner=password, user=password, R=4)
            else:  # Decrypt
                output_file = "decrypted_" + os.path.basename(input_file)
                try:
                    pdf = pikepdf.open(input_file, password=password)
                    pdf.save(output_file)
                    pdf.close()
                except pikepdf._qpdf.PasswordError:
                    messagebox.showerror("Error", "Invalid password for decryption.")
                    return

            with pikepdf.Pdf.open(input_file) as pdf:
                pdf.save(output_file, encryption=encryption)

            messagebox.showinfo("Success", f"PDF {action}ed successfully!")

        encrypt_decrypt_window = tk.Toplevel()
        encrypt_decrypt_window.title("Encrypt or Decrypt PDF")
        encrypt_decrypt_window.geometry("400x200")
        encrypt_decrypt_window.resizable(False, False)
        encrypt_decrypt_window.config(bg="gray20")
        #image_icon72 = PhotoImage(file = "img/securelogo.png")
        #encrypt_decrypt_window.iconphoto(False, image_icon72)

        label = tk.Label(encrypt_decrypt_window, text="Enter password:", bg="gray20", fg="cyan")
        label.pack()

        password_entry = tk.Entry(encrypt_decrypt_window, show="*")
        password_entry.pack()

        encrypt_button = tk.Button(encrypt_decrypt_window, text="Encrypt", command=lambda: process_pdf("Encrypt"), bg="gray40", fg="cyan")
        encrypt_button.pack()

        decrypt_button = tk.Button(encrypt_decrypt_window, text="Decrypt", command=lambda: process_pdf("Decrypt"), bg="gray40", fg="cyan")
        decrypt_button.pack()

    def rotate_pages():
        def process_rotation():
            degrees = int(degrees_entry.get())
            input_file = get_file_path()
            output_file = "rotated_" + os.path.basename(input_file)

            with pikepdf.Pdf.open(input_file) as pdf:
                for page in pdf.pages:
                    page.Rotate = degrees
                pdf.save(output_file)

            messagebox.showinfo("Success", "PDF rotated successfully!")

        rotate_window = tk.Toplevel()
        rotate_window.title("Rotate Pages")
        rotate_window.geometry("400x200")
        rotate_window.config(bg="gray20")
        rotate_window.resizable(False, False)
        #image_icon73 = PhotoImage(file = "img/complogo.png")
        #rotate_window.iconphoto(False, image_icon73)

        label = tk.Label(rotate_window, text="Enter rotation degrees:", bg="gray20", fg="cyan")
        label.pack()

        degrees_entry = tk.Entry(rotate_window)
        degrees_entry.pack()

        rotate_button = tk.Button(rotate_window, text="Rotate", command=process_rotation, bg="gray40", fg="cyan")
        rotate_button.pack()


    def extract_images():
        def process_extraction():
            input_file = get_file_path()
            output_folder = filedialog.askdirectory()

            # Deschide PDF-ul
            pdf = fitz.open(input_file)

            for page_num in range(len(pdf)):
                page = pdf[page_num]
                image_list = page.get_images(full=True)
                
                for image_index, img in enumerate(image_list):
                    # Extrage imaginea
                    xref = img[0]
                    base_image = pdf.extract_image(xref)
                    image_bytes = base_image["image"]

                    # Salvează imaginea
                    image_path = os.path.join(output_folder, f"page{page_num+1}_image{image_index}.png")
                    with open(image_path, "wb") as f:
                        f.write(image_bytes)

                    print("Image saved:", image_path)

            pdf.close()
            messagebox.showinfo("Success", "Images extracted successfully!")

        extract_images_window = tk.Toplevel()
        extract_images_window.title("Extract Images")
        extract_images_window.geometry("400x200")
        extract_images_window.resizable(False, False)
        extract_images_window.config(bg="gray20")
        #image_icon74 = PhotoImage(file = "img/complogo.png")
        #extract_images_window.iconphoto(False, image_icon74)

        extract_button = tk.Button(extract_images_window, text="Extract", command=process_extraction, bg="gray40", fg="cyan")
        extract_button.pack()

    def get_file_path():
        file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
        return file_path

    def separate_pages():
        def process_separation():
            input_file = get_file_path()
            output_folder = filedialog.askdirectory()

            with pikepdf.Pdf.open(input_file) as pdf:
                for page_num, page in enumerate(pdf.pages, start=1):
                    new_pdf = pikepdf.Pdf.new()
                    new_pdf.pages.append(page)
                    output_file = os.path.join(output_folder, f"page{page_num}.pdf")
                    new_pdf.save(output_file)

            messagebox.showinfo("Success", "Pages separated successfully!")

        separate_pages_window = tk.Toplevel()
        separate_pages_window.title("Separate Pages")
        separate_pages_window.geometry("400x200")
        separate_pages_window.resizable(False, False)
        separate_pages_window.config(bg="gray20")
        #image_icon75 = PhotoImage(file = "img/complogo.png")
        #separate_pages_window.iconphoto(False, image_icon75)

        separate_button = tk.Button(separate_pages_window, text="Separate", command=process_separation, bg="gray40", fg="cyan")
        separate_button.pack()

    def delete_pages():
        def process_deletion():
            input_file = get_file_path()
            output_file = "deleted_" + os.path.basename(input_file)
            pages_to_delete = list(map(int, pages_entry.get().split(',')))

            with pikepdf.Pdf.open(input_file) as pdf:
                for page_num in sorted(pages_to_delete, reverse=True):
                    del pdf.pages[page_num - 1]
                pdf.save(output_file)

            messagebox.showinfo("Success", "Pages deleted successfully!")

        delete_window = tk.Toplevel()
        delete_window.title("Delete Pages")
        delete_window.geometry("400x200")
        delete_window.resizable(False, False)
        delete_window.config(bg="gray20")
        #image_icon76 = PhotoImage(file = "img/complogo.png")
        #delete_window.iconphoto(False, image_icon76)

        label = tk.Label(delete_window, text="Enter page numbers to delete (separated by comma):", bg="gray20", fg="cyan")
        label.pack()

        pages_entry = tk.Entry(delete_window)
        pages_entry.pack()

        delete_button = tk.Button(delete_window, text="Delete", command=process_deletion, bg="gray40", fg="cyan")
        delete_button.pack()

    def mainpdf():
        rootpdff = tk.Tk()
        rootpdff.title("PDF Editing Tools")
        rootpdff.geometry("400x300")
        rootpdff.resizable(False, False)
        rootpdff.config(bg="gray20")
        #image_icon77 = PhotoImage(file = "img/complogo.png")
        #rootpdff.iconphoto(False, image_icon77)

        encrypt_decrypt_button = tk.Button(rootpdff, text="Encrypt or Decrypt PDF", command=encrypt_decrypt, bg="gray40", fg="cyan")
        encrypt_decrypt_button.pack(pady=5)

        rotate_pages_button = tk.Button(rootpdff, text="Rotate Pages", command=rotate_pages, bg="gray40", fg="cyan")
        rotate_pages_button.pack(pady=5)

        extract_images_button = tk.Button(rootpdff, text="Extract Images", command=extract_images, bg="gray40", fg="cyan")
        extract_images_button.pack(pady=5)

        separate_pages_button = tk.Button(rootpdff, text="Separate Pages", command=separate_pages, bg="gray40", fg="cyan")
        separate_pages_button.pack(pady=5)

        delete_pages_button = tk.Button(rootpdff, text="Delete Pages", command=delete_pages, bg="gray40", fg="cyan")
        delete_pages_button.pack(pady=5)

        rootpdff.mainloop()

    mainpdf()

if netwvar == 14:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    import tkinter as tk
    import logging
    import time
    import numpy
    import matplotlib.pyplot as plt

    #from Tracker import Tracker
    from datetime import datetime


    import psutil
    import time
    from threading import Thread


    # Index : number of bytes sent
    __BYTES_SENT__ = 0
    # Index : number of bytes received
    __BYTES_RECV__ = 1
    # Index : number of packets sent
    __PACKETS_SENT__ = 2
    # Index : number of packets received
    __PACKETS_RECV__ = 3
    # Index : total number of errors while receiving
    __ERR_IN__ = 4
    # Index : total number of errors while sending
    __ERR_OUT__ = 5
    # Index : total number of incoming packets which were dropped
    __DROP_IN__ = 6
    # Index : total number of outgoing packets which were dropped
    __DROP_OUT__ = 7


    class Tracker:

        def __init__(self):
            self.__reset_bytes_recv_vars__()
            self.__reset_bytes_sent_vars__()
            self.init_total_sent = self.__get_bytes_sent_total__()
            self.init_total_recv = self.__get_bytes_recv_total__()


        def get_total_data_used(self):
            """ Returns the data used since the start 4G/3G ...
            """
            return ((self.__get_bytes_sent_total__() - self.init_total_sent) +
                    (self.__get_bytes_recv_total__() - self.init_total_recv))


        def get_current_upload_speed(self):
            """ Returns the current upload speed in bytes per seconds.
            """
            dtime = time.time() - self.last_bytes_sent_time
            dsent = self.__get_bytes_sent_total__() - self.last_bytes_sent_total
            self.__reset_bytes_sent_vars__()
            return dsent / dtime if dtime != 0 else 0


        def get_current_download_speed(self):
            """ Returns the current downlaod speed in bytes per seconds.
            """
            dtime = time.time() - self.last_bytes_recv_time
            dsent = self.__get_bytes_recv_total__() - self.last_bytes_recv_total
            self.__reset_bytes_recv_vars__()
            return dsent / dtime if dtime != 0 else 0


        def __reset_bytes_sent_vars__(self):
            self.last_bytes_sent_total = self.__get_bytes_sent_total__()
            self.last_bytes_sent_time = time.time()


        def __reset_bytes_recv_vars__(self):
            self.last_bytes_recv_total = self.__get_bytes_recv_total__()
            self.last_bytes_recv_time = time.time()


        def __get_bytes_sent_total__(self):
            return psutil.net_io_counters(pernic=False)[__BYTES_SENT__]


        def __get_bytes_recv_total__(self):
            return psutil.net_io_counters(pernic=False)[__BYTES_RECV__]


    logger = logging.getLogger(__name__)
    # Data shown on the plot represents the last 1 minutes
    DATA_DURATION = 5
    # The data variable
    speeds_recv = []
    speeds_sent = []
    times = []
    def main():
        """ Executes the program.
        """
        #root = tk.Tk()
        #root.title('Internet speed - N3RO')
        
        tracker = Tracker()
        plt.ion()
        last_total_data_used = 0

        while True:
            # Retrieve the up and down speeds
            time.sleep(0.5)
            down_speed = 8 * (tracker.get_current_download_speed() / (2**20))
            up_speed = 8 * (tracker.get_current_upload_speed() / (2**20))

            # Store it
            add_data(down_speed, up_speed)

            # Data used
            total_data_used = round(tracker.get_total_data_used() / (2**20), 3)
            write_data_used(last_total_data_used, total_data_used)
            last_total_data_used = total_data_used

            # Update & display the plot
            recv_curve, = plt.plot(times, speeds_recv)
            sent_curve, = plt.plot(times, speeds_sent)

            plt.legend([recv_curve, sent_curve], ['Download', 'Upload'])
            plt.ylabel('Mb/s', fontsize=8)
            ax = plt.gca()
            ax.tick_params(axis='x', labelsize=6)
            ax.tick_params(axis='y', labelsize=6)

            plt.draw()
            plt.pause(0.0001)
            plt.clf()


    def add_data(down_speed, up_speed):
        if len(times) > 1:
            if divmod((times[-1] - times[0]).total_seconds(), 60)[0] >= DATA_DURATION:
                del times[0]
                del speeds_recv[0]
                del speeds_sent[0]
        speeds_recv.append(down_speed)
        speeds_sent.append(up_speed)
        times.append(datetime.now())


    def write_data_used(last_total_data_used, total_data_used):
        if total_data_used != last_total_data_used:
            if total_data_used > last_total_data_used + 0.5:
                print('!! ' + str(total_data_used) + ' Mo used.')
            elif total_data_used > last_total_data_used + 1:
                print('! ' + str(total_data_used) + ' Mo used.')
            else:
                print(str(total_data_used) + ' Mo used.')


    if __name__ == '__main__':
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s ' +
                                      '-- %(levelname)s ' +
                                      '-- [%(filename)s:%(lineno)s ' +
                                      '-- %(funcName)s() ] ' +
                                      '-- %(message)s')
        stream_handler = logging.StreamHandler()
        stream_handler.setLevel(logging.DEBUG)
        stream_handler.setFormatter(formatter)
        logger.addHandler(stream_handler)

        try:
            main()
        except Exception as e:
            logger.exception('Unexpected error')

if crpvar2 == 155:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    import hashlib
    import os
    import sys
    import threading
    import tkinter as tk
    from pathlib import Path
    from tkinter import *
    from tkinter import filedialog, messagebox

    from Cryptodome.Cipher import AES


    class EncryptionTool:
        def __init__(
            self,
            user_file,
            user_key,
            user_salt,
        ):

            # get the path to input file

            self.user_file = user_file

            self.input_file_size = os.path.getsize(self.user_file)
            self.chunk_size = 1024
            self.total_chunks = self.input_file_size // self.chunk_size + 1

            # convert the key and salt to bytes

            self.user_key = bytes(user_key, "utf-8")
            self.user_salt = bytes(user_key[::-1], "utf-8")

            # get the file extension

            self.file_extension = self.user_file.split(".")[-1]

            # hash type for hashing key and salt

            self.hash_type = "SHA256"

            # encrypted file name

            self.encrypt_output_file = (
                ".".join(self.user_file.split(".")[:-1])
                + "."
                + self.file_extension
                + ".encr"
            )

            # decrypted file name

            self.decrypt_output_file = self.user_file[:-5].split(".")
            self.decrypt_output_file = (
                ".".join(self.decrypt_output_file[:-1])
                + "_decrypted."
                + self.decrypt_output_file[-1]
            )

            # dictionary to store hashed key and salt

            self.hashed_key_salt = dict()

            # hash key and salt into 16 bit hashes

            self.hash_key_salt()

        def read_in_chunks(self, file_object, chunk_size=1024):
            """Lazy function (generator) to read a file piece by piece.
            Default chunk size: 1k.
            """

            while True:
                data = file_object.read(chunk_size)
                if not data:
                    break
                yield data

        def encrypt(self):

            # create a cipher object

            cipher_object = AES.new(
                self.hashed_key_salt["key"], AES.MODE_CFB, self.hashed_key_salt["salt"]
            )

            self.abort()  # if the output file already exists, remove it first

            input_file = open(self.user_file, "rb")
            output_file = open(self.encrypt_output_file, "ab")
            done_chunks = 0

            for piece in self.read_in_chunks(input_file, self.chunk_size):
                encrypted_content = cipher_object.encrypt(piece)
                output_file.write(encrypted_content)
                done_chunks += 1
                yield done_chunks / self.total_chunks * 100

            input_file.close()
            output_file.close()

            # clean up the cipher object

            del cipher_object

        def decrypt(self):

            #  exact same as above function except in reverse

            cipher_object = AES.new(
                self.hashed_key_salt["key"], AES.MODE_CFB, self.hashed_key_salt["salt"]
            )

            self.abort()  # if the output file already exists, remove it first

            input_file = open(self.user_file, "rb")
            output_file = open(self.decrypt_output_file, "xb")
            done_chunks = 0

            for piece in self.read_in_chunks(input_file):
                decrypted_content = cipher_object.decrypt(piece)
                output_file.write(decrypted_content)
                done_chunks += 1
                yield done_chunks / self.total_chunks * 100

            input_file.close()
            output_file.close()

            # clean up the cipher object

            del cipher_object

        def abort(self):
            if os.path.isfile(self.encrypt_output_file):
                os.remove(self.encrypt_output_file)
            if os.path.isfile(self.decrypt_output_file):
                os.remove(self.decrypt_output_file)

        def hash_key_salt(self):

            # --- convert key to hash
            #  create a new hash object

            hasher = hashlib.new(self.hash_type)
            hasher.update(self.user_key)

            # turn the output key hash into 32 bytes (256 bits)

            self.hashed_key_salt["key"] = bytes(hasher.hexdigest()[:32], "utf-8")

            # clean up hash object

            del hasher

            # --- convert salt to hash
            #  create a new hash object

            hasher = hashlib.new(self.hash_type)
            hasher.update(self.user_salt)

            # turn the output salt hash into 16 bytes (128 bits)

            self.hashed_key_salt["salt"] = bytes(hasher.hexdigest()[:16], "utf-8")

            # clean up hash object

            del hasher


    class MainWindow:

        """GUI Wrapper"""

        # configure root directory path relative to this file

        THIS_FOLDER_G = ""
        if getattr(sys, "frozen", False):

            # frozen

            THIS_FOLDER_G = os.path.dirname(sys.executable)
        else:

            # unfrozen

            THIS_FOLDER_G = os.path.dirname(os.path.realpath(__file__))

        def __init__(self, rootcr):
            self.rootcr = rootcr
            self._cipher = None
            self._file_url = tk.StringVar()
            self._secret_key = tk.StringVar()
            self._secret_key_check = tk.StringVar()
            self._salt = tk.StringVar()
            self._status = tk.StringVar()
            self._status.set("---")

            self.should_cancel = False

            rootcr.title("FastEncrypt")
            rootcr.configure(bg="#eeeeee")
            #image_icon81 = PhotoImage(file = "img/securelogo.png")
            #rootcr.iconphoto(False, image_icon81)
            
            '''
            try:
                icon_img = tk.Image(
                    "photo", file=self.THIS_FOLDER_G + "./files/encrypc.ico"
                )
                rootcr.call("wm", "iconphoto", rootcr._w, icon_img)
            except Exception:
                pass
            '''

            self.menu_bar = tk.Menu(rootcr, bg="#eeeeee", relief=tk.FLAT)
            self.menu_bar.add_command(label="Help", command=self.show_help_callback)
            self.menu_bar.add_command(label="About", command=self.show_about)

            rootcr.configure(menu=self.menu_bar)

            self.file_entry_label = tk.Label(
                rootcr,
                text="Enter File Path Or Click SELECT FILE Button",
                bg="#eeeeee",
                anchor=tk.W,
            )
            self.file_entry_label.grid(
                padx=12,
                pady=(8, 0),
                ipadx=0,
                ipady=1,
                row=0,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.file_entry = tk.Entry(
                rootcr,
                textvariable=self._file_url,
                bg="#fff",
                exportselection=0,
                relief=tk.FLAT,
            )
            self.file_entry.grid(
                padx=15,
                pady=6,
                ipadx=8,
                ipady=8,
                row=1,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.select_btn = tk.Button(
                rootcr,
                text="SELECT FILE",
                command=self.selectfile_callback,
                width=42,
                bg="#3498db",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.select_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=2,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry_label1 = tk.Label(
                rootcr,
                text="Enter Key (To be Remembered while Decryption)",
                bg="#eeeeee",
                anchor=tk.W,
            )
            self.key_entry_label1.grid(
                padx=12,
                pady=(8, 0),
                ipadx=0,
                ipady=1,
                row=3,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry1 = tk.Entry(
                rootcr,
                textvariable=self._secret_key,
                bg="#fff",
                exportselection=0,
                relief=tk.FLAT,
            )
            self.key_entry1.grid(
                padx=15,
                pady=6,
                ipadx=8,
                ipady=8,
                row=4,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry_label2 = tk.Label(
                rootcr, text="Re-enter Key (Validation)", bg="#eeeeee", anchor=tk.W
            )
            self.key_entry_label2.grid(
                padx=12,
                pady=(8, 0),
                ipadx=0,
                ipady=1,
                row=5,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.key_entry2 = tk.Entry(
                rootcr,
                textvariable=self._secret_key_check,
                bg="#fff",
                exportselection=0,
                relief=tk.FLAT,
            )
            self.key_entry2.grid(
                padx=15,
                pady=6,
                ipadx=8,
                ipady=8,
                row=6,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.encrypt_btn = tk.Button(
                rootcr,
                text="ENCRYPT",
                command=self.e_check_callback,
                bg="#27ae60",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.encrypt_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=7,
                column=0,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.decrypt_btn = tk.Button(
                rootcr,
                text="DECRYPT",
                command=self.d_check_callback,
                bg="#27ae60",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.decrypt_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=7,
                column=2,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.reset_btn = tk.Button(
                rootcr,
                text="CLEAR",
                command=self.reset_callback,
                bg="#717d7e",
                fg="#ffffff",
                bd=2,
                relief=tk.FLAT,
            )
            self.reset_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=8,
                column=0,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.stop_btn = tk.Button(
                rootcr,
                text="STOP",
                command=self.cancel_callback,
                bg="#aaaaaa",
                fg="#ffffff",
                bd=2,
                state="disabled",
                relief=tk.FLAT,
            )
            self.stop_btn.grid(
                padx=15,
                pady=8,
                ipadx=24,
                ipady=6,
                row=8,
                column=2,
                columnspan=2,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            self.status_label = tk.Label(
                rootcr,
                textvariable=self._status,
                bg="#eeeeee",
                anchor=tk.W,
                justify=tk.LEFT,
                relief=tk.FLAT,
                wraplength=350,
            )
            self.status_label.grid(
                padx=12,
                pady=(0, 12),
                ipadx=0,
                ipady=1,
                row=9,
                column=0,
                columnspan=4,
                sticky=tk.W + tk.E + tk.N + tk.S,
            )

            tk.Grid.columnconfigure(rootcr, 0, weight=1)
            tk.Grid.columnconfigure(rootcr, 1, weight=1)
            tk.Grid.columnconfigure(rootcr, 2, weight=1)
            tk.Grid.columnconfigure(rootcr, 3, weight=1)

        def selectfile_callback(self):
            try:
                name = filedialog.askopenfile()
                self._file_url.set(name.name)
            except Exception as e:
                self._status.set(e)
                self.status_label.update()

        def freeze_controls(self):
            self.file_entry.configure(state="disabled")
            self.key_entry1.configure(state="disabled")
            self.key_entry2.configure(state="disabled")
            self.select_btn.configure(state="disabled", bg="#aaaaaa")
            self.encrypt_btn.configure(state="disabled", bg="#aaaaaa")
            self.decrypt_btn.configure(state="disabled", bg="#aaaaaa")
            self.reset_btn.configure(state="disabled", bg="#aaaaaa")
            self.stop_btn.configure(state="normal", bg="#e74c3c")
            self.status_label.update()

        def unfreeze_controls(self):
            self.file_entry.configure(state="normal")
            self.key_entry1.configure(state="normal")
            self.key_entry2.configure(state="normal")
            self.select_btn.configure(state="normal", bg="#3498db")
            self.encrypt_btn.configure(state="normal", bg="#27ae60")
            self.decrypt_btn.configure(state="normal", bg="#27ae60")
            self.reset_btn.configure(state="normal", bg="#717d7e")
            self.stop_btn.configure(state="disabled", bg="#aaaaaa")
            self.status_label.update()

        def e_check_callback(self):

            newPath = Path(self._file_url.get())
            if newPath.is_file():
                pass
            else:
                messagebox.showinfo("EncrypC", "Please Enter a valid File URL !!")
                return

            if len(self._secret_key.get()) == 0:
                messagebox.showinfo("EncrypC", "Please Enter a valid Secret Key !!")
                return
            elif self._secret_key.get() != self._secret_key_check.get():
                messagebox.showinfo("EncrypC", "Passwords do not match !!")
                return

            self.encrypt_callback()

        def d_check_callback(self):

            newPath = Path(self._file_url.get())
            if newPath.is_file():
                pass
            else:
                messagebox.showinfo("EncrypC", "Please Enter a valid File URL !!")
                return

            if self._file_url.get()[-4:] != "encr":
                messagebox.showinfo(
                    "EncrypC",
                    """Provided File is not an Encrypted File !!
    Please Enter an Encrypted File to Decrypt.""",
                )
                return

            if len(self._secret_key.get()) == 0:
                messagebox.showinfo("EncrypC", "Please Enter a Secret Key !!")
                return
            elif self._secret_key.get() != self._secret_key_check.get():
                messagebox.showinfo("EncrypC", "Passwords do not match !!")
                return

            self.decrypt_callback()

        def encrypt_callback(self):
            t1 = threading.Thread(target=self.encrypt_execute)
            t1.start()

        def encrypt_execute(self):
            self.freeze_controls()

            try:
                self._cipher = EncryptionTool(
                    self._file_url.get(), self._secret_key.get(), self._salt.get()
                )
                for percentage in self._cipher.encrypt():
                    if self.should_cancel:
                        break
                    percentage = "{0:.2f}%".format(percentage)
                    self._status.set(percentage)
                    self.status_label.update()

                if self.should_cancel:
                    self._cipher.abort()
                    self._status.set("Cancellation Successful !!")
                    messagebox.showinfo("EncrypC", "Cancellation Successful !!")
                    self._cipher = None
                    self.should_cancel = False
                    self.unfreeze_controls()
                    return

                self._cipher = None
                self.should_cancel = False
                self._status.set("File Encryption Successful !!")
                messagebox.showinfo("EncrypC", "File Encryption Successful !!")
            except Exception as e:

                self._status.set(e)

            self.unfreeze_controls()

        def decrypt_callback(self):
            t2 = threading.Thread(target=self.decrypt_execute)
            t2.start()

        def decrypt_execute(self):
            self.freeze_controls()

            try:
                self._cipher = EncryptionTool(
                    self._file_url.get(), self._secret_key.get(), self._salt.get()
                )
                for percentage in self._cipher.decrypt():
                    if self.should_cancel:
                        break
                    percentage = "{0:.2f}%".format(percentage)
                    self._status.set(percentage)
                    self.status_label.update()

                if self.should_cancel:
                    self._cipher.abort()
                    self._status.set("Cancellation Successful !!")
                    messagebox.showinfo("EncrypC", "Cancellation Successful !!")
                    self._cipher = None
                    self.should_cancel = False
                    self.unfreeze_controls()
                    return

                self._cipher = None
                self.should_cancel = False
                self._status.set("File Decryption Successful !!")
                messagebox.showinfo("EncrypC", "File Decryption Successful !!")
            except Exception as e:

                self._status.set(e)

            self.unfreeze_controls()

        def reset_callback(self):
            self._cipher = None
            self._file_url.set("")
            self._secret_key.set("")
            self._salt.set("")
            self._status.set("---")

        def cancel_callback(self):
            self.should_cancel = True

        def show_help_callback(self):
            messagebox.showinfo(
                "Tutorial",
                """1. Open the Application and Click SELECT FILE Button to select your file e.g. "mydoc.pdf" (OR You can add path manually).
    2. Enter your Key (This should be alphanumeric letters). Remember this so you can Decrypt the file later. (Else you'll lose your file permanently)
    3. Click ENCRYPT Button to encrypt the file. A new encrypted file with ".encr" extention e.g. "mydoc.pdf.encr" will be created in the same directory where the "mydoc.pdf" is.
    4. When you want to Decrypt a file you, will select the file with the ".encr" extention and Enter your Key which you chose at the time of Encryption. Click DECRYPT Button to decrypt. The decrypted file will be of the same name as before with the suffix "decrypted" for e.g. "mydoc_decrypted.pdf".
    5. Click CLEAR Button to reset the input fields and status bar.""",
            )

        def show_about(self):
            messagebox.showinfo(
                "EncrypC v1.7.0",
                """FastEncrypt is a File Encryption Tool based on AES Algorithm. 
    Managed by Tudor Marmureanu.""",
            )


    ROOT = tk.Tk()
    MAIN_WINDOW = MainWindow(ROOT)
    bundle_dir = getattr(sys, "_MEIPASS", os.path.abspath(os.path.dirname(__file__)))
    #path_to_ico = os.path.abspath(os.path.join(bundle_dir, "encrypc.ico"))
    #ROOT.iconbitmap(path_to_ico)
    ROOT.resizable(height=False, width=False)
    ROOT.mainloop()

if aivar == 20:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    def AIChatbot():
        import tkinter as tk
        from tkinter import scrolledtext
        import re
        import subprocess
        import os
        from datetime import datetime

        class CommandProcessor:
            def __init__(self):
                self.info_text = """Daca nu poti copia, atunci verifica ca maparile sa fie facute si sa ai acces la ele si ca locatiile din fisierul tau txt sa corespunda locatiilor reale din PC si, astfel, copierea se realizeaza instant.
                Copierea se realizeaza mai eficient decat daca ai face manual tot procesul, deoarece locatiile sunt deja precompilate, deci este o maniera mai eficienta cu 20%.
                Daca bara de copiere nu este verde niciodata, atunci locatiile din fisierul tau txt nu corespund sau cuvantul inainte de : este modificat.
                Daca nu se copiaza nimic, atunci verifica maparile si asigura-te ca locatiile corespund cu fisierul txt.
                Acest tool sau program te ajuta sa faci si operatiuni diverse in reteaua ta, inclusiv sa scanezi porturile, sa vezi ce dispozitive se afla in retea sau in VLAN, sa executi diverse comenzi in retea, sa verifici proprietatile hardware ale sistemului tau in timp real, contine si functii care manipuleaza fisierele pdf si multe altele.
                Altceva ar mai fi ca poate sa compare 2 fisiere sau foldere, sa caute o secventa de text si sa o inlocuiasca, genereaza parole in diverse combinatii, ba chiar poate deschide un nou Terminal personalizat si sa cripteze fisiere.
                Licenta are scopul de a limita accesul neautorizat la fel cum este si in cazul conturilor create, adica fiecare cont are un rol predefinit.
                Contul dev nu poate fi accesat decat de Tudor Marmureanu, deoarece nimeni nu are acces full la tot ce contine tocmai din cauza ca se poate da peste cap tot sistemul sau se pot produce pagube in retea.
                Conturile deja predefinite inglobeaza celelalte functionalitati care nu se regasesc in contul it, in principal pentru ca nu au legatura cu procesul de copy.
                Sunt mai multe conturi si functionalitati, insa Tudor Marmureanu nu mi-a dat acces sa dezvalui toata informatia.
                Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale.
                Atat timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii."""

            def process_command(self, question):
                """Process user command and return response"""
                question_lower = question.lower()
                
                # Service Tag commands - Complete list from txt file
                if (question_lower == "open the servicetag" or question_lower == "show the servicetag" or 
                    question_lower == "display the servicetag" or question_lower == "open servicetag" or 
                    question_lower == "show servicetag" or question_lower == "display servicetag" or 
                    question_lower == "deschide-mi servicetagul" or question_lower == "deschide-mi servicetag-ul" or 
                    question_lower == "deschide servicetag-ul" or question_lower == "deschide-mi servicetag" or 
                    question_lower == "afiseaza-mi servicetag" or question_lower == "afiseaza-mi servicetagul" or 
                    question_lower == "deschide servicetagul" or question_lower == "deschide servicetag" or 
                    question_lower == "afiseaza servicetag" or question_lower == "afiseaza servicetagul" or 
                    question_lower == "afiseaza servicetag-ul" or question_lower == "afiseaza-mi servicetag-ul" or 
                    question_lower == "servicetag" or question_lower == "servicetag-ul" or question_lower == "servicetagul" or
                    question_lower == "afiseazami servicetag" or question_lower == "afiseazami servicetagul" or
                    question_lower == "deschidemi servicetagul" or question_lower == "deschidemi servicetag-ul"):
                    return self._get_service_tag()
                
                # Windows License Key commands - Complete list from txt file
                elif (question_lower == "open the windows key" or question_lower == "open the windows serial number" or 
                      question_lower == "open the product key" or question_lower == "open the product key on windows" or question_lower == "open the windows product key"or 
                      question_lower == "display the windows key" or question_lower == "display the windows serial number" or 
                      question_lower == "display the product key" or question_lower == "display the product key on windows" or 
                      question_lower == "show the windows key" or question_lower == "show the windows serial number" or 
                      question_lower == "show the product key" or question_lower == "show the product key on windows" or 
                      question_lower == "open windows key" or question_lower == "open windows serial number" or 
                      question_lower == "open product key" or question_lower == "open product key on windows" or 
                      question_lower == "display windows key" or question_lower == "display windows serial number" or 
                      question_lower == "display product key" or question_lower == "display product key on windows" or 
                      question_lower == "show windows key" or question_lower == "show windows serial number" or 
                      question_lower == "show product key" or question_lower == "show product key on windows" or 
                      question_lower == "deschide-mi licenta" or question_lower == "deschide-mi cheia de licenta" or 
                      question_lower == "afiseaza-mi licenta" or question_lower == "afiseaza-mi cheia de licenta" or 
                      question_lower == "deschide licenta" or question_lower == "deschide cheia de licenta" or 
                      question_lower == "afiseaza licenta" or question_lower == "afiseaza cheia de licenta" or 
                      question_lower == "deschidemi licenta" or question_lower == "deschidemi cheia de licenta" or 
                      question_lower == "afiseazami licenta" or question_lower == "afiseazami cheia de licenta" or 
                      question_lower == "arata-mi licenta" or question_lower == "aratami licenta" or question_lower == "arata licenta" or 
                      question_lower == "arata-mi cheia de licenta" or question_lower == "aratami cheia de licenta" or 
                      question_lower == "arata cheia de licenta" or question_lower == "vezi licenta" or question_lower == "vezi cheia de licenta" or 
                      question_lower == "vezi-mi licenta" or question_lower == "vezi-mi cheia de licenta" or 
                      question_lower == "vezimi licenta" or question_lower == "vezimi cheia de licenta" or 
                      question_lower == "licenta windows" or question_lower == "cheia de licenta windows" or 
                      question_lower == "cheie licenta" or question_lower == "cheia licenta" or question_lower == "key windows" or 
                      question_lower == "windows key" or question_lower == "product key" or question_lower == "windows product key" or 
                      question_lower == "serial windows" or question_lower == "windows serial" or question_lower == "cheie activare" or 
                      question_lower == "cheia de activare" or question_lower == "cod activare windows" or 
                      question_lower == "cod de activare windows" or question_lower == "cheie activare windows" or 
                      question_lower == "cheia de activare windows" or question_lower == "licenta de windows" or 
                      question_lower == "cheia din windows" or question_lower == "licenta din windows" or 
                      question_lower == "cheia de windows" or question_lower == "afiseaza cheia din windows" or 
                      question_lower == "afiseaza-mi cheia din windows" or question_lower == "afiseazami cheia din windows" or 
                      question_lower == "deschide cheia din windows" or question_lower == "deschide-mi cheia din windows" or 
                      question_lower == "deschidemi cheia din windows" or question_lower == "arata cheia din windows" or 
                      question_lower == "arata-mi cheia din windows" or question_lower == "aratami cheia din windows" or 
                      question_lower == "vezi cheia din windows" or question_lower == "vezi-mi cheia din windows" or 
                      question_lower == "vezimi cheia din windows" or question_lower == "cod de windows" or 
                      question_lower == "cod din windows" or question_lower == "serial de windows" or 
                      question_lower == "serial din windows" or question_lower == "key de windows" or question_lower == "key din windows" or
                      question_lower == "aratami cheia windows" or question_lower == "aratami cheia de windows" or
                      question_lower == "aratami cheia din windows" or question_lower == "arat-ami cheia windows" or
                      question_lower == "arata-mi cheia din windows" or question_lower == "arata-mi cheia de windows" or
                      question_lower == "obtain the windows key" or question_lower == "obtain windows key" or question_lower == "obtain product key" or
                      question_lower == "obtain the product key" or question_lower == "get the windows key" or question_lower == "get windows key" or
                      question_lower == "get product key" or question_lower == "get the product key" or question_lower == "find the windows key" or
                      question_lower == "find windows key" or question_lower == "find product key" or question_lower == "find the product key" or question_lower == "gaseste licenta" or
                      question_lower == "gaseste cheia de licenta" or question_lower == "gaseste-mi licenta" or question_lower == "gaseste-mi cheia de licenta" or
                      question_lower == "gasestemi licenta" or question_lower == "gasestemi cheia de licenta" or question_lower == "cauta licenta" or
                      question_lower == "cauta cheia de licenta" or question_lower == "cauta-mi licenta" or question_lower == "cauta-mi cheia de licenta" or
                      question_lower == "cautami licenta" or question_lower == "cautami cheia de licenta" or question_lower == "cheia licenta windows" or
                      question_lower == "cheia de licenta windows" or question_lower == "cheia licenta" or question_lower == "cheia de licenta" or
                      question_lower == "cautami cheia licenta" or question_lower == "cheie licenta windows" or
                      question_lower == "cheie de licenta windows" or question_lower == "cheie licenta" or question_lower == "cheie de licenta" or
                      question_lower == "cheia" or question_lower == "cheie" or question_lower == "cheia windows" or question_lower == "cheie windows" or
                      question_lower == "cheia de windows" or question_lower == "cheie de windows" or question_lower == "windows key" or question_lower == "key windows" or
                      question_lower == "key of windows" or question_lower == "key form windows" or question_lower == "key of the windows" or question_lower == "key from the windows" or
                      question_lower == "windovs product key" or question_lower == "windows license" or question_lower == "windows license key" or
                      question_lower == "afiseaza windows key" or question_lower == "afiseaza windows product key" or question_lower == "afiseaza windows license" or
                      question_lower == "afiseaza windows serial number" or question_lower == "cheia de la windows" or question_lower == "cheie de la windows" or
                      question_lower == "licenta de la windows" or question_lower == "serial number de la windows" or question_lower == "product key de la windows"):
                    return self._get_windows_key()
                
                # System management commands
                elif question_lower in ["lusrmgr.msc", "lusrmgr"]:
                    os.startfile("lusrmgr.msc")
                    return "Opening Local Users and Groups Manager..."
                
                elif question_lower in ["devmgmt.msc", "devmgmt", "device manager"]:
                    os.startfile("devmgmt.msc")
                    return "Opening Device Manager..."
                
                elif (question_lower == "edit power plan" or question_lower == "power plan" or question_lower == "battery" or 
                      question_lower == "battery plan" or question_lower == "batery" or question_lower == "batery plan"):
                    try:
                        subprocess.run(["control", "powercfg.cpl"])
                        return "Opening Power Options..."
                    except Exception as e:
                        return f"Error opening Power Options: {e}"
                
                elif (question_lower == "control panel apps" or question_lower == "control panel" or 
                      question_lower == "appwiz.cpl" or question_lower == "appwiz" or question_lower == "apwiz" or question_lower == "apwiz.cpl"):
                    os.startfile("appwiz.cpl")
                    return "Opening Programs and Features..."
                
                elif (question_lower == "sysdm" or question_lower == "sysdm.cpl" or question_lower == "windows domain" or 
                      question_lower == "domain" or question_lower == "domeniu" or question_lower == "windows domeniu" or question_lower == "domeniu windows"):
                    os.startfile("sysdm.cpl")
                    return "Opening System Properties..."
                
                # Power management commands - Complete list from txt file
                elif (question_lower == "shutdown" or question_lower == "shutdown pc" or question_lower == "inchide pc" or 
                      question_lower == "inchide acest pc" or question_lower == "inchide" or question_lower == "shutdown laptop" or 
                      question_lower == "inchide laptop" or question_lower == "inchide acest laptop"):
                    subprocess.call("shutdown /s /t 1")
                    return "Shutting down system..."
                
                elif (question_lower == "restart" or question_lower == "restart pc" or question_lower == "restarteaza pc" or 
                      question_lower == "restarteaza" or question_lower == "restart laptop" or question_lower == "restarteaza laptop" or 
                      question_lower == "restarteaza acest pc" or question_lower == "restarteaza acest laptop"):
                    subprocess.call("shutdown /r /t 1")
                    return "Restarting system..."
                
                elif (question_lower == "logout" or question_lower == "logout pc" or question_lower == "log out" or 
                      question_lower == "logout laptop" or question_lower == "log out pc" or question_lower == "log out laptop"):
                    subprocess.call("shutdown -l")
                    return "Logging out..."
                
                # System information - Complete list from txt file
                elif (question_lower == "system info" or question_lower == "system information" or 
                      question_lower == "display system info" or question_lower == "afiseaza informatiile sistemului" or 
                      question_lower == "afiseaza informatiile pc-ului" or question_lower == "afiseaza informatiile pcului" or 
                      question_lower == "afiseaza informatiile laptopului" or question_lower == "afiseaza informatiile" or 
                      question_lower == "afiseaza-mi informatiile sistemului" or question_lower == "afiseaza-mi informatiile pc-ului" or 
                      question_lower == "afiseaza-mi informatiile pcului" or question_lower == "afiseaza-mi informatiile laptopului" or 
                      question_lower == "afiseaza-mi informatiile" or
                      question_lower == "afiseazami informatiile sistemului" or question_lower == "afiseazami informatiile pc-ului" or 
                      question_lower == "afiseazami informatiile pcului" or question_lower == "afiseazami informatiile laptopului" or 
                      question_lower == "afiseazami informatiile" or
                      question_lower == "arata-mi informatiile sistemului" or question_lower == "arata-mi informatiile pc-ului" or 
                      question_lower == "arata-mi informatiile pcului" or question_lower == "arata-mi informatiile laptopului" or 
                      question_lower == "arata-mi informatiile" or
                      question_lower == "aratami informatiile sistemului" or question_lower == "aratami informatiile pc-ului" or 
                      question_lower == "aratami informatiile pcului" or question_lower == "aratami informatiile laptopului" or 
                      question_lower == "aratami informatiile"):
                    return self._get_system_info()
                
                # Network commands - Complete list from txt file
                elif (question_lower == "display the devices connected on my network" or 
                      question_lower == "display devices connected on my network" or 
                      question_lower == "display the devices on my network" or question_lower == "display devices on my network" or 
                      question_lower == "show the devices connected on my network" or 
                      question_lower == "show devices connected on my network" or 
                      question_lower == "show the devices on my network" or question_lower == "show devices on my network" or 
                      question_lower == "afiseaza device-urile conectate la retea" or 
                      question_lower == "afiseaza device-urile conectate la reteaua mea" or 
                      question_lower == "afiseaza deviceurile conectate la retea" or 
                      question_lower == "afiseaza deviceurile conectate la reteaua mea" or 
                      question_lower == "afiseaza-mi device-urile conectate la retea" or 
                      question_lower == "afiseaza-mi device-urile conectate la reteaua mea" or 
                      question_lower == "afiseaza-mi deviceurile conectate la retea" or 
                      question_lower == "afiseaza-mi deviceurile conectate la reteaua mea" or
                      question_lower == "afiseazami device-urile conectate la retea" or 
                      question_lower == "afiseazami device-urile conectate la reteaua mea" or 
                      question_lower == "afiseazami deviceurile conectate la retea" or 
                      question_lower == "afiseazami deviceurile conectate la reteaua mea" or
                      question_lower == "show devices on network" or question_lower == "arata device-urile conectate la retea" or 
                      question_lower == "arata device-urile conectate la reteaua mea" or 
                      question_lower == "arata deviceurile conectate la retea" or 
                      question_lower == "arata deviceurile conectate la reteaua mea" or 
                      question_lower == "arata-mi device-urile conectate la retea" or 
                      question_lower == "arata-mi device-urile conectate la reteaua mea" or 
                      question_lower == "arata-mi deviceurile conectate la retea" or 
                      question_lower == "arata-mi deviceurile conectate la reteaua mea" or
                      question_lower == "aratami device-urile conectate la retea" or 
                      question_lower == "aratami device-urile conectate la reteaua mea" or 
                      question_lower == "aratami deviceurile conectate la retea" or 
                      question_lower == "aratami deviceurile conectate la reteaua mea"):
                    return self._get_network_devices()
                
                # WiFi passwords - Complete list from txt file
                elif (question_lower == "afiseaza toate parolele wi-fi" or question_lower == "afiseaza toate parolele wifi" or 
                      question_lower == "afiseaza parolele wi-fi" or question_lower == "afiseaza parolele wifi" or 
                      question_lower == "afiseaza-mi toate parolele wi-fi" or question_lower == "afiseaza-mi toate parolele wifi" or 
                      question_lower == "afiseaza-mi parolele wi-fi" or question_lower == "afiseaza-mi parolele wifi" or 
                      question_lower == "afiseazami toate parolele wi-fi" or question_lower == "afiseazami toate parolele wifi" or 
                      question_lower == "afiseazami parolele wi-fi" or question_lower == "afiseazami parolele wifi" or 
                      question_lower == "arata toate parolele wi-fi" or question_lower == "arata toate parolele wifi" or 
                      question_lower == "arata parolele wi-fi" or question_lower == "arata parolele wifi" or 
                      question_lower == "arata-mi toate parolele wi-fi" or question_lower == "arata-mi toate parolele wifi" or 
                      question_lower == "aratami toate parolele wi-fi" or question_lower == "aratami toate parolele wifi" or 
                      question_lower == "arata-mi parolele wi-fi" or question_lower == "arata-mi parolele wifi" or 
                      question_lower == "aratami parolele wi-fi" or question_lower == "aratami parolele wifi" or 
                      question_lower == "show wifi passwords" or question_lower == "show all wifi passwords" or 
                      question_lower == "show the wifi passwords" or question_lower == "display all wifi passwords" or 
                      question_lower == "display the wifi passwords" or question_lower == "show wifi pass" or 
                      question_lower == "show the wifi pass" or question_lower == "show all wifi pass" or 
                      question_lower == "display all wifi pass" or question_lower == "display the wifi pass" or 
                      question_lower == "show wifi paswords" or question_lower == "show wifi pas" or 
                      question_lower == "show all wifi pas" or question_lower == "show the wifi pas" or 
                      question_lower == "display all wifi pas" or question_lower == "show wi-fi passwords" or 
                      question_lower == "show the wi-fi passwords" or question_lower == "show all wi-fi passwords" or 
                      question_lower == "display all wi-fi passwords" or question_lower == "display the wi-fi passwords" or 
                      question_lower == "show wi-fi pass" or question_lower == "show the wi-fi pass" or 
                      question_lower == "display wi-fi pass" or question_lower == "display the wi-fi pass" or 
                      question_lower == "show all wi-fi pass" or question_lower == "display all wi-fi pass" or 
                      question_lower == "show wi-fi paswords" or question_lower == "show wi-fi pas" or 
                      question_lower == "vreau sa imi afisezi parolele wifi" or question_lower == "vreau sa imi afisezi parolele wi-fi" or 
                      question_lower == "display the wi-fi password" or question_lower == "display the wifi password" or 
                      question_lower == "display the wi-fi passwords" or question_lower == "display the wifi passwords" or 
                      question_lower == "show the wi-fi password" or question_lower == "show the wifi password" or 
                      question_lower == "show the wi-fi passwords" or question_lower == "show the wifi passwords"):
                    return self._get_wifi_passwords()
                
                # Identity question - Complete list from txt file
                elif (question_lower == "cine esti" or question_lower == "ce esti" or question_lower == "cine esti tu" or 
                      question_lower == "ce esti tu" or question_lower == "cine esti?" or question_lower == "ce esti?" or 
                      question_lower == "cine esti tu?" or question_lower == "ce esti tu?" or question_lower == "who are you?" or question_lower == "who are you"):
                    return "Sunt un model de inteligenta artificiala care functioneaza pe principiul retelelor neuronale. Atata timp cat Tudor Marmureanu imi trimite pachetele de date pentru full acces, va pot oferi mult mai multe informatii despre diverse functii."
                
                # Default response using keyword matching
                else:
                    return self._get_default_response(question)

            def _get_service_tag(self):
                """Get system service tag"""
                try:
                    output = subprocess.check_output(["wmic", "bios", "get", "serialnumber"]).decode().strip().split("\n")
                    service_tag = output[1].strip()
                    try:
                        with open("ServiceTag.txt", 'w') as file:
                            file.write(service_tag)
                        return f"Service Tag: {service_tag}\n(Saved to ServiceTag.txt)"
                    except Exception as e:
                        return f"Service Tag: {service_tag}\n(Error saving to file: {e})"
                except Exception as e:
                    return f"Error retrieving Service Tag: {e}"

            def _get_windows_key(self):
                """Get Windows license key"""
                try:
                    output = subprocess.check_output(["wmic", "path", "softwarelicensingservice", "get", "OA3xOriginalProductKey"]).decode().strip().split("\n")
                    # Handle the output parsing more carefully
                    license_key = ""
                    for line in output:
                        if line.strip() and "OA3xOriginalProductKey" not in line:
                            license_key = line.strip()
                            break
                    
                    if not license_key:
                        license_key = "No product key found"
                    
                    try:
                        with open("WindowsKey.txt", 'w') as file:
                            file.write(license_key)
                        return f"Windows License Key: {license_key}\n(Saved to WindowsKey.txt)"
                    except Exception as e:
                        return f"Windows License Key: {license_key}\n(Error saving to file: {e})"
                except Exception as e:
                    return f"Error retrieving Windows License Key: {e}"

            def _get_system_info(self):
                """Get system information"""
                try:
                    info = subprocess.check_output(['systeminfo']).decode('utf-8').split('\n')
                    formatted_info = [item.rstrip() for item in info if item.strip()]
                    try:
                        with open("SystemInfo.txt", 'w') as file:
                            file.write('\n'.join(formatted_info))
                        return f"System Information:\n" + '\n'.join(formatted_info[:10]) + f"\n\n(Full info saved to SystemInfo.txt - {len(formatted_info)} lines total)"
                    except Exception as e:
                        return f"System Information:\n" + '\n'.join(formatted_info[:10]) + f"\n\n(Error saving to file: {e})"
                except Exception as e:
                    return f"Error retrieving system information: {e}"

            def _get_network_devices(self):
                """Get network devices"""
                try:
                    output_arp = subprocess.check_output(['arp', '-a']).decode('utf-8')
                    output_netstat = subprocess.check_output(['netstat', '-an']).decode('utf-8')
                    
                    full_output = f"Active devices on the network:\n{output_arp}\n\nNetwork connections and open ports:\n{output_netstat}"
                    
                    with open('devices_on_network.txt', 'w') as f:
                        f.write(full_output)
                    
                    return f"{full_output}\n\n(Saved to devices_on_network.txt)"
                except Exception as e:
                    return f"Error retrieving network devices: {e}"

            def _get_wifi_passwords(self):
                """Get WiFi passwords"""
                try:
                    passwords = []
                    data = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
                    profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]
                    
                    for profile in profiles:
                        try:
                            results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear']).decode('utf-8').split('\n')
                            password_lines = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
                            password = password_lines[0] if password_lines else ""
                            passwords.append(f"{profile:<30} | {password}")
                        except:
                            passwords.append(f"{profile:<30} | Password not found")
                    
                    with open("Wifi_Passwords.txt", "w") as file:
                        file.write('\n'.join(passwords))
                    
                    return f"WiFi Passwords:\n" + '\n'.join(passwords) + "\n\n(Saved to Wifi_Passwords.txt)"
                except Exception as e:
                    return f"Error retrieving WiFi passwords: {e}"

            def _get_default_response(self, question):
                """Get default response using keyword matching with improved skip words"""
                if '?' in question:
                    question = question.replace('?', '')
                
                # Expanded skip words set (fără diacritice)
                skip_words = {
                    # Pronouns and basic words
                    "me", "it", "you", "he", "she", "we", "they", "i", "my", "your", "his", "her", "our", "their",
                    "eu", "tu", "el", "ea", "noi", "voi", "ei", "ele", "meu", "tau", "sau", "lui", "ei", "nostru", "vostru", "lor",
                    
                    # Verbs
                    "have", "has", "had", "am", "is", "are", "was", "were", "be", "been", "do", "does", "did", "will", "would", "could", "should",
                    "sunt", "esti", "este", "suntem", "sunteti", "eram", "erai", "era", "erام", "erati", "erau", "fac", "faci", "face", "facem", "faceti", "fac",
                    "am", "ai", "are", "avem", "aveti", "au", "aveam", "aveai", "avea", "aveام", "aveati", "aveau",
                    
                    # Prepositions and conjunctions  
                    "in", "on", "at", "by", "for", "with", "to", "from", "of", "off", "about", "and", "or", "but", "if", "when", "where", "how", "why", "what", "which", "that", "this", "these", "those",
                    "la", "in", "pe", "cu", "de", "din", "prin", "pentru", "despre", "si", "sau", "dar", "daca", "cand", "unde", "cum", "ce", "care", "care", "acest", "aceasta", "acestea", "acei", "acele",
                    
                    # Articles
                    "a", "an", "the", "un", "o", "niste",
                    
                    # Common adjectives/adverbs
                    "good", "bad", "big", "small", "fast", "slow", "new", "old", "hot", "cold", "here", "there", "now", "then", "today", "yesterday", "tomorrow",
                    "bun", "rau", "mare", "mic", "rapid", "lent", "nou", "vechi", "cald", "rece", "aici", "acolo", "acum", "atunci", "azi", "ieri", "maine",
                    
                    # Numbers
                    "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",
                    "unu", "doi", "trei", "patru", "cinci", "sase", "sapte", "opt", "noua", "zece",
                    
                    # Specific words that should be ignored
                    "scanezi", "place", "run", "not", "priveste", "privire", "voastre", "noastre", "mele", "tale", "ale",
                    "exista", "locatiilor", "locatii", "locatiile", "dns", "vlan", "vad", "vezi", "vazut", "cat", "deci", "asadar",
                    "cazul", "caz", "contrar", "alte", "altele", "altor", "construit", "parca", "prin", "intermediul", "ajutor",
                    "ajutorul", "ajutoare", "baza", "bazez", "bazezi", "bazam", "bazati", "puternic", "slab", "doar", "numai",
                    "intrucat", "incat", "soare", "frig", "furtuna", "ninge", "ploua", "stele", "rol", "faceau", "faceati", "faceam",
                    "situatie", "situatii", "niciodata", "aia", "acea", "aceea", "fisiere", "fisierele", "fisierelor", "fisier",
                    "fisierul", "directorul", "director", "directoare", "directoarele", "arhiva", "zip", "arhive", "arhivele",
                    "arhivelor", "cont", "conturi", "conturile", "conturilor", "fa", "mi", "ti", "le", "lor", "noastra", "voastra",
                    "voua", "va", "noua", "mie", "placea", "placut", "copi", "copii", "instant", "astfel", "altfel", "legatura",
                    "copierea", "inglobeaza", "principal", "procesul", "deja", "nicicand", "niciunde", "nici", "faca", "candva",
                    "cand", "putea", "chiar", "timp", "real", "realmente", "mult", "alt", "peste", "produce", "contine", "contin",
                    "cauza", "cap", "tot", "toti", "toate", "poate", "poti", "as", "merge", "functioneaza", "pentru", "deoarece",
                    "tocmai", "din", "avea", "aveai", "fi", "fost", "musai", "trebuie", "trebuia", "trebuit", "mai", "imi", "ne",
                    "ii", "cheie", "cheia", "chei", "mergea", "mers", "poate", "realiza", "nu", "pot", "poti", "nimic", "se", "putea", "prea",
                    "proces", "process", "nereusita", "nereusit",
                    
                    # Single characters and common punctuation-related
                    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
                    "-", "_", "mi", "ti", "l", "v", "m", "ar", "va"
                }
                
                unique_sentences = set()
                
                # Clean and split question into words
                words_in_question = []
                for word in re.split(r'\W+', question.lower()):
                    # Only include words that are longer than 2 characters and not in skip_words
                    if len(word) > 2 and word not in skip_words:
                        words_in_question.append(word)
                
                # If no meaningful words left, return default message
                if not words_in_question:
                    return "Imi pare rau, dar nu am fost antrenat sa raspund la aceasta cerere. Voi primi actualizari constante."
                
                # Search for sentences containing meaningful words
                sentences = [s.strip() for s in self.info_text.split('.') if s.strip()]
                
                for sentence in sentences:
                    sentence_words = set(re.split(r'\W+', sentence.lower()))
                    
                    # Check if any meaningful word from question is in sentence
                    if any(word in sentence_words for word in words_in_question):
                        # Additional check: make sure the sentence has some substantial content
                        sentence_meaningful_words = [w for w in sentence_words if len(w) > 2 and w not in skip_words]
                        if len(sentence_meaningful_words) >= 3:  # Sentence must have at least 3 meaningful words
                            unique_sentences.add(sentence.strip())
                
                # Return results or default message
                if unique_sentences:
                    return '. '.join(unique_sentences) + '.'
                else:
                    return "Imi pare rau, dar nu am fost antrenat sa raspund la aceasta cerere. Voi primi actualizari constante."

        class EfficientChatInterface:
            """Modern, efficient chat interface"""
            def __init__(self, master):
                self.master = master
                self.processor = CommandProcessor()
                self._setup_ui()

            def _setup_ui(self):
                """Setup user interface"""
                self.master.title("AI Chatbot - Muapmash model")
                self.master.configure(bg="gray20")
                self.master.geometry("900x700")
                
                # Main container
                main_frame = tk.Frame(self.master, bg="gray20")
                main_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
                
                # Title
                title_label = tk.Label(
                    main_frame,
                    text="AI Chatbot - Muapmash model",
                    bg="gray20",
                    fg="#00ff88",
                    font=("Roboto", 16, "bold")
                )
                title_label.pack(pady=(0, 15))
                
                # Chat history with better styling and proper wrapping
                chat_frame = tk.Frame(main_frame, bg="gray20")
                chat_frame.pack(fill=tk.BOTH, expand=True)
                
                self.chat_history = scrolledtext.ScrolledText(
                    chat_frame,
                    wrap=tk.WORD,  # This ensures text wraps at word boundaries
                    bg="gray10",
                    fg="#ccff66",
                    font=("Roboto", 10),
                    state=tk.DISABLED,
                    relief=tk.FLAT,
                    bd=0,
                    insertbackground="cyan",
                    selectbackground="gray40"
                )
                self.chat_history.pack(fill=tk.BOTH, expand=True)
                
                # Input frame
                input_frame = tk.Frame(main_frame, bg="gray20")
                input_frame.pack(fill=tk.X, pady=(15, 0))
                
                # Input label
                input_label = tk.Label(
                    input_frame,
                    text="Ask a question:",
                    bg="gray20",
                    fg="cyan",
                    font=("Roboto", 11, "bold")
                )
                input_label.pack(anchor="w", pady=(0, 5))
                
                # Input field container - Changed to Text widget for better wrapping
                entry_frame = tk.Frame(input_frame, bg="gray40", relief=tk.FLAT, bd=1)
                entry_frame.pack(fill=tk.X)
                
                # Replace Entry with Text widget for multi-line input with wrapping
                self.input_field = tk.Text(
                    entry_frame,
                    bg="gray40",
                    fg="#ccff66",
                    insertbackground="cyan",
                    font=("Roboto", 12),
                    relief=tk.FLAT,
                    bd=10,
                    highlightthickness=0,
                    wrap=tk.WORD,  # Enable word wrapping
                    height=3,  # Set initial height to 3 lines
                    undo=True,  # Enable undo functionality
                    maxundo=20
                )
                self.input_field.pack(fill=tk.BOTH, padx=2, pady=2)
                
                # Button frame
                button_frame = tk.Frame(input_frame, bg="gray20")
                button_frame.pack(fill=tk.X, pady=(10, 0))
                
                # Send button
                self.send_button = tk.Button(
                    button_frame,
                    text="Send",
                    command=self.send_message,
                    bg="#0066cc",
                    fg="white",
                    font=("Roboto", 11, "bold"),
                    relief=tk.FLAT,
                    bd=0,
                    padx=20,
                    pady=8,
                    cursor="hand2",
                    activebackground="#66ff66",
                    activeforeground="white"
                )
                self.send_button.pack(side=tk.LEFT)
                
                # Clear button
                clear_button = tk.Button(
                    button_frame,
                    text="Clear",
                    command=self.clear_chat,
                    bg="#cc3300",
                    fg="white",
                    font=("Roboto", 11, "bold"),
                    relief=tk.FLAT,
                    bd=0,
                    padx=20,
                    pady=8,
                    cursor="hand2",
                    activebackground="#66ff66",
                    activeforeground="white"
                )
                clear_button.pack(side=tk.LEFT, padx=(10, 0))
                
                # Status label
                self.status_label = tk.Label(
                    main_frame,
                    text="Ready - Type your question above",
                    bg="gray20",
                    fg="#66ff99",
                    font=("Roboto", 9)
                )
                self.status_label.pack(pady=(10, 0))
                
                # Bind events
                self.input_field.bind('<Return>', self.on_enter_key)
                self.input_field.bind('<Control-Return>', self.insert_newline)
                self.master.bind('<F1>', lambda e: self.show_help())
                
                # Focus on input field
                self.input_field.focus_set()
                
                # Add welcome message
                self.add_to_chat("AI Assistant", "Hello! I'm your AI assistant. I can help you with system commands, network operations, and much more. Type your question and press Enter to send, or Ctrl+Enter for a new line.", "assistant")

            def on_enter_key(self, event):
                """Handle Enter key - send message if Shift not pressed"""
                if event.state & 0x1:  # Shift key pressed
                    return  # Allow normal newline
                else:
                    self.send_message()
                    return "break"  # Prevent default newline

            def insert_newline(self, event):
                """Insert newline when Ctrl+Enter is pressed"""
                self.input_field.insert(tk.INSERT, '\n')
                return "break"

            def send_message(self):
                """Send message and get response"""
                question = self.input_field.get("1.0", tk.END).strip()
                if not question:
                    return
                
                # Clear input field
                self.input_field.delete("1.0", tk.END)
                
                # Update status
                self.status_label.config(text="Processing...", fg="yellow")
                self.master.update()
                
                # Add user message to chat
                self.add_to_chat("You", question, "user")
                
                try:
                    # Process command
                    response = self.processor.process_command(question)
                    self.add_to_chat("AI Assistant", response, "assistant")
                    self.status_label.config(text="Response completed", fg="#66ff99")
                except Exception as e:
                    error_msg = f"Error processing command: {str(e)}"
                    self.add_to_chat("AI Assistant", error_msg, "error")
                    self.status_label.config(text="Error occurred", fg="#ff6666")

            def add_to_chat(self, sender, message, msg_type):
                """Add message to chat history with better formatting"""
                self.chat_history.config(state=tk.NORMAL)
                
                # Add timestamp
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                # Color scheme based on message type
                if msg_type == "user":
                    sender_color = "#66ccff"
                    text_color = "#ccff66"
                elif msg_type == "assistant":
                    sender_color = "#00ff88"
                    text_color = "#ffffff"
                else:  # error
                    sender_color = "#ff6666"
                    text_color = "#ffcccc"
                
                # Add sender with timestamp
                self.chat_history.insert(tk.END, f"\n[{timestamp}] {sender}:\n", "sender")
                
                # Add message content with proper wrapping
                self.chat_history.insert(tk.END, f"{message}\n", "message")
                
                # Configure tags for colors
                self.chat_history.tag_config("sender", foreground=sender_color, font=("Arial", 10, "bold"))
                self.chat_history.tag_config("message", foreground=text_color, font=("Consolas", 10))
                
                # Add separator
                self.chat_history.insert(tk.END, "─" * 80 + "\n", "separator")
                self.chat_history.tag_config("separator", foreground="gray50")
                
                # Auto-scroll to bottom
                self.chat_history.see(tk.END)
                self.chat_history.config(state=tk.DISABLED)

            def clear_chat(self):
                """Clear chat history"""
                self.chat_history.config(state=tk.NORMAL)
                self.chat_history.delete(1.0, tk.END)
                self.chat_history.config(state=tk.DISABLED)
                self.status_label.config(text="Chat cleared", fg="#66ff99")
                
                # Re-add welcome message
                self.add_to_chat("AI Assistant", "Chat cleared! Ready for new questions.", "assistant")

            def show_help(self):
                """Show help information"""
                help_text = """
    AVAILABLE COMMANDS:

    SYSTEM INFORMATION:
    • "servicetag" / "show servicetag" - Get system service tag
    • "windows key" / "product key" - Get Windows license key  
    • "system info" - Display system information

    POWER MANAGEMENT:
    • "shutdown" / "inchide pc" - Shutdown system
    • "restart" / "restarteaza" - Restart system
    • "logout" - Log out current user

    SYSTEM TOOLS:
    • "device manager" / "devmgmt" - Open Device Manager
    • "power plan" / "battery" - Open Power Options
    • "control panel" - Open Programs and Features
    • "domain" / "sysdm" - Open System Properties

    NETWORK:
    • "show devices on network" - Display network devices
    • "show wifi passwords" - Display all saved WiFi passwords

    GENERAL:
    • F1 - Show this help
    • Enter - Send message
    • Ctrl+Enter - New line in message
    • Clear button - Clear chat history

    Type your question in Romanian or English!
                """
                self.add_to_chat("AI Assistant", help_text, "assistant")

        # Create and run the application
        rootai = tk.Tk()
        app = EfficientChatInterface(rootai)
        
        try:
            rootai.mainloop()
        except KeyboardInterrupt:
            print("\nApplication closed by user")
        except Exception as e:
            print(f"Application error: {e}")

    # Run the chatbot
    if __name__ == "__main__":
        AIChatbot()

if notepadvar == 21:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox, colorchooser, font
    from tkinter.scrolledtext import ScrolledText
    import os
    import re
    import webbrowser
    import pygments
    from pygments.lexers import get_lexer_by_name, get_all_lexers
    from pygments.styles import get_all_styles
    from pygments.token import Token

    class LineNumberedText(tk.Frame):
        def __init__(self, parent, *args, **kwargs):
            tk.Frame.__init__(self, parent)
            self.text = ScrolledText(self, *args, **kwargs)
            self.line_numbers = tk.Text(self, width=4, padx=4, bg='#f0f0f0', bd=0,
                                   highlightthickness=0, takefocus=0)
            self.line_numbers.tag_configure('line_numbers', justify='right')
            
            self.text.grid(row=0, column=1, sticky="nsew")
            self.line_numbers.grid(row=0, column=0, sticky="nsew")
            
            self.text.bind('<KeyRelease>', self.on_key_release)
            self.text.bind('<ButtonRelease-1>', self.on_key_release)
            self.text.bind('<MouseWheel>', self.on_key_release)
            self.text.bind('<Configure>', self.on_key_release)
            
            self.columnconfigure(1, weight=1)
            self.rowconfigure(0, weight=1)
            
            # Initial line numbers update
            self.on_key_release()
            
        def on_key_release(self, event=None):
            self.update_line_numbers()
            
        def update_line_numbers(self):
            line_count = self.text.get('1.0', tk.END).count('\n')
            if line_count <= 0:
                line_count = 1
                
            line_number_content = '\n'.join(str(i) for i in range(1, line_count + 1))
            self.line_numbers.config(state=tk.NORMAL)
            self.line_numbers.delete('1.0', tk.END)
            self.line_numbers.insert('1.0', line_number_content)
            self.line_numbers.config(state=tk.DISABLED)
            
            # Sync scrolling
            self.line_numbers.yview_moveto(self.text.yview()[0])
            
        def highlight_line(self, line_number, bg_color='#e0e0e0'):
            self.text.tag_remove('active_line', '1.0', tk.END)
            self.text.tag_add('active_line', f'{line_number}.0', f'{line_number + 1}.0')
            self.text.tag_config('active_line', background=bg_color)

    class SyntaxHighlighter:
        def __init__(self, text_widget):
            self.text = text_widget
            self.current_lexer = None
            self.current_style = 'default'
            self.token_tags = {}
            self._setup_tags()
            
        def _setup_tags(self):
            # Configure tags for different token types
            self.token_tags = {
                Token.Keyword: 'keyword',
                Token.String: 'string',
                Token.Name.Function: 'function',
                Token.Name.Class: 'class',
                Token.Comment: 'comment',
                Token.Number: 'number',
                Token.Operator: 'operator',
                Token.Name.Builtin: 'builtin',
                Token.Literal: 'literal',
                Token.String.Doc: 'docstring',
                Token.Name.Decorator: 'decorator',
            }
            
            # Default styling
            self.text.tag_configure('keyword', foreground='#0000FF', font=('Courier New', 10, 'bold'))
            self.text.tag_configure('string', foreground='#A31515')
            self.text.tag_configure('function', foreground='#795E26')
            self.text.tag_configure('class', foreground='#267f99', font=('Courier New', 10, 'bold'))
            self.text.tag_configure('comment', foreground='#008000', font=('Courier New', 10, 'italic'))
            self.text.tag_configure('number', foreground='#098658')
            self.text.tag_configure('operator', foreground='#000000')
            self.text.tag_configure('builtin', foreground='#0000FF')
            self.text.tag_configure('literal', foreground='#A31515')
            self.text.tag_configure('docstring', foreground='#008000', font=('Courier New', 10, 'italic'))
            self.text.tag_configure('decorator', foreground='#AF00DB')
        
        def set_lexer(self, language):
            try:
                self.current_lexer = get_lexer_by_name(language)
                return True
            except pygments.util.ClassNotFound:
                self.current_lexer = None
                return False
        
        def set_style(self, style_name):
            try:
                style = pygments.styles.get_style_by_name(style_name)
                self.current_style = style_name
                
                # Update tag configurations based on the style
                for token_type, tag_name in self.token_tags.items():
                    if token_type in style:
                        style_attrs = style.style_for_token(token_type)
                        fg = style_attrs['color']
                        bg = style_attrs['bgcolor']
                        bold = style_attrs['bold']
                        italic = style_attrs['italic']
                        
                        kwargs = {}
                        if fg:
                            kwargs['foreground'] = f'#{fg}'
                        if bg:
                            kwargs['background'] = f'#{bg}'
                            
                        font_style = ('Courier New', 10)
                        if bold and italic:
                            font_style = ('Courier New', 10, 'bold italic')
                        elif bold:
                            font_style = ('Courier New', 10, 'bold')
                        elif italic:
                            font_style = ('Courier New', 10, 'italic')
                            
                        kwargs['font'] = font_style
                        self.text.tag_configure(tag_name, **kwargs)
                
                return True
            except pygments.util.ClassNotFound:
                return False
        
        def highlight(self):
            if not self.current_lexer:
                return
                
            # Remove all existing tags
            for tag in self.token_tags.values():
                self.text.tag_remove(tag, '1.0', tk.END)
                
            # Get text content
            content = self.text.get('1.0', tk.END)
            
            # Tokenize text using pygments
            tokens = pygments.lex(content, self.current_lexer)
            
            # Apply tags for each token
            pos = 0
            for token_type, value in tokens:
                # Find all token types that match
                for token_pattern, tag_name in self.token_tags.items():
                    if token_type in token_pattern:
                        start_index = f"1.0+{pos}c"
                        end_index = f"1.0+{pos + len(value)}c"
                        self.text.tag_add(tag_name, start_index, end_index)
                        break
                pos += len(value)


    class FindReplaceDialog(tk.Toplevel):
        def __init__(self, parent, text_widget):
            super().__init__(parent)
            self.text = text_widget
            self.title("Find & Replace")
            self.geometry("400x150")
            self.resizable(False, False)
            
            # Variables
            self.find_var = tk.StringVar()
            self.replace_var = tk.StringVar()
            self.case_sensitive_var = tk.BooleanVar()
            self.whole_word_var = tk.BooleanVar()
            self.regex_var = tk.BooleanVar()
            
            # Create UI
            ttk.Label(self, text="Find:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            ttk.Entry(self, textvariable=self.find_var, width=30).grid(row=0, column=1, padx=5, pady=5)
            
            ttk.Label(self, text="Replace:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
            ttk.Entry(self, textvariable=self.replace_var, width=30).grid(row=1, column=1, padx=5, pady=5)
            
            options_frame = ttk.Frame(self)
            options_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="w")
            
            ttk.Checkbutton(options_frame, text="Case sensitive", variable=self.case_sensitive_var).pack(side=tk.LEFT)
            ttk.Checkbutton(options_frame, text="Whole word", variable=self.whole_word_var).pack(side=tk.LEFT)
            ttk.Checkbutton(options_frame, text="Regular expression", variable=self.regex_var).pack(side=tk.LEFT)
            
            button_frame = ttk.Frame(self)
            button_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5)
            
            ttk.Button(button_frame, text="Find Next", command=self.find_next).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Replace", command=self.replace).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Replace All", command=self.replace_all).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Close", command=self.destroy).pack(side=tk.LEFT, padx=5)
            
            self.last_search_pos = "1.0"
            self.found_items = []
            self.current_match = -1
            
        def find_next(self):
            search_str = self.find_var.get()
            if not search_str:
                return
                
            start_pos = self.text.index(tk.INSERT)
            
            # Remove previous highlights
            self.text.tag_remove('search_highlight', '1.0', tk.END)
            
            search_kwargs = {"nocase": not self.case_sensitive_var.get()}
            
            if self.regex_var.get():
                # Use regex search
                content = self.text.get('1.0', tk.END)
                flags = 0 if self.case_sensitive_var.get() else re.IGNORECASE
                try:
                    pattern = re.compile(search_str, flags)
                    matches = list(pattern.finditer(content))
                    
                    if not matches:
                        messagebox.showinfo("Find", "No match found")
                        return
                    
                    self.found_items = []
                    for match in matches:
                        start_idx = f"1.0+{match.start()}c"
                        end_idx = f"1.0+{match.end()}c"
                        self.found_items.append((start_idx, end_idx))
                        self.text.tag_add('search_highlight', start_idx, end_idx)
                    
                    self.current_match = (self.current_match + 1) % len(self.found_items)
                    self.text.tag_config('search_highlight', background='yellow')
                    self.text.see(self.found_items[self.current_match][0])
                    self.text.mark_set(tk.INSERT, self.found_items[self.current_match][0])
                    
                except re.error as e:
                    messagebox.showerror("Regex Error", f"Invalid regular expression: {e}")
            else:
                # Use normal search
                found_pos = self.text.search(search_str, start_pos, **search_kwargs)
                if not found_pos:
                    # Try from the beginning if not found
                    found_pos = self.text.search(search_str, '1.0', **search_kwargs)
                    
                if not found_pos:
                    messagebox.showinfo("Find", "No match found")
                    return
                    
                end_pos = f"{found_pos}+{len(search_str)}c"
                self.text.tag_add('search_highlight', found_pos, end_pos)
                self.text.tag_config('search_highlight', background='yellow')
                self.text.see(found_pos)
                self.text.mark_set(tk.INSERT, found_pos)
                self.last_search_pos = end_pos
        
        def replace(self):
            search_str = self.find_var.get()
            replace_str = self.replace_var.get()
            
            if not search_str:
                return
                
            # First find the current occurrence
            self.find_next()
            
            # Then replace if found
            try:
                sel_start = self.text.index(tk.SEL_FIRST)
                sel_end = self.text.index(tk.SEL_LAST)
                self.text.delete(sel_start, sel_end)
                self.text.insert(sel_start, replace_str)
            except tk.TclError:
                # No selection, do nothing
                pass
        
        def replace_all(self):
            search_str = self.find_var.get()
            replace_str = self.replace_var.get()
            
            if not search_str:
                return
                
            # Start from the beginning
            self.text.mark_set(tk.INSERT, '1.0')
            count = 0
            
            if self.regex_var.get():
                # Use regex replace all
                content = self.text.get('1.0', tk.END)
                flags = 0 if self.case_sensitive_var.get() else re.IGNORECASE
                try:
                    pattern = re.compile(search_str, flags)
                    new_content, count = pattern.subn(replace_str, content)
                    if count > 0:
                        self.text.delete('1.0', tk.END)
                        self.text.insert('1.0', new_content)
                    messagebox.showinfo("Replace All", f"{count} occurrences replaced")
                except re.error as e:
                    messagebox.showerror("Regex Error", f"Invalid regular expression: {e}")
            else:
                # Use normal search and replace
                search_kwargs = {"nocase": not self.case_sensitive_var.get()}
                current_pos = '1.0'
                
                while True:
                    found_pos = self.text.search(search_str, current_pos, tk.END, **search_kwargs)
                    if not found_pos:
                        break
                        
                    end_pos = f"{found_pos}+{len(search_str)}c"
                    self.text.delete(found_pos, end_pos)
                    self.text.insert(found_pos, replace_str)
                    current_pos = f"{found_pos}+{len(replace_str)}c"
                    count += 1
                    
                messagebox.showinfo("Replace All", f"{count} occurrences replaced")


    class ThemeManager:
        def __init__(self, editor):
            self.editor = editor
            self.current_theme = "default"
            
            # Define themes
            self.themes = {
                "default": {
                    "background": "#FFFFFF",
                    "foreground": "#000000",
                    "line_numbers_bg": "#F0F0F0",
                    "line_numbers_fg": "#000000",
                    "cursor": "#000000",
                    "selection_bg": "#ADD6FF",
                    "active_line_bg": "#E8F2FE",
                    "font": ("Courier New", 10),
                },
                "dark": {
                    "background": "#1E1E1E",
                    "foreground": "#D4D4D4",
                    "line_numbers_bg": "#252526",
                    "line_numbers_fg": "#858585",
                    "cursor": "#AEAFAD",
                    "selection_bg": "#264F78",
                    "active_line_bg": "#282828",
                    "font": ("Courier New", 10),
                },
                "monokai": {
                    "background": "#272822",
                    "foreground": "#F8F8F2",
                    "line_numbers_bg": "#3E3D32",
                    "line_numbers_fg": "#90908A",
                    "cursor": "#F8F8F0",
                    "selection_bg": "#49483E",
                    "active_line_bg": "#3E3D32",
                    "font": ("Courier New", 10),
                },
                "solarized_light": {
                    "background": "#FDF6E3",
                    "foreground": "#657B83",
                    "line_numbers_bg": "#EEE8D5",
                    "line_numbers_fg": "#839496",
                    "cursor": "#586E75",
                    "selection_bg": "#EEE8D5",
                    "active_line_bg": "#EEE8D5",
                    "font": ("Courier New", 10),
                },
                "solarized_dark": {
                    "background": "#002B36",
                    "foreground": "#839496",
                    "line_numbers_bg": "#073642",
                    "line_numbers_fg": "#586E75",
                    "cursor": "#93A1A1",
                    "selection_bg": "#073642",
                    "active_line_bg": "#073642",
                    "font": ("Courier New", 10),
                }
            }
        
        def apply_theme(self, theme_name):
            if theme_name not in self.themes:
                return False
                
            theme = self.themes[theme_name]
            self.current_theme = theme_name
            
            # Apply theme to text editor
            self.editor.text.config(
                background=theme["background"],
                foreground=theme["foreground"],
                insertbackground=theme["cursor"],
                selectbackground=theme["selection_bg"],
                font=theme["font"]
            )
            
            # Apply theme to line numbers
            self.editor.line_numbers.config(
                background=theme["line_numbers_bg"],
                foreground=theme["line_numbers_fg"],
                font=theme["font"]
            )
            
            # Apply theme to active line highlighting
            self.editor.text.tag_config('active_line', background=theme["active_line_bg"])
            
            return True
        
        def add_custom_theme(self, name, settings):
            self.themes[name] = settings
            
        def get_theme_names(self):
            return list(self.themes.keys())


    class AdvancedNotepad:
        def __init__(self, rootntpadd):
            self.rootntpadd = rootntpadd
            self.rootntpadd.title("Advanced Notepad")
            self.rootntpadd.geometry("1000x600")
            
            # Set application icon
            try:
                self.rootntpadd.iconbitmap("notepad.ico")  # Replace with your icon file
            except:
                pass  # Ignore if icon file is not found
                
            # Initialize variables
            self.current_file = None
            self.modified = False
            
            # Create main frame
            self.main_frame = ttk.Frame(rootntpadd)
            self.main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Create the editor with line numbers
            self.editor = LineNumberedText(self.main_frame)
            self.editor.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Set font
            default_font = font.Font(family="Courier New", size=10)
            self.editor.text.configure(font=default_font, wrap=tk.NONE, undo=True)
            
            # Initialize syntax highlighter
            self.syntax_highlighter = SyntaxHighlighter(self.editor.text)
            self.syntax_highlighter.set_lexer("python")  # Default to Python syntax
            
            # Initialize theme manager
            self.theme_manager = ThemeManager(self.editor)
            self.theme_manager.apply_theme("default")
            
            # Create menu bar - moved after theme_manager initialization
            self.create_menu_bar()
            
            # Create toolbar
            self.create_toolbar()
            
            # Create status bar
            self.status_bar = ttk.Frame(rootntpadd)
            self.status_bar.pack(fill=tk.X, side=tk.BOTTOM)
            
            self.status_text = ttk.Label(self.status_bar, text="Line: 1, Col: 0")
            self.status_text.pack(side=tk.LEFT, padx=5)
            
            self.language_label = ttk.Label(self.status_bar, text="Python")
            self.language_label.pack(side=tk.RIGHT, padx=5)
            
            # Bind events
            self.editor.text.bind("<KeyRelease>", self.on_key_release)
            self.editor.text.bind("<ButtonRelease-1>", self.update_status_bar)
            self.editor.text.bind("<Control-f>", self.show_find_dialog)
            self.editor.text.bind("<Control-h>", self.show_find_dialog)
            self.editor.text.bind("<Control-s>", self.save_file)
            self.editor.text.bind("<Control-o>", self.open_file)
            self.editor.text.bind("<Control-n>", self.new_file)
            self.editor.text.bind("<Control-w>", self.close_file)
            
            # Initial status bar update
            self.update_status_bar()
            
            # Set focus to the editor
            self.editor.text.focus_set()
            
        def create_menu_bar(self):
            menubar = tk.Menu(self.rootntpadd)
            
            # File menu
            file_menu = tk.Menu(menubar, tearoff=0)
            file_menu.add_command(label="New", accelerator="Ctrl+N", command=self.new_file)
            file_menu.add_command(label="Open", accelerator="Ctrl+O", command=self.open_file)
            file_menu.add_command(label="Save", accelerator="Ctrl+S", command=self.save_file)
            file_menu.add_command(label="Save As", command=self.save_as_file)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.exit_app)
            menubar.add_cascade(label="File", menu=file_menu)
            
            # Edit menu
            edit_menu = tk.Menu(menubar, tearoff=0)
            edit_menu.add_command(label="Undo", accelerator="Ctrl+Z", command=lambda: self.editor.text.event_generate("<<Undo>>"))
            edit_menu.add_command(label="Redo", accelerator="Ctrl+Y", command=lambda: self.editor.text.event_generate("<<Redo>>"))
            edit_menu.add_separator()
            edit_menu.add_command(label="Cut", accelerator="Ctrl+X", command=lambda: self.editor.text.event_generate("<<Cut>>"))
            edit_menu.add_command(label="Copy", accelerator="Ctrl+C", command=lambda: self.editor.text.event_generate("<<Copy>>"))
            edit_menu.add_command(label="Paste", accelerator="Ctrl+V", command=lambda: self.editor.text.event_generate("<<Paste>>"))
            edit_menu.add_separator()
            edit_menu.add_command(label="Find/Replace", accelerator="Ctrl+F", command=self.show_find_dialog)
            edit_menu.add_command(label="Select All", accelerator="Ctrl+A", command=lambda: self.editor.text.tag_add(tk.SEL, "1.0", tk.END))
            menubar.add_cascade(label="Edit", menu=edit_menu)
            
            # View menu
            view_menu = tk.Menu(menubar, tearoff=0)
            
            # Language submenu
            language_menu = tk.Menu(view_menu, tearoff=0)
            languages = sorted([lexer[0] for lexer in get_all_lexers()])
            
            # Add common languages first
            common_languages = ['Python', 'Java', 'JavaScript', 'HTML', 'CSS', 'C', 'C++', 'C#', 'PHP', 'Ruby', 'SQL', 'XML']
            for lang in common_languages:
                language_menu.add_command(label=lang, command=lambda l=lang: self.set_language(l))
                
            language_menu.add_separator()
            
            # Add all other languages
            for lang in languages:
                if lang not in common_languages:
                    language_menu.add_command(label=lang, command=lambda l=lang: self.set_language(l))
            
            view_menu.add_cascade(label="Language", menu=language_menu)
            
            # Theme submenu
            theme_menu = tk.Menu(view_menu, tearoff=0)
            for theme in self.theme_manager.get_theme_names():
                theme_menu.add_command(label=theme.replace('_', ' ').title(), 
                                     command=lambda t=theme: self.set_theme(t))
            
            view_menu.add_cascade(label="Theme", menu=theme_menu)
            view_menu.add_separator()
            
            # Font submenu
            font_menu = tk.Menu(view_menu, tearoff=0)
            font_menu.add_command(label="Font Settings", command=self.change_font)
            view_menu.add_cascade(label="Font", menu=font_menu)
            
            menubar.add_cascade(label="View", menu=view_menu)
            
            # Tools menu
            tools_menu = tk.Menu(menubar, tearoff=0)
            tools_menu.add_command(label="Word Count", command=self.word_count)
            tools_menu.add_command(label="Character Count", command=self.character_count)
            tools_menu.add_separator()
            tools_menu.add_command(label="Convert to Uppercase", command=self.convert_to_uppercase)
            tools_menu.add_command(label="Convert to Lowercase", command=self.convert_to_lowercase)
            tools_menu.add_command(label="Convert Tabs to Spaces", command=self.convert_tabs_to_spaces)
            menubar.add_cascade(label="Tools", menu=tools_menu)
            
            # Help menu
            help_menu = tk.Menu(menubar, tearoff=0)
            help_menu.add_command(label="About", command=self.show_about)
            help_menu.add_command(label="Keyboard Shortcuts", command=self.show_shortcuts)
            menubar.add_cascade(label="Help", menu=help_menu)
            
            self.rootntpadd.config(menu=menubar)
        
        def create_toolbar(self):
            toolbar_frame = ttk.Frame(self.rootntpadd)
            toolbar_frame.pack(fill=tk.X, padx=5, pady=2)
            
            ttk.Button(toolbar_frame, text="New", command=self.new_file).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Open", command=self.open_file).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Save", command=self.save_file).pack(side=tk.LEFT, padx=2)
            
            ttk.Separator(toolbar_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, padx=5, fill=tk.Y)
            
            ttk.Button(toolbar_frame, text="Cut", command=lambda: self.editor.text.event_generate("<<Cut>>")).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Copy", command=lambda: self.editor.text.event_generate("<<Copy>>")).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Paste", command=lambda: self.editor.text.event_generate("<<Paste>>")).pack(side=tk.LEFT, padx=2)
            
            ttk.Separator(toolbar_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, padx=5, fill=tk.Y)
            
            ttk.Button(toolbar_frame, text="Find", command=self.show_find_dialog).pack(side=tk.LEFT, padx=2)
            ttk.Button(toolbar_frame, text="Word Count", command=self.word_count).pack(side=tk.LEFT, padx=2)
        
        def on_key_release(self, event=None):
            self.update_status_bar()
            self.highlight_current_line()
            
            # Apply syntax highlighting
            if hasattr(self, 'syntax_highlighter') and self.syntax_highlighter.current_lexer:
                self.syntax_highlighter.highlight()
                
            # Mark as modified
            if not self.modified and event and event.char:
                self.modified = True
                self.update_title()
        
        def update_status_bar(self, event=None):
            cursor_position = self.editor.text.index(tk.INSERT)
            line, col = cursor_position.split('.')
            self.status_text.config(text=f"Line: {line}, Col: {col}")
        
        def highlight_current_line(self):
            cursor_position = self.editor.text.index(tk.INSERT)
            line = cursor_position.split('.')[0]
            self.editor.highlight_line(int(line))
        
        def update_title(self):
            filename = os.path.basename(self.current_file) if self.current_file else "Untitled"
            modified_indicator = "*" if self.modified else ""
            self.rootntpadd.title(f"{filename}{modified_indicator} - Advanced Notepad")
        
        def new_file(self, event=None):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to continue?"):
                    return
                    
            self.editor.text.delete('1.0', tk.END)
            self.current_file = None
            self.modified = False
            self.update_title()
            return "break"  # Prevent default behavior
        
        def open_file(self, event=None):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to continue?"):
                    return "break"
                    
            file_path = filedialog.askopenfilename(
                filetypes=[
                    ("All Files", "*.*"),
                    ("Text Files", "*.txt"),
                    ("Python Files", "*.py"),
                    ("HTML Files", "*.html"),
                    ("CSS Files", "*.css"),
                    ("JavaScript Files", "*.js"),
                    ("XML Files", "*.xml"),
                    ("JSON Files", "*.json"),
                    ("Markdown Files", "*.md"),
                ]
            )
            
            if file_path:
                try:
                    with open(file_path, 'r', encoding='utf-8') as file:
                        content = file.read()
                    self.editor.text.delete('1.0', tk.END)
                    self.editor.text.insert('1.0', content)
                    self.current_file = file_path
                    self.modified = False
                    self.update_title()
                    
                    # Detect language based on file extension
                    extension = os.path.splitext(file_path)[1].lower()
                    if extension == '.py':
                        self.set_language('Python')
                    elif extension == '.html':
                        self.set_language('HTML')
                    elif extension == '.css':
                        self.set_language('CSS')
                    elif extension == '.js':
                        self.set_language('JavaScript')
                    elif extension == '.xml':
                        self.set_language('XML')
                    elif extension == '.json':
                        self.set_language('JSON')
                    elif extension == '.md':
                        self.set_language('Markdown')
                        
                except Exception as e:
                    messagebox.showerror("Error", f"Could not open file: {e}")
                    
            return "break"  # Prevent default behavior
        
        def save_file(self, event=None):
            if not self.current_file:
                return self.save_as_file()
                
            try:
                with open(self.current_file, 'w', encoding='utf-8') as file:
                    file.write(self.editor.text.get('1.0', tk.END))
                self.modified = False
                self.update_title()
            except Exception as e:
                messagebox.showerror("Error", f"Could not save file: {e}")
                
            return "break"  # Prevent default behavior
        
        def save_as_file(self):
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[
                    ("All Files", "*.*"),
                    ("Text Files", "*.txt"),
                    ("Python Files", "*.py"),
                    ("HTML Files", "*.html"),
                    ("CSS Files", "*.css"),
                    ("JavaScript Files", "*.js"),
                    ("XML Files", "*.xml"),
                    ("JSON Files", "*.json"),
                    ("Markdown Files", "*.md"),
                ]
            )
            
            if file_path:
                self.current_file = file_path
                self.save_file()
                
                # Detect language based on file extension
                extension = os.path.splitext(file_path)[1].lower()
                if extension == '.py':
                    self.set_language('Python')
                elif extension == '.html':
                    self.set_language('HTML')
                elif extension == '.css':
                    self.set_language('CSS')
                elif extension == '.js':
                    self.set_language('JavaScript')
                elif extension == '.xml':
                    self.set_language('XML')
                elif extension == '.json':
                    self.set_language('JSON')
                elif extension == '.md':
                    self.set_language('Markdown')
                    
            return "break"  # Prevent default behavior
        
        def close_file(self, event=None):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to continue?"):
                    return "break"
                    
            self.editor.text.delete('1.0', tk.END)
            self.current_file = None
            self.modified = False
            self.update_title()
            return "break"  # Prevent default behavior
        
        def exit_app(self):
            if self.modified:
                if not messagebox.askyesno("Unsaved Changes", "You have unsaved changes. Do you want to exit?"):
                    return
            self.rootntpadd.destroy()
        
        def show_find_dialog(self, event=None):
            FindReplaceDialog(self.rootntpadd, self.editor.text)
            return "break"  # Prevent default behavior
        
        def set_language(self, language):
            language_map = {
                'Python': 'python',
                'Java': 'java',
                'JavaScript': 'javascript',
                'HTML': 'html',
                'CSS': 'css',
                'C': 'c',
                'C++': 'cpp',
                'C#': 'csharp',
                'PHP': 'php',
                'Ruby': 'ruby',
                'SQL': 'sql',
                'XML': 'xml',
                'JSON': 'json',
                'Markdown': 'markdown',
            }
            
            lexer_name = language_map.get(language, language.lower())
            
            if self.syntax_highlighter.set_lexer(lexer_name):
                self.language_label.config(text=language)
                self.syntax_highlighter.highlight()
            else:
                messagebox.showwarning("Language Support", f"Syntax highlighting for {language} is not available.")
        
        def set_theme(self, theme_name):
            self.theme_manager.apply_theme(theme_name)
            # Re-apply syntax highlighting
            self.syntax_highlighter.highlight()
        
        def change_font(self):
            current_font = font.Font(font=self.editor.text['font'])
            font_dialog = tk.Toplevel(self.rootntpadd)
            font_dialog.title("Font Settings")
            font_dialog.geometry("300x200")
            font_dialog.resizable(False, False)
            
            ttk.Label(font_dialog, text="Family:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            
            # Get system fonts
            font_families = sorted(list(font.families()))
            family_var = tk.StringVar(value=current_font.actual()['family'])
            family_combo = ttk.Combobox(font_dialog, textvariable=family_var, values=font_families, width=20)
            family_combo.grid(row=0, column=1, padx=5, pady=5)
            
            ttk.Label(font_dialog, text="Size:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
            size_var = tk.IntVar(value=current_font.actual()['size'])
            size_combo = ttk.Combobox(font_dialog, textvariable=size_var, values=list(range(8, 25)), width=5)
            size_combo.grid(row=1, column=1, padx=5, pady=5, sticky="w")
            
            # Bold and italic checkboxes
            bold_var = tk.BooleanVar(value='bold' in current_font.actual()['weight'])
            italic_var = tk.BooleanVar(value='italic' in current_font.actual()['slant'])
            
            ttk.Checkbutton(font_dialog, text="Bold", variable=bold_var).grid(row=2, column=0, padx=5, pady=5, sticky="w")
            ttk.Checkbutton(font_dialog, text="Italic", variable=italic_var).grid(row=2, column=1, padx=5, pady=5, sticky="w")
            
            # Preview
            preview_frame = ttk.LabelFrame(font_dialog, text="Preview")
            preview_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
            
            preview_text = tk.Text(preview_frame, height=3, width=30)
            preview_text.insert('1.0', "AaBbCcXxYyZz 123456")
            preview_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            def update_preview():
                weight = 'bold' if bold_var.get() else 'normal'
                slant = 'italic' if italic_var.get() else 'roman'
                preview_font = font.Font(family=family_var.get(), size=size_var.get(), weight=weight, slant=slant)
                preview_text.configure(font=preview_font)
                
            family_combo.bind("<<ComboboxSelected>>", lambda e: update_preview())
            size_combo.bind("<<ComboboxSelected>>", lambda e: update_preview())
            bold_var.trace_add("write", lambda *args: update_preview())
            italic_var.trace_add("write", lambda *args: update_preview())
            
            update_preview()  # Initial preview update
            
            def apply_font():
                weight = 'bold' if bold_var.get() else 'normal'
                slant = 'italic' if italic_var.get() else 'roman'
                new_font = font.Font(family=family_var.get(), size=size_var.get(), weight=weight, slant=slant)
                self.editor.text.configure(font=new_font)
                self.editor.line_numbers.configure(font=new_font)
                font_dialog.destroy()
                
            button_frame = ttk.Frame(font_dialog)
            button_frame.grid(row=4, column=0, columnspan=2, padx=5, pady=5)
            
            ttk.Button(button_frame, text="Apply", command=apply_font).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Cancel", command=font_dialog.destroy).pack(side=tk.LEFT, padx=5)
        
        def word_count(self):
            text = self.editor.text.get('1.0', tk.END)
            words = len(text.split())
            lines = len(text.splitlines())
            chars = len(text)
            messagebox.showinfo("Statistics", f"Words: {words}\nLines: {lines}\nCharacters: {chars}")
        
        def character_count(self):
            text = self.editor.text.get('1.0', tk.END)
            chars = len(text) - 1  # Subtract one for the final newline
            chars_no_spaces = len(text.replace(" ", "").replace("\n", "").replace("\t", ""))
            messagebox.showinfo("Character Count", f"Characters (with spaces): {chars}\nCharacters (without spaces): {chars_no_spaces}")
        
        def convert_to_uppercase(self):
            try:
                if self.editor.text.tag_ranges(tk.SEL):
                    selected_text = self.editor.text.get(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.delete(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.insert(tk.INSERT, selected_text.upper())
            except tk.TclError:
                # No selection, convert all text
                text = self.editor.text.get('1.0', tk.END)
                self.editor.text.delete('1.0', tk.END)
                self.editor.text.insert('1.0', text.upper())
        
        def convert_to_lowercase(self):
            try:
                if self.editor.text.tag_ranges(tk.SEL):
                    selected_text = self.editor.text.get(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.delete(tk.SEL_FIRST, tk.SEL_LAST)
                    self.editor.text.insert(tk.INSERT, selected_text.lower())
            except tk.TclError:
                # No selection, convert all text
                text = self.editor.text.get('1.0', tk.END)
                self.editor.text.delete('1.0', tk.END)
                self.editor.text.insert('1.0', text.lower())
        
        def convert_tabs_to_spaces(self):
            text = self.editor.text.get('1.0', tk.END)
            text = text.replace("\t", "    ")  # Replace tabs with 4 spaces
            self.editor.text.delete('1.0', tk.END)
            self.editor.text.insert('1.0', text)
        
        def show_about(self):
            about_dialog = tk.Toplevel(self.rootntpadd)
            about_dialog.title("About Advanced Notepad")
            about_dialog.geometry("400x300")
            about_dialog.resizable(False, False)
            
            about_text = """Advanced Notepad

    Version 1.0

    Features:
    - Syntax highlighting for multiple languages
    - Line numbering
    - Multiple themes
    - Find and replace with regex support
    - Code folding
    - And more!

    """
            
            ttk.Label(about_dialog, text=about_text, justify=tk.CENTER, wraplength=380).pack(expand=True, fill=tk.BOTH, padx=10, pady=10)
            ttk.Button(about_dialog, text="Close", command=about_dialog.destroy).pack(pady=10)
        
        def show_shortcuts(self):
            shortcuts_dialog = tk.Toplevel(self.rootntpadd)
            shortcuts_dialog.title("Keyboard Shortcuts")
            shortcuts_dialog.geometry("400x400")
            
            shortcuts_text = """
    Keyboard Shortcuts:

    File Operations:
      Ctrl+N     New File
      Ctrl+O     Open File
      Ctrl+S     Save File
      Ctrl+W     Close File

    Edit Operations:
      Ctrl+Z     Undo
      Ctrl+Y     Redo
      Ctrl+X     Cut
      Ctrl+C     Copy
      Ctrl+V     Paste
      Ctrl+A     Select All
      Ctrl+F     Find/Replace

    Navigation:
      Home       Start of Line
      End        End of Line
      Ctrl+Home  Start of Document
      Ctrl+End   End of Document
      Ctrl+G     Go to Line
    """
            
            shortcuts_frame = ttk.Frame(shortcuts_dialog)
            shortcuts_frame.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)
            
            shortcuts_text_widget = tk.Text(shortcuts_frame, wrap=tk.WORD, height=20, width=40)
            shortcuts_text_widget.insert('1.0', shortcuts_text)
            shortcuts_text_widget.config(state=tk.DISABLED)
            shortcuts_text_widget.pack(expand=True, fill=tk.BOTH)
            
            ttk.Button(shortcuts_dialog, text="Close", command=shortcuts_dialog.destroy).pack(pady=10)


    if __name__ == "__main__":
        rootntpadd = tk.Tk()
        app = AdvancedNotepad(rootntpadd)
        rootntpadd.mainloop()

if paintvar == 22:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    def OpenPaint():
        from tkinter import filedialog, messagebox, colorchooser
        import PIL.ImageGrab as ImageGrab
        from PIL import Image, ImageDraw
        import PIL
        global color, image, draw  # adăugăm variabilele globale pentru imagine și obiectul draw
        color = 'black'
        Width = 600
        Height = 440

        rootpnt = Tk()

        def save():
            filename = filedialog.asksaveasfilename(initialfile="untitled.png", defaultextension=".png",
                                                    filetypes=[("PNG files", "*.png"), ("All files", "*.*")])
            if filename:
                image.save(filename)

        def change_color(c):
            global color
            color = c

        def pick_color():
            global color
            picked = colorchooser.askcolor()
            if picked[1]:
                color = picked[1]

        def drawing(event):
            x1, y1 = (event.x - 1), (event.y - 1)
            x2, y2 = (event.x + 1), (event.y + 1)
            canvas.create_oval((x1, y1, x2, y2), fill=color, outline=color, width=vertical.get())
            draw.ellipse([x1, y1, x2 + vertical.get(), y2 + vertical.get()], outline=color, fill=color)

        def on_closing():
            answer = messagebox.askyesnocancel("QUIT", "DO YOU WANT TO SAVE YOUR WORK?", parent=rootpnt)
            if answer is not None:
                if answer:
                    save()
                rootpnt.destroy()

        def new_canvas():
            canvas.delete('all')
            draw.rectangle([0, 0, Width, Height], fill='white')

        rootpnt.title("Paint")
        rootpnt.geometry('600x550')
        rootpnt.resizable(False, False)
        rootpnt.configure(bg='black')
        rootpnt.protocol("WM_DELETE_WINDOW", on_closing)

        frame = Frame(rootpnt, bg='white')
        color_frame = Frame(frame, bg='black', borderwidth=10)

        menu_bar = Menu(rootpnt)
        rootpnt.config(menu=menu_bar)
        submenu = Menu(menu_bar, tearoff=0)

        menu_bar.add_cascade(label='File', menu=submenu)
        submenu.add_command(label='New Canvas', command=new_canvas)
        submenu.add_command(label='Save', command=save)

        colors = ['black', 'grey', 'brown', 'orange', 'yellow', 'red', 'green', 'turquoise', 'indigo', 'purple', 'blue',
                  'white', 'lime', 'pink', 'gold', 'cyan']
        buttons = []

        for i, col in enumerate(colors):
            button = Button(color_frame, bg=col, width=1, command=lambda col=col: change_color(col))
            buttons.append(button)
            button.grid(row=i // 11, column=i % 11)

        vertical = Scale(frame, from_=1, to=25, label='Size')
        vertical.set(3)

        erase_but = Button(frame, text='Erase', command=lambda: change_color('white'))
        color_but = Button(frame, text='Color', command=pick_color)

        canvas = Canvas(rootpnt, bg='white', width=Width, height=Height)
        canvas.bind('<B1-Motion>', drawing)

        image = Image.new("RGB", (Width, Height), 'white')  # Inițializăm imaginea cu fundal alb
        draw = ImageDraw.Draw(image)

        frame.grid(row=0, column=0, sticky='nsew')
        color_frame.grid(row=0, column=0, padx=20)
        vertical.grid(row=0, column=1)
        erase_but.grid(row=0, column=2, padx=20)
        color_but.grid(row=0, column=3)

        canvas.grid(row=1, column=0)

        # Centralize Window
        rootpnt.update()
        window_width = rootpnt.winfo_width()
        window_height = rootpnt.winfo_height()
        screen_width = rootpnt.winfo_screenwidth()
        screen_height = rootpnt.winfo_screenheight()
        x = int((screen_width / 2) - (window_width / 2))
        y = int((screen_height / 2) - (window_height / 2))
        rootpnt.geometry(f"{window_width}x{window_height}+{x}+{y}")

        rootpnt.mainloop()
    OpenPaint()

if Adm1var == 30:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    import sys
    import re
    import keyword
    from tkinter import font
    import importlib
    import gc
    import webbrowser
    from os.path import expanduser
    import tkinter.scrolledtext as tkst
    import configparser

    # configuration.py
    def create_default_ini_file(file_path):
        if not os.path.exists(file_path):
            mopad_ini_content = """
    [Run]
    mate = mate-terminal -x sh -c "python3 {}; exec bash"
    gnome = gnome-terminal -- sh -c "python3 {}; exec bash"
    kde = konsole --hold -e "python3 {}"
    xterm = xterm -hold -e "python3 {}"
    windows = start cmd /K python {}
    mac = open -a Terminal ./python3 {}

    [Terminal]
    mate = mate-terminal
    gnome = gnome-terminal
    kde = konsole
    xterm = xterm
    windows = start cmd
    mac = open -a Terminal ./

    [Interpreter]
    mate = mate-terminal -x "python3"
    gnome = gnome-terminal -- "python3"
    kde = konsole -e python3
    xterm = xterm python3
    windows = start cmd /K python
    mac = open -a Terminal ./python3

    [System]
    system = windows

    [Password]
    password = 
    """
            with open(file_path, 'w') as config_file:
                config_file.write(mopad_ini_content)

    # Verifică și creează fișierul ini implicit dacă nu există
    create_default_ini_file('mopad.ini')

    # Continuă cu citirea și procesarea configurației din fișierul ini
    config = configparser.ConfigParser()
    config.read('mopad.ini')

    # Extrage și procesează configurația așa cum ai făcut anterior
    # (Exemplu de utilizare config)
    current_system = config['System'].get('system', 'windows')
    print(f"System: {current_system}")

    class Configuration():
        
        def __init__(self):
            
            self.config = configparser.ConfigParser()
            file = self.getDir()
            
            self.config.read(file)
            
        def getDir(self):
            path = os.path.realpath(__file__)      # Pfad ermitteln
            
            basename = self.checkPath(os.path.dirname(path))
            path = basename + '/mopad.ini'
            
            return path
            
        def getRun(self, system):
            return self.config['Run'][system]
        
        def getTerminal(self, system):
            return self.config['Terminal'][system]
        
        def getInterpreter(self, system):
            return self.config['Interpreter'][system]
        
        def getSystem(self):
            return self.config['System']['system']
        
        def getTab(self):
            return self.config['Tab']['tab']
        
        def getFontSize(self):
            return self.config['Size']['size']
        
        def setSystem(self, system):
            self.config['System']['system'] = system

            path = os.path.realpath(__file__)    
            basename = self.checkPath(os.path.dirname(path))

            iniPath = basename + "/mopad.ini"
            
            with open(iniPath, 'w') as f:
                self.config.write(f)

        def setStandard(self):
            config = configparser.ConfigParser()
            
            config['Run'] = {}
            config['Run']['mate'] = 'mate-terminal -x sh -c "python3 {}; exec bash"'
            config['Run']['gnome'] = 'gnome-terminal -- sh -c "python3 {}; exec bash"'
            config['Run']['kde'] = 'konsole --hold -e "python3 {}"'
            config['Run']['xterm'] = 'xterm -hold -e "python3 {}"'
            config['Run']['windows'] = 'start cmd /K python {}'
            config['Run']['mac'] = 'open -a Terminal ./python3 {}'
            
            config['Terminal'] = {}
            config['Terminal']['mate'] = 'mate-terminal'
            config['Terminal']['gnome'] = 'gnome-terminal'
            config['Terminal']['kde'] = 'konsole'
            config['Terminal']['xterm'] = 'xterm'
            config['Terminal']['windows'] = 'start cmd'
            config['Terminal']['mac'] = 'open -a Terminal ./' 
            
            config['Interpreter'] = {}
            config['Interpreter']['mate'] = 'mate-terminal -x "python3"'
            config['Interpreter']['gnome'] = 'gnome-terminal -- "python3"'
            config['Interpreter']['kde'] = 'konsole -e python3'
            config['Interpreter']['xterm'] = 'xterm python3'
            config['Interpreter']['windows'] = 'start cmd /K python'
            config['Interpreter']['mac'] = 'open -a Terminal ./python3'
            
            config['System'] = {}
            config['System']['system'] = ''
            
            config['Tab'] = {}
            config['Tab']['tab'] = '4'
            
            config['Size'] = {}
            config['Size']['size'] = '13'
            
            return config


        def checkPath(self, path):
            if '\\' in path:
                path = path.replace('\\', '/')
            return path


    #if __name__ == '__main__':
    c = Configuration()

    system = c.getSystem()
    runCommand = c.getRun(system)
    terminalCommand = c.getTerminal(system)
    interpreterCommand = c.getInterpreter(system)
        
    #c.setSystem('gnome')  
     
    print(system + ':\n' + runCommand + '\n' + terminalCommand + '\n' + interpreterCommand) 
        



    class TextLineNumbers(tk.Canvas):
        '''
            Canvas for Linenumbers
        '''
        def __init__(self, *args, **kwargs):
            tk.Canvas.__init__(self, *args, **kwargs)
            self.textwidget = None
            self.font_size = 14
            self.configFont()

            
        def configFont(self):
            '''font for linenumbers'''
            system = platform.system().lower()
            if system == "windows":
                self.font = font.Font(family='monospace', size=self.font_size)
            elif system == "linux":
                self.font = font.Font(family='monospace', size=self.font_size)
            else:
                self.font = font.Font(family='monospace', size=self.font_size)


        def attach(self, text_widget):
            self.textwidget = text_widget

        def redraw(self, *args):
            '''redraw line numbers'''
            self.delete("all")

            i = self.textwidget.index("@0,0")
            while True :
                dline= self.textwidget.dlineinfo(i)
                if dline is None: break
                y = dline[1]
                linenum = str(i).split(".")[0]
                self.create_text(1,y,anchor="nw", font=self.font, text=linenum, fill='white')
                i = self.textwidget.index("%s+1line" % i)
            

    class CodeEditor(tk.Text):
        
        '''
            modified text Widget ... thanks to stackoverflow.com :)
        '''
        def __init__(self, *args, **kwargs):
            tk.Text.__init__(self, *args, **kwargs)
            
            self.tk.eval('''
                proc widget_proxy {widget widget_command args} {

                    # call the real tk widget command with the real args
                    set result [uplevel [linsert $args 0 $widget_command]]

                    # generate the event for certain types of commands
                    if {([lindex $args 0] in {insert replace delete}) ||
                        ([lrange $args 0 2] == {mark set insert}) || 
                        ([lrange $args 0 1] == {xview moveto}) ||
                        ([lrange $args 0 1] == {xview scroll}) ||
                        ([lrange $args 0 1] == {yview moveto}) ||
                        ([lrange $args 0 1] == {yview scroll})} {

                        event generate  $widget <<Change>> -when tail
                    }

                    # return the result from the real widget command
                    return $result
                }
                ''')
            self.tk.eval('''
                rename {widget} _{widget}
                interp alias {{}} ::{widget} {{}} widget_proxy {widget} _{widget}
            '''.format(widget=str(self)))
            
            # global variables
            self.filename = None
            self.tab_width = 4
            self.font_size = 14
            self.linenumber = None
            
            # make background black / foreground white
            self.config(insertbackground='#00FF00')
            self.config(background='#000000')
            self.config(foreground='#FFFFFF')
            
            # color when selection is used
            self.tag_config("sel", background="#053582", foreground="white")
            
            # config font
            self.configFont()

            # define keywords: thanks to github.comm
            # see Dvlv/Tkinter-By-Example
            self.KEYWORDS_1 = ["False", "class", "finally", "is",
                               "None", "continue", "lambda", "True", "def", "from",
                               "nonlocal", "and", "del", "global", "not", "as", 
                               "or", "yield", "assert", "import", "pass", "break",
                               "raise"]
            self.KEYWORDS_FLOW = ["if", "else", "elif", "try", "except", "for",\
                                  "in", "while", "return", "with"]

            self.SPACES_REGEX = re.compile("^\s*")
            self.STRING_REGEX_SINGLE = re.compile("'[^'\r\n]*'")
            self.STRING_REGEX_DOUBLE = re.compile('"[^"\r\n]*"')
            self.NUMBER_REGEX = re.compile(r"\b(?=\(*)\d+\.?\d*(?=\)*\,*)\b")
            self.KEYWORDS_REGEX = re.compile("(?=\(*)(?<![a-z])(None|True|False)(?=\)*\,*)")
            self.SELF_REGEX = re.compile("(?=\(*)(?<![a-z])(self)(?=\)*\,*)")
            self.FUNCTIONS_REGEX = re.compile("(?=\(*)(?<![a-z])(print|list|dict|set|int|str|float|input|range|open|tuple)(?=\()")
            self.COMMENTS_REGEX = re.compile("#[^#\r\n]*")
            
            self.REGEX_TO_TAG = {
                self.STRING_REGEX_SINGLE : "string",
                self.STRING_REGEX_DOUBLE : "string",
                self.NUMBER_REGEX : "digit",
                self.KEYWORDS_REGEX : "keywordcaps",
                self.SELF_REGEX : "keyword1",
                self.FUNCTIONS_REGEX : "keywordfunc",
                self.COMMENTS_REGEX : "comment",
            }

            self.tag_config("keyword1", foreground="#448dc4")   
            self.tag_config("keywordcaps", foreground="#CC7A00")
            self.tag_config("keywordflow", foreground="#00b402")
            self.tag_config("keywordfunc", foreground="#ddd313")
            self.tag_config("decorator", foreground="#298fb5")
            self.tag_config("digit", foreground="#ff4d4d")
            self.tag_config("string", foreground="#8e98a1")
            self.tag_config("comment", foreground="#6b6b6b")
            
            # key bindings: 
            self.bind("<KeyRelease>", self.on_key_release, add='+')
            self.bind('<KeyRelease>', self.checkBraces, add='+')
            self.bind("<Tab>", self.tab)
            self.bind('<Return>', self.indent, add='+')
            self.bind('<Return>', self.updateAutoCompleteList, add='+')
            self.bind('<Key>', self.updateAutocompleteEntry, add='+')
            self.bind('<BackSpace>', self.backtab)
            self.bind("<ButtonRelease-3>", self.textPadPopUp)
            self.bind('<Control-x>', self.cut)
            self.bind('<Control-c>', self.copy)
            self.bind('<Control-v>', self.paste)
            
            # set autocompleteList
            self.SetAutoCompleteList()
            
            # other importan variables
            self.charstring = ''
            self.list = []

        
        def tag_keywords(self, event=None, current_index=None):
            if not current_index:
                current_index = self.index(tk.INSERT)
            line_number = current_index.split(".")[0]
            line_beginning = ".".join([line_number, "0"])
            line_text = self.get(line_beginning, line_beginning + " lineend")
            line_words = line_text.split()
            number_of_spaces = self.number_of_leading_spaces(line_text)
            y_position = number_of_spaces

            for tag in self.tag_names():
                self.tag_remove(tag, line_beginning, line_beginning + " lineend")

            self.add_regex_tags(line_number, line_text)

            for word in line_words:
                stripped_word = word.strip("():,")

                word_start = str(y_position)
                word_end = str(y_position + len(stripped_word))
                start_index = ".".join([line_number, word_start])
                end_index = ".".join([line_number, word_end])

                if stripped_word in self.KEYWORDS_1:
                    self.tag_add("keyword1", start_index, end_index)
                elif stripped_word in self.KEYWORDS_FLOW:
                    self.tag_add("keywordflow", start_index, end_index)
                elif stripped_word.startswith("@"):
                    self.tag_add("decorator", start_index, end_index)

                y_position += len(word) + 1

        def tag_all_lines(self):
            final_index = self.index(tk.END)
            final_line_number = int(final_index.split(".")[0])
            
            for line_number in range(final_line_number):
                line_to_tag = ".".join([str(line_number), "0"])
                self.tag_keywords(None, line_to_tag)


        def number_of_leading_spaces(self, line):
            spaces = re.search(self.SPACES_REGEX, line)
            if spaces.group(0) is not None:
                number_of_spaces = len(spaces.group(0))
            else:
                number_of_spaces = 0

            return number_of_spaces

        def add_regex_tags(self, line_number, line_text):
            for regex, tag in self.REGEX_TO_TAG.items():
                for match in regex.finditer(line_text):
                    start, end = match.span()
                    start_index = ".".join([line_number, str(start)])
                    end_index = ".".join([line_number, str(end)])
                    self.tag_add(tag, start_index, end_index)

        def on_key_release(self, event=None):
            #print(event.keysym)
            if event.keysym in ("Up", "Down", "Left", "Right", "Shift_L", "Shift_R"):
                return
            else:
                self.tag_keywords()
            
            # look for colon in last line 
            if event.keysym == 'Return':
                index = self.index(tk.INSERT).split(".")
                actual_line = int(index[0])
                actual_line = self.get("%d.%d" % (actual_line, 0), "%d.end" % (actual_line))
                last_line = int(index[0]) - 1
                last_line_text = self.get("%d.%d" % (last_line, 0), "%d.end" % (last_line))
                
                # remove newline character to look after colon at end of line
                last_line_text = last_line_text.rstrip()
                # look if actual_line is only whitespace:
                actual_line = actual_line.strip(' \n')
                if last_line_text.endswith(':') and actual_line == '':
                    self.insert(tk.INSERT, self.tab_width * ' ')

        # functions for autocomplete
        def SetAutoCompleteList(self):
            '''
                basic autocompleteList with keywords and some important things (for me)
            '''
            
            self.autocompleteList = ['__init__', '__main__','__name__', '__repr__', '__str__',
                    '__dict__', 'args', 'kwargs', "self", "__file__", 'super()'] # autocomplete

            self.kwList = keyword.kwlist
            for item in self.kwList:
                self.autocompleteList.append(item)

        def updateAutoCompleteList(self, event=None):
            '''
                a simple algorithm for parsing the given text and filter important words
            '''
            self.SetAutoCompleteList()
                
            first_list = []
            second_list = []
            
            text = self.get(1.0, tk.END)
            text = text.replace("(", " ").replace(")", " ").replace\
                            ("[", " ").replace("]", " ").replace\
                            (':', " ").replace(',', " ").replace("<", " ").replace\
                            (">", " ").replace("/", " ").replace("=", " ").replace\
                            (";", " ").replace("self.", "").replace('.', ' ')
            
            first_list = text.split('\n')
            
            for row in first_list:
                if row.startswith('import '):
                    try:
                        # try to import global variables from import 
                        # -> this could be made better ... :)
                        module_name = row.replace('import' , ' ')
                        module_name = module_name.split()[0]
                        
                        module = importlib.import_module(module_name, package=None)
                        x = dir(module)

                        for elem in x:
                            if elem.startswith('_'):
                                continue
                            else:
                                second_list.append(elem)
                    
                    except Exception as e:
                        #print(str(e))
                        continue
                            
                elif row.strip().startswith('#') or row.strip().startswith('"""') or\
                   row.strip().startswith("'''"):
                    continue
                else:
                    word_list = row.split()
                    for word in word_list:
                        if re.match("(^[0-9])", word):
                            continue
                        elif '#' in word:
                            continue
                        elif word in self.kwList:
                            continue
                        elif word in self.autocompleteList:
                            continue
                        elif not len(word) < 3:
                            w = re.sub("{}<>;,:]", '', word)
                            second_list.append(w)
            
            # delete doubled entries ...
            x = set(second_list)
            second_list = list(x)

            for word in second_list:
                if len(word) > 25:
                    continue
                self.autocompleteList.append(word)
            #print()
            #print(self.autocompleteList)
            return


        def updateAutocompleteEntry(self, event=None):
            '''
                make new list for the input from the user
            '''
            char = event.char
            key = event.keycode
            sym = event.keysym
            
            # debugging ... :)
            #print(char)
            #print(key)
            
            self.list = []
            if sym in ("Up", "Down", "Left", "Right", "Space", \
                                "Control_R", "Control_L", "Alt_R", "Alt_L", \
                                "Backtab", "Return"):
                
                # set label and variables to none
                self.entry.config(text='---')
                self.list = []
                self.charstring = ''
            
            elif char in [".", "(", ")", '"', "'", ",", "="]:
                self.entry.config(text='---')
                self.list = []
                self.charstring = ''
            
            else:
                self.charstring += char
                for item in self.autocompleteList:
                    if item.startswith(self.charstring):
                        self.list.append(item)
                
                
                if self.list and len(self.charstring)>=2:
                    self.entry.config(text=self.list[0])                            
                else:
                    self.entry.config(text='---')

                if len(self.list) == 3:
                    self.entry.config(text=self.list[0])
                                


        def configFont(self):
            '''
                set the font .... tested only in windows .. if you want to make it cross platform
            '''
            system = platform.system().lower()
            if system == "windows":
                self.font = font.Font(family='Consolas', size=self.font_size)
                self.configure(font=self.font)
            elif system == "linux":
                self.font = font.Font(family='Mono', size=self.font_size)
                self.configure(font=self.font)

        def tab(self, event):
            '''
                make tab(4 * whitespaces) or insert autocomplete when using tab
            '''
            if not self.list:
                self.insert(tk.INSERT, " " * self.tab_width)
            else:
                l = len(self.charstring)
                x, y = self.index(tk.INSERT).split(".")
                y2 = int(y) - l
                y2 = str(y2)
                pos = x + '.' + y2
                self.mark_set('insert', pos)
                self.tag_add("sel", pos, '%d.%d' % (int(x), int(y)))
                self.insert(tk.INSERT, self.list[0])
                if self.tag_ranges("sel"):      # test if selection...
                    self.delete('sel.first', 'sel.last')
                
            self.charstring == ''
            self.entry.config(text='---')
            self.list = []
            
            return 'break'

        def backtab(self, event):
            '''
                make backtab when using backspace
            '''
            self.entry.config(text='---')
            self.list = []
            self.charstring = ''

            chars = self.get("insert linestart", 'insert')
            if not self.tag_ranges("sel"):
                if chars.isspace():     # only if there are whitespaces !
                    if len(chars) >= 4:
                        self.delete("insert-4c", "insert")
                        return 'break'

        def indent(self, event=None):
            '''
                make indent
            '''
            self.entry.config(text='---')
            self.list = []
            self.charstring = ''
            
            index = self.index(tk.INSERT).split(".")
            line_no = int(index[0])
            # position cursor:
            pos = int(index[1])
            
            
            self.updateAutoCompleteList()
            
            if pos == 0:
                return
            
            line_text = self.get("%d.%d" % (line_no, 0),  "%d.end" % (line_no))
            text_only = line_text.lstrip(" ")
            no_of_spaces = len(line_text) - len(text_only)
            
            # if enter was hit in a row that has leading spaces and spaces between
            # cursor and text 
            line_text_cursor = self.get("%d.%d" % (line_no, pos), "%d.end" % (line_no))
            spaces_betweeen = line_text_cursor.lstrip(" ")
            spaces_betweeen = spaces_betweeen.rstrip(" ")
            leading_spaces = len(line_text_cursor) - len(spaces_betweeen)
            #print(leading_spaces)
            
            # if so: delete them for a nice editing feeling
            if leading_spaces:
                no_of_spaces -= leading_spaces

            spaces = '\n' + " " * no_of_spaces
            
            self.insert(tk.INSERT, spaces)
            self.see(self.index(tk.INSERT)) 
            
            # on Return ends:
            return 'break'

        def checkBraces(self, event=None):
            'check braces, paren, brackets '
            key = event.keycode
            sym = event.keysym
            
            line = int(self.index(tk.INSERT).split('.')[0])
            line_text = self.get("%d.%d" % (line, 0), "%d.end" % (line))
            
            self.tag_configure("braceHighlight", foreground="red")
            self.tag_configure('parenHighlight', foreground='red')
            self.tag_configure('bracketHighlight', foreground='red')
            
            # paren ()
            if sym == 'parenleft':
                x = self.isBalancedParen(line_text)
                if x == False:
                    z = line_text.rfind('(')
                else:
                    z = False
                
                if z:
                    self.tag_add("parenHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('parenHighlight', "%d.0"%(line), '%d.end'%(line))
            
            elif sym == 'parenright':
                x = self.isBalancedParen(line_text)
                if x == False:
                    z = line_text.rfind(')')
                else:
                    z = False
                
                if z:
                    self.tag_add("parenHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('parenHighlight', "%d.0"%(line), '%d.end'%(line))
            
            # bracket []
            elif sym == 'bracketleft':
                x = self.isBalancedBracket(line_text)
                if x == False:
                    z = line_text.rfind('[')
                else:
                    z = False
                
                if z:
                    self.tag_add("bracketHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('bracketHighlight', "%d.0"%(line), '%d.end'%(line))
            
            elif sym == 'bracketright':
                x = self.isBalancedBracket(line_text)
                if x == False:
                    z = line_text.rfind(']')
                else:
                    z = False
                
                if z:
                    self.tag_add("bracketHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('bracketHighlight', "%d.0"%(line), '%d.end'%(line))
            
            # brace {}
            elif sym == 'braceleft':
                x = self.isBalancedBrace(line_text)
                if x == False:
                    z = line_text.rfind('{')
                else:
                    z = False
                
                if z:
                    self.tag_add("braceHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('braceHighlight', "%d.0"%(line), '%d.end'%(line))
            
            elif sym == 'braceright':
                x = self.isBalancedBrace(line_text)
                if x == False:
                    z = line_text.rfind('}')
                else:
                    z = False
                
                if z:
                    self.tag_add("braceHighlight", "%d.%d"%(line, z), "%d.%d"%(line, z+1)) 
                else:
                    self.tag_remove('braceHighlight', "%d.0"%(line), '%d.end'%(line))


            else:
                return

        def isBalancedParen(self, txt):
            braced = 0
            for ch in txt:
                if ch == '(': braced += 1
                if ch == ')':
                    braced -= 1
                    if braced < 0: return False
            return braced == 0

        def isBalancedBracket(self, txt):
            braced = 0
            for ch in txt:
                if ch == '[': braced += 1
                if ch == ']':
                    braced -= 1
                    if braced < 0: return False
            return braced == 0

        def isBalancedBrace(self, txt):
            braced = 0
            for ch in txt:
                if ch == '{': braced += 1
                if ch == '}':
                    braced -= 1
                    if braced < 0: return False
            return braced == 0

        def textPadPopUp(self, event):
            menu = tk.Menu(self, tearoff=False, background='#000000',foreground='white',
                    activebackground='blue', activeforeground='white')
            menu.add_command(label="Undo", compound=tk.LEFT, command=self.undo)
            menu.add_command(label="Redo", compound=tk.LEFT, command=self.redo)
            menu.add_separator()
            menu.add_command(label='Cut', compound=tk.LEFT, command=self.cut)
            menu.add_command(label="Copy", compound=tk.LEFT, command=self.copy)
            menu.add_command(label="Paste", compound=tk.LEFT, command=self.paste)
            menu.add_separator()
            menu.add_command(label="Select All", compound=tk.LEFT, command=self.selectAll)
            menu.add_separator()
            menu.add_command(label="Open Terminal", compound=tk.LEFT, command = self.terminal)
            menu.tk_popup(event.x_root, event.y_root, 0)
        
        def undo(self, event=None):
            try:
                self.edit_undo()
                self.highlightAll()
            except:
                return
        
        def redo(self, event=None):
            try:
                self.edit_redo()
                self.highlightAll()
            except:
                return
        
        def cut(self, event=None):
            self.event_generate("<<Cut>>")
            self.tag_keywords()
            return 'break'
        
        def copy(self, event=None):
            self.event_generate("<<Copy>>")
            self.tag_keywords()
            return 'break'
            
        def paste(self, event=None):
            self.event_generate("<<Paste>>")
            #self.tag_keywords()
            self.highlightAll()
            return 'break'
        
        def selectAll(self, event=None):
            self.tag_add('sel', '1.0', 'end')
        
        def goto(self, event=None):
            pass
        
        def terminal(self, event=None):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            terminalCommand = c.getTerminal(system)
            
            subprocess.call(terminalCommand, shell=True)
        
        def highlightAll(self):
            final_index = self.index(tk.END)
            final_line_number = int(final_index.split(".")[0])

            for line_number in range(final_line_number):
                line_to_tag = ".".join([str(line_number), "0"])
                self.tag_keywords(None, line_to_tag)



    class CodeeditorFrame(ttk.Frame):
        '''
            Codeeditor + Linenumber Frame
        '''

        def __init__(self, master=None):
            super().__init__(master)
            self.pack(expand=True, fill=tk.BOTH)
            self.initUI()

        def initUI(self):
            
            # frame1
            frame1 = ttk.Frame(self)
            frame1.pack(fill=tk.BOTH, expand=True)
            
            # autocompleteEntry (packed on bottom)
            self.autocompleteEntry = ttk.Label(frame1, text='---', font=('Mono', 14))
            self.autocompleteEntry.pack(side='bottom', fill='y')
            
            # scrollbar y
            textScrollY = ttk.Scrollbar(frame1, orient=tk.VERTICAL)
            textScrollY.config(cursor="double_arrow")
            textScrollY.pack(side=tk.RIGHT, fill=tk.Y)
            
            # in tkinter it is important what to pack first (!)
            self.linenumber = TextLineNumbers(frame1, width=45, bg='#000000')
            self.linenumber.pack(side="left", fill="y")
            
            # scrollbar x (packed on bottom)
            textScrollX = ttk.Scrollbar(frame1, orient=tk.HORIZONTAL)
            textScrollX.config(cursor="sb_h_double_arrow")
            textScrollX.pack(side=tk.BOTTOM, fill=tk.X)

            self.textPad = CodeEditor(frame1, undo=True, maxundo=-1, 
                                      autoseparators=True, wrap='none')
            self.textPad.filename = None
            self.textPad.pack(side=tk.TOP, expand=True, fill=tk.BOTH)

            textScrollY.config(command=self.textPad.yview)
            textScrollX.config(command=self.textPad.xview)
            self.textPad.configure(yscrollcommand=textScrollY.set)
            self.textPad.configure(xscrollcommand=textScrollX.set)
            self.linenumber.attach(self.textPad)


            self.textPad.entry = self.autocompleteEntry
            self.textPad.linenumber = self.linenumber
            
            self.textPad.bind("<<Change>>", self.on_change)
            self.textPad.bind("<Configure>", self.on_change)


        def on_change(self, event):
            self.linenumber.redraw()


    #if __name__ == '__main__':
    root = tk.Tk()
    root['bg'] = 'black'
        
    app = CodeeditorFrame()
        
    app.mainloop()
        

    class Dialog(tk.Toplevel):

        def __init__(self, parent, title=None):

            super().__init__(parent)
            self.transient(parent)

            if title:
                self.title(title)

            self.parent = parent

            self.result = None

            body = ttk.Frame(self)
            self.initial_focus = self.body(body)
            body.pack(padx=5, pady=5)

            self.buttonbox()


            if not self.initial_focus:
                self.initial_focus = self

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

            self.initial_focus.focus_set()
            
            # make background black 
            self.configure(bg='#000000')
            
            # no borders ?
            #self.overrideredirect(1)
            
            self.wait_window(self)


        def body(self, master):
            # create dialog body.  return widget that should have
            # initial focus.  this method should be overridden
            pass

        def buttonbox(self):
            # add standard button box. override if you don't want the
            # standard buttons

            box = ttk.Frame(self)
            #box.configure(bg='black')
            
            w = ttk.Button(box, text="OK", width=10, command=self.ok, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            w = ttk.Button(box, text="Cancel", width=10, command=self.cancel)
            w.pack(side=tk.LEFT, padx=5, pady=5)

            #self.bind("<Return>", self.ok)
            #self.bind("<Escape>", self.cancel)

            box.pack()

        def ok(self, event=None):

            if not self.validate():
                self.initial_focus.focus_set() # put focus back
                return

            self.withdraw()
            self.update_idletasks()

            self.apply()

            self.cancel()

        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

        def validate(self):

            return 1 # override

        def apply(self):

            pass # override

        def CheckPath(self, path):
            if '\\' in path:
                path = path.replace('\\', '/')
            return path

    #########################################################
    class NewDirectoryDialog(Dialog):
        
        def body(self, master):
            # get configuration 
            
            # make body
            ttk.Label(master, text="Name of directory:").grid(row=0)
            
            self.e1 = tk.Entry(master)
            self.e1 = tk.Entry(master, bg='black', fg='white')
            self.e1.configure(cursor="xterm green")
            self.e1.configure(insertbackground = "red")
            self.e1.configure(highlightcolor='#448dc4')
            self.e1.grid(row=0, column=1, sticky='nsew')
            
            return self.e1 # initial focus

        def apply(self):
            name = self.e1.get()
            dir = self.CheckPath(os.getcwd())
            dir += '/' + name
            os.mkdir(dir)




    ############################################################

    class RenameDialog(Dialog):
        
        def __init__(self, parent, title=None, item=None):
            self.item = item
            super().__init__(parent, title)
        
        def body(self, master):

            # make body
            ttk.Label(master, text='Current name: ').grid(row=1, column=0)
            ttk.Label(master, text=self.item).grid(row=1, column=1)
            ttk.Label(master, text="New name: ").grid(row=2)
            
            self.e1 = tk.Entry(master)
            self.e1 = tk.Entry(master, bg='black', fg='white')
            self.e1.configure(cursor="xterm green")
            self.e1.configure(insertbackground = "red")
            self.e1.configure(highlightcolor='#448dc4')
            self.e1.grid(row=2, column=1, sticky='nsew')
            
            return self.e1 # initial focus

        def apply(self):
            self.result = 1
            lastName = self.getLastName(self.item)
            cwd = self.CheckPath(os.getcwd()) + '/'
            
            oldFullPath = cwd + lastName 
            
            new = self.e1.get()
            
            newFullPath = cwd + new
            
            try:
                os.rename(oldFullPath, newFullPath)
            except Exception as e:
                print(str(e))
            
        def getLastName(self, item):
            # get LastName
            if item.startswith('>'):
                item = item.replace('> ', '')
                if ('/') in item:
                    item = item.split('/')[-1]
                return item
            elif item.startswith('/'):
                item = item.split('/')[-1]
                return item
            else:
                return item


    #############################################################

    class MessageDialog(Dialog):
        def __init__(self, parent, title, text=None):
            self.text = text
            super().__init__(parent, title)
        
        def body(self, master):
            label1 = ttk.Label(master, text=self.text)
            label1.configure(style="White.TLabel")
            label1.pack()
            
            return label1
        
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            b1 = ttk.Button(box, text="Ok", width=10, command=self.cancel, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()
            

        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.parent.focus_set()
            self.destroy()


    #############################################################


    class MessageYesNoDialog(Dialog):
        def __init__(self, parent, title, text=None):
            self.text = text
            super().__init__(parent, title)
        
        def body(self, master):
            label1 = ttk.Label(master, text=self.text)
            label1.configure(style="White.TLabel")
            label1.pack()
            
            return label1
        
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            b1 = ttk.Button(box, text="Yes", width=10, command=self.apply, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)
            b2 = ttk.Button(box, text="No", width=10, command=self.cancel, default=tk.ACTIVE)
            b2.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()

        def apply(self, event=None):
            self.result = 1
            self.parent.focus_set()
            self.destroy()
            

        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.parent.focus_set()
            self.destroy()


    class InfoDialog(Dialog):

        def __init__(self, parent, title, text, directory, file, size):
            self.text = text
            self.directory = directory
            self.file = file
            self.size = size
            super().__init__(parent, title)

        def body(self, master):
            label1 = ttk.Label(master, text=' ' + self.text + ' ')
            label1.configure(style="Red.TLabel")
            label1.pack()
            label1b = ttk.Label(master, text=' ')
            label1b.configure(style="White.TLabel")
            label1b.pack()
            

        
            if self.directory:
                label2a = ttk.Label(master, text='Type: directory\n', anchor=tk.W)
                label2a.configure(style="White.TLabel")
                label2a.pack()
            else:
                label2a = ttk.Label(master, text='Type: file\n', anchor=tk.W)
                label2a.configure(style="White.TLabel")
                label2a.pack()
            if self.file:
                label3a = ttk.Label(master, text='Size: ' + str(self.size) + ' bytes\n', anchor=tk.W)
                label3a.configure(style="White.TLabel")
                label3a.pack()
                
            return label1
        
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            w = ttk.Button(box, text="OK", width=10, command=self.cancel, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            box.pack()


        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

    #############################################################
    class HelpDialog(Dialog):
        def __init__(self, parent, title):
            super().__init__(parent, title)
        
        def body(self, master):
            tabControl = ttk.Notebook(master)
            
            ##
            # Tab What is
            ##
            tab1 = ttk.Frame(tabControl)
            tabControl.add(tab1, text='What is CrossViper ?')
            tabControl.pack(expand=1, fill='both')
            
            readonlyWhatIs = tkst.ScrolledText(tab1, bg='black', fg='white', wrap='none')
            readonlyWhatIs.pack()
            
            textWhatIs = '''
            MoPad - Morten's cross platform Python Pad
            
            Mopad is an Editor for the "Python Programming Language".
            
            It shows the "python source code" colored (syntax highlighting) and 
            helps you to code with its own auto-complete function.
            
            It can run the codefile (requirement is, that you have installed 
            Python on your OS)
            It can also run the "Python Interpreter" and a terminal window 
            (specific for your current OS) -> this can be modified in the 
            settings (-> which where saved in mopad.ini => it's a text file)
            
            On the bottom-right, you find two buttons => one for searching the 
            current file and the other to analyse the code 
            (-> shows you the classes and functions)
            
            On the left side it has its own file-explorer to 
            copy, delete, rename ... files and folders. Use the pop-up menu
            (right mousebutton).
            '''
            
            readonlyWhatIs.insert(1.0, textWhatIs)
            readonlyWhatIs.configure(state='disabled')


            ##
            # Tab Shortcut
            ##
            
            tab2 = ttk.Frame(tabControl)
            tabControl.add(tab2, text='Shortcuts')
            tabControl.pack(expand=1, fill='both')
            
            readonlyShortcuts = tkst.ScrolledText(tab2, bg='black', fg='white', wrap='none')
            readonlyShortcuts.pack()

            
            textShortcut = '''
            Shortcuts:
            
            New File        -       Ctrl + N
            Open File       -       Ctrl + O
            Save File       -       Ctrl + S
            SaveAs          -       Ctrl + Shift + S
            Print to File   -       Ctrl + P
            Quit Mopad      -       Alt + F4
            Undo            -       Ctrl + Z
            Redo            -       Ctrl + Shift + Z
            Copy            -       Ctrl + C
            Cut             -       Ctrl + X
            Paste           -       Ctrl + V
            Select All      -       Ctrl + A
            Change Tab      -       Alt + Right
            Autocomplete    -       Tab
            Search          -       Ctrl + F
            Class Overview  -       Ctrl + G
            Show Settings   -       F12
            Zoom In         -       Alt + Up
            Zoom Out        -       Alt + Down
            Set Cursor      -       Ctrl + Left / Ctrl + Right
            Show Help       -       F1
            
            '''
            
            readonlyShortcuts.insert(1.0, textShortcut)
            readonlyShortcuts.configure(state='disabled')

            ##
            # Tab About
            ##
            tab3 = ttk.Frame(tabControl)
            tabControl.add(tab3, text='About')
            tabControl.pack(expand=1, fill='both')
            
            readonlyAbout = tkst.ScrolledText(tab3, bg='black', fg='white', wrap='none')
            readonlyAbout.pack()

            textAbout = '''
            Complex IDE - cross platform Python Pad
            
            
            Programmed 2024 by Tudor Marmureanu     
            '''
            readonlyAbout.insert(1.0, textAbout)
            readonlyAbout.configure(state='disabled')

            
            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            w = ttk.Button(box, text="OK", width=10, command=self.cancel, default=tk.ACTIVE)
            w.pack(side=tk.BOTTOM, padx=5, pady=5)
            box.pack()
            buttonbox = tk.Frame(self)

        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

    #############################################################
    class GotoDialog(Dialog):
        def __init__(self, parent, title=None):
            self.Pad = parent
            super().__init__(parent, title)

        def body(self, master):
            # make body
            ttk.Label(master, text="Goto Linenumber:").grid(row=0)
            
            #self.e1 = tk.Entry(master)
            
            index = int(self.Pad.index("end-1c linestart").split('.')[0])
            
            var = tk.StringVar()
            var.set("1")
            self.spinbox = tk.Spinbox(master, from_= 1, to=index, textvariable=var, bg='black', fg='white', width=5)
            self.spinbox.grid(row=0, column=1, sticky='nsew')
            self.spinbox.configure(cursor="xterm green")
            self.spinbox.configure(insertbackground = "red")
            self.spinbox.configure(highlightcolor='#448dc4')
            self.spinbox.configure(buttonbackground='green')
            self.spinbox.selection('range', tk.INSERT, tk.END)
            
            return self.spinbox # initial focus

        def buttonbox(self):
            # add standard button box. override if you don't want the
            # standard buttons

            box = ttk.Frame(self)

            w = ttk.Button(box, text="OK", width=10, command=self.apply, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            w = ttk.Button(box, text="Cancel", width=10, command=self.cancel)
            w.pack(side=tk.LEFT, padx=5, pady=5)


            box.pack()
            

        def apply(self, event=None):
            number = self.spinbox.get()
            if number.isnumeric():
                number = int(number)
            else:
                return
            
            #print('number', number)
            
            try:
                self.Pad.mark_set("insert", "%d.0" % (number))
            except Exception as e:
                print(str(e))
                
            self.Pad.see(tk.INSERT)
            self.Pad.focus_set()
            
            self.cancel()
            
        
        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()


    #############################################################

    class SettingsDialog(Dialog):
        
        def body(self, master):
            # get configuration 
            self.master = master
            self.c = Configuration()        # in configuration.py
            self.system = self.c.getSystem()
            self.runCommand = self.c.getRun(self.system)
            self.terminalCommand = self.c.getTerminal(self.system)
            self.interpreterCommand = self.c.getInterpreter(self.system)
            self.master.grid_columnconfigure(1, weight=1)
                
            self.title('Settings')
            
            # make body
            ttk.Label(master, text="Run:").grid(row=0)
            ttk.Label(master, text="Terminal:").grid(row=1)
            ttk.Label(master, text="Interpreter:").grid(row=2)
            
            self.v = tk.IntVar()
            if self.c.getSystem() == 'mate':
                self.v.set(1)
            elif self.c.getSystem() == 'gnome':
                self.v.set(2)
            elif self.c.getSystem() == 'kde':
                self.v.set(3)
            elif self.c.getSystem() == 'xterm':
                self.v.set(4)
            elif self.c.getSystem() == 'windows':
                self.v.set(5)
            elif self.c.getSystem() == 'mac':
                self.v.set(6)

            
            self.e1 = tk.Entry(master, bg='black', fg='white', width=40)
            self.e1.configure(cursor='left_ptr')
            self.e1.configure(insertbackground = "red")
            self.e1.configure(highlightcolor='#448dc4')
            self.e1Label = ttk.Label(master, text = '{} = Filename')
            #self.e1Label.configure(style='White.TLabel')

            self.e2 = tk.Entry(master, bg='black', fg='white', width=40)
            self.e2.configure(cursor='left_ptr')
            self.e2.configure(insertbackground = "red")
            self.e2.configure(highlightcolor='#448dc4')

            self.e3 = tk.Entry(master, bg='black', fg='white', width=40)
            self.e3.configure(cursor='left_ptr')
            self.e3.configure(insertbackground = "red")
            self.e3.configure(highlightcolor='#448dc4')

            
            

            self.mate_radio = ttk.Radiobutton(master, text='Mate', variable=self.v,
                                            command=self.setMate, value=1)
            self.gnome_radio = ttk.Radiobutton(master, text='Gnome', variable=self.v,
                                            command=self.setGnome, value=2)
            self.kde_radio = ttk.Radiobutton(master, text='KDE', variable=self.v,
                                            command=self.setKDE, value=3)
            self.xterm_radio = ttk.Radiobutton(master, text='xterm', variable=self.v,
                                            command=self.setXterm, value=4)
            self.win_radio = ttk.Radiobutton(master, text='Windows', variable=self.v,
                                            command=self.setWindows, value=5)
            self.mac_radio = ttk.Radiobutton(master, text='MacOS', variable=self.v,
                                            command=self.setMac, value=6)



            self.e1.grid(row=0, column=1, sticky='ew')
            self.e1.insert(0, self.runCommand)
            self.e1Label.grid(row=0, column=2, sticky='ew')
            self.e2.grid(row=1, column=1, sticky='ew')
            self.e2.insert(0, self.terminalCommand)
            self.e3.grid(row=2, column=1, sticky='ew')
            self.e3.insert(0, self.interpreterCommand)
            self.mate_radio.grid(row=3, column=0)
            self.gnome_radio.grid(row=3, column=1)
            self.kde_radio.grid(row=3, column=2)
            self.xterm_radio.grid(row=4, column=0)
            self.win_radio.grid(row=4, column=1)
            self.mac_radio.grid(row=4, column=2)
            
            return self.e1 # initial focus
        
        def setStandard(self):
            config = configparser.ConfigParser()
            
            config['Run'] = {}
            config['Run']['mate'] = 'mate-terminal -x sh -c "python3 {}; exec bash"'
            config['Run']['gnome'] = 'gnome-terminal -- sh -c "python3 {}; exec bash"'
            config['Run']['kde'] = 'konsole --hold -e "python3 {}"'
            config['Run']['xterm'] = 'xterm -hold -e "python3 {}"'
            config['Run']['windows'] = 'start cmd /K python {}'
            config['Run']['mac'] = 'open -a Terminal ./python3 {}'
            
            config['Terminal'] = {}
            config['Terminal']['mate'] = 'mate-terminal'
            config['Terminal']['gnome'] = 'gnome-terminal'
            config['Terminal']['kde'] = 'konsole'
            config['Terminal']['xterm'] = 'xterm'
            config['Terminal']['windows'] = 'start cmd'
            config['Terminal']['mac'] = 'open -a Terminal ./' 
            
            config['Interpreter'] = {}
            config['Interpreter']['mate'] = 'mate-terminal -x "python3"'
            config['Interpreter']['gnome'] = 'gnome-terminal -- "python3"'
            config['Interpreter']['kde'] = 'konsole -e python3'
            config['Interpreter']['xterm'] = 'xterm python3'
            config['Interpreter']['windows'] = 'start cmd /K python'
            config['Interpreter']['mac'] = 'open -a Terminal ./python3'
            
            config['System'] = {}
            config['System']['system'] = ''
            
            config['Password'] = {}
            config['Password']['password'] = ''
            
            return config

        def setSystem(self, system):
            system = system
            self.runCommand = self.c.getRun(system)
            self.e1.delete(0, tk.END)
            self.e1.insert(0, self.runCommand)

            self.terminalCommand = self.c.getTerminal(system)
            self.e2.delete(0, tk.END)
            self.e2.insert(0, self.terminalCommand)

            self.interpreterCommand = self.c.getInterpreter(system)
            self.e3.delete(0, tk.END)
            self.e3.insert(0, self.interpreterCommand)


        def setMate(self, event=None):
            self.setSystem('mate')
            
        def setGnome(self, event=None):
            self.setSystem('gnome')

        def setKDE(self, event=None):
            self.setSystem('kde')

        def setXterm(self, event=None):
            self.setSystem('xterm')

        def setWindows(self, event=None):
            self.setSystem('windows')

        def setMac(self, event=None):
            self.setSystem('mac')

        def apply(self):
            value = self.v.get()
            config = self.setStandard()
            
            if value == 1:
                config['System']['system'] = 'mate'
                config['Run']['mate'] = self.e1.get()
                config['Terminal']['mate'] = self.e2.get()
                config['Interpreter']['mate'] = self.e3.get()
        
            elif value == 2:
                config['System']['system'] = 'gnome'
                config['Run']['gnome'] = self.e1.get()
                config['Terminal']['gnome'] = self.e2.get()
                config['Interpreter']['gnome'] =self.e3.get()

            elif value == 3:
                config['System']['system'] = 'kde'
                config['Run']['kde'] = self.e1.get()
                config['Terminal']['kde'] = self.e2.get()
                config['Interpreter']['kde'] = self.e3.get()

            elif value == 4:
                config['System']['system'] = 'xterm'
                config['Run']['xterm'] = self.e1.get()
                config['Terminal']['xterm'] = self.e2.get()
                config['Interpreter']['xterm'] = self.e3.get()

            elif value == 5:
                config['System']['system'] = 'windows'
                config['Run']['windows'] = self.e1.get()
                config['Terminal']['windows'] = self.e2.get()
                config['Interpreter']['windows'] = self.e3.get()

            elif value == 6:
                config['System']['system'] = 'mac'
                config['Run']['mac'] = self.e1.get()
                config['Terminal']['mac'] = self.e2.get()
                config['Interpreter']['mac'] = self.e3.get()

            else:
                return
            
            if getattr(sys, 'frozen', False):
                thisFile = os.path.realpath(sys._MEIPASS)
            else:
                thisFile = os.path.realpath(__file__)      # Pfad ermitteln

            base = os.path.dirname(thisFile)
            base = self.CheckPath(base)

            iniPath = base + "/mopad.ini"
            with open(iniPath, 'w') as f:
                config.write(f)
            


    #########################################################

    class ViewDialog(tk.Toplevel):
        def __init__(self, parent, title=None, textPad=None):

            super().__init__(parent)
            self.transient(parent)
            self.textPad = textPad
            self.configure(bg='black')

            if title:
                self.title(title)

            self.parent = parent

            self.result = None

            body = ttk.Frame(self)
            self.initial_focus = self.body(body)
            body.pack(padx=5, pady=5)

            self.buttonbox()

            self.grab_set()

            if not self.initial_focus:
                self.initial_focus = self

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

            
            self.work()


            self.initial_focus.focus_set()
            self.wait_window(self)
            
            

        def body(self, master):
            self.treeview = ttk.Treeview(self)
            self.treeview.pack()
            self.treeview.bind('<Double-1>', self.OnActivated)

            self.treeview.tag_configure('class', background='black', foreground='yellow')
            self.treeview.tag_configure('function', background='black', foreground='#448dc4')
            self.treeview.tag_configure('something', background='black', foreground='gray')

            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            w = ttk.Button(box, text="OK", width=10, command=self.cancel, default=tk.ACTIVE)
            w.pack(side=tk.LEFT, padx=5, pady=5)
            box.pack()


        def cancel(self, event=None):

            # put focus back to the parent window
            self.parent.focus_set()
            self.destroy()

        def work(self):
            if not self.textPad:
                self.cancel()
            if self.textPad.filename == None or self.textPad.filename == 'noname':
                filename = 'noname'

            if self.textPad.filename:
                filename = self.textPad.filename.split('/')[-1]
            
            if not filename:
                self.cancel()
            
            self.treeview.heading('#0', text=filename)
            self.treeview.column('#0', stretch=tk.YES, minwidth=350, width=350)
            self.i = 0
            
            #filename = self.textPad.filename
            
            textLines = self.textPad.get('1.0', 'end-1c')
            lines = textLines.split('\n')
                        
            self.AddTreeNodes(lines)
            
            #self.treeview.Bind(xxxxx)


        def AddTreeNodes(self, text):
            self.findLine = {}
            x = 0
            for line in text:
                x += 1
                y = 0
                whitespaces = len(line) - len(line.lstrip())
                if 'class' in line:
                    l = line.lstrip()
                    #print(l)
                    if l.startswith('class'):
                        node = self.treeview.insert('', 'end', text=line, tags='class')
                        key = '_class_' + line
                        self.findLine[key] = x
                    
                        for secondLine in text[x:]:
                            whitespacesSecond = len(secondLine) - len(secondLine.lstrip())
                            y += 1
                            newClass = False
                            if newClass == False:
                                if 'class' in secondLine:
                                    l = secondLine.lstrip()
                                    if l.startswith('#'):
                                        continue
                                    newClass = True
                                    key = ''
                                    break
                                elif 'def' in secondLine:
                                    l = secondLine.lstrip()
                                    if l.startswith('def'):
                                        if l.startswith('#'):
                                            continue
                                        else:
                                            if whitespaces < whitespacesSecond:
                                                self.treeview.insert(node, 'end', text=secondLine, tags='function')
                                                key += secondLine
                                                self.findLine[key] = x+y
                                                key = '_class_' + line
                                            else:
                                                break
                elif 'def' in line:
                    whitespaces = len(line) - len(line.lstrip())
                    if whitespaces == 0:
                        l = line.lstrip()
                        if l.startswith('def'):
                            if l.startswith('#'):
                                continue
                            else:
                                node = self.treeview.insert('', 'end', text=line, tags='function')
                                key = '_root_' + line
                                self.findLine[key] = x

                        else:
                            continue
                
                elif 'if __name__ ==' in line:
                    l = line.lstrip()
                    if l.startswith('if __name__'):
                        node = self.treeview.insert('', 'end', line, tags='something')
                        key = '_root_' + line
                        self.findLine[key] = x
            
            #print(self.findLine)

        def OnActivated(self, event):
            item = self.treeview.identify('item', event.x, event.y)
            label =  self.treeview.item(item, "text")

            if label == '':
                self.textPad.mark_set('insert', '1.0')
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()
                return
            
            key = ''
            searchKey = ''
        
            if 'class' in label and 'def' not in label:
                key = '_class_' + label
                z = self.findLine[key]
                self.textPad.mark_set('insert', "%d.0" %(z))
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()

            elif 'def' in label:
                childLabel = label
                
                info = self.treeview.get_children()
                self.nodeList = []
                for i in info:
                    #print(i)
                    if i.startswith('I'):
                        self.nodeList.append(i)
                #print(':', self.nodeList)
                parentLabel = None
                for i in self.nodeList:
                    if i < item:
                        parentLabel = self.treeview.item(i, 'text')
                
                if parentLabel == None:
                    searchKey = '_root_' + childLabel
                    #print('searchKey:' , searchKey)
                    z = self.findLine[searchKey]
                    self.textPad.mark_set('insert', "%d.0" %(z))
                    self.textPad.see(tk.INSERT)
                    self.textPad.focus_force()

                elif parentLabel:
                    if 'class' in parentLabel:
                        try:
                            searchKey = '_class_' + parentLabel
                            searchKey += childLabel
                            z = self.findLine[searchKey]
                            self.textPad.mark_set('insert', "%d.0" %(z))
                            self.textPad.see(tk.INSERT)
                            self.textPad.focus_force()
                        except:
                            #exception class ends -> change to def in _root_ 
                            searchKey = '_root_' + childLabel
                            z = self.findLine[searchKey]
                            self.textPad.mark_set('insert', "%d.0" %(z))
                            self.textPad.see(tk.INSERT)
                            self.textPad.focus_force()
      

                    else:
                        searchKey = '_root_' + childLabel
                        z = self.findLine[searchKey]
                        self.textPad.mark_set('insert', "%d.0" %(z))
                        self.textPad.see(tk.INSERT)
                        self.textPad.focus_force()
                        
            
            elif 'if __name__' in label:
                key = '_root_' + label
                z = self.findLine[key]
                self.textPad.mark_set('insert', "%d.0" %(z))
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()

    #########################################################


    class OpenFileDialog(tk.Toplevel):
        def __init__(self, parent, notebookFrame=None, title=None, text=''):
            super().__init__(parent)
            
            self.firstFilebrowser = notebookFrame.filebrowserFrame
            self.transient(parent)

            # no titlebar ... !
            #self.overrideredirect(1)
            
            self.text = text
            self.parent = parent
            
            self['bg'] = 'black'
            
            if title:
                self.title(title)
            else:
                title='Open'

            # value for get : Yes or No
            self.result = None

            body = ttk.Frame(self)
            label1 = ttk.Label(body, text=self.text)
            label1.configure(style="White.TLabel")
            label1.pack()
            
            self.filebrowserFrame = FilebrowserFrame(body)
            self.filebrowserFrame.parent = self
            
            # add this to know notebookFrame in filebrowserFrame
            self.filebrowserFrame.notebookFrame = notebookFrame
            
            self.tree = self.filebrowserFrame.tree
            self.selected = self.filebrowserFrame.selected

            #self.treeview.bind('<Double-1>', self.apply, add='+')
            #self.treeview.bind('<Return>', self.apply, add='+')
            
            self.filebrowserFrame.pack(expand=True)

            body.pack(padx=5, pady=5)

            self.buttonbox()

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))
           
            self.tree.focus()
           
            # make dialog modal
            self.focus_force() 
            self.grab_set()

        def buttonbox(self):
            box = ttk.Frame(self)
            b1 = ttk.Button(box, text="Close", width=10, command=self.apply, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()

        def apply(self, event=None):
            self.result = 1
                    
            self.parent.focus_set()
            self.firstFilebrowser.refreshTree()
            self.destroy()
            
                
        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.parent.focus_set()
            self.firstFilebrowser.refreshTree()
            self.destroy()


    #########################################################
    class SaveFileDialog(tk.Toplevel):
        def __init__(self, parent, title=None, text=''):

            super().__init__(parent)
            self.transient(parent)
            
            self.text = text
            self.filename = None
            
            if title:
                self.title(title)
            else:
                title='Save'

            self.parent = parent
            self.text = text
            
            # value for get : Yes or No
            self.result = None

            body = ttk.Frame(self)
            label1 = ttk.Label(body, text=self.text)
            label1.configure(style="White.TLabel")

            self.treeview = ttk.Treeview(body)
            self.treeview.tag_configure('row', background='black', foreground='white')
            self.treeview.tag_configure('folder', background='black', foreground='yellow')
            self.treeview.tag_configure('subfolder', background='black', foreground='#448dc4')
            self.treeview.tag_configure('hidden', background='black', foreground='gray')
            
            self.treeview['show'] = 'tree'
            self.treeview.bind("<Double-1>", self.OnDoubleClickTreeview)
            self.treeview.bind("<Button-1>", self.OnClickTreeview)
            self.treeview.bind('<<TreeviewSelect>>', self.on_select)

            
            self.filenameBox = tk.Entry(self, bg='black', fg='white')
            self.filenameBox.configure(cursor="xterm green")
            self.filenameBox.configure(insertbackground = "red")
            self.filenameBox.configure(highlightcolor='#448dc4')
            self.filenameBox.bind("<Return>", self.apply)

            
            
            path = self.checkPath(os.getcwd())
            abspath = os.path.abspath(path)
            
            root_node = self.treeview.insert('', 'end', text=abspath, open=True, tags='folder')
            self.process_directory(root_node, abspath)


            body.pack(padx=5, pady=5)
            label1.pack()
            self.treeview.pack(expand=True)
            self.filenameBox.pack()

            self.buttonbox()

            self.protocol("WM_DELETE_WINDOW", self.cancel)

            self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                      parent.winfo_rooty()+50))

            self.configure(bg='black')
            
            # variable fpr selected item
            self.selected = None
            
            self.wait_window(self)

        def refreshTree(self):
            for i in self.treeview.get_children():
                self.treeview.delete(i)
            path = '.'
            abspath = os.path.abspath(path)
            root_node = self.treeview.insert('', 'end', text=abspath, open=True, tags='folder')
            self.process_directory(root_node, abspath)

            
        def process_directory(self, parent, path):
            try:
                l = []
                for p in os.listdir(path):
                    abspath = os.path.join(path, p)
                    isdir = os.path.isdir(abspath)

                    if isdir:
                        item = '> /' + str(p)
                        l.append(item)
                        continue
                        
                    else:
                        item = str(p)
                        l.append(item)
                    
                    # list sort ...
                l.sort()
                #l.reverse()
                
                for items in l:
                    if items.startswith('>'):
                        self.treeview.insert(parent, 'end', text=str(items), open=False, tags='subfolder')
                    elif items.startswith('.'):
                        self.treeview.insert(parent, 'end', text=str(items), open=False, tags='hidden')                    
                    else:
                        self.treeview.insert(parent, 'end', text=str(items), open=False, tags='row')
           
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return
            
        def OnClickTreeview(self, event=None):
            item = self.treeview.identify('item',event.x,event.y)
            dir = self.treeview.item(item, 'text')
            self.checkPath(dir)
            
            if dir:
                if '>' in dir:
                    dir = dir.replace('> ', '')
                
            self.selected = dir
            
            
        def OnDoubleClickTreeview(self, event):
            item = self.treeview.identify('item',event.x,event.y)
            root = os.getcwd()

            
            if self.treeview.item(item, "text").startswith('>'):
                sub = self.treeview.item(item, "text").split()[1]

                dir = root + sub
                dir = self.checkPath(dir)
                try:
                    os.chdir(dir)
                except Exception as e:
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                self.selected = None
                self.refreshTree()
        
            elif '/' in self.treeview.item(item, "text") or '\\' in self.treeview.item(item, "text"):
                os.chdir('..')
                dir = self.checkPath(os.getcwd())
                self.refreshTree()
                return 'break'

            else:
                item = self.treeview.identify('item',event.x,event.y)
                obj = self.treeview.item(item, 'text')
                self.checkPath(obj)
                
                self.selected = obj
                
                if '>' in obj:
                    obj = obj.replace('> ', '')
                    os.chdir(obj)

                elif obj == root:
                    return
                


            self.refreshTree()

        def checkPath(self, path):
            if path:
                if '\\' in path:
                    path = path.replace('\\', '/')
            return path

        def on_select(self, event):
            item = self.treeview.focus()
            
            text = self.treeview.item(item, 'text')


            if text.startswith('>'):
                text = ''
            elif ('/') in text:
                text = ''
            else:
                text = self.treeview.item(item, 'text')
            
            self.filenameBox.delete(0, 'end')
            self.filenameBox.insert(0, text)

            
        def buttonbox(self):
            box = ttk.Frame(self)
            
            b1 = ttk.Button(box, text="Ok", width=10, command=self.apply, default=tk.ACTIVE)
            b1.pack(side=tk.LEFT, padx=5, pady=5)
            b2 = ttk.Button(box, text="Cancel", width=10, command=self.cancel, default=tk.ACTIVE)
            b2.pack(side=tk.LEFT, padx=5, pady=5)

            box.pack()

        def apply(self, event=None):
            self.result = 1
            
            filename = self.filenameBox.get()
            if filename:
                dir = os.getcwd()
                self.filename = dir + '/' + filename
            
            if filename == None or '/' in filename:
                self.result = 0
                self.filename = None
            
            self.parent.focus_set()
            self.destroy()
                
            
        def cancel(self, event=None):
            # put focus back to the parent window
            self.result = 0
            self.filename = None
            self.parent.focus_set()
            self.destroy()
            
    #########################################################

    class FilebrowserFrame(ttk.Frame):
        def __init__(self, parent):
            super().__init__(parent)
            self.parent = parent
            self.initUI()
            #self.initStyle()

            self.selected = []
            self.sourceItem = None
            self.destinationItem = None
            
            self.notebookFrame = None
        
        def initUI(self):
            self.config
            
            treeScrollY = ttk.Scrollbar(self, orient=tk.VERTICAL)
            treeScrollY.config(cursor="double_arrow")
            treeScrollY.pack(side=tk.RIGHT, fill=tk.Y)
            
            self.tree = ttk.Treeview(self)

            self.tree.tag_configure('pythonFile', background='black', foreground='green')
            self.tree.tag_configure('row', background='black', foreground='white')
            self.tree.tag_configure('folder', background='black', foreground='yellow')
            self.tree.tag_configure('subfolder', background='black', foreground='#448dc4')
            self.tree.tag_configure('hidden', background='black', foreground='gray')
        
            self.tree['show'] = 'tree'
            self.tree.bind("<Double-1>", self.OnDoubleClickTreeview)
            self.tree.bind("<Return>", self.OnReturnTreeview)
            self.tree.bind("<Button-1>", self.OnClickTreeview)
            self.tree.bind('<<TreeviewSelect>>', self.OnSelect)
            self.tree.bind("<ButtonRelease-3>", self.treePopUp)
            #self.tree.bind("<FocusIn>", self.refreshTree)
            
            # TreeView
            path = expanduser("~")
            os.chdir(path)
            
            
            root_node = self.tree.insert('', 'end', text=path, open=True, tags='folder')
            self.process_directory(root_node, path)

            self.tree.pack(side=tk.LEFT, expand=True, fill=tk.BOTH)

            treeScrollY.config(command=self.tree.yview)
            self.tree.configure(yscrollcommand=treeScrollY.set)
        
        def OnReturnTreeview(self, event=None):
            item = self.tree.focus()

            if self.tree.item(item, "text") == '': 

                return
            
            elif self.tree.item(item, "text").startswith('>'):
                root = os.getcwd()
                sub = self.tree.item(item, "text").split()[1]
                dir = root + sub
                dir = self.checkPath(dir)
                try:
                    os.chdir(dir)
                except Exception as e:
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                self.selected = None
                self.refreshTree()
                self.parent.title(dir)
        
            elif '/' in self.tree.item(item, "text") or '\\' in self.tree.item(item, "text"):
                os.chdir('..')
                dir = self.checkPath(os.getcwd())
                self.parent.title(dir)
                self.refreshTree()
                return 'break'

            else:
                file = self.tree.item(item,"text")
                dir = os.getcwd()
                dir = self.checkPath(dir)
                filename = dir + '/' + file
                self.tree.config(cursor="X_cursor")
                self.tree.bind('<Double-1>', self.ignore)
                
                try:
                    self.notebookFrame.new()
                    self.notebookFrame.open(filename)

                except Exception as e:

                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                    filename = self.notebookFrame.textPad.filename = None
                    self.notebookFrame.tabChanged()
                    self.notebookFrame.textPad.focus()
                    

                self.tree.config(cursor='')
                self.tree.update()
                self.parent.title(filename)
                
                # workaround 
                # step 2
                self.refreshTree()
                self.tree.update()
                self.tree.after(500, self.bindit)
            
            self.refreshTree()

        
        def OnDoubleClickTreeview(self, event=None):
            item = self.tree.identify('item',event.x,event.y)
            #print("you clicked on", self.tree.item(item,"text"))
            if self.tree.item(item, "text") == '': 

                return
            
            elif self.tree.item(item, "text").startswith('>'):
                root = os.getcwd()
                sub = self.tree.item(item, "text").split()[1]
                dir = root + sub
                dir = self.checkPath(dir)
                try:
                    os.chdir(dir)
                except Exception as e:
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                self.selected = None
                self.refreshTree()
                self.parent.title(dir)
        
            elif '/' in self.tree.item(item, "text") or '\\' in self.tree.item(item, "text"):
                os.chdir('..')
                dir = self.checkPath(os.getcwd())
                self.parent.title(dir)
                self.refreshTree()
                return 'break'

            else:
                file = self.tree.item(item,"text")
                dir = os.getcwd()
                dir = self.checkPath(dir)
                filename = dir + '/' + file
                self.tree.config(cursor="X_cursor")
                self.tree.bind('<Double-1>', self.ignore)
                
                try:
                    self.notebookFrame.new()
                    self.notebookFrame.open(filename)

                except Exception as e:

                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                    filename = self.notebookFrame.textPad.filename = None
                    self.notebookFrame.tabChanged()
                    self.notebookFrame.textPad.focus()
                    #return

                try:
                    self.tree.config(cursor='')
                    self.tree.update()
                    #self.rightPanel.textPad.mark_set("insert", "1.0")
                    self.parent.title(filename)
                    #self.rightPanel.textPad.focus_set()

                
                    # workaround 
                    # step 2
                    self.refreshTree()
                    self.tree.update()
                    self.tree.after(500, self.bindit)
                except:
                    return
            
            self.refreshTree()

        def ignore(self, event):
            # workaround for dismiss OnDoubleClickTreeview to open file twice 
            # step 1
            return 'break'

        def bindit(self):
            # workaround 
            # step 3
            self.tree.bind('<Double-1>', self.OnDoubleClickTreeview)

        def OnClickTreeview(self, event=None):
            item = self.tree.identify('item',event.x,event.y)
            if '/' in self.tree.item(item,"text") or '\\' in self.tree.item(item, "text"):
                self.parent.title(self.checkPath(self.tree.item(item, 'text')))
                    
            else:
                dir = self.checkPath(os.getcwd())
                self.parent.title(dir + '/' + self.checkPath(self.tree.item(item, 'text')))
            #print(item)

        
        def OnSelect(self, event=None):
            self.selected = event.widget.selection()

        def checkPath(self, path):
            if '\\' in path:
                path = path.replace('\\', '/')
            return path

        def treePopUp(self, event=None):
            item = self.tree.identify('item',event.x,event.y)
            self.tree.selection_set(item)
                
            menu = tk.Menu(self, tearoff=False, background='#000000',foreground='white',
                    activebackground='blue', activeforeground='white')
            menu.add_command(label='Info', compound=tk.LEFT, command=self.treeGenerateInfo)
            menu.add_separator()
            menu.add_command(label="Create New Folder", compound=tk.LEFT, command=self.treeGenerateFolder)
            menu.add_separator()
            menu.add_command(label="Copy Item", compound=tk.LEFT, command=self.treeGenerateCopy)
            menu.add_command(label="Paste Item", compound=tk.LEFT, command=self.treeGeneratePaste)
            menu.add_command(label="Rename Item", compound=tk.LEFT, command=self.treeGenerateRename)

            menu.add_separator()
            menu.add_command(label="Delete Item", compound=tk.LEFT, command=self.treeGenerateDelete)
            menu.add_separator()
            menu.add_command(label="Open Terminal", compound=tk.LEFT, command = self.treeGenerateTerminal)
            menu.tk_popup(event.x_root, event.y_root, 0)

        def treeGenerateInfo(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return
            
            self.infoFile()

        def infoFile(self):
            rootDir = self.checkPath(os.getcwd())
            #print(rootDir)
            directory = None
            file = None
            size = None
            if self.selected:
                for idx in self.selected:
                    try:
                        text = self.tree.item(idx)['text']
                    except:
                        self.selected = []
                        return
                if '/' in text or '\\' in text:
                    directory = True
                else:
                    file = True
                if file == True:
                    filename = rootDir + '/' + text
                    size = os.path.getsize(filename)
                    size = format(size, ',d')
                else:
                    filename = text
                text = self.checkPath(text)
                InfoDialog(self, title='Info', text=text, directory=directory, file=file, size=size)
            
            else:
                return

        def treeGenerateFolder(self):
            self.newFolder()
        
        def newFolder(self):
            NewDirectoryDialog(self, title='Create directory')
            self.refreshTree()

        def treeGenerateCopy(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return

            self.copyFile()

        def copyFile(self):
            if not self.selected:
                self.clipboard = ''
                return
            else:
                for idx in self.selected:
                    text = self.tree.item(idx)['text']
            
            self.clipboard = text
            self.homedir = self.checkPath(os.getcwd())
            
            if self.clipboard.startswith('>'):
                dir = self.clipboard.split()[1]
                self.sourceItem = self.homedir + dir
            elif '/' in self.clipboard or '\\' in self.clipboard:
                self.sourceItem = self.homedir
            else:
                self.sourceItem = self.homedir + '/' + self.clipboard
                self.sourceItem = self.checkPath(self.sourceItem)
            
            self.selected = None
            self.parent.title(self.sourceItem + ' -> marked')

        def treeGeneratePaste(self):
            if not self.sourceItem:
                self.parent.title('<No Selection>')
                return
                
            self.pasteFile()

        def pasteFile(self):
            if not self.sourceItem:
                self.parent.title('<No Selection>')
                return
            
            if not self.selected:
                currentDirectory = self.checkPath(os.getcwd())
                self.destinationItem = currentDirectory
                
            if self.selected:
                try:
                    for idx in self.selected:
                        text = self.tree.item(idx)['text']
            
                except Exception as e:
                    #print('this')
                    MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                    return
            
                currentDirectory = self.checkPath(os.getcwd())
            
                if text.startswith('>'):
                    dir = text.split()[1]
                    self.destinationItem = currentDirectory + dir
            
                elif '/' in text or '\\' in text:
                    self.destinationItem = currentDirectory

                else:
                    self.destinationItem = currentDirectory + '/' + text
            
            #print('self.sourceItem:', self.sourceItem)
            #print('self.destinationItem:', self.destinationItem)
            
            if os.path.isfile(self.sourceItem):             # Source == file
                if os.path.isdir(self.destinationItem):     # Destination == directory
                    destination = self.destinationItem      

                    try:
                        shutil.copy2(self.sourceItem, destination)
                        self.refreshTree()

                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return
                
                elif os.path.isfile(self.destinationItem):  # Destination == file
                    destination = os.path.dirname(self.destinationItem)

                    try:
                        shutil.copy2(self.sourceItem, destination)
                        self.refreshTree()

                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return

            elif os.path.isdir(self.sourceItem):            # Source == directory
                if os.path.isdir(self.destinationItem):     # Destination == directory
                    destination = self.destinationItem + '/'
                    basename = self.sourceItem.split('/')[-1]
                    destination = destination + basename
                    destination = self.checkPath(destination)
                    #print('destination:', destination)

                    try:
                        shutil.copytree(self.sourceItem, destination)
                        self.refreshTree()
                    
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return
                
                elif os.path.isfile(self.destinationItem):   # Destination == file
                    destination = os.path.dirname(self.destinationItem) + '/'
                    destination = self.checkPath(destination)
                    basename = self.sourceItem.split('/')[-1]
                    destination = destination + basename
                    #print('destination:', destination)
                    
                    try:
                        shutil.copytree(self.sourceItem, destination)
                        self.refreshTree()
                        
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                        return
            
            self.selected = None
            self.sourceItem = None
            
            self.parent.title('Done !')

        
        def treeGenerateDelete(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return
            
            self.deleteFile()

        def deleteFile(self):
            rootDir = self.checkPath(os.getcwd())
            directory = None
            file = None
            size = None
            
            if self.selected:
                for idx in self.selected:
                    try:
                        text = self.tree.item(idx)['text']
                    except:
                        self.selected = []
                        return
                
                if '/' in text or '\\' in text:
                    directory = True
                else:
                    file = True
                
                if file == True:
                    filename = rootDir + '/' + text
                else: # directory
                    if text.startswith('>'):
                        dir = text.split()[-1]
                        filename = rootDir + dir
                    elif '/' in text or '\\' in text:
                        filename = text
                    
            else:
                return
            
            filename = self.checkPath(filename)
            
            dialog = MessageYesNoDialog(self, 'Delete', '\n\tDelete\n\n' + filename + '  ?\n\n')
            result = dialog.result
            
            if result == 1:
                if directory:
                    try:
                        shutil.rmtree(filename)
                        self.refreshTree()
                        
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')

                        
                elif file:
                    try:
                        os.remove(filename)
                        self.refreshTree()
                    
                    except Exception as e:
                        MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                
                self.parent.title('Done !')
        
        def treeGenerateRename(self):
            if not self.selected:
                self.parent.title('<No Selection>')
                return
                
            obj = self.tree.selection()
            item = self.tree.item(obj)['text']
            
            dialog = RenameDialog(self, title='Rename Item', item=item)
            result = dialog.result
            
            print(result)
            if result:
                self.parent.title('Done !')
            
            self.refreshTree()

        def treeGenerateTerminal(self):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            terminalCommand = c.getTerminal(system)
            
            subprocess.call(terminalCommand, shell=True)

        def process_directory(self, parent, path):
            try:
                l = []
                for p in os.listdir(path):
                    abspath = os.path.join(path, p)
                    isdir = os.path.isdir(abspath)

                    if isdir:
                        item = '> /' + str(p)
                        l.append(item)

                    else:
                        item = str(p)
                        l.append(item)
                    
                l.sort()
                #l.reverse()
                
                for items in l:
                    if items.startswith('>'):
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='subfolder')
                    elif items.startswith('.'):
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='hidden')                    
                    elif items.endswith('.py') or items.endswith('.pyw'):
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='pythonFile')
                    else:
                        self.tree.insert(parent, 'end', text=str(items), open=False, tags='row')
           
            except Exception as e:
                print(str(e))
                return

        def refreshTree(self, event=None):
            for i in self.tree.get_children():
                self.tree.delete(i)
            path = '.'
            abspath = os.path.abspath(path)
            root_node = self.tree.insert('', 'end', text=abspath, open=True, tags='folder')
            self.process_directory(root_node, abspath)

    #if __name__ == '__main__':
    root = tk.Tk()
    app = FilebrowserFrame(root)
    app.pack(fill=tk.BOTH, expand=True)
    root.mainloop()

    class NotebookFrame(ttk.Frame):
        def __init__(self, parent):
            super().__init__(parent)
            self.parent = parent
            
            try:
                self.overlord = self.parent.parent
            except:
                self.overlord = None
            
            self.filebrowserFrame = None
            
            self.initUI()
        
        def initUI(self):
            self.buttonFrame = ttk.Frame(self)
            self.initButtons()
            self.notebook = ttk.Notebook(self)
            
            self.buttonFrame.pack(side=tk.TOP, fill=tk.X)
            self.notebook.pack(side=tk.TOP, expand=True, fill=tk.BOTH)
            self.new()
        
        def initButtons(self):
            HOMEPATH = os.path.dirname(__file__) + '/'
            
            # Buttons
            #newIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/newIDE.png')
            newButton = ttk.Button(self.buttonFrame, text="New", command=self.new)
            #newButton.image = newIcon
            newButton.pack(side=tk.LEFT)
            newButton_ttp = CreateToolTip(newButton, 'New')

            #openIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/openIDE.png')
            openButton = ttk.Button(self.buttonFrame, text="Open", command=self.openFileDialog)
            #openButton.image = openIcon
            openButton.pack(side=tk.LEFT)
            openButton_ttp = CreateToolTip(openButton, 'Open') 
            
            #saveIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/saveIDE.png')
            saveButton = ttk.Button(self.buttonFrame, text="Save", command=self.save)
            #saveButton.image = saveIcon
            saveButton.pack(side=tk.LEFT)
            saveButton_ttp = CreateToolTip(saveButton, 'Save')

            #saveAsIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/saveAsIDE.png')
            saveAsButton = ttk.Button(self.buttonFrame, text="Save As", command=self.saveAs)
            #saveAsButton.image = saveAsIcon
            saveAsButton.pack(side=tk.LEFT)
            saveAsButton_ttp = CreateToolTip(saveAsButton, 'Save As')

            #printIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/printIDE.png')
            printButton = ttk.Button(self.buttonFrame, text="Print", command=self.printer)
            #printButton.image = printIcon
            printButton.pack(side=tk.LEFT)
            printButton_ttp = CreateToolTip(printButton, "Print to HTML-File")

            #undoIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/undoIDE.png')
            undoButton = ttk.Button(self.buttonFrame, text="Undo", command=self.undo)
            #undoButton.image = undoIcon
            undoButton.pack(side=tk.LEFT)
            undoButton_ttp = CreateToolTip(undoButton, 'Undo')

            #redoIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/redoIDE.png')
            redoButton = ttk.Button(self.buttonFrame, text="Redo", command=self.redo)
            #redoButton.image = redoIcon
            redoButton.pack(side=tk.LEFT)
            redoButton_ttp = CreateToolTip(redoButton, "Redo")

            #zoomInIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/zoomInIDE.png')
            zoomInButton = ttk.Button(self.buttonFrame, text="Zoom In", command=self.zoomIn)
            #zoomInButton.image = zoomInIcon
            zoomInButton.pack(side=tk.LEFT)
            zoomInButton_ttp = CreateToolTip(zoomInButton, "Zoom In")

            #zoomOutIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/zoomOutIDE.png')
            zoomOutButton = ttk.Button(self.buttonFrame, text="Zoom Out", command=self.zoomOut)
            #zoomOutButton.image = zoomOutIcon
            zoomOutButton.pack(side=tk.LEFT)
            zoomOutButton_ttp = CreateToolTip(zoomOutButton, "Zoom Out")

            #settingsIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/settingsIDE.png')
            settingsButton = ttk.Button(self.buttonFrame, text="Settings", command=self.settings)
            #settingsButton.image = settingsIcon
            settingsButton.pack(side=tk.LEFT)
            settingsButton_ttp = CreateToolTip(settingsButton, "Show Settings")

            #runIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/runIDE.png')
            runButton = ttk.Button(self.buttonFrame, text="Run", command=self.run)
            #runButton.image = runIcon
            runButton.pack(side=tk.RIGHT)
            runButton_ttp = CreateToolTip(runButton, "Run File")
            
            #terminalIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/terminalIDE.png')
            terminalButton = ttk.Button(self.buttonFrame, text="Terminal", command=self.terminal)
            #terminalButton.image = terminalIcon
            terminalButton.pack(side=tk.RIGHT)
            terminalButton_ttp = CreateToolTip(terminalButton, 'Open Terminal')

            #interpreterIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/interpreterIDE.png')
            interpreterButton = ttk.Button(self.buttonFrame, text="Interpreter", command=self.interpreter)
            #interpreterButton.image = interpreterIcon
            interpreterButton.pack(side=tk.RIGHT)
            interpreterButton_ttp = CreateToolTip(interpreterButton, "Open Python Interpreter")

            '''
            viewIcon = tk.PhotoImage(file=self.dir + 'IDE/view.png')
            viewButton = ttk.Button(self.rightBottomFrame, image=viewIcon, command=self.overview)
            viewButton.image = viewIcon
            viewButton.pack(side=tk.RIGHT)
            self.createToolTip(viewButton, 'Class Overview')
            '''
            
            #searchIcon = tk.PhotoImage(file=HOMEPATH + 'IDE/searchIDE.png')
            searchButton = ttk.Button(self.buttonFrame, text="Search", command=self.search)
            #searchButton.image = searchIcon
            searchButton.pack(side=tk.RIGHT)
            searchButton_ttp = CreateToolTip(searchButton, "Search")


            self.searchBox = tk.Entry(self.buttonFrame, bg='black', fg='white')
            self.searchBox.configure(cursor="xterm green")
            self.searchBox.configure(insertbackground = "red")
            self.searchBox.configure(highlightcolor='#448dc4')

            #self.searchBox.bind('<Key>', self.OnSearchBoxChange)
            self.searchBox.bind('<Return>', self.search)
            self.searchBox.pack(side=tk.RIGHT, padx=5)
        
            
        def new(self, event=None):
            self.codeeditorFrame = CodeeditorFrame(self)
            self.notebook.add(self.codeeditorFrame, text='noname')
            self.frameName = self.notebook.select()

            self.textPad = self.codeeditorFrame.textPad
            
            self.notebook.bind("<ButtonRelease-1>", self.tabChanged)
            self.notebook.bind("<ButtonRelease-3>", self.closeContext)
            
            x = len(self.notebook.tabs()) - 1
            self.notebook.select(x)
            self.tabChanged()
        
        def open(self, filename=None, event=None):
            if not filename:
                filename = filedialog.askopenfilename()
            
                if not filename:
                    return
            
            try:
                # open file for reading
                with open(filename, 'r') as f:
                    text = f.read()
            
                # update textPad
                self.textPad.delete('1.0', tk.END)
                self.textPad.insert("1.0", text)
                self.textPad.filename = filename
                self.textPad.tag_all_lines()
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return
                
            # update tab text
            file = self.textPad.filename.split('/')[-1]
            id = self.notebook.index(self.notebook.select())
            self.notebook.tab(id, text=file)
            
            # generate tabChanged event (get new textPad, etc)
            self.tabChanged()
            
            # update autocompleteList from codeeditor
            self.textPad.updateAutoCompleteList()
            self.filebrowserFrame.refreshTree()

        def openFileDialog(self):
            dialog = OpenFileDialog(parent=self.parent, notebookFrame=self, title='Open')

        def save(self, event=None):
            if not self.textPad:
                return
                
            if not self.textPad.filename:
                self.saveAs()
            
            filename = self.textPad.filename
            
            if not filename:
                return
            
            try:
                with open(filename, 'w') as f:
                    text = self.textPad.get("1.0",'end-1c')
                    f.write(text)
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
            
            # update textPad
            self.textPad.filename = filename
            
            # update tab text
            file = self.textPad.filename.split('/')[-1]
            id = self.notebook.index(self.notebook.select())
            self.notebook.tab(id, text=file)
            
            # generate tabChanged event (get new textPad, etc)
            self.tabChanged()
            self.filebrowserFrame.refreshTree()
            
        def saveAs(self, event=None):
            dialog = SaveFileDialog(self, "Save as")
            filename = dialog.filename
            
            if not filename:
                return
            
            try:
                with open(filename, 'w') as f:
                    text = self.textPad.get("1.0",'end-1c')
                    f.write(text)
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
            
            # update textPad
            self.textPad.filename = filename
            
            # update tab text
            file = self.textPad.filename.split('/')[-1]
            id = self.notebook.index(self.notebook.select())
            self.notebook.tab(id, text=file)
            
            # generate tabChanged event (get new textPad, etc)
            self.tabChanged()
            self.filebrowserFrame.refreshTree()

        def printer(self, event=None):
            # print file to html
            if not self.textPad:
                return
                
            if not self.textPad.filename:
                return

            text = self.textPad.get("1.0",'end-1c')
            filename = self.textPad.filename.split('/')[-1]
            kwList = keyword.kwlist
            
            output = "<head>" + filename + "</head>\n"
            output += "<body>\n"
            output += '<pre><code>\n'
            output += text + '\n'
            output += '</pre></code>\n'
            output += "</body>"

            fname = self.textPad.filename + "_.html"
            
            with open(fname, "w") as f:
                f.write(output)
            
            try:
                webbrowser.open(fname)
            
            except Exception as e:
                MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return
            
            self.filebrowserFrame.refreshTree()
            
        def undo(self, event=None):
            if self.textPad:
                self.textPad.undo()
            
        def redo(self, event=None):
            if self.textPad:
                self.textPad.redo()
            
        def zoomIn(self, event=None):
            if not self.textPad:
                return
            if self.textPad.font_size < 30:
                self.textPad.font_size += 1
                self.textPad.configFont()
                
                self.textPad.linenumber.font_size +=1
                self.textPad.linenumber.configFont()
                self.textPad.linenumber.redraw()

        def zoomOut(self, event=None):
            if not self.textPad:
                return
            if self.textPad.font_size > 5:
                self.textPad.font_size -= 1
                self.textPad.configFont()
                
                self.textPad.linenumber.font_size -=1
                self.textPad.linenumber.configFont()
                self.textPad.linenumber.redraw()

        def settings(self, event=None):
            dialog = SettingsDialog(self)

        def run(self, event=None):
            if not self.textPad:
                return
            
            filepath = self.textPad.filename
            
            if not filepath:
                return
            
            self.save()

            file = filepath.split('/')[-1]
        
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            runCommand = c.getRun(system).format(file)

            subprocess.call(runCommand, shell=True)

        def terminal(self, event=None):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            terminalCommand = c.getTerminal(system)
            
            try:
                subprocess.call(terminalCommand, shell=True)
            except Exception as e:
                dialog = MessageDialog(self, 'Error', '\n' + str(e) + '\n')
                return


        def interpreter(self, event=None):
            c = Configuration()     # -> in configuration.py
            system = c.getSystem()
            interpreterCommand = c.getInterpreter(system)

            subprocess.call(interpreterCommand, shell=True)
        
        def search(self, start=None):
            if not self.textPad:
                return
                
            self.textPad.tag_remove('sel', "1.0", tk.END)
            
            toFind = self.searchBox.get()
            pos = self.textPad.index(tk.INSERT)
            result = self.textPad.search(toFind, str(pos), stopindex=tk.END)
            
            if result:
                length = len(toFind)
                row, col = result.split('.')
                end = int(col) + length
                end = row + '.' + str(end)
                self.textPad.tag_add('sel', result, end)
                self.textPad.mark_set('insert', end)
                self.textPad.see(tk.INSERT)
                self.textPad.focus_force()
            else:
                self.textPad.mark_set('insert', '1.0')
                self.textPad.see(tk.INSERT)
                self.textPad.focus()
                self.setEndMessage(400)
                self.searchBox.focus()
                return

        def setEndMessage(self, seconds):
                pathList = __file__.replace('\\', '/')
                pathList = __file__.split('/')[:-1]
            
                self.dir = ''
                for item in pathList:
                    self.dir += item + '/'

                canvas = tk.Canvas(self.textPad, width=64, height=64)
                x = self.textPad.winfo_width() / 2
                y = self.textPad.winfo_height() / 2

                canvas.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
                #image = tk.PhotoImage(file = self.dir + 'IDE/lastIDE.png')
                canvas.create_image(0, 0,  anchor=tk.NW)
                
                self.textPad.update()
                self.after(seconds, self.textPad.entry.config(text='---'))
                
                canvas.destroy()
                self.textPad.update()


        def tabChanged(self, event=None):
            tabs = self.notebook.tabs()
            try:
                id = self.notebook.index(self.notebook.select())
            except:
                return 
                
            name = tabs[id]
            codeframe = self.notebook._nametowidget(name)
            
            self.textPad = codeframe.textPad
        
            self.updateMainWindow()
            self.textPad.focus()
            
        def updateMainWindow(self, event=None):
            if not self.textPad:
                return
                
            if not self.overlord:
                if self.textPad.filename:
                    self.parent.title(self.textPad.filename)
                else:
                    self.parent.title("Complex IDE")
            else:
                if self.textPad.filename:
                    self.overlord.title(self.textPad.filename)
                else:
                    self.overlord.title("Complex IDE")

            
        def closeContext(self, event=None):
            tabs = self.notebook.tabs()
            if not tabs:
                return
            
            menu = tk.Menu(self.notebook, tearoff=False, background='#000000',foreground='white',
                    activebackground='blue', activeforeground='white')
            menu.add_command(label='Close', compound=tk.LEFT, command=self.closeTab)
            menu.tk_popup(event.x_root, event.y_root, 0)
            
        def closeTab(self, event=None):
            id = self.notebook.index(self.notebook.select())
            self.notebook.forget(id)
            
            try:
                x = len(self.notebook.tabs()) - 1
                self.notebook.select(x)
                self.tabChanged()
            except:
                self.textPad = None
                return
            
    ###################################################################
    class CreateToolTip():
        """
        create a tooltip for a given widget
        -> this solution was found on stackoverlow.com :)
        """
        def __init__(self, widget, text='widget info'):
            self.waittime = 500     # miliseconds
            self.wraplength = 180   # pixels
            self.widget = widget
            self.text = text
            self.widget.bind("<Enter>", self.enter)
            self.widget.bind("<Leave>", self.leave)
            self.widget.bind("<ButtonPress>", self.leave)
            self.id = None
            self.tw = None

        def enter(self, event=None):
            self.schedule()

        def leave(self, event=None):
            self.unschedule()
            self.hidetip()

        def schedule(self):
            self.unschedule()
            self.id = self.widget.after(self.waittime, self.showtip)

        def unschedule(self):
            id = self.id
            self.id = None
            if id:
                self.widget.after_cancel(id)

        def showtip(self, event=None):
            x = y = 0
            x, y, cx, cy = self.widget.bbox("insert")
            x += self.widget.winfo_rootx() + 1
            y += self.widget.winfo_rooty() + 40
            
            # creates a toplevel window
            self.tw = tk.Toplevel(self.widget)
            
            # Leaves only the label and removes the app window
            self.tw.wm_overrideredirect(True)
            self.tw.wm_geometry("+%d+%d" % (x, y))
            label = tk.Label(self.tw, text=self.text, justify='left',
                           background="#000000", foreground='yellow',
                           relief='solid', borderwidth=1,
                           wraplength = self.wraplength)
            label.pack(ipadx=1)

        def hidetip(self):
            tw = self.tw
            self.tw= None
            if tw:
                tw.destroy()
    ###################################################################


    #if __name__ == '__main__':
    root = tk.Tk()
    app = NotebookFrame(root)
    app.pack(fill=tk.BOTH, expand=True)
    root.mainloop()

    class Mopad(ttk.Frame):
        '''
            Main App
        '''

        def __init__(self, parent=None):
            super().__init__(parent)
            self.parent = parent
            self.pack(expand=True, fill=tk.BOTH)
            self.initUI()
            self.initStyle()


        def initUI(self):
            
            # PanedWindow
            self.panedWindow = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
            self.panedWindow.pack(fill=tk.BOTH, expand=1)
            
            # InterpreterFrame
            self.filebrowserFrame = FilebrowserFrame(self.parent)
            #self.filebrowserFrame2 = FilebrowserFrame(self.parent)
            #self.filebrowserFrame.pack(side='left', fill='y')

            # NotebookFrame
            self.notebookFrame = NotebookFrame(self.parent)
            #self.notebookFrame.pack(side='right', expand=1, fill='both')
            self.notebookFrame.textPad.bind("<FocusIn>", self.textPadFocus)
            
            # add a variable for fileBrowserFrame to know the notebookFrame
            self.filebrowserFrame.notebookFrame = self.notebookFrame
            self.notebookFrame.filebrowserFrame = self.filebrowserFrame
            
            # add to PanedWindow
            self.panedWindow.add(self.filebrowserFrame)
            self.panedWindow.add(self.notebookFrame)
            #self.panedWindow.add(self.filebrowserFrame2)
            
        def textPadFocus(self, event=None):
            self.notebookFrame.updateMainWindow()

        def initStyle(self):
            self.style = ttk.Style()
            self.style.theme_use('clam')
            
            self.style.configure("Treeview", background="black", 
                    fieldbackground="black", foreground="white",
                    selectbackground='green')
            self.style.configure("Treeview.Heading", background="black", foreground='white', relief='flat')
            self.style.map('Treeview.Heading', 
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])

            self.style.configure('TCheckbutton', background='black',
                    fieldbackground='black', foreground='white')

            self.style.configure('TRadiobutton', background='black',
                    fieldbackground='black', foreground='white')
            self.style.map('TRadiobutton',
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])


            self.style.configure('TSpinbox', background='black',
                    fieldbackground='black', foreground='white')

            self.style.configure('TNotebook', background='black',
                    fieldbackground='black', foreground='white')
            self.style.configure('TNotebook.Tab', background='black',
                    fieldbackground='black', foreground='white')
            self.style.map('TNotebook.Tab',
                foreground=[('selected', 'yellow')],
                background=[('selected', 'black')])
                
            self.style.configure('TFrame', background='black',
                    fieldbackground='black', foreground='white',
                    highlightcolor='white', highlightbackground='black',
                    highlightthickness=5)

            self.style.configure('TLabel', background='black',
                    fieldbackground='black', foreground='green')
            self.style.configure("White.TLabel", background='black',
                    fieldbackground='black', foreground="white")
            self.style.configure("Red.TLabel", background='black',
                    fieldbackground='black', foreground="red")

            self.style.configure('TPanedwindow', background='black',
                    fieldbackground='black', foreground='white')

            self.style.configure('TEntry', background='black',
                    fieldbackground='black', foreground='white')

            self.style.map('TEntry',
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])
            

            self.style.configure('TButton', background='black',
                    fieldbackground='black', foreground='#FFFFFF')
            self.style.configure('Red', background='red')
            self.style.map('TButton',
                foreground=[('pressed', 'white'),
                            ('focus', 'white'),
                            ('active', 'white')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])       

            self.style.configure("TScrollbar", background="#1d1d1d",
                                  foreground="#000000", activebackground="#000000",
                                  troughcolor="#000000")
            self.style.map('TScrollbar',
                foreground=[('pressed', '#424242'),
                            ('focus', '#424242'),
                            ('active', '#424242')],
                background=[('pressed', '!focus', 'green'),
                            ('active', 'green')],
                highlightcolor=[('focus', 'green'),
                            ('!focus', 'white')],
                activerelief=[('pressed', 'groove'),
                        ('!pressed', 'ridge')])
                    
    def center(win):
        # Center the root screen
        win.update_idletasks()
        width = win.winfo_width()
        frm_width = win.winfo_rootx() - win.winfo_x()
        win_width = width + 2 * frm_width
        height = win.winfo_height()
        titlebar_height = win.winfo_rooty() - win.winfo_y()
        win_height = height + titlebar_height + frm_width
        x = win.winfo_screenwidth() // 2 - win_width // 2
        y = win.winfo_screenheight() // 2 - win_height // 2
        win.geometry('{}x{}+{}+{}'.format(width, height, x, y))
        win.deiconify()
            
    if __name__ == '__main__':
        root = tk.Tk()
        #root['bg'] = 'black'
        
        app = Mopad(root)
        app.master.title('Complex IDE')
        app.master.minsize(width=800, height=600) 
      
        center(root)  
        app.mainloop()
        
if Adm2var == 40:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    __author__ = "Tudor Marmureanu"



    from tkinter import *
    from tkinter import ttk
    from tkinter import colorchooser
    from tkinter import filedialog
    from tkinter import font

    # from fontTopLevel import *

    class pyPROApp:
        def __init__(self, master):
            global dictDesignWindowPropCollect
            dictDesignWindowPropCollect = {}  #### Dictionary to collect properties of the design window
            self.implementFont_determine = 0    ### Variable that works in conjunction with implementFont command
            self.dictCountFont = {}     ### Dicitonary to store font instances for design window widgets
            self.implementImage_determine = 0   ### Variable that works in conjunction with implementImage command
            self.dictCountImage = {}         ### Dictionary to store PhotoImage instances for design window
            self.count_image_instances = 1
            self.commands_all = {}      ### Dictionary to store commands for all widgets

            self.styleWidgetConfigLabel = ttk.Style()       ###ttk.Style for Main and WidgetToplevel widgets
            self.clickWidgetConfig = 0  # Variable that determines if WidgetConfig Window has been opened earlier

            self.numberFont_2 = 1  ###### Variable for New Font Name
            self.isFontToplevel = 0  #### Variable to determine whether FontToplevel is opened

            self.iswinConfigToplevel = 0    ### Variable to determine wheter winConfigToplevel is opned earlier


            global screen_width, screen_height
            self.master = master
            screen_width = windowPRO.winfo_screenwidth()
            screen_height = windowPRO.winfo_screenheight()

        ### Parameters for Title of Design Window
            dictDesignWindowPropCollect["title"] = f"windowDesign.title('Design Window')"
            
        ### Parameters for Geometry of Design Window
            global new_value_width
            new_value_width = int(screen_width / 2)
            global new_value_height
            new_value_height = int(screen_height / 1.57)
            global new_value_position_x
            new_value_position_x = int(screen_width / 4.5)
            global new_value_position_y
            new_value_position_y = int(screen_height / 3.36)
            dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry('{new_value_width}x{new_value_height}+" \
                                                      f"{new_value_position_x}+{new_value_position_y}')"

            ######## Main Window
            windowPRO.title("BuildIt")
            windowPRO.geometry(
                "%dx%d+%d+%d" % (screen_width / 2, screen_height / 8, screen_width / 4.5, (screen_height / 20) - 20))

            ####### Main Menu Widget
            Menu_main = Menu(master)

            ### comms for Code Gen
            def comm4compile_text():
                codeGen = CodeGenerate()
                codeGen.compile2Text()

            def comm4compile_python():
                codeGen2 = CodeGenerate()
                codeGen2.compile2PythonFile()

            command4Code_Gen = Menu()
            command4Code_Gen.add_command(label = "To Python File", command = comm4compile_python)
            command4Code_Gen.add_command(label="To pyPRO's NotePad", command = comm4compile_text)


            ### comms for Beautify
            cascade_change_theme = Menu()
            cascade_change_theme.add_command(label="alt", command=lambda: self.styleWidgetConfigLabel.theme_use("alt"))
            cascade_change_theme.add_command(label="clam", command=lambda: self.styleWidgetConfigLabel.theme_use("clam"))
            cascade_change_theme.add_command(label = "classic", command = lambda: self.styleWidgetConfigLabel.theme_use("classic"))
            cascade_change_theme.add_command(label = "default", command = lambda: self.styleWidgetConfigLabel.theme_use("default"))
            cascade_change_theme.add_command(label="vista", command=lambda: self.styleWidgetConfigLabel.theme_use("vista"))
            cascade_change_theme.add_command(label="winnative", command=lambda: self.styleWidgetConfigLabel.theme_use("winnative"))
            cascade_change_theme.add_command(label="xpnative", command=lambda: self.styleWidgetConfigLabel.theme_use("xpnative"))

            command4Beautify = Menu()
            command4Beautify.add_separator()
            command4Beautify.add_command(label = "Default Theme", command=lambda: self.styleWidgetConfigLabel.theme_use("vista"))
            command4Beautify.add_cascade(label = "Change Theme", menu = cascade_change_theme)
            command4Beautify.add_separator()

            ### comms for Window Setup
            def command4winConfig():
                global winsetupObject
                winsetupObject = DesignWindowSetup()
            command4Window = Menu()
            command4Window.add_command(label = "Window Setup", command = command4winConfig)


            Menu_main.add_cascade(label="Code Gen", menu=command4Code_Gen)  ### CodeGen cass
            Menu_main.add_cascade(label="Beautify", menu = command4Beautify) ### Beautify cass
            Menu_main.add_cascade(label="Edit")
            Menu_main.add_cascade(label="Window", menu = command4Window)
            master.config(menu=Menu_main)  ##### Configure main menu widget to window

            self.toplevel4WidgetToolkit()  #####Run Widget Toolkit Toplevel

        def toplevel4WidgetToolkit(self):  ####### Creates Wigets Toolkit Window and All Inside It
            ####### Top level for Widget Toolkit
            toplevelWidgetToolkit = Toplevel(self.master)
            toplevelWidgetToolkit.transient(self.master)
            toplevelWidgetToolkit.geometry("%dx%d+%d+%d" % (207, screen_height/1.105, screen_width/168, screen_height/35))
            toplevelWidgetToolkit.title("Widgets Toolkit")
            toplevelWidgetToolkit.resizable(False, True)
            print(toplevelWidgetToolkit.winfo_screenwidth())
            ####### Scrollbar for Main Widgets
            scrollbarWidgetToolkit = ttk.Scrollbar(toplevelWidgetToolkit, )
            scrollbarWidgetToolkit.pack(side=RIGHT, fill=Y)

            ####### Canvas for Widget Toolkit
            canvasWidgetToolkit = Canvas(toplevelWidgetToolkit, highlightthickness=0,
                                         yscrollcommand=scrollbarWidgetToolkit.set, width=207,
                                         height=screen_height/1.105)
            canvasWidgetToolkit.pack(side=LEFT, )

            ####### Frame to contain all Main Widgets
            frameWidgetToolkit = ttk.Frame(canvasWidgetToolkit)
            frameWidgetToolkit.pack()
            # n, ne, e, se, s, sw, w, nw, or center
            canvasWidgetToolkit.create_window((0, 0), window=frameWidgetToolkit, anchor=NW)

            scrollbarWidgetToolkit.config(
                command=canvasWidgetToolkit.yview)  #### Set scrollbarWidgetToolkit for canvasWidgetToolkit

            toplevelWidgetToolkit.bind("<Configure>", lambda event: canvasWidgetToolkit.config(
                scrollregion=canvasWidgetToolkit.bbox(ALL)))  #### Bind Scroll region to Configure Event

            ######### Widgets Placement for the Widget Toolkit

            ### All Main Widgets Here

            # Label  for Tk Widgets
            label_tk_widgets = ttk.Label(frameWidgetToolkit, text="tk Widgets", font=("Onyx", 15, "bold"))
            label_tk_widgets.pack(anchor=N, pady=5)

            # Main Button Widget
            self.widget_button = ttk.Button(frameWidgetToolkit, text="Button", style="main.TButton",
                                            command=lambda: self.determineButton("button"))
            self.widget_button.pack(anchor=W, )

            # Main Checkbutton Widget
            widget_checkbutton = ttk.Button(frameWidgetToolkit, text="Checkbutton", style="main.TButton",
                                            command=lambda: self.determineCheckbutton("checkbutton"))
            widget_checkbutton.pack(anchor=W, )

            # Main Entry Widget
            widget_entry = ttk.Button(frameWidgetToolkit, text="Entry", style="main.TButton",
                                      command=lambda: self.determineEntry("entry"))
            widget_entry.pack(anchor=W, )

            # Main Label Widget
            widget_label = ttk.Button(frameWidgetToolkit, text="Label", style="main.TButton",
                                      command=lambda: self.determineLabel("label"))
            widget_label.pack(anchor=W, )

            # Main Listbox Widget
            widget_listbox = ttk.Button(frameWidgetToolkit, text="Listbox", style="main.TButton",
                                        command=lambda: self.determineListbox("listbox"))
            widget_listbox.pack(anchor=W)

            # Main Menu Widget
            widget_menu = ttk.Button(frameWidgetToolkit, text="Menu", style="main.TButton", command=self.mainMenu)
            widget_menu.pack(anchor=W)

            # Main Menubutton Widget
            widget_menubutton = ttk.Button(frameWidgetToolkit, text="Menubutton", style="main.TButton",
                                           command=lambda: self.determineMenubutton("menubutton"))
            widget_menubutton.pack(anchor=W)

            # Main Message Widget
            widget_message = ttk.Button(frameWidgetToolkit, text="Message", style="main.TButton",
                                        command=lambda: self.determineMessage("message"))
            widget_message.pack(anchor=W)

            # Main OptionMenu Widget
            widget_optionmenu = ttk.Button(frameWidgetToolkit, text="OptionMenu", style="main.TButton",
                                           command=lambda: self.mainOptionMenu("optionmenu"))
            widget_optionmenu.pack(anchor=W)

            # Main Radiobutton Widget
            widget_radiobutton = ttk.Button(frameWidgetToolkit, text="Radiobutton", style="main.TButton",
                                            command=lambda: self.determineRadiobutton("radiobutton"))
            widget_radiobutton.pack(anchor=W, )

            # Main Scale - Horizontal
            widget_scalehorizontal = ttk.Button(frameWidgetToolkit, text="Scale - Horizontal", style="main.TButton",
                                                command=lambda: self.determineScale("scale_horizontal"))
            widget_scalehorizontal.pack(anchor=W, )

            # Main Scale - Vertical
            widget_scalevertical = ttk.Button(frameWidgetToolkit, text="Scale - Vertical", style="main.TButton",
                                              command=lambda: self.determineScale("scale_vertical"))
            widget_scalevertical.pack(anchor=W, )

            # Main Scrollbar - Horizontal
            widget_scrollbar = ttk.Button(frameWidgetToolkit, text="Scrollbar - Horizontal", style="main.TButton",
                                          command=lambda: self.determineScrollbar("scrollbar"))
            widget_scrollbar.pack(anchor=W)

            # Main Scrollbar - Vertical
            widget_scrollbar = ttk.Button(frameWidgetToolkit, text="Scrollbar - Vertical", style="main.TButton",
                                          command=lambda: self.determineScrollbar("scrollbar"))
            widget_scrollbar.pack(anchor=W)

            # Main Spinbox Widget
            widget_spinbox = ttk.Button(frameWidgetToolkit, text="Spinbox", style="main.TButton",
                                        command=lambda: self.determineSpinbox("spinbox"))
            widget_spinbox.pack(anchor=W, )

            # Main Text Widget
            widget_text = ttk.Button(frameWidgetToolkit, text="Text", style="main.TButton",
                                     command=lambda: self.determineText("text"))
            widget_text.pack(anchor=W, )

            # Label for Tk Containers
            label_tk_containers = ttk.Label(frameWidgetToolkit, text="tk Containers", font=("Onyx", 15, "bold"))
            label_tk_containers.pack(anchor=N, pady=5)

            # Main Frame Contain
            widget_frame = ttk.Button(frameWidgetToolkit, text="Frame", style="main.TButton",
                                      command=lambda: self.determineFrame("frame"))
            widget_frame.pack(anchor=W, )

            # Main LabelFrame Contain
            widget_labelframe = ttk.Button(frameWidgetToolkit, text="LabelFrame", style="main.TButton",
                                           command=lambda: self.determineLabelFrame("labelframe"))
            widget_labelframe.pack(anchor=W, )

            # Main PanedWindow Contain
            widget_panedwindow = ttk.Button(frameWidgetToolkit, text="PanedWindow", style="main.TButton",
                                            command=lambda: self.determinePanedWindow("panedwindow"))
            widget_panedwindow.pack(anchor=W, )

            # Main Toplevel Contain
            widget_toplevel = ttk.Button(frameWidgetToolkit, text="Toplevel", style="main.TButton",
                                         command=lambda: self.determineToplevel("toplevel"))
            widget_toplevel.pack(anchor=W, )

            # Styling for Main Buttons
            style_main_buttons = ttk.Style()
            style_main_buttons.configure("main.TButton", width=30, anchor=W, )

        def toplevel4WidgetConfig(self):  ############ Contains Attributes available in all Widgets Classes

            self.clickWidgetConfig = 1  #### Variable that determines if WidgetConfig Window has been opened earlier

            ###### Top level for Widgets Config toplevel
            self.toplevelWidgetConfig = Toplevel(self.master, name = "!toplevel_attr_editor")
            self.toplevelWidgetConfig.transient(self.master)
            self.toplevelWidgetConfig.title("Widgets Config")
            self.toplevelWidgetConfig.geometry(
                "%dx%d+%d+%d" % (280, screen_height/1.105, screen_width-300, screen_height/35))
            self.toplevelWidgetConfig.resizable(False, True)

            ### Canvas for Widget Config Toplevel
            canvasWidgetConfig = Canvas(self.toplevelWidgetConfig, width=265, height=screen_height/1.1052,
                                        highlightthickness=0)
            canvasWidgetConfig.pack(side=LEFT)

            ### Frame to host All Widgets in Widget Config Toplevel
            self.frameWidgetConfig = ttk.Frame(canvasWidgetConfig)
            self.frameWidgetConfig.pack(fill = BOTH, expand = 1)

            ### Scrollbar to scroll Frame and hence all Widgets inside it
            scrollbarWidgetConfig = ttk.Scrollbar(self.toplevelWidgetConfig, orient=VERTICAL, command=canvasWidgetConfig.yview)
            scrollbarWidgetConfig.pack(side=RIGHT, fill=Y)

            canvasWidgetConfig.create_window((0, 0), window=self.frameWidgetConfig,
                                             anchor=NW)  ### Canvas Window to host self.frameWidgetConfig

            canvasWidgetConfig.config(
                yscrollcommand=scrollbarWidgetConfig.set)  ###### Set scrollbarWidgetConfig to canvasWidgetConfig

            self.toplevelWidgetConfig.bind("<Configure>", lambda event: canvasWidgetConfig.config(
                scrollregion=canvasWidgetConfig.bbox(ALL)))  #### Bind Scroll region to Configure Event

            # ATTRIBUTES DISPLAY AND EDIT
            ### Edit Attributes Label section
            label4edit_attributes = ttk.Label(self.frameWidgetConfig, text="Edit Attributes", font=("Onyx", 15, "bold"))
            label4edit_attributes.grid(row=100, column=1, sticky=N, columnspan=2, pady=5)

            ### Widget Variable Section
            label4widget_variable = ttk.Label(self.frameWidgetConfig, text="Widget\nVariable", style="widgetconfig.TLabel")
            label4widget_variable.grid(row=101, column=1, sticky=W)
            frame4widget_variable = ttk.Frame(self.frameWidgetConfig)
            frame4widget_variable.grid(row=101, column=2)
            self.entry4widget_variable = Entry(frame4widget_variable, relief=FLAT, disabledbackground = "white")
            self.entry4widget_variable.pack(side=LEFT, padx=3)

            blank_label4command = ttk.Label(frame4widget_variable, text="", anchor=W, width=3)
            blank_label4command.pack(side=LEFT)

            ### activebackground Sec
            def color4activebackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4activebackground.delete(0, END)
                windowObject.entry4activebackground.insert(END, color)

            self.label4activebackground = ttk.Label(self.frameWidgetConfig, text="active\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4activebackground.grid(sticky=W, row=105, column=1)
            self.frame4activebackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4activebackground.grid(row=105, column=2)
            self.entry4activebackground = Entry(self.frame4activebackground, relief=FLAT)
            self.entry4activebackground.pack(side=LEFT, padx=3)
            button4activebackground = ttk.Button(self.frame4activebackground, text=">>", style="moreOptions.TButton",
                                                 command = color4activebackground)
            button4activebackground.pack(side=LEFT)

            ### activeforeground Sec
            def color4activeforeground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4activeforeground.delete(0, END)
                windowObject.entry4activeforeground.insert(END, color)

            self.label4activeforeground = ttk.Label(self.frameWidgetConfig, text="active\nforeground",
                                                    style="widgetconfig.TLabel")
            self.label4activeforeground.grid(sticky=W, row=110, column=1)
            self.frame4activeforeground = ttk.Frame(self.frameWidgetConfig)
            self.frame4activeforeground.grid(row=110, column=2)
            self.entry4activeforeground = Entry(self.frame4activeforeground, )
            self.entry4activeforeground.pack(side=LEFT, padx=3)
            button4activeforeground = ttk.Button(self.frame4activeforeground, text=">>", style="moreOptions.TButton",
                                                 command = color4activeforeground)
            button4activeforeground.pack(side=LEFT)

            ### activestyle Sec
            activestyles = ("dotbox", "none", "underline")
            self.label4activestyle = ttk.Label(self.frameWidgetConfig, text="active\nstyle", style="widgetconfig.TLabel")
            self.label4activestyle.grid(sticky=W, row=120, column=1)
            self.combo4activestyle = ttk.Combobox(self.frameWidgetConfig, values=activestyles)
            self.combo4activestyle.grid(row=120, column=2, ipadx=5)

            ### anchor Sec
            anchors = ("nw", "n", "ne", "w", "center", "e", "sw", "s", "se")
            self.label4anchor = ttk.Label(self.frameWidgetConfig, text="anchor", style="widgetconfig.TLabel")
            self.label4anchor.grid(sticky=W, row=200, column=1)
            self.combo4anchor = ttk.Combobox(self.frameWidgetConfig, values = anchors)
            self.combo4anchor.grid(row=200, column=2, ipadx=5)

            ### aspect Sec
            def command4aspect(new_value):
                new_value = self.int_aspect.get()
                windowObject.int_aspect.set(new_value)

            self.int_aspect = IntVar(value = 100)
            self.label4aspect = ttk.Label(self.frameWidgetConfig, text = "aspect", style = "widgetconfig.TLabel")
            self.label4aspect.grid(sticky = W, row = 250, column = 1)
            self.frame4aspect = Frame(self.frameWidgetConfig, )
            self.frame4aspect.grid(sticky = W, row = 250, column = 2, padx = 25)
            self.label24aspect = Label(self.frame4aspect, text = self.int_aspect.get(), textvariable = self.int_aspect)
            self.label24aspect.pack()
            self.scale4aspect = ttk.Scale(self.frame4aspect, from_ = 1, to = 1000, orient = HORIZONTAL,
                                                variable = self.int_aspect, command = command4aspect)
            self.scale4aspect.pack()

            ### autoseparators
            self.bool_autoseparators = BooleanVar()
            self.bool_autoseparators.set(True)
            self.label4autoseparators = ttk.Label(self.frameWidgetConfig, text="auto\nseparators",
                                                   style="widgetconfig.TLabel")
            self.label4autoseparators.grid(sticky=W, row=260, column=1)
            self.frame4autoseparators = ttk.Frame(self.frameWidgetConfig)
            self.frame4autoseparators.grid(row=260, column=2)
            radioTrue4autoseparators = ttk.Radiobutton(self.frame4autoseparators, text="True",
                                                        variable=self.bool_autoseparators, value=True)
            radioTrue4autoseparators.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4autoseparators = ttk.Radiobutton(self.frame4autoseparators, text="False",
                                                         variable=self.bool_autoseparators, value=False)
            radioFalse4autoseparators.grid(sticky=E, row=1, column=2, padx=20)

            ### background Sec
            def color4background():
                color = colorchooser.askcolor()[1]
                windowObject.entry4background.delete(0, END)
                windowObject.entry4background.insert(END, color)

            self.label4background = ttk.Label(self.frameWidgetConfig, text="background", style="widgetconfig.TLabel")
            self.label4background.grid(sticky=W, row=300, column=1)
            self.frame4background = ttk.Frame(self.frameWidgetConfig)
            self.frame4background.grid(row=300, column=2)
            self.entry4background = Entry(self.frame4background, relief=FLAT)
            self.entry4background.pack(side=LEFT, padx=3)
            button4background = ttk.Button(self.frame4background, text=">>", style="moreOptions.TButton",
                                           command = color4background)
            button4background.pack(side=LEFT)

            ### bitmap Sec
            bitmaps = ("error", "gray75", "gray50", "gray25", "gray12", "hourglass", "info", "questhead", "question",
                       "warning")
            self.label4bitmap = ttk.Label(self.frameWidgetConfig, text="bitmap", style="widgetconfig.TLabel")
            self.label4bitmap.grid(sticky=W, row=400, column=1)
            self.combo4bitmap = ttk.Combobox(self.frameWidgetConfig, values = bitmaps)
            self.combo4bitmap.grid(row=400, column=2, ipadx=5)

            ### blockcursor Sec
            self.bool_blockcursor = BooleanVar()
            self.bool_blockcursor.set(True)
            self.label4blockcursor = ttk.Label(self.frameWidgetConfig, text="blockcursor",
                                                  style="widgetconfig.TLabel")
            self.label4blockcursor.grid(sticky=W, row=410, column=1)
            self.frame4blockcursor = ttk.Frame(self.frameWidgetConfig)
            self.frame4blockcursor.grid(row=410, column=2)
            radioTrue4blockcursor = ttk.Radiobutton(self.frame4blockcursor, text="True",
                                                       variable=self.bool_blockcursor, value=True)
            radioTrue4blockcursor.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4blockcursor = ttk.Radiobutton(self.frame4blockcursor, text="False",
                                                        variable=self.bool_blockcursor, value=False)
            radioFalse4blockcursor.grid(sticky=E, row=1, column=2, padx=20)

            ### borderwidth Sec
            # self.int_borderwidth = IntVar()
            # self.int_borderwidth.set("")
            self.label4borderwidth = ttk.Label(self.frameWidgetConfig, text="borderwidth", style="widgetconfig.TLabel")
            self.label4borderwidth.grid(sticky=W, row=500, column=1)
            self.spinbox4borderwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=200, increment=2, width=10, wrap=True)
                                                   # textvariable = self.int_borderwidth)
            self.spinbox4borderwidth.grid(row=500, column=2)

            ### buttonbackground Sec
            def color4buttonbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4buttonbackground.delete(0, END)
                windowObject.entry4buttonbackground.insert(END, color)

            self.label4buttonbackground = ttk.Label(self.frameWidgetConfig, text="button\nbackground", style="widgetconfig.TLabel")
            self.label4buttonbackground.grid(sticky=W, row=505, column=1)
            self.frame4buttonbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4buttonbackground.grid(row=505, column=2)
            self.entry4buttonbackground = Entry(self.frame4buttonbackground, relief=FLAT)
            self.entry4buttonbackground.pack(side=LEFT, padx=3)
            button4buttonbackground = ttk.Button(self.frame4buttonbackground, text=">>", style="moreOptions.TButton",
                                                 command = color4buttonbackground)
            button4buttonbackground.pack(side=LEFT)

            ### buttoncursor Sec
            buttoncursors = ( "arrow", "based_arrow_down", "based_arrow_up", "boat", "bogosity", "bottom_left_corner",
                              "bottom_right_corner", "bottom_side", "bottom_tee", "box_spiral", "center_ptr", "circle",
                              "clock", "coffee_mug", "cross",
            "cross_reverse", "crosshair", "diamond_cross", "dot", "dotbox", "double_arrow", "draft_large", "draft_small",
            "draped_box", "exchange", "fleur", "gobbler", "gumby", "hand1", "hand2", "heart", "icon", "iron_cross",
            "left_ptr", "left_side", "left_tee", "leftbutton", "ll_angle", "lr_angle", "man", "middlebutton", "mouse",
            "pencil", "pirate", "plus", "question_arrow", "right_ptr", "right_side", "right_tee", "rightbutton",
            "rtl_logo", "sailboat", "sb_down_arrow", "sb_h_double_arrow", "sb_left_arrow", "sb_right_arrow", "sb_up_arrow",
            "sb_v_double_arrow", "shuttle", "sizing", "spider", "spraycan", "star", "target", "tcross", "top_left_arrow",
            "top_left_corner", "top_right_corner", "top_side", "top_tee", "trek", "ul_angle", "umbrella", "ur_angle",
            "watch", "xterm", "X_cursor")
            self.label4buttoncursor = ttk.Label(self.frameWidgetConfig, text="button\ncursor", style="widgetconfig.TLabel")
            self.label4buttoncursor.grid(sticky=W, row=510, column=1)
            self.combo4buttoncursor = ttk.Combobox(self.frameWidgetConfig, values=buttoncursors)
            self.combo4buttoncursor.grid(row=510, column=2, ipadx=5)

            ### buttondownrelief Sec
            buttondownreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4buttondownrelief = ttk.Label(self.frameWidgetConfig, text="buttondown\nrelief", style="widgetconfig.TLabel")
            self.label4buttondownrelief.grid(sticky=W, row=515, column=1)
            self.combo4buttondownrelief = ttk.Combobox(self.frameWidgetConfig, values=buttondownreliefs)
            self.combo4buttondownrelief.grid(row=515, column=2, ipadx=5)

            ### buttonuprelief Sec
            buttonupreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4buttonuprelief = ttk.Label(self.frameWidgetConfig, text="buttonup\nrelief", style="widgetconfig.TLabel")
            self.label4buttonuprelief.grid(sticky=W, row=520, column=1)
            self.combo4buttonuprelief = ttk.Combobox(self.frameWidgetConfig, values=buttonupreliefs)
            self.combo4buttonuprelief.grid(row=520, column=2, ipadx=5)

            ### command Sec
            self.label4command = ttk.Label(self.frameWidgetConfig, text="command", style="widgetconfig.TLabel")
            self.label4command.grid(sticky=W, row=600, column=1)
            self.frame4command = ttk.Frame(self.frameWidgetConfig)
            self.frame4command.grid(row=600, column=2)
            self.entry4command = Entry(self.frame4command, relief=FLAT, )
            self.entry4command.pack(side=LEFT, padx=3)
            blank_label4command = ttk.Label(self.frame4command, text="", anchor=W, width=3)
            blank_label4command.pack(side=LEFT)

            ### compound Sec
            compounds = ("bottom", "center", "left", "right", "top")
            self.label4compound = ttk.Label(self.frameWidgetConfig, text="compound", style="widgetconfig.TLabel")
            self.label4compound.grid(sticky=W, row=610, column=1)
            self.combo4compound = ttk.Combobox(self.frameWidgetConfig, values = compounds)
            self.combo4compound.grid(row=610, column=2, ipadx=5)

            ### Cursor Sec
            cursors = ("arrow", "based_arrow_down", "based_arrow_up", "boat", "bogosity", "bottom_left_corner", "bottom_right_corner",
             "bottom_side", "bottom_tee", "box_spiral", "center_ptr", "circle", "clock", "coffee_mug", "cross",
             "cross_reverse", "crosshair", "diamond_cross", "dot", "dotbox", "double_arrow", "draft_large", "draft_small",
             "draped_box", "exchange", "fleur", "gobbler", "gumby", "hand1", "hand2", "heart", "icon", "iron_cross",
             "left_ptr", "left_side", "left_tee", "leftbutton", "ll_angle", "lr_angle", "man", "middlebutton", "mouse",
             "pencil", "pirate", "plus", "question_arrow", "right_ptr", "right_side", "right_tee", "rightbutton",
             "rtl_logo", "sailboat", "sb_down_arrow", "sb_h_double_arrow", "sb_left_arrow", "sb_right_arrow", "sb_up_arrow",
             "sb_v_double_arrow", "shuttle", "sizing", "spider", "spraycan", "star", "target", "tcross", "top_left_arrow",
             "top_left_corner", "top_right_corner", "top_side", "top_tee", "trek", "ul_angle", "umbrella", "ur_angle",
             "watch", "xterm", "X_cursor")
            self.label4cursor = ttk.Label(self.frameWidgetConfig, text="cursor", style="widgetconfig.TLabel")
            self.label4cursor.grid(sticky=W, row=700, column=1)
            self.combo4cursor = ttk.Combobox(self.frameWidgetConfig, values = cursors)
            self.combo4cursor.grid(row=700, column=2, ipadx=5)

            ### digits Sec
            # self.int_digits = IntVar(value = "")
            self.label4digits = ttk.Label(self.frameWidgetConfig, text="digits",
                                                      style="widgetconfig.TLabel")
            self.label4digits.grid(sticky=W, row=701, column=1)
            self.spinbox4digits = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=17, increment=1, width=10, wrap=True)
                                                          # textvariable = self.int_digits)
            self.spinbox4digits.grid(row=701, column=2)

            ### direction Sec
            directions = ("above", "below", "left", "right")
            self.label4direction = ttk.Label(self.frameWidgetConfig, text="direction", style="widgetconfig.TLabel")
            self.label4direction.grid(sticky=W, row=705, column=1)
            self.combo4direction = ttk.Combobox(self.frameWidgetConfig, values=directions)
            self.combo4direction.grid(row=705, column=2, ipadx=5)

            ### disabledbackground Sec
            def color4disabledbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4disabledbackground.delete(0, END)
                windowObject.entry4disabledbackground.insert(END, color)

            self.label4disabledbackground = ttk.Label(self.frameWidgetConfig, text="disabled\nbackground",
                                                      style="widgetconfig.TLabel")
            self.label4disabledbackground.grid(sticky=W, row=710, column=1)
            self.frame4disabledbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4disabledbackground.grid(row=710, column=2)
            self.entry4disabledbackground = Entry(self.frame4disabledbackground, relief=FLAT)
            self.entry4disabledbackground.pack(side=LEFT, padx=3)
            button4disabledbackground = ttk.Button(self.frame4disabledbackground, text=">>", style="moreOptions.TButton",
                                                   command = color4disabledbackground)
            button4disabledbackground.pack(side=LEFT)

            ### disabledforeground
            def color4disabledforeground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4disabledforeground.delete(0, END)
                windowObject.entry4disabledforeground.insert(END,color)

            self.label4disabledforeground = ttk.Label(self.frameWidgetConfig, text="disabled\nforeground",
                                                      style="widgetconfig.TLabel")
            self.label4disabledforeground.grid(sticky=W, row=800, column=1)
            self.frame4disabledforeground = ttk.Frame(self.frameWidgetConfig)
            self.frame4disabledforeground.grid(row=800, column=2)
            self.entry4disabledforeground = Entry(self.frame4disabledforeground, relief=FLAT)
            self.entry4disabledforeground.pack(side=LEFT, padx=3)
            button4disabledforeground = ttk.Button(self.frame4disabledforeground, text=">>", style="moreOptions.TButton",
                                                   command = color4disabledforeground)
            button4disabledforeground.pack(side=LEFT)

            ### exportselection
            self.bool_exportselection = BooleanVar()
            self.bool_exportselection.set(1)
            self.label4exportselection = ttk.Label(self.frameWidgetConfig, text="export\nselection",
                                                   style="widgetconfig.TLabel")
            self.label4exportselection.grid(sticky=W, row=810, column=1)
            self.frame4exportselection = ttk.Frame(self.frameWidgetConfig)
            self.frame4exportselection.grid(row=810, column=2)
            radioTrue4exportselection = ttk.Radiobutton(self.frame4exportselection, text="True",
                                                        variable=self.bool_exportselection, value=True)
            radioTrue4exportselection.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4exportselection = ttk.Radiobutton(self.frame4exportselection, text="False",
                                                         variable=self.bool_exportselection, value=False)
            radioFalse4exportselection.grid(sticky=E, row=1, column=2, padx=20)

            ### font Sec
            self.label4font = ttk.Label(self.frameWidgetConfig, text="font", style="widgetconfig.TLabel")
            self.label4font.grid(sticky=W, row=900, column=1)
            self.frame4font = ttk.Frame(self.frameWidgetConfig)
            self.frame4font.grid(row=900, column=2, )
            self.entry4font = Entry(self.frame4font, relief=FLAT)
            self.entry4font.pack(side=LEFT, padx=3)
            button4font = ttk.Button(self.frame4font, text=">>", style="moreOptions.TButton",
                                     command=self.executeFontToplevel)
            button4font.pack(side=LEFT)

            ### foreground Sec
            def color4foreground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4foreground.delete(0, END)
                windowObject.entry4foreground.insert(END,color)
            self.label4foreground = ttk.Label(self.frameWidgetConfig, text="foreground", style="widgetconfig.TLabel")
            self.label4foreground.grid(sticky=W, row=1000, column=1)
            self.frame4foreground = ttk.Frame(self.frameWidgetConfig)
            self.frame4foreground.grid(row=1000, column=2)
            self.entry4foreground = Entry(self.frame4foreground, relief=FLAT)
            self.entry4foreground.pack(side=LEFT, padx=3)
            button4foreground = ttk.Button(self.frame4foreground, text=">>", style="moreOptions.TButton",
                                           command = color4foreground)
            button4foreground.pack(side=LEFT)

            ### format Sec
            self.label4format = ttk.Label(self.frameWidgetConfig, text="format", style="widgetconfig.TLabel")
            self.label4format.grid(sticky=W, row=1010, column=1)
            self.frame4format = ttk.Frame(self.frameWidgetConfig)
            self.frame4format.grid(row=1010, column=2)
            self.entry4format = Entry(self.frame4format, relief=FLAT)
            self.entry4format.pack(side=LEFT, padx=3)
            blank_label4format = ttk.Label(self.frame4format, text="", anchor=W, width=3)
            blank_label4format.pack(side=LEFT)

            ### from_ Sec
            # self.int_from_ = IntVar()
            self.label4from_ = ttk.Label(self.frameWidgetConfig, text="from_", style="widgetconfig.TLabel")
            self.label4from_.grid(sticky=W, row=1020, column=1)
            self.frame4from_ = ttk.Frame(self.frameWidgetConfig)
            self.frame4from_.grid(row=1020, column=2)
            self.entry4from_ = Entry(self.frame4from_, relief=FLAT,)
                                     # textvariable = self.int_from_)
            self.entry4from_.pack(side=LEFT, padx=3)
            blank_label4from_ = ttk.Label(self.frame4from_, text="", anchor=W, width=3)
            blank_label4from_.pack(side=LEFT)

            ### handlepad
            # self.int_handlepad = IntVar()
            # self.int_handlepad.set(8)
            self.label4handlepad = ttk.Label(self.frameWidgetConfig, text="handlepad", style="widgetconfig.TLabel")
            self.label4handlepad.grid(sticky=W, row=1030, column=1)
            self.spinbox4handlepad = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment=1, to=50, width=10, wrap=True,)
                                                 # textvariable = self.int_handlepad)
            self.spinbox4handlepad.insert(END, 8)
            self.spinbox4handlepad.grid(row=1030, column=2)

            ### handlesize
            # self.int_handlesize = IntVar(value = 8)
            self.label4handlesize = ttk.Label(self.frameWidgetConfig, text="handlesize", style="widgetconfig.TLabel")
            self.label4handlesize.grid(sticky=W, row=1040, column=1)
            self.spinbox4handlesize = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment=1, to=50, width=10, wrap=True,)
                                                  # textvariable = self.int_handlesize)
            self.spinbox4handlesize.insert(END, 8)
            self.spinbox4handlesize.grid(row=1040, column=2)

            ### height Sec
            self.label4height = ttk.Label(self.frameWidgetConfig, text="height", style="widgetconfig.TLabel")
            self.label4height.grid(sticky=W, row=1100, column=1)
            self.spinbox4height = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment = 5, to = self.label4height.winfo_screenheight(), width=10, wrap = True)
            self.spinbox4height.grid(row=1100, column=2)

            ### highlightbackground Sec
            def color4highlightbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4highlightbackground.delete(0, END)
                windowObject.entry4highlightbackground.insert(END,color)

            self.label4highlightbackground = ttk.Label(self.frameWidgetConfig, text="highlight\nbackground",
                                                       style="widgetconfig.TLabel", )
            self.label4highlightbackground.grid(sticky=W, row=1200, column=1)
            self.frame4highlightbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4highlightbackground.grid(row=1200, column=2)
            self.entry4highlightbackground = Entry(self.frame4highlightbackground, relief=FLAT)
            self.entry4highlightbackground.pack(side=LEFT, padx=3)
            button4highlightbackground = ttk.Button(self.frame4highlightbackground, text=">>", style="moreOptions.TButton",
                                                    command = color4highlightbackground)
            button4highlightbackground.pack(side=LEFT)

            ### highlightcolor Sec
            def color4highlightcolor():
                color = colorchooser.askcolor()[1]
                windowObject.entry4highlightcolor.delete(0, END)
                windowObject.entry4highlightcolor.insert(END,color)

            self.label4highlightcolor = ttk.Label(self.frameWidgetConfig, text="highlight\ncolor",
                                                  style="widgetconfig.TLabel")
            self.label4highlightcolor.grid(sticky=W, row=1300, column=1)
            self.frame4highlightcolor = ttk.Frame(self.frameWidgetConfig)
            self.frame4highlightcolor.grid(row=1300, column=2)
            self.entry4highlightcolor = Entry(self.frame4highlightcolor, relief=FLAT)
            self.entry4highlightcolor.pack(side=LEFT, padx=3)
            button4highlightcolor = ttk.Button(self.frame4highlightcolor, text=">>", style="moreOptions.TButton",
                                               command = color4highlightcolor)
            button4highlightcolor.pack(side=LEFT)

            ### highlightthickness Sec
            # self.int_highlightthickness = IntVar()
            self.label4highlightthickness = ttk.Label(self.frameWidgetConfig, text="highlight\nthickness",
                                                      style="widgetconfig.TLabel")
            self.label4highlightthickness.grid(sticky=W, row=1400, column=1)
            self.spinbox4highlightthickness = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                          wrap=True,)
                                                                    # textvariable = self.int_highlightthickness)
            self.spinbox4highlightthickness.grid(row=1400, column=2)

            ### image Sec
            # def command4scale_imagewidth(value):
            #     value = float(value)
            #     value = int(value)
            #     windowObject.dictCountImage[f"Image{windowObject.count_image_instances-1}"].config(width = value, height = value)
            # def command4scale_imageheight():
            #     pass

            def filedialog4image():
                file_get = filedialog.askopenfile(filetypes = [("Portable Network Graphics (PNG)", "*png")])

                try:
                    file_get.name
                # label_adjustimagewidth = ttk.Label(self.frameWidgetConfig, text = "adjust\nimage\nwidth",
                #                                    style = "widgetconfig.TLabel")
                # label_adjustimagewidth.grid(row = 1406, column = 1)
                # scale_imagewidth = ttk.Scale(self.frameWidgetConfig, from_ = 0, to = 999, command = command4scale_imagewidth)
                # scale_imagewidth.grid(row = 1406, column = 2,)
                #
                # label_adjustimageheight = ttk.Label(self.frameWidgetConfig, text="adjust\nimage\nheight",
                #                                     style="widgetconfig.TLabel")
                # label_adjustimageheight.grid(row=1407, column=1)
                # scale_imageheight = ttk.Scale(self.frameWidgetConfig, from_ = 0, to = 999)
                # scale_imageheight.grid(row = 1407, column = 2)
                except:
                    pass
                else:
                    windowObject.dictCountImage[f"Image{windowObject.count_image_instances}"] = PhotoImage(master = windowDesign,
                                                    file = file_get.name, name = f"image_{windowObject.count_image_instances}")
                    print(file_get.name)
                    windowObject.entry4image.delete(0, END)
                    windowObject.entry4image.insert(END, f"image_{windowObject.count_image_instances}")


                    windowObject.implementImage_determine = 22
                # except:
                #     pass
                # arrangeObject.refreshAttributes()
                # windowObject.count_image_instances += 1

            self.label4image = ttk.Label(self.frameWidgetConfig, text="image", style="widgetconfig.TLabel")
            self.label4image.grid(sticky=W, row=1405, column=1)
            self.frame4image = ttk.Frame(self.frameWidgetConfig)
            self.frame4image.grid(row=1405, column=2)
            self.entry4image = Entry(self.frame4image, relief=FLAT)
            self.entry4image.pack(side=LEFT, padx=3)
            button4image = ttk.Button(self.frame4image, text=">>", style="moreOptions.TButton", command = filedialog4image)
            button4image.pack(side=LEFT)

            ### inactiveselectbackground Sec
            def color4inactiveselectbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4inactiveselectbackground.delete(0, END)
                windowObject.entry4inactiveselectbackground.insert(END,color)

            self.label4inactiveselectbackground = ttk.Label(self.frameWidgetConfig, text="inactive\nselect\nbackground",
                                                            style="widgetconfig.TLabel")
            self.label4inactiveselectbackground.grid(sticky=W, row=1409, column=1)
            self.frame4inactiveselectbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4inactiveselectbackground.grid(row=1409, column=2)
            self.entry4inactiveselectbackground = Entry(self.frame4inactiveselectbackground, relief=FLAT)
            self.entry4inactiveselectbackground.pack(side=LEFT, padx=3)
            button4inactiveselectbackground = ttk.Button(self.frame4inactiveselectbackground, text=">>",
                                                    style="moreOptions.TButton", command = color4inactiveselectbackground)
            button4inactiveselectbackground.pack(side=LEFT)


            ### increment Sec
            # self.int_increment = IntVar()
            self.label4increment = ttk.Label(self.frameWidgetConfig, text="increment", style="widgetconfig.TLabel")
            self.label4increment.grid(sticky=W, row=1411, column=1)
            self.frame4increment = ttk.Frame(self.frameWidgetConfig)
            self.frame4increment.grid(row=1411, column=2)
            self.entry4increment = Entry(self.frame4increment, relief=FLAT, )
                                         # textvariable = self.int_increment)
            self.entry4increment.pack(side=LEFT, padx=3)
            button4increment = ttk.Button(self.frame4increment, text=">>", style="moreOptions.TButton")
            button4increment.pack(side=LEFT)

            ### indicatoron Sec
            self.bool_indicatoron = BooleanVar()
            self.bool_indicatoron.set(1)
            self.label4indicatoron = ttk.Label(self.frameWidgetConfig, text="indicatoron", style="widgetconfig.TLabel")
            self.label4indicatoron.grid(sticky=W, row=1412, column=1)
            self.frame4indicatoron = ttk.Frame(self.frameWidgetConfig)
            self.frame4indicatoron.grid(row=1412, column=2)
            radioTrue4indicatoron = ttk.Radiobutton(self.frame4indicatoron, text="True", variable=self.bool_indicatoron,
                                                  value=True)
            radioTrue4indicatoron.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4indicatoron = ttk.Radiobutton(self.frame4indicatoron, text="False", variable=self.bool_indicatoron,
                                                   value=False)
            radioFalse4indicatoron.grid(sticky=E, row=1, column=2, padx=20)

            ### insertbackground Sec
            def color4insertbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4insertbackground.delete(0, END)
                windowObject.entry4insertbackground.insert(END, color)

            self.label4insertbackground = ttk.Label(self.frameWidgetConfig, text="insert\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4insertbackground.grid(sticky=W, row=1415, column=1)
            self.frame4insertbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4insertbackground.grid(row=1415, column=2)
            self.entry4insertbackground = Entry(self.frame4insertbackground, relief=FLAT)
            self.entry4insertbackground.pack(side=LEFT, padx=3)
            button4insertbackground = ttk.Button(self.frame4insertbackground, text=">>", style="moreOptions.TButton",
                                                 command = color4insertbackground)
            button4insertbackground.pack(side=LEFT)

            ### insertborderwidth Sec
            # self.int_insertborderwidth = IntVar()
            self.label4insertborderwidth = ttk.Label(self.frameWidgetConfig, text="insert\nborderwidth",
                                                     style="widgetconfig.TLabel")
            self.label4insertborderwidth.grid(sticky=W, row=1420, column=1)
            self.spinbox4insertborderwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                         wrap=True,)
                                                         # textvariable = self.int_insertborderwidth)
            self.spinbox4insertborderwidth.grid(row=1420, column=2)

            ### insertofftime Sec
            # self.int_insertofftime = IntVar()
            self.label4insertofftime = ttk.Label(self.frameWidgetConfig, text="insert\nofftime",
                                                 style="widgetconfig.TLabel")
            self.label4insertofftime.grid(sticky=W, row=1425, column=1)
            self.spinbox4insertofftime = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                     wrap=True,)
                                                     # textvariable = self.int_insertofftime)
            self.spinbox4insertofftime.grid(row=1425, column=2)

            ### insertontime Sec
            # self.int_insertontime = IntVar()
            self.label4insertontime = ttk.Label(self.frameWidgetConfig, text="insert\nontime", style="widgetconfig.TLabel")
            self.label4insertontime.grid(sticky=W, row=1430, column=1)
            self.spinbox4insertontime = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                    wrap=True,)
                                                    # textvariable = self.int_insertontime)
            self.spinbox4insertontime.grid(row=1430, column=2)

            ### insertunfocussed
            insertunfocusseds = ("hollow", "solid", "none")
            self.label4insertunfoccussed = ttk.Label(self.frameWidgetConfig, text="insert\nunfocussed",
                                                     style="widgetconfig.TLabel")
            self.label4insertunfoccussed.grid(sticky=W, row=1431, column=1)
            self.combo4insertunfoccussed = ttk.Combobox(self.frameWidgetConfig, values=insertunfocusseds)
            self.combo4insertunfoccussed.grid(row=1431, column=2, ipadx=5)

            ### insertwidth Sec
            # self.int_insertwidth = IntVar()
            self.label4insertwidth = ttk.Label(self.frameWidgetConfig, text="insert\nwidth", style="widgetconfig.TLabel")
            self.label4insertwidth.grid(sticky=W, row=1435, column=1)
            self.spinbox4insertwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10, wrap=True)
                                                   # textvariable = self.int_insertwidth)
            self.spinbox4insertwidth.grid(row=1435, column=2)

            ### invalidcommand Sec
            self.label4invalidcommand = ttk.Label(self.frameWidgetConfig, text="invalid\ncommand",
                                                       style="widgetconfig.TLabel", )
            self.label4invalidcommand.grid(sticky=W, row=1450, column=1)
            self.frame4invalidcommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4invalidcommand.grid(row=1450, column=2)
            self.entry4invalidcommand = Entry(self.frame4invalidcommand, relief=FLAT)
            self.entry4invalidcommand.pack(side=LEFT, padx=3)
            button4invalidcommand = ttk.Button(self.frame4invalidcommand, text=">>", style="moreOptions.TButton")
            button4invalidcommand.pack(side=LEFT)

            ### Justify Sec
            justifys = ("left", "center", "right")
            self.label4justify = ttk.Label(self.frameWidgetConfig, text="justify", style="widgetconfig.TLabel")
            self.label4justify.grid(sticky=W, row=1460, column=1)
            self.combo4justify = ttk.Combobox(self.frameWidgetConfig, values = justifys)
            self.combo4justify.grid(row=1460, column=2, ipadx=5)

            ### label Sec
            self.label4label = ttk.Label(self.frameWidgetConfig, text="label", style="widgetconfig.TLabel")
            self.label4label.grid(sticky=W, row=1470, column=1)
            self.frame4label = ttk.Frame(self.frameWidgetConfig)
            self.frame4label.grid(row=1470, column=2)
            self.entry4label = Entry(self.frame4label, relief=FLAT)
            self.entry4label.pack(side=LEFT, padx=3)
            blank_label4label = ttk.Label(self.frame4label, text="", anchor=W, width=3)
            blank_label4label.pack(side=LEFT)

            ### labelanchor Sec
            labelanchors = ("nw", "n", "ne", "en", "e", "es", "wn", "w", "ws", "sw", "s", "se")
            self.label4labelanchor = ttk.Label(self.frameWidgetConfig, text="labelanchor", style="widgetconfig.TLabel")
            self.label4labelanchor.grid(sticky=W, row=1501, column=1)
            self.combo4labelanchor = ttk.Combobox(self.frameWidgetConfig, values=labelanchors)
            self.combo4labelanchor.grid(row=1501, column=2, ipadx=5)

            ### labelwidget Sec
            self.label4labelwidget = ttk.Label(self.frameWidgetConfig, text="labelwidget", style="widgetconfig.TLabel")
            self.label4labelwidget.grid(sticky=W, row=1502, column=1)
            self.frame4labelwidget = ttk.Frame(self.frameWidgetConfig)
            self.frame4labelwidget.grid(row=1502, column=2)
            self.entry4labelwidget = Entry(self.frame4labelwidget, relief=FLAT)
            self.entry4labelwidget.pack(side=LEFT, padx=3)
            blank_label4labelwidget = ttk.Label(self.frame4labelwidget, text="", anchor=W, width=3)
            blank_label4labelwidget.pack(side=LEFT)

            ### length Sec
            self.label4length = ttk.Label(self.frameWidgetConfig, text="length", style="widgetconfig.TLabel")
            self.label4length.grid(sticky=W, row=1503, column=1)
            self.spinbox4length = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=300, increment=2, width=10, wrap=True)
            self.spinbox4length.grid(row=1503, column=2)

            ### listvariable Sec
            self.label4listvariable = ttk.Label(self.frameWidgetConfig, text="list\nvariable",
                                                  style="widgetconfig.TLabel", )
            self.label4listvariable.grid(sticky=W, row=1504, column=1)
            self.frame4listvariable = ttk.Frame(self.frameWidgetConfig)
            self.frame4listvariable.grid(row=1504, column=2)
            self.entry4listvariable = Entry(self.frame4listvariable, relief=FLAT)
            self.entry4listvariable.pack(side=LEFT, padx=3)
            button4listvariable = ttk.Button(self.frame4listvariable, text=">>", style="moreOptions.TButton")
            button4listvariable.pack(side=LEFT)

            ### maxundo
            # self.int_maxundo = IntVar()
            self.label4maxundo = ttk.Label(self.frameWidgetConfig, text="maxundo", style="widgetconfig.TLabel")
            self.label4maxundo.grid(sticky=W, row=1505, column=1)
            self.frame4maxundo = ttk.Frame(self.frameWidgetConfig)
            self.frame4maxundo.grid(row=1505, column=2)
            self.entry4maxundo = Entry(self.frame4maxundo, relief=FLAT,)
                                       # textvariable = self.int_maxundo)
            self.entry4maxundo.pack(side=LEFT, padx=3)
            blank_label4maxundo = ttk.Label(self.frame4maxundo, text="", anchor=W, width=3)
            blank_label4maxundo.pack(side=LEFT)

            ### menu Sec
            self.label4menu = ttk.Label(self.frameWidgetConfig, text="menu",
                                                style="widgetconfig.TLabel", )
            self.label4menu.grid(sticky=W, row=1506, column=1)
            self.frame4menu = ttk.Frame(self.frameWidgetConfig)
            self.frame4menu.grid(row=1506, column=2)
            self.entry4menu = Entry(self.frame4menu, relief=FLAT)
            self.entry4menu.pack(side=LEFT, padx=3)
            button4menu = ttk.Button(self.frame4menu, text=">>", style="moreOptions.TButton")
            button4menu.pack(side=LEFT)

            ### offrelief Sec
            offreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4offrelief = ttk.Label(self.frameWidgetConfig, text="offrelief", style="widgetconfig.TLabel")
            self.label4offrelief.grid(sticky=W, row=1507, column=1)
            self.combo4offrelief = ttk.Combobox(self.frameWidgetConfig, values=offreliefs)
            self.combo4offrelief.grid(row=1507, column=2, ipadx=5)

            ### opaqueresize Sec
            self.bool_opaqueresize = BooleanVar()
            self.bool_opaqueresize.set(1)
            self.label4opaqueresize = ttk.Label(self.frameWidgetConfig, text="opaque\nresize", style="widgetconfig.TLabel")
            self.label4opaqueresize.grid(sticky=W, row=1508, column=1)
            self.frame4opaqueresize = ttk.Frame(self.frameWidgetConfig)
            self.frame4opaqueresize.grid(row=1508, column=2)
            radioTrue4opaqueresize = ttk.Radiobutton(self.frame4opaqueresize, text="True", variable=self.bool_opaqueresize,
                                                  value=True)
            radioTrue4opaqueresize.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4opaqueresize = ttk.Radiobutton(self.frame4opaqueresize, text="False", variable=self.bool_opaqueresize,
                                                   value=False)
            radioFalse4opaqueresize.grid(sticky=E, row=1, column=2, padx=20)

            ### orient Sec
            orient = ("horizontal", "vertical")
            self.label4orient = label4cursor = ttk.Label(self.frameWidgetConfig, text="orient", style="widgetconfig.TLabel")
            self.label4orient.grid(sticky=W, row=1510, column=1)
            self.combo4orient = ttk.Combobox(self.frameWidgetConfig, values = orient)
            self.combo4orient.grid(row=1510, column=2, ipadx=5)

            ### overrelief Sec
            overreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4overrelief = ttk.Label(self.frameWidgetConfig, text="overrelief", style="widgetconfig.TLabel")
            self.label4overrelief.grid(sticky=W, row=1515, column=1)
            self.combo4overrelief = ttk.Combobox(self.frameWidgetConfig, values = overreliefs)
            self.combo4overrelief.grid(row=1515, column=2, ipadx=5)

            ### padx Sec
            # self.int_padx = IntVar()
            self.label4padx = ttk.Label(self.frameWidgetConfig, text="padx", style="widgetconfig.TLabel")
            self.label4padx.grid(sticky=W, row=1600, column=1)
            self.spinbox4padx = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10, wrap=True)
                                            # textvariable = self.int_padx)
            self.spinbox4padx.grid(row=1600, column=2)

            ### pady Sec
            # self.int_pady = IntVar()
            self.label4pady = ttk.Label(self.frameWidgetConfig, text="pady", style="widgetconfig.TLabel")
            self.label4pady.grid(sticky=W, row=1700, column=1)
            self.spinbox4pady = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10, wrap=True,)
                                            # textvariable = self.int_pady)
            self.spinbox4pady.grid(row=1700, column=2)

            ### readonlybackground
            def color4readonlybackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4readonlybackground.delete(0, END)
                windowObject.entry4readonlybackground.insert(END,color)

            self.label4readonlybackground = ttk.Label(self.frameWidgetConfig, text="readonly\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4readonlybackground.grid(sticky=W, row=1710, column=1)
            self.frame4readonlybackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4readonlybackground.grid(row=1710, column=2)
            self.entry4readonlybackground = Entry(self.frame4readonlybackground, relief=FLAT)
            self.entry4readonlybackground.pack(side=LEFT, padx=3)
            button4readonlybackground = ttk.Button(self.frame4readonlybackground, text=">>", style="moreOptions.TButton",
                                                   command = color4readonlybackground)
            button4readonlybackground.pack(side=LEFT)

            ### relief Sec
            reliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4relief = ttk.Label(self.frameWidgetConfig, text="relief", style="widgetconfig.TLabel")
            self.label4relief.grid(sticky=W, row=1800, column=1)
            self.combo4relief = ttk.Combobox(self.frameWidgetConfig, values = reliefs)
            self.combo4relief.grid(row=1800, column=2, ipadx=5)

            ### repeatdelay Sec
            # self.int_repeatdelay = IntVar()
            self.label4repeatdelay = ttk.Label(self.frameWidgetConfig, text="repeat\ndelay", style="widgetconfig.TLabel")
            self.label4repeatdelay.grid(sticky=W, row=1815, column=1)
            self.spinbox4repeatdelay = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                   wrap=True,)
                                                   # textvariable = self.int_repeatdelay)
            self.spinbox4repeatdelay.grid(row=1815, column=2)

            ### repeatinterval
            # self.int_repeatinterval = IntVar()
            self.label4repeatinterval = ttk.Label(self.frameWidgetConfig, text="repeat\ninterval",
                                                  style="widgetconfig.TLabel")
            self.label4repeatinterval.grid(sticky=W, row=1820, column=1)
            self.spinbox4repeatinterval = ttk.Spinbox(self.frameWidgetConfig, from_=0, to=3000, increment=100, width=10,
                                                      wrap=True,)
                                                      # textvariable = self.int_repeatinterval)
            self.spinbox4repeatinterval.grid(row=1820, column=2)

            ### resolution
            # self.int_resolution = IntVar()
            self.label4resolution = ttk.Label(self.frameWidgetConfig, text="resolution",
                                                      style="widgetconfig.TLabel")
            self.label4resolution.grid(sticky=W, row=1821, column=1)
            self.frame4resolution = ttk.Frame(self.frameWidgetConfig)
            self.frame4resolution.grid(row=1821, column=2)
            self.entry4resolution = Entry(self.frame4resolution, relief=FLAT,)
                                          # textvariable = self.int_resolution)
            self.entry4resolution.pack(side=LEFT, padx=3)
            blank_label4resolution = ttk.Label(self.frame4resolution, text="", anchor=W, width=3)
            blank_label4resolution.pack(side=LEFT)

            ### sashcursor
            sashcursors = (
            "arrow", "based_arrow_down", "based_arrow_up", "boat", "bogosity", "bottom_left_corner", "bottom_right_corner",
            "bottom_side", "bottom_tee", "box_spiral", "center_ptr", "circle", "clock", "coffee_mug", "cross",
            "cross_reverse", "crosshair", "diamond_cross", "dot", "dotbox", "double_arrow", "draft_large", "draft_small",
            "draped_box", "exchange", "fleur", "gobbler", "gumby", "hand1", "hand2", "heart", "icon", "iron_cross",
            "left_ptr", "left_side", "left_tee", "leftbutton", "ll_angle", "lr_angle", "man", "middlebutton", "mouse",
            "pencil", "pirate", "plus", "question_arrow", "right_ptr", "right_side", "right_tee", "rightbutton",
            "rtl_logo", "sailboat", "sb_down_arrow", "sb_h_double_arrow", "sb_left_arrow", "sb_right_arrow", "sb_up_arrow",
            "sb_v_double_arrow", "shuttle", "sizing", "spider", "spraycan", "star", "target", "tcross", "top_left_arrow",
            "top_left_corner", "top_right_corner", "top_side", "top_tee", "trek", "ul_angle", "umbrella", "ur_angle",
            "watch", "xterm", "X_cursor")
            self.label4sashcursor = ttk.Label(self.frameWidgetConfig, text="sash\ncursor", style="widgetconfig.TLabel")
            self.label4sashcursor.grid(sticky=W, row=1822, column=1)
            self.combo4sashcursor = ttk.Combobox(self.frameWidgetConfig, values=sashcursors)
            self.combo4sashcursor.grid(row=1822, column=2, ipadx=5)

            ### sashpad Sec
            def command4sashpad(new_value):
                new_value = self.int_sashpad.get()
                windowObject.int_sashpad.set(new_value)

            self.int_sashpad = IntVar(value = 0,)
            self.label4sashpad = ttk.Label(self.frameWidgetConfig, text = "sash\npad", style = "widgetconfig.TLabel")
            self.label4sashpad.grid(sticky = W, row = 1823, column = 1)
            self.frame4sashpad = Frame(self.frameWidgetConfig, )
            self.frame4sashpad.grid(sticky = W, row = 1823, column = 2, padx = 25)
            self.label24sashpad = Label(self.frame4sashpad, textvariable = self.int_sashpad)
            self.label24sashpad.pack()
            self.scale4sashpad = ttk.Scale(self.frame4sashpad, from_ = 1, to = 50,
                                                variable = self.int_sashpad, command = command4sashpad)
            self.scale4sashpad.pack()

            ### sashrelief Sec
            sashreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4sashrelief = ttk.Label(self.frameWidgetConfig, text="sash\nrelief", style="widgetconfig.TLabel")
            self.label4sashrelief.grid(sticky=W, row=1824, column=1)
            self.combo4sashrelief = ttk.Combobox(self.frameWidgetConfig, values=sashreliefs)
            self.combo4sashrelief.grid(row=1824, column=2, ipadx=5)

            ### sashwidth Sec
            def command4sashwidth(new_value):
                new_value = self.int_sashwidth.get()
                windowObject.int_sashwidth.set(new_value)

            self.int_sashwidth = IntVar(value = 3)
            self.label4sashwidth = ttk.Label(self.frameWidgetConfig, text = "sash\nwidth", style = "widgetconfig.TLabel")
            self.label4sashwidth.grid(sticky = W, row = 1825, column = 1)
            self.frame4sashwidth = Frame(self.frameWidgetConfig, )
            self.frame4sashwidth.grid(sticky = W, row = 1825, column = 2, padx = 25)
            self.label24sashwidth = Label(self.frame4sashwidth, textvariable = self.int_sashwidth)
            self.label24sashwidth.pack()
            self.scale4sashwidth = ttk.Scale(self.frame4sashwidth, from_ = 1, to = 50,
                                                variable = self.int_sashwidth, command = command4sashwidth)
            self.scale4sashwidth.pack()

            ### showhandle Sec
            self.bool_showhandle = BooleanVar()
            self.bool_showhandle.set(True)
            self.label4showhandle = ttk.Label(self.frameWidgetConfig, text="show\nhandle", style="widgetconfig.TLabel")
            self.label4showhandle.grid(sticky=W, row=1826, column=1)
            self.frame4showhandle = ttk.Frame(self.frameWidgetConfig)
            self.frame4showhandle.grid(row=1826, column=2)
            radioTrue4showhandle = ttk.Radiobutton(self.frame4showhandle, text="True", variable=self.bool_showhandle,
                                                     value=True)
            radioTrue4showhandle.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4showhandle = ttk.Radiobutton(self.frame4showhandle, text="False",
                                                      variable=self.bool_showhandle,
                                                      value=False)
            radioFalse4showhandle.grid(sticky=E, row=1, column=2, padx=20)


            ### selectbackground Sec
            def color4selectbackground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4selectbackground.delete(0, END)
                windowObject.entry4selectbackground.insert(END,color)
            self.label4selectbackground = ttk.Label(self.frameWidgetConfig, text="select\nbackground",
                                                    style="widgetconfig.TLabel")
            self.label4selectbackground.grid(sticky=W, row=1828, column=1)
            self.frame4selectbackground = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectbackground.grid(row=1828, column=2)
            self.entry4selectbackground = Entry(self.frame4selectbackground, relief=FLAT)
            self.entry4selectbackground.pack(side=LEFT, padx=3)
            button4selectbackground = ttk.Button(self.frame4selectbackground, text=">>", style="moreOptions.TButton",
                                                 command = color4selectbackground)
            button4selectbackground.pack(side=LEFT)

            ### selectborderwidth Sec
            # self.int_selectborderwidth = IntVar()
            self.label4selectborderwidth = ttk.Label(self.frameWidgetConfig, text="select\nborderwidth",
                                                     style="widgetconfig.TLabel")
            self.label4selectborderwidth.grid(sticky=W, row=1830, column=1)
            self.spinbox4selectborderwidth = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                         wrap=True,)
                                                         # textvariable = self.int_selectborderwidth)
            self.spinbox4selectborderwidth.grid(row=1830, column=2)

            ### selectcolor Sec
            def color4selectcolor():
                color = colorchooser.askcolor()[1]
                windowObject.entry4selectcolor.delete(0, END)
                windowObject.entry4selectcolor.insert(END,color)
            self.label4selectcolor = ttk.Label(self.frameWidgetConfig, text="selectcolor",
                                          style="widgetconfig.TLabel")
            self.label4selectcolor.grid(sticky=W, row=1831, column=1)
            self.frame4selectcolor = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectcolor.grid(row=1831, column=2)
            self.entry4selectcolor = Entry(self.frame4selectcolor, relief=FLAT)
            self.entry4selectcolor.pack(side=LEFT, padx=3)
            button4selectcolor = ttk.Button(self.frame4selectcolor, text=">>", style="moreOptions.TButton",
                                            command = color4selectcolor)
            button4selectcolor.pack(side=LEFT)

            ### selectforeground Sec
            def color4selectforeground():
                color = colorchooser.askcolor()[1]
                windowObject.entry4selectforeground.delete(0, END)
                windowObject.entry4selectforeground.insert(END,color)
            self.label4selectforeground = ttk.Label(self.frameWidgetConfig, text="select\nforeground",
                                                    style="widgetconfig.TLabel")
            self.label4selectforeground.grid(sticky=W, row=1835, column=1)
            self.frame4selectforeground = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectforeground.grid(row=1835, column=2)
            self.entry4selectforeground = Entry(self.frame4selectforeground, relief=FLAT)
            self.entry4selectforeground.pack(side=LEFT, padx=3)
            button4selectforeground = ttk.Button(self.frame4selectforeground, text=">>", style="moreOptions.TButton",
                                                 command = color4selectforeground)
            button4selectforeground.pack(side=LEFT)

            ### selectimage Sec
            self.label4selectimage = ttk.Label(self.frameWidgetConfig, text="selectimage", style="widgetconfig.TLabel")
            self.label4selectimage.grid(sticky=W, row=1836, column=1)
            self.frame4selectimage = ttk.Frame(self.frameWidgetConfig)
            self.frame4selectimage.grid(row=1836, column=2)
            self.entry4selectimage = Entry(self.frame4selectimage, relief=FLAT)
            self.entry4selectimage.pack(side=LEFT, padx=3)
            button4selectimage = ttk.Button(self.frame4selectimage, text=">>", style="moreOptions.TButton")
            button4selectimage.pack(side=LEFT)

            ### selectmode Sec
            selectmodes = ("browse", "single", "multiple", "extended")
            self.label4selectmode = ttk.Label(self.frameWidgetConfig, text="select\nmode", style="widgetconfig.TLabel")
            self.label4selectmode.grid(sticky=W, row=1837, column=1)
            self.combo4selectmode = ttk.Combobox(self.frameWidgetConfig, values = selectmodes)
            self.combo4selectmode.grid(row=1837, column=2, ipadx=5)

            ### show Sec
            self.label4show = ttk.Label(self.frameWidgetConfig, text="show", style="widgetconfig.TLabel")
            self.label4show.grid(sticky=W, row=1838, column=1)
            self.frame4show = ttk.Frame(self.frameWidgetConfig)
            self.frame4show.grid(row=1838, column=2)
            self.entry4show = Entry(self.frame4show, relief=FLAT)
            self.entry4show.pack(side=LEFT, padx=3)
            button4show = ttk.Button(self.frame4show, text=">>", style="moreOptions.TButton")
            button4show.pack(side=LEFT)

            ### showvalue Sec
            self.bool_showvalue = BooleanVar()
            self.bool_showvalue.set(1)
            self.label4showvalue = ttk.Label(self.frameWidgetConfig, text="showvalue", style="widgetconfig.TLabel")
            self.label4showvalue.grid(sticky=W, row=1839, column=1)
            self.frame4showvalue = ttk.Frame(self.frameWidgetConfig)
            self.frame4showvalue.grid(row=1839, column=2)
            radioTrue4showvalue = ttk.Radiobutton(self.frame4showvalue, text="True", variable=self.bool_showvalue,
                                                  value=True)
            radioTrue4showvalue.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4showvalue = ttk.Radiobutton(self.frame4showvalue, text="False", variable=self.bool_showvalue,
                                                   value=False)
            radioFalse4showvalue.grid(sticky=E, row=1, column=2, padx=20)

            ### sliderlength Sec
            def command4sliderlength(new_value):
                new_value = self.int_sliderlength.get()
                windowObject.int_sliderlength.set(new_value)

            self.int_sliderlength = IntVar(value = 30)
            self.label4sliderlength = ttk.Label(self.frameWidgetConfig, text = "slider\nlength", style = "widgetconfig.TLabel")
            self.label4sliderlength.grid(sticky = W, row = 1840, column = 1)
            self.frame4sliderlength = Frame(self.frameWidgetConfig, )
            self.frame4sliderlength.grid(sticky = W, row = 1840, column = 2, padx = 25)
            self.label24sliderlength = Label(self.frame4sliderlength, text = self.int_sliderlength.get())
            self.label24sliderlength.pack()
            self.scale4sliderlength = ttk.Scale(self.frame4sliderlength, from_ = 1, to = 500,
                                                variable = self.int_sliderlength, command = command4sliderlength)
            self.scale4sliderlength.pack()

            ### sliderrelief Sec
            sliderreliefs = ("flat", "raised", "sunken", "groove", "ridge", "solid")
            self.label4sliderrelief = ttk.Label(self.frameWidgetConfig, text="slider\nrelief", style="widgetconfig.TLabel")
            self.label4sliderrelief.grid(sticky=W, row=1841, column=1)
            self.combo4sliderrelief = ttk.Combobox(self.frameWidgetConfig, values=sliderreliefs)
            self.combo4sliderrelief.grid(row=1841, column=2, ipadx=5)

            ### spacing1 Sec
            # self.int_spacing1 = IntVar()
            self.label4spacing1 = ttk.Label(self.frameWidgetConfig, text="spacing1",
                                                     style="widgetconfig.TLabel")
            self.label4spacing1.grid(sticky=W, row=1843, column=1)
            self.spinbox4spacing1 = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                         wrap=True)
                                                # textvariable = self.int_spacing1)
            self.spinbox4spacing1.grid(row=1843, column=2)

            ### spacing2 Sec
            # self.int_spacing2 = IntVar()
            self.label4spacing2 = ttk.Label(self.frameWidgetConfig, text="spacing2",
                                            style="widgetconfig.TLabel")
            self.label4spacing2.grid(sticky=W, row=1844, column=1)
            self.spinbox4spacing2 = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                wrap=True,)
                                                # textvariable = self.int_spacing2)
            self.spinbox4spacing2.grid(row=1844, column=2)

            ### spacing3 Sec
            # self.int_spacing3 = IntVar()
            self.label4spacing3 = ttk.Label(self.frameWidgetConfig, text="spacing3",
                                            style="widgetconfig.TLabel")
            self.label4spacing3.grid(sticky=W, row=1845, column=1)
            self.spinbox4spacing3 = ttk.Spinbox(self.frameWidgetConfig, from_=1, to=50, increment=2, width=10,
                                                wrap=True,)
                                                # textvariable = self.int_spacing3)
            self.spinbox4spacing3.grid(row=1845, column=2)

            ### state Sec
            states = ("active", "disabled", "normal")
            self.label4state = ttk.Label(self.frameWidgetConfig, text="state", style="widgetconfig.TLabel")
            self.label4state.grid(sticky=W, row=1848, column=1)
            self.combo4state = ttk.Combobox(self.frameWidgetConfig, values = states)
            self.combo4state.grid(row=1848, column=2, ipadx=5)

            ### tabs Sec
            self.label4tabs = ttk.Label(self.frameWidgetConfig, text="tabs", style="widgetconfig.TLabel")
            self.label4tabs.grid(sticky=W, row=1850, column=1)
            self.frame4tabs = ttk.Frame(self.frameWidgetConfig)
            self.frame4tabs.grid(row=1850, column=2)
            self.entry4tabs = Entry(self.frame4tabs, relief=FLAT, )
            self.entry4tabs.pack(side=LEFT, padx=3)
            blank_label4tabs = ttk.Label(self.frame4tabs, text="", anchor=W, width=3)
            blank_label4tabs.pack(side=LEFT)

            ### takefocus Sec
            self.bool_takefocus = BooleanVar()
            self.bool_takefocus.set(1)
            self.label4takefocus = ttk.Label(self.frameWidgetConfig, text="takefocus", style="widgetconfig.TLabel")
            self.label4takefocus.grid(sticky=W, row=1900, column=1)
            self.frame4takefocus = ttk.Frame(self.frameWidgetConfig)
            self.frame4takefocus.grid(row=1900, column=2)
            radioTrue4takefocus = ttk.Radiobutton(self.frame4takefocus, text="True", variable=self.bool_takefocus, value=True)
            radioTrue4takefocus.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4takefocus = ttk.Radiobutton(self.frame4takefocus, text="False", variable=self.bool_takefocus, value=False)
            radioFalse4takefocus.grid(sticky=E, row=1, column=2, padx=20)

            ### text Sec
            self.label4text = ttk.Label(self.frameWidgetConfig, text="text", style="widgetconfig.TLabel")
            self.label4text.grid(sticky=W, row=2000, column=1)
            self.frame4text = ttk.Label(self.frameWidgetConfig)
            self.frame4text.grid(row=2000, column=2)
            self.entry4text = Entry(self.frame4text,  relief = FLAT)
            self.entry4text.grid(row=1, column=1, padx = 3 )
            button4text = ttk.Button(self.frame4text, text = ">>", style = "moreOptions.TButton")
            button4text.grid(row = 1, column = 2,)
            xscrollbar4text = ttk.Scrollbar(self.frame4text, orient=HORIZONTAL, command=self.entry4text.xview)
            xscrollbar4text.grid(sticky=EW, row=2, column=1, )
            self.entry4text.config(xscrollcommand=xscrollbar4text.set)

            ### textvariable Sec
            self.label4textvariable = ttk.Label(self.frameWidgetConfig, text="text\nvariable", style="widgetconfig.TLabel")
            self.label4textvariable.grid(sticky=W, row=2005, column=1)
            self.frame4textvariable = ttk.Frame(self.frameWidgetConfig)
            self.frame4textvariable.grid(row=2005, column=2)
            self.entrytextvariable = Entry(self.frame4textvariable, relief=FLAT, )
            self.entrytextvariable.pack(side=LEFT, padx=3)
            blank_label4textvariable = ttk.Label(self.frame4textvariable, text="", anchor=W, width=3)
            blank_label4textvariable.pack(side=LEFT)

            ### tickinterval Sec
            # self.int_tickinterval = IntVar()
            self.label4tickinterval = ttk.Label(self.frameWidgetConfig, text="tick\ninterval",
                                              style="widgetconfig.TLabel")
            self.label4tickinterval.grid(sticky=W, row=2006, column=1)
            self.frame4tickinterval = ttk.Frame(self.frameWidgetConfig)
            self.frame4tickinterval.grid(row=2006, column=2)
            self.entry4tickinterval = Entry(self.frame4tickinterval, relief=FLAT,)
                                            # textvariable = self.int_tickinterval)
            self.entry4tickinterval.pack(side=LEFT, padx=3)
            blank_label4tickinterval = ttk.Label(self.frame4tickinterval, text="", anchor=W, width=3)
            blank_label4tickinterval.pack(side=LEFT)

            ### to Sec
            # self.int_to = IntVar()
            self.label4to = ttk.Label(self.frameWidgetConfig, text="to", style="widgetconfig.TLabel")
            self.label4to.grid(sticky=W, row=2011, column=1)
            self.frame4to = ttk.Frame(self.frameWidgetConfig)
            self.frame4to.grid(row=2011, column=2)
            self.entry4to = Entry(self.frame4to, relief=FLAT, )
                                  # textvariable = self.int_to)
            self.entry4to.pack(side=LEFT, padx=3)
            blank_label4to = ttk.Label(self.frame4to, text="", anchor=W, width=3)
            blank_label4to.pack(side=LEFT)

            ### troughcolor Sec
            def color4troughcolor():
                color = colorchooser.askcolor()[1]
                windowObject.entry4troughcolor.delete(0, END)
                windowObject.entry4troughcolor.insert(END,color)
            self.label4troughcolor = ttk.Label(self.frameWidgetConfig, text="trough\ncolor",
                                                    style="widgetconfig.TLabel")
            self.label4troughcolor.grid(sticky=W, row=2012, column=1)
            self.frame4troughcolor = ttk.Frame(self.frameWidgetConfig)
            self.frame4troughcolor.grid(row=2012, column=2)
            self.entry4troughcolor = Entry(self.frame4troughcolor, relief=FLAT)
            self.entry4troughcolor.pack(side=LEFT, padx=3)
            button4troughcolor = ttk.Button(self.frame4troughcolor, text=">>", style="moreOptions.TButton",
                                            command = color4troughcolor)
            button4troughcolor.pack(side=LEFT)

            ### underline Sec
            # self.int_underline = IntVar()
            self.label4underline = ttk.Label(self.frameWidgetConfig, text="underline", style="widgetconfig.TLabel")
            self.label4underline.grid(sticky=W, row=2013, column=1)
            self.frame4underline = ttk.Frame(self.frameWidgetConfig)
            self.frame4underline.grid(row=2013, column=2)
            self.entry4underline = Entry(self.frame4underline, relief=FLAT, )
                                         # textvariable = self.int_underline)
            self.entry4underline.pack(side=LEFT, padx=3)
            blank_label4underline = ttk.Label(self.frame4underline, text="", anchor=W, width=3)
            blank_label4underline.pack(side=LEFT)

            ### undo
            self.bool_undo = BooleanVar()
            self.bool_undo.set(1)
            self.label4undo = ttk.Label(self.frameWidgetConfig, text="undo", style="widgetconfig.TLabel")
            self.label4undo.grid(sticky=W, row=2015, column=1)
            self.frame4undo = ttk.Frame(self.frameWidgetConfig)
            self.frame4undo.grid(row=2015, column=2)
            radioTrue4undo = ttk.Radiobutton(self.frame4undo, text="True", variable=self.bool_undo,
                                                  value=True)
            radioTrue4undo.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4undo = ttk.Radiobutton(self.frame4undo, text="False", variable=self.bool_undo,
                                                   value=False)
            radioFalse4undo.grid(sticky=E, row=1, column=2, padx=20)

            ### validate Sec
            validates = ("all", "focus", "focusin", "focusout", "key", "none")
            self.label4validate = ttk.Label(self.frameWidgetConfig, text="validate", style="widgetconfig.TLabel")
            self.label4validate.grid(sticky=W, row=2016, column=1)
            self.combo4validate = ttk.Combobox(self.frameWidgetConfig, values=validates)
            self.combo4validate.grid(row=2016, column=2, ipadx=5)

            ###validatecommand Sec
            self.label4validatecommand = ttk.Label(self.frameWidgetConfig, text="validate\ncommand",
                                                   style="widgetconfig.TLabel")
            self.label4validatecommand.grid(sticky=W, row=2017, column=1)
            self.frame4validatecommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4validatecommand.grid(row=2017, column=2)
            self.entry4validatecommand = Entry(self.frame4validatecommand, relief=FLAT, )
            self.entry4validatecommand.pack(side=LEFT, padx=3)
            blank_label4validatecommand = ttk.Label(self.frame4validatecommand, text="", anchor=W, width=3)
            blank_label4validatecommand.pack(side=LEFT)

            ### value Sec
            # self.int_value = IntVar()
            self.label4value = ttk.Label(self.frameWidgetConfig, text="value", style="widgetconfig.TLabel")
            self.label4value.grid(sticky=W, row=2018, column=1)
            self.frame4value = ttk.Frame(self.frameWidgetConfig)
            self.frame4value.grid(row=2018, column=2)
            self.entry4value = Entry(self.frame4value, relief=FLAT,)
                                     # textvariable = self.int_value)
            self.entry4value.pack(side=LEFT, padx=3)
            blank_label4value = ttk.Label(self.frame4value, text="", anchor=W, width=3)
            blank_label4value.pack(side=LEFT)

            ### value(s) Sec
            self.label4values = ttk.Label(self.frameWidgetConfig, text="value(s)", style="widgetconfig.TLabel")
            self.label4values.grid(sticky=W, row=2019, column=1)
            self.frame4values = ttk.Frame(self.frameWidgetConfig)
            self.frame4values.grid(row=2019, column=2)
            self.entry4values = Entry(self.frame4values, relief=FLAT)
            self.entry4values.pack(side=LEFT, padx=3)
            button4values = ttk.Button(self.frame4values, text=">>", style="moreOptions.TButton")
            button4values.pack(side=LEFT)

            ### variable Sec
            self.label4variable = ttk.Label(self.frameWidgetConfig, text="variable", style="widgetconfig.TLabel")
            self.label4variable.grid(sticky=W, row=2020, column=1)
            self.frame4variable = ttk.Frame(self.frameWidgetConfig)
            self.frame4variable.grid(row=2020, column=2)
            self.entry4variable = Entry(self.frame4variable, relief=FLAT, )
            self.entry4variable.pack(side=LEFT, padx=3)
            blank_label4variable = ttk.Label(self.frame4variable, text="", anchor=W, width=3)
            blank_label4variable.pack(side=LEFT)

            ### width Sec
            self.label4width = ttk.Label(self.frameWidgetConfig, text="width", style="widgetconfig.TLabel")
            self.label4width.grid(sticky=W, row=2100, column=1)
            self.spinbox4width = ttk.Spinbox(self.frameWidgetConfig, from_=1, increment = 5, to=self.label4width.winfo_screenwidth(), width = 10, wrap = True)
            self.spinbox4width.grid(row=2100, column=2)

            ### wrap Sec
            self.bool_wrap = BooleanVar()
            self.bool_wrap.set(1)
            self.label4wrap = ttk.Label(self.frameWidgetConfig, text="wrap", style="widgetconfig.TLabel")
            self.label4wrap.grid(sticky=W, row=2105, column=1)
            self.frame4wrap = ttk.Frame(self.frameWidgetConfig)
            self.frame4wrap.grid(row=2105, column=2)
            radioTrue4wrap = ttk.Radiobutton(self.frame4wrap, text="True", variable=self.bool_wrap,
                                                  value=True)
            radioTrue4wrap.grid(sticky=W, row=1, column=1, padx=20)
            radioFalse4wrap = ttk.Radiobutton(self.frame4wrap, text="False", variable=self.bool_wrap,
                                                   value=False)
            radioFalse4wrap.grid(sticky=E, row=1, column=2, padx=20)

            ### wrap (for Text) Sec
            wraps = ("char", "word", "none")
            self.label4wrap_Text = ttk.Label(self.frameWidgetConfig, text="wrap", style="widgetconfig.TLabel")
            self.label4wrap_Text.grid(sticky=W, row=2110, column=1)
            self.combo4wrap_Text = ttk.Combobox(self.frameWidgetConfig, values=wraps)
            self.combo4wrap_Text.grid(row=2110, column=2, ipadx=5)

            ### wraplength Sec
            # self.int_wraplength = IntVar()
            self.label4wraplength = ttk.Label(self.frameWidgetConfig, text="wraplength", style="widgetconfig.TLabel")
            self.label4wraplength.grid(sticky=W, row=2200, column=1)
            self.frame4wraplength = ttk.Frame(self.frameWidgetConfig)
            self.frame4wraplength.grid(row=2200, column=2)
            self.entry4wraplength = Entry(self.frame4wraplength, relief=FLAT,)
                                          # textvariable = self.int_wraplength)
            self.entry4wraplength.pack(side=LEFT, padx=3)
            blank_label4wraplength = ttk.Label(self.frame4wraplength, text="", anchor=W, width=3)
            blank_label4wraplength.pack(side=LEFT)

            ### xscrollcommand Sec
            self.label4xscrollcommand = ttk.Label(self.frameWidgetConfig, text="xscroll\ncommand",
                                                  style="widgetconfig.TLabel")
            self.label4xscrollcommand.grid(sticky=W, row=2300, column=1)
            self.frame4xscrollcommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4xscrollcommand.grid(row=2300, column=2)
            self.entry4xscrollcommand = Entry(self.frame4xscrollcommand, relief=FLAT, )
            self.entry4xscrollcommand.pack(side=LEFT, padx=3)
            blank_label4xscrollcommand = ttk.Label(self.frame4xscrollcommand, text="", anchor=W, width=3)
            blank_label4xscrollcommand.pack(side=LEFT)

            ### yscrollcommand Sec
            self.label4yscrollcommand = ttk.Label(self.frameWidgetConfig, text="yscroll\ncommand",
                                                  style="widgetconfig.TLabel")
            self.label4yscrollcommand.grid(sticky=W, row=2400, column=1)
            self.frame4yscrollcommand = ttk.Frame(self.frameWidgetConfig)
            self.frame4yscrollcommand.grid(row=2400, column=2)
            self.entry4yscrollcommand = Entry(self.frame4yscrollcommand, relief=FLAT, )
            self.entry4yscrollcommand.pack(side=LEFT, padx=3)
            blank_label4yscrollcommand = ttk.Label(self.frame4yscrollcommand, text="", anchor=W, width=3)
            blank_label4yscrollcommand.pack(side=LEFT)

            ### Listbox Section to add
            # self.frame4AllListConfig = ttk.Frame(self.frameWidgetConfig)
            # self.frame4AllListConfig.grid(row = 2500, column=1, columnspan=2)
            # ttk.Label(self.frame4AllListConfig, text = "").grid()
            # ttk.Label(self.frame4AllListConfig, text = "").grid()
            #
            # frameListAdd = ttk.Frame(self.frame4AllListConfig)
            # frameListAdd.grid(row=10, column=1, columnspan=2)
            # labelListAdd = ttk.Label(frameListAdd, text="Add List", font=("Courier", 20, "bold"))
            # labelListAdd.pack(side=LEFT, anchor=W)
            # buttonListAdd = ttk.Button(frameListAdd, text="+")
            # buttonListAdd.pack(side=RIGHT, anchor=E)
            #
            # ### List for label, frame and entry variables of the listss
            # self.list_label_list = ["label4List_{x}" for x in range(0, 100)]
            # self.list_frame_list = ["frame4List_{x}" for x in range(0, 100)]
            # self.list_entry_list = ["entry4List_{x}" for x in range(0, 100)]
            # self.row_list = 12  ## Variable for grid of new toggled list
            # self.list_id = 2  ## Variable that toogles list label number
            #
            # def addList():      ### Command for + button
            #     windowObject.list_label_list[windowObject.list_id] = ttk.Label(self.frame4AllListConfig, text=f"List_{windowObject.list_id}",
            #                                                       style="widgetconfig.TLabel")
            #     windowObject.list_label_list[windowObject.list_id].grid(sticky=W, row=windowObject.row_list, column=1)
            #     windowObject.list_frame_list[windowObject.list_id] = ttk.Frame(self.frame4AllListConfig)
            #     windowObject.list_frame_list[windowObject.list_id].grid(row=windowObject.row_list, column=2)
            #     windowObject.list_entry_list[windowObject.list_id] = Entry(windowObject.list_frame_list[windowObject.list_id], relief=FLAT)
            #     windowObject.list_entry_list[windowObject.list_id].pack(side=LEFT, padx=3, pady = 3)
            #
            #     windowObject.row_list += 1
            #     windowObject.list_id += 1
            #
            # buttonListAdd.config(command = addList)
            #
            # self.list_label_list[1] = ttk.Label(self.frame4AllListConfig, text="List_1", style="widgetconfig.TLabel")
            # self.list_label_list[1].grid(sticky=W, row=11, column=1)
            #
            # self.list_frame_list[1] = ttk.Frame(self.frame4AllListConfig)
            # self.list_frame_list[1].grid(row=11, column=2)
            #
            # self.list_entry_list[1] = Entry(self.list_frame_list[1], relief=FLAT)
            # self.list_entry_list[1].pack(side=LEFT, padx=3, pady = 3)
            #
            # button4values = ttk.Button(self.frame4AllListConfig, text=">>", style="moreOptions.TButton",
            #                            command = arrangeObject.createList)
            # button4values.grid(row = 150, column = 2, sticky = E)

            ### PanedWindow Section to add
            self.frame4AllPaneConfig = ttk.Frame(self.frameWidgetConfig)
            self.frame4AllPaneConfig.grid(row = 2600, column=1, columnspan=2)

            ttk.Label(self.frame4AllPaneConfig, text = "").grid()
            ttk.Label(self.frame4AllPaneConfig, text = "").grid()

            framePaneAdd = ttk.Frame(self.frame4AllPaneConfig)
            framePaneAdd.grid(row=10, column=1, columnspan=2)
            labelPaneAdd = ttk.Label(framePaneAdd, text="Add Pane", font=("Courier", 20, "bold"))
            labelPaneAdd.pack(side=LEFT, anchor=W)
            buttonPaneAdd = ttk.Button(framePaneAdd, text="+")
            buttonPaneAdd.pack(side=RIGHT, anchor=E)

                ### List for label, frame and entry variables of the panes
            self.pane_label_list = ["label4Pane_{x}" for x in range(0, 100)]
            self.pane_frame_list = ["frame4Pane_{x}" for x in range(0, 100)]
            self.pane_entry_list = ["entry4Pane_{x}" for x in range(0, 100)]
            self.row_pane = 12     ## Variable for grid of new toggled pane
            self.pane_id = 2        ## Variable that toogles pane label number

            def addPane():      ### Command for + button
                windowObject.pane_label_list[windowObject.pane_id] = ttk.Label(self.frame4AllPaneConfig, text=f"Pane_{windowObject.pane_id}",
                                                                  style="widgetconfig.TLabel")
                windowObject.pane_label_list[windowObject.pane_id].grid(sticky=W, row=windowObject.row_pane, column=1)
                windowObject.pane_frame_list[windowObject.pane_id] = ttk.Frame(self.frame4AllPaneConfig)
                windowObject.pane_frame_list[windowObject.pane_id].grid(row=windowObject.row_pane, column=2)
                windowObject.pane_entry_list[windowObject.pane_id] = Entry(windowObject.pane_frame_list[windowObject.pane_id], relief=FLAT)
                windowObject.pane_entry_list[windowObject.pane_id].pack(side=LEFT, padx=3, pady = 3)

                windowObject.row_pane += 1
                windowObject.pane_id += 1

            buttonPaneAdd.config(command = addPane)

            self.pane_label_list[1] = ttk.Label(self.frame4AllPaneConfig, text="Pane_1", style="widgetconfig.TLabel")
            self.pane_label_list[1].grid(sticky=W, row=11, column=1)

            self.pane_frame_list[1] = ttk.Frame(self.frame4AllPaneConfig)
            self.pane_frame_list[1].grid(row=11, column=2)

            self.pane_entry_list[1] = Entry(self.pane_frame_list[1], relief=FLAT)
            self.pane_entry_list[1].pack(side=LEFT, padx=3, pady = 3)

            button4values = ttk.Button(self.frame4AllPaneConfig, text=">>", style="moreOptions.TButton",
                                       command = arrangeObject.createPane)
            button4values.grid(row = 150, column = 2, sticky = E)


            ##### Styling for Wiget Config Label & Button
            self.styleWidgetConfigLabel.configure("widgetconfig.TLabel", font=("Courier New", 10), padding=3, anchor=W)
            self.styleWidgetConfigLabel.configure("moreOptions.TButton", width=3, anchor=W)

        def widgetTreeview(self):
            self.tree4Widget = ttk.Treeview(windowPRO, )
            self.tree4Widget.pack(side = LEFT, fill=BOTH, expand = 1)
            scroll4Widgettree = ttk.Scrollbar(orient = "vertical", command = self.tree4Widget.yview)
            scroll4Widgettree.pack(side = RIGHT, fill = Y)
            self.tree4Widget["yscrollcommand"] = scroll4Widgettree.set
            self.tree4Widget.insert("", END, iid="Design Window", text="Design Window", open = True)

        ##### Method to validate whether WidgetConfig Toplevel currently exits.
        def validateWidgetConfigTopLevelState(self):
            if self.clickWidgetConfig == 0:  # If NOT exists,
                self.toplevel4WidgetConfig()  # new Toplevel for Widget is created
            elif self.clickWidgetConfig == 1:  # If exists:
                self.toplevelWidgetConfig.destroy()  # Current Toplevel is destroyed
                self.toplevel4WidgetConfig()  # New Toplevel for Widget is created

        ########## Command for Main tk Widgets
        def determineButton(self, widget_value):
            global iswidget
            iswidget = widget_value

        def mainButton(self):
            self.validateWidgetConfigTopLevelState()
            ### Removal of Unavailable Attributes for this Widget
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineCheckbutton(self, widget_value):
            global iswidget
            iswidget = widget_value

        def mainCheckbutton(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineEntry(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainEntry(self):
            self.validateWidgetConfigTopLevelState()

            self.combo4state.config(values = ("active", "disabled", "normal", "readonly"))  ### Add 'readonly' to state
            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        ### Addition of Attributes

        def determineLabel(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainLabel(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineListbox(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainListbox(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()


        def mainMenu(self):
            self.validateWidgetConfigTopLevelState()

        ### Removal of Unavailable Attributes for this Widget

        def determineMenubutton(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainMenubutton(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()


        def determineMessage(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainMessage(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def mainOptionMenu(self, widget_value):
            self.validateWidgetConfigTopLevelState()

            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

            ### Removal of Unavailable Attributes for this Widget
            self.validateWidgetConfigTopLevelState()
            self.label4activebackground.destroy()
            self.label4highlightthickness.destroy()
            self.frame4activebackground.destroy()
            self.spinbox4highlightthickness.destroy()
            self.label4activeforeground.destroy()
            self.label4highlightcolor.destroy()
            self.frame4activeforeground.destroy()
            self.frame4highlightcolor.destroy()
            self.label4anchor.destroy()
            self.label4highlightbackground.destroy()
            self.combo4anchor.destroy()
            self.frame4highlightbackground.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4foreground.destroy()
            self.frame4foreground.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4relief.destroy()
            self.combo4relief.destroy()
            self.label4takefocus.destroy()
            self.frame4takefocus.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4cursor.destroy()
            self.combo4cursor.destroy()
            self.label4borderwidth.destroy()
            self.spinbox4borderwidth.destroy()
            self.label4width.destroy()
            self.spinbox4width.destroy()
            self.label4background.destroy()
            self.frame4background.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineRadiobutton(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainRadiobutton(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavialable Attributes for this widget
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineScale(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainScale(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4height.destroy()  # Remove Height Attribute
            self.spinbox4height.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineScrollbar(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainScrollbar(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4foreground.destroy()  # Remove Foreground Label Attribute
            self.frame4foreground.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineSpinbox(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainSpinbox(self):
            self.validateWidgetConfigTopLevelState()

            self.combo4state.config(values=("active", "disabled", "normal", "readonly"))    ### Add 'readonly' to state
            ### Removal of Unavailable Attributes for this Widget
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4height.destroy()
            self.spinbox4height.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineText(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainText(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        ###### Command for Main tk Containers
        def determineFrame(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainFrame(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4font.destroy()  # Remove Font  Attribute
            self.frame4font.destroy()
            self.label4foreground.destroy()  # Remove Foreground Label Attribute
            self.frame4foreground.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determineLabelFrame(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainLabelFrame(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4justify.destroy()  # Remove Justify Attribute
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()

        def determinePanedWindow(self, widget_value):
            global iswidget
            iswidget = widget_value  ### Determines Widget to display on the design window

        def mainPanedWindow(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4foreground.destroy()
            self.frame4foreground.destroy()
            self.label4highlightbackground.destroy()
            self.frame4highlightbackground.destroy()
            self.label4highlightcolor.destroy()
            self.frame4highlightcolor.destroy()
            self.label4highlightthickness.destroy()
            self.spinbox4highlightthickness.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4padx.destroy()
            self.spinbox4padx.destroy()
            self.label4pady.destroy()
            self.spinbox4pady.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4takefocus.destroy()
            self.frame4takefocus.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()

        def determineToplevel(self, widget_value):
            global iswidget
            iswidget = widget_value     ### Widget Deteminant

        def mainToplevel(self):
            self.validateWidgetConfigTopLevelState()

            ### Removal of Unavailable Attributes for this Widget
            self.label4activebackground.destroy()
            self.frame4activebackground.destroy()
            self.label4activeforeground.destroy()
            self.frame4activeforeground.destroy()
            self.label4anchor.destroy()
            self.combo4anchor.destroy()
            self.label4bitmap.destroy()
            self.combo4bitmap.destroy()
            self.label4command.destroy()
            self.frame4command.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledforeground.destroy()
            self.frame4disabledforeground.destroy()
            self.label4foreground.destroy()
            self.frame4foreground.destroy()
            self.label4font.destroy()
            self.frame4font.destroy()
            self.label4justify.destroy()
            self.combo4justify.destroy()
            self.label4state.destroy()
            self.combo4state.destroy()
            self.label4text.destroy()
            self.frame4text.destroy()
            self.label4textvariable.destroy()
            self.frame4textvariable.destroy()
            self.label4underline.destroy()
            self.frame4underline.destroy()
            self.label4wraplength.destroy()
            self.frame4wraplength.destroy()
            self.label4compound.destroy()
            self.combo4compound.destroy()
            self.label4disabledbackground.destroy()
            self.frame4disabledbackground.destroy()
            self.label4from_.destroy()
            self.frame4from_.destroy()
            self.label4image.destroy()
            self.frame4image.destroy()
            self.label4insertbackground.destroy()
            self.frame4insertbackground.destroy()
            self.label4insertborderwidth.destroy()
            self.spinbox4insertborderwidth.destroy()
            self.label4insertofftime.destroy()
            self.spinbox4insertofftime.destroy()
            self.label4insertontime.destroy()
            self.spinbox4insertontime.destroy()
            self.label4insertwidth.destroy()
            self.spinbox4insertwidth.destroy()
            self.label4orient.destroy()
            self.combo4orient.destroy()
            self.label4overrelief.destroy()
            self.combo4overrelief.destroy()
            self.label4repeatdelay.destroy()
            self.spinbox4repeatdelay.destroy()
            self.label4repeatinterval.destroy()
            self.spinbox4repeatinterval.destroy()
            self.label4selectbackground.destroy()
            self.frame4selectbackground.destroy()
            self.label4selectborderwidth.destroy()
            self.spinbox4selectborderwidth.destroy()
            self.label4selectforeground.destroy()
            self.frame4selectforeground.destroy()
            self.label4to.destroy()
            self.frame4to.destroy()
            self.label4variable.destroy()
            self.frame4variable.destroy()
            self.label4xscrollcommand.destroy()
            self.frame4xscrollcommand.destroy()
            self.label4yscrollcommand.destroy()
            self.frame4yscrollcommand.destroy()
            self.label4selectcolor.destroy()
            self.frame4selectcolor.destroy()
            self.label4selectmode.destroy()
            self.combo4selectmode.destroy()
            self.label4exportselection.destroy()
            self.frame4exportselection.destroy()
            self.label4readonlybackground.destroy()
            self.frame4readonlybackground.destroy()
            self.label4show.destroy()
            self.frame4show.destroy()
            self.label4validate.destroy()
            self.combo4validate.destroy()
            self.label4validatecommand.destroy()
            self.frame4validatecommand.destroy()
            self.label4invalidcommand.destroy()
            self.frame4invalidcommand.destroy()
            self.label4activestyle.destroy()
            self.combo4activestyle.destroy()
            self.label4listvariable.destroy()
            self.frame4listvariable.destroy()
            self.label4direction.destroy()
            self.combo4direction.destroy()
            self.label4indicatoron.destroy()
            self.frame4indicatoron.destroy()
            self.label4menu.destroy()
            self.frame4menu.destroy()
            self.label4offrelief.destroy()
            self.combo4offrelief.destroy()
            self.label4selectimage.destroy()
            self.frame4selectimage.destroy()
            self.label4aspect.destroy()
            self.frame4aspect.destroy()
            self.label4value.destroy()
            self.frame4value.destroy()
            self.label4buttonbackground.destroy()
            self.frame4buttonbackground.destroy()
            self.label4buttoncursor.destroy()
            self.combo4buttoncursor.destroy()
            self.label4buttondownrelief.destroy()
            self.combo4buttondownrelief.destroy()
            self.label4buttonuprelief.destroy()
            self.combo4buttonuprelief.destroy()
            self.label4increment.destroy()
            self.frame4increment.destroy()
            self.label4wrap.destroy()
            self.frame4wrap.destroy()
            self.label4format.destroy()
            self.frame4format.destroy()
            self.label4values.destroy()
            self.frame4values.destroy()
            self.label4labelanchor.destroy()
            self.combo4labelanchor.destroy()
            self.label4labelwidget.destroy()
            self.entry4labelwidget.destroy()
            self.label4autoseparators.destroy()
            self.frame4autoseparators.destroy()
            self.label4blockcursor.destroy()
            self.frame4blockcursor.destroy()
            self.label4inactiveselectbackground.destroy()
            self.frame4inactiveselectbackground.destroy()
            self.label4insertunfoccussed.destroy()
            self.combo4insertunfoccussed.destroy()
            self.label4maxundo.destroy()
            self.frame4maxundo.destroy()
            self.label4undo.destroy()
            self.frame4undo.destroy()
            self.label4tabs.destroy()
            self.frame4tabs.destroy()
            self.label4wrap_Text.destroy()
            self.combo4wrap_Text.destroy()
            self.label4spacing1.destroy()
            self.spinbox4spacing1.destroy()
            self.label4spacing2.destroy()
            self.spinbox4spacing2.destroy()
            self.label4spacing3.destroy()
            self.spinbox4spacing3.destroy()
            self.label4digits.destroy()
            self.spinbox4digits.destroy()
            self.label4label.destroy()
            self.frame4label.destroy()
            self.label4resolution.destroy()
            self.frame4resolution.destroy()
            self.label4showvalue.destroy()
            self.frame4showvalue.destroy()
            self.label4sliderlength.destroy()
            self.frame4sliderlength.destroy()
            self.label4sliderrelief.destroy()
            self.combo4sliderrelief.destroy()
            self.label4tickinterval.destroy()
            self.frame4tickinterval.destroy()
            self.label4troughcolor.destroy()
            self.frame4troughcolor.destroy()
            self.label4handlepad.destroy()
            self.spinbox4handlepad.destroy()
            self.label4handlesize.destroy()
            self.spinbox4handlesize.destroy()
            self.label4opaqueresize.destroy()
            self.frame4opaqueresize.destroy()
            self.label4sashcursor.destroy()
            self.combo4sashcursor.destroy()
            self.label4sashpad.destroy()
            self.frame4sashpad.destroy()
            self.label4sashrelief.destroy()
            self.combo4sashrelief.destroy()
            self.label4sashwidth.destroy()
            self.frame4sashwidth.destroy()
            self.label4showhandle.destroy()
            self.frame4showhandle.destroy()
            self.label4length.destroy()
            self.spinbox4length.destroy()
            self.frame4AllPaneConfig.destroy()


        ###### Commands for >> Font Buttons
        def executeFontToplevel(self):
            self.numberFont_2
            self.isFontToplevel

            global fontObject

            if self.isFontToplevel == 0:
                fontObject = ChooseFont(self.numberFont_2,
                                        self.toplevelWidgetConfig,)  #### Creates font Object and passes in the CHANGED new font name
            elif self.isFontToplevel == 1:
                fontObject.toplevel4Font.destroy()
                fontObject = ChooseFont(self.numberFont_2,
                                        self.toplevelWidgetConfig,)  #### Creates font Object and passes in the CHANGED new font name
            if self.entry4font.get() == "":
                self.entry4font.insert(0, fontObject.fontNameVariable)
            elif self.entry4font.get() != "":
                self.entry4font.delete(0, END)
                self.entry4font.insert(0, fontObject.fontNameVariable)

            self.numberFont_2 += 1
            self.isFontToplevel = 1


    class ChooseFont:
        def __init__(self, numberFont_1, master):

            self.toplevel4Font = Toplevel(master)

            self.toplevel4Font.resizable(False, False)
            self.fontScreenWidth = self.toplevel4Font.winfo_screenwidth()
            fontScreenHeight = self.toplevel4Font.winfo_screenheight()
            self.toplevel4Font.transient()
            self.toplevel4Font.geometry("%dx%d+%d+%d" % (self.fontScreenWidth/2.973, 445, self.fontScreenWidth/3, fontScreenHeight/2.5))
            # global selectedFont

            self.numberFont_1 = numberFont_1     #### Variable that determines new Font Name
            self.fontNameVariable = "font_{}".format(self.numberFont_1)     ###### Variable for Font Names
            self.dictFontSettings = {"name": self.fontNameVariable, "family": "Segoe UI", "size": 9}

            self.sampleFont = font.Font(family = "Arial", size= 8)
            windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"] = font.Font(root = windowDesign, **self.dictFontSettings) #### Font object for selected font in Font Window

            self.fontWidgets()    ######## Display Font Toplevel Widgets


        def applyFont(self,):
            # global selectedFont

            getFontFamily = self.comboFontFamily.get()
            self.dictFontSettings["family"] = getFontFamily
            self.sampleFont.config(family = getFontFamily)
            
            getFontSize = int(self.spinboxSize.get())
            self.dictFontSettings["size"] = getFontSize
            self.sampleFont.config(size = getFontSize)

            self.text4Preview.tag_config("tagPreviewText", font = self.sampleFont)
            self.groupStyle = (self.checkVariable1.get(), self.checkVariable2.get(), self.checkVariable3.get(), self.checkVariable4.get())  ##### Tuple that commulates responses from check boxes

            def iterateStyle():
                if fontObject.groupStyle[0] == 1:
                    self.sampleFont.config(weight = font.BOLD)
                if fontObject.groupStyle[0] == 0:
                    self.sampleFont.config(weight = font.NORMAL)
                if fontObject.groupStyle[1] == 1:
                    self.sampleFont.config(slant = font.ITALIC)
                if fontObject.groupStyle[1] == 0:
                    self.sampleFont.config(slant = font.ROMAN)
                if fontObject.groupStyle[2] == 1:
                    self.sampleFont.config(overstrike = 1)
                if fontObject.groupStyle[2] == 0:
                    self.sampleFont.config(overstrike = 0)
                if fontObject.groupStyle[3] == 1:
                    self.sampleFont.config(underline = 1)
                if fontObject.groupStyle[3] == 0:
                    self.sampleFont.config(underline = 0)
            self.toplevel4Font.after(1, iterateStyle)


        def applyFont_WidgetEvent(self, event):
            self.applyFont()

        def fontWidgets(self):
            ###### Font Family Sec
                ### Label for font family
            labelFontFamily = ttk.Label(self.toplevel4Font, text = "font family:",)
            labelFontFamily.grid(row = 1, column = 1, sticky = N, padx = 20, pady = 10)
                ### Combobox for font family
            get_families = font.families()   ##### Get all Available Font Families
            self.comboFontFamily = ttk.Combobox(self.toplevel4Font, values = get_families, )
            self.comboFontFamily.grid(row = 2, column = 1, sticky = W, padx = 20, pady = 10)
            self.comboFontFamily.set("Segoe UI")

            ###### Font Size Sec
                ### Label font size
            labelFontSize = ttk.Label(self.toplevel4Font, text = "font size:")
            labelFontSize.grid(row = 3, column = 1, sticky = N, padx = 20, pady = 10)
                ### Spinbox
            ##size_var = IntVar()
            ##size_var.initialize (8)
            self.spinboxSize = ttk.Spinbox(self.toplevel4Font, from_ = 8, to = 98, increment = 3, wrap = True, command = self.applyFont)
            self.spinboxSize.grid(row = 4, column = 1, sticky = W, padx = 20, pady = 10)
            self.spinboxSize.set(9)

            Label(self.toplevel4Font, ).grid(row = 5, column = 1)   ####### Spacing Label
            Label(self.toplevel4Font, ).grid(row = 6, column = 1)

            ###### Separator - Horizontal Sec
            seperatorFontHorizontal = ttk.Separator(self.toplevel4Font, orient = HORIZONTAL,  )
            seperatorFontHorizontal.grid(row = 7, column = 1, columnspan = 4, sticky = EW, )

            ###### Separator - Vertical Sec
            separatorFontVertical = ttk.Separator(self.toplevel4Font, orient = VERTICAL)
            separatorFontVertical.grid(row = 1, column = 2, rowspan = 6, sticky = NS, )

            ###### Preview Section
                ### Label for Preview
            labelPreview = ttk.Label(self.toplevel4Font, text = "Preview: ")
            labelPreview.grid(sticky = N, row = 8, column = 0, columnspan = 5, pady = 10)
                ### Text for Preview
            self.text4Preview = Text(self.toplevel4Font, width = int(self.fontScreenWidth/24)+1, height = 10, relief = FLAT, wrap = WORD)
            self.text4Preview.grid(sticky = W, row = 9, column = 0, columnspan = 5, pady = 5)
            self.text4Preview.insert(END, "abcABC")
            self.text4Preview.tag_add("tagPreviewText", 1.0, END)
            self.text4Preview.tag_config("tagPreviewText", font = self.sampleFont,
                                         justify = CENTER, spacing1 = 10)
            self.text4Preview["state"] = "disabled"

            ###### Font Styling Section
                ### Label for font styling
            labelFontStyle = ttk.Label(self.toplevel4Font, text = "font styling:")
            labelFontStyle.grid(row = 1, column = 3, sticky = N, padx = 40, pady = 10)
                ### Check button to select styling
            self.checkVariable1 = IntVar()
            checkFontStyle1 = ttk.Checkbutton(self.toplevel4Font, text = "Bold", variable = self.checkVariable1, command = self.applyFont)
            checkFontStyle1.grid(row = 2, column = 3, sticky = W, padx = 30)
            self.checkVariable2 = IntVar()
            checkFontStyle2 = ttk.Checkbutton(self.toplevel4Font, text = "Italic", variable = self.checkVariable2, command = self.applyFont)
            checkFontStyle2.grid(row = 3, column = 3, sticky = W, padx = 30)
            self.checkVariable3 = IntVar()
            checkFontStyle3 = ttk.Checkbutton(self.toplevel4Font, text = "Overstrike", variable = self.checkVariable3, command = self.applyFont)
            checkFontStyle3.grid(row = 4, column = 3, sticky = W, padx = 30)
            self.checkVariable4 = IntVar()
            checkFontStyle4 = ttk.Checkbutton(self.toplevel4Font, text = "Underline", variable = self.checkVariable4, command = self.applyFont)
            checkFontStyle4.grid(row = 5, column = 3, sticky = W, padx = 30)

            ####### apply Font Button
            def implementFont():
                try:
                    self.sampleFont.config(family = fontObject.comboFontFamily.get())
                    self.sampleFont.config(size = fontObject.spinboxSize.get())
                    windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(family=fontObject.comboFontFamily.get())
                    windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(size=fontObject.spinboxSize.get())
                    if fontObject.groupStyle[0] == 1:
                        self.dictFontSettings["weight"] = "bold"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(weight = font.BOLD)
                    if fontObject.groupStyle[0] == 0:
                        self.dictFontSettings["weight"] = "normal"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(weight = font.NORMAL)
                    if fontObject.groupStyle[1] == 1:
                        self.dictFontSettings["slant"] = "italic"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(slant = font.ITALIC)
                    if fontObject.groupStyle[1] == 0:
                        self.dictFontSettings["slant"] = "roman"
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(slant = font.ROMAN)
                    if fontObject.groupStyle[2] == 1:
                        self.dictFontSettings["overstrike"] = 1
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(overstrike = 1)
                    if fontObject.groupStyle[2] == 0:
                        self.dictFontSettings["overstrike"] = 0
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(overstrike = 0)
                    if fontObject.groupStyle[3] == 1:
                        self.dictFontSettings["underline"] = 1
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(underline = 1)
                    if fontObject.groupStyle[3] == 0:
                        self.dictFontSettings["underline"] = 0
                        windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(underline = 0)

                    windowObject.implementFont_determine = 22
                    arrangeObject.refreshAttributes()
                    windowObject.implementFont_determine = 0
                except AttributeError:
                    pass
            
            def resetFont():
                fontObject.sampleFont.config(family = "Segoe UI", size = 9, weight = font.NORMAL, slant = font.ROMAN,
                                             overstrike = 0, underline = 0)
                windowObject.dictCountFont[f"selectedFont{self.numberFont_1}"].config(family = "Segoe UI", size = 9,
                                                    weight = font.NORMAL, slant = font.ROMAN, overstrike = 0, underline = 0)
                fontObject.comboFontFamily.set("Segoe UI")
                fontObject.spinboxSize.set(9)
                self.checkVariable1.set(0)
                self.checkVariable2.set(0)
                self.checkVariable3.set(0)
                self.checkVariable4.set(0)

            def closeFont():
                fontObject.toplevel4Font.destroy()

            buttonResetFont = ttk.Button(self.toplevel4Font, text="Reset Font", command=resetFont)
            buttonResetFont.grid(row=11, column=1, sticky = W)

            buttonApplyFont = ttk.Button(self.toplevel4Font, text = "Apply Font", command = implementFont)
            buttonApplyFont.grid(row = 11, columnspan = 5)

            buttonCloseFont = ttk.Button(self.toplevel4Font, text = "Close", command = closeFont)
            buttonCloseFont.grid(row = 11, column = 4, sticky = W)

            ###### Styling for All Font Labels
            style4LabelFontStyling = ttk.Style()
            style4LabelFontStyling.configure("TLabel", font = ("Segoe UI", 9, "bold", "italic"))

            ###### Event Handlers
            self.comboFontFamily.bind("<<ComboboxSelected>>", self.applyFont_WidgetEvent)    ####### Combobox Event
            self.spinboxSize.bind("<Return>", self.applyFont_WidgetEvent)              ####### Spinbox Event for Enter Key
            self.comboFontFamily.bind("<Return>", self.applyFont_WidgetEvent)                ####### Combobox Event for Enter Key

    global winConfigStart
    winConfigStart = [0]
    class DesignWindowSetup:
        global winConfigStart
        def __init__(self):
            if windowObject.iswinConfigToplevel == 0:
                winConfigStart[0] = (Toplevel(master = windowPRO))
                self.winConfig(winConfigStart[0])
            elif windowObject.iswinConfigToplevel == 1:
                winConfigStart[0].destroy()
                winConfigStart[0] = Toplevel(master = windowPRO)
                self.winConfig(winConfigStart[0])
            self.exitDesignWindowSetup()

        def winConfig(self,  get_toplevel_winconfig):
            self.toplevel4winConfig = get_toplevel_winconfig
            self.toplevel4winConfig.geometry("%dx%d+%d+%d" % (620, 535,
                                                              windowPRO.winfo_screenwidth()/4, windowPRO.winfo_screenheight()/5))
            global iswinConfigToplevel
            windowObject.iswinConfigToplevel = 1
            self.placeWidgetsDesign()

        def placeWidgetsDesign(self):
            ### Parameter Assignment for windowDesign geometry meth
            global new_value_width
            new_value_width = int(screen_width / 2)
            global new_value_height
            new_value_height = int(screen_height / 1.57)
            global new_value_position_x
            new_value_position_x = int(screen_width / 4.5)
            global new_value_position_y
            new_value_position_y = int(screen_height / 3.36)
            dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}x{new_value_height}+" \
                                                      f"{new_value_position_x}+{new_value_position_y})"

            ### Parameter Assignment for windowDesign resizable meth
            global new_resizable_width
            new_resizable_width = True
            global new_resizable_height
            new_resizable_height = True
            dictDesignWindowPropCollect["resizable"] = f"windowDesign.resizable(width = {new_resizable_width}, " \
                                                       f"height = {new_resizable_height})"

            ### Parameter Assignment for windowDesign overrideredirect
            global new_overrideredirect
            new_overrideredirect = False

            ### Parameter Assignment for maxsize
            global new_maxsize_width
            new_maxsize_width = int(windowPRO.winfo_screenwidth() / 2)
            global new_maxsize_height
            new_maxsize_height = int(windowPRO.winfo_screenheight() / 1.57)

            ### Parameter Assignment for minsize
            global new_minsize_width
            new_minsize_width = int(windowPRO.winfo_screenwidth() / 2)
            global new_minsize_height
            new_minsize_height = int(windowPRO.winfo_screenheight() / 1.57)

            ### main toplevel title
            label4designconfig = ttk.Label(self.toplevel4winConfig, text = "Configure Your GUI Window To Your Taste",
                                           font = ("Courier", 15, "bold"), background = "grey", anchor = CENTER)
            label4designconfig.grid(row = 10, column = 0, columnspan = 9, ipadx = 75)

            Label(self.toplevel4winConfig, text = "").grid(row = 12)

            ### title
            dictDesignWindowPropCollect["title"] = f"windowDesign.title('Design Window')"
            def command4title():
                variable4title = entry4title.get()
                windowDesign.title(variable4title)
                dictDesignWindowPropCollect["title"] = f"windowDesign.title('{variable4title}')"
                
            frame4title_iconphoto = ttk.Frame(self.toplevel4winConfig)
            frame4title_iconphoto.grid(row = 20, column = 0, columnspan = 8)
            label4title = ttk.Label(frame4title_iconphoto, text = "title")
            label4title.grid(row = 20, column = 1, padx = 20)
            entry4title = ttk.Entry(master = frame4title_iconphoto)
            entry4title.grid(row = 20, column = 2,)
            button4title = ttk.Button(frame4title_iconphoto, text=">>", width=3, command = command4title)
            button4title.grid(row=20, column=3, padx=2)

            Label(frame4title_iconphoto, text = "").grid(row = 20, column = 4, padx = 40)

            ### photo
            def command4photo():
                file = filedialog.askopenfile("r", filetypes = [("Portable Network Graphics (PNG)", "*png")])
                value_image = PhotoImage(master = windowDesign, file = file.name)
                windowDesign.iconphoto(False, value_image)
                entry4photo.delete(0,END)
                entry4photo.insert(0, file.name)
                entry4photo["state"] = "readonly"
                dictDesignWindowPropCollect["iconphoto"] = f"PhotoImage(master = windowDesign, file = '{file.name}')"
                dictDesignWindowPropCollect["iconphoto2"] = f"windowDesign.iconphoto(False, IconPhoto)"
                
            label4photo = ttk.Label(frame4title_iconphoto, text = "icon photo")
            label4photo.grid(row = 20, column = 5, padx = 20)
            entry4photo = ttk.Entry(frame4title_iconphoto)
            entry4photo.grid(row = 20, column = 6)
            scroll4photo = ttk.Scrollbar(frame4title_iconphoto, orient = "horizontal", command = entry4photo.xview)
            scroll4photo.grid(row = 21, column = 6, ipadx = 40)
            entry4photo.config(xscrollcommand = scroll4photo.set)
            button4photo = ttk.Button(frame4title_iconphoto, text = ">>", width = 3, command = command4photo)
            button4photo.grid(row = 20, column = 7, padx = 2)

            Label(self.toplevel4winConfig, text = "").grid(row = 27)
            label4geometry = ttk.Label(self.toplevel4winConfig, text = "Geometry (Window Dimensions)",
                                       font = ("Calisto MT", 12, "bold"))
            label4geometry.grid(row = 30, column = 0, columnspan = 2)

            ### geometry width
            def command4width(new_value):
                global new_value_width
                new_value_width = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x,  new_value_position_y))
                label24width.config(text = new_value_width)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y})"
            label4width = ttk.Label(self.toplevel4winConfig, text = "width")
            label4width.grid(row = 40, column = 1)
            int_width = IntVar(value = windowPRO.winfo_screenwidth()/2)
            frame4width = ttk.Frame(self.toplevel4winConfig)
            frame4width.grid(row = 40, column = 2)
            label24width = ttk.Label(frame4width, text = int_width.get())
            label24width.pack()
            scale4width = ttk.Scale(frame4width, variable = int_width, from_ = 50,
                                    to = windowPRO.winfo_screenwidth(), command = command4width)
            scale4width.pack()

            ### geometry height
            def command4height(new_value):
                global new_value_height
                new_value_height = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x,  new_value_position_y))
                label24height.config(text = new_value_height)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y})"
            label4height = ttk.Label(self.toplevel4winConfig, text = "height")
            label4height.grid(row = 50, column = 1)
            int_height = IntVar(value = windowPRO.winfo_screenheight()/1.57)
            frame4height = ttk.Frame(self.toplevel4winConfig)
            frame4height.grid(row = 50, column = 2)
            label24height = ttk.Label(frame4height, text = int_height.get())
            label24height.pack()
            scale4height = ttk.Scale(frame4height, variable = int_height, from_ = 50,
                                     to = windowPRO.winfo_screenheight(), command = command4height)
            scale4height.pack()

            ### position_x relative to screen
            def command4position_x(new_value):
                global new_value_position_x
                new_value_position_x = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x, new_value_position_y))
                label24position_x.config(text = new_value_position_x)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry({new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y})"
            label4position_x = ttk.Label(self.toplevel4winConfig, text = "x position of Design Window")
            label4position_x.grid(row = 60, column = 1)
            int_position_x = IntVar(value = windowPRO.winfo_screenwidth()/4.5)
            frame4position_x = ttk.Frame(self.toplevel4winConfig)
            frame4position_x.grid(row = 60, column = 2)
            label24position_x = ttk.Label(frame4position_x, text = int_position_x.get())
            label24position_x.pack()
            scale4position_x = ttk.Scale(frame4position_x, variable = int_position_x, from_ = 0,
                                         to = windowPRO.winfo_screenwidth()-50, command = command4position_x)
            scale4position_x.pack()

            ### position_y relative to screen
            def command4position_y(new_value):
                global new_value_position_y
                new_value_position_y = int(float(new_value))
                windowDesign.geometry(
                    "%dx%d+%d+%d" % (new_value_width, new_value_height, new_value_position_x, new_value_position_y))
                label24position_y.config(text = new_value_position_y)
                dictDesignWindowPropCollect["geometry"] = f"windowDesign.geometry('{new_value_width}, {new_value_height}, " \
                                                          f"{new_value_position_x}, {new_value_position_y}')"
            label4position_y = ttk.Label(self.toplevel4winConfig, text = "y position of Design Window")
            label4position_y.grid(row = 70, column = 1)
            int_position_y = IntVar(value = windowPRO.winfo_screenheight() / 3.36)
            frame4position_y = ttk.Frame(self.toplevel4winConfig)
            frame4position_y.grid(row = 70, column = 2)
            label24position_y = ttk.Label(frame4position_y, text = int_position_y.get())
            label24position_y.pack()
            scale4position_y = ttk.Scale(frame4position_y, variable = int_position_y, from_ = 0,
                                         to = windowPRO.winfo_screenheight()-50, command = command4position_y)
            scale4position_y.pack()

            ### Window Properties Section Label
            Label(self.toplevel4winConfig, text="").grid(row=71)
            label4geometry = ttk.Label(self.toplevel4winConfig, text="Window Properties",
                                       font=("Calisto MT", 12, "bold"))
            label4geometry.grid(row=72, column=0, columnspan=2, sticky = W)

            ### is resizable_width
            def command4resizable_width():
                global new_resizable_width
                new_resizable_width = bool_resizable_width.get()
                windowDesign.resizable(width = new_resizable_width, height = new_resizable_height)
                dictDesignWindowPropCollect["resizable"] = f"windowDesign.resizable(width = {new_resizable_width}, " \
                                                                 f"height = {new_resizable_height})"
            label4resizable_width = ttk.Label(self.toplevel4winConfig, text = "Is width resizable?")
            label4resizable_width.grid(row = 80, column = 1)
            bool_resizable_width = BooleanVar(value = True)
            frame4resizable_width = ttk.Frame(self.toplevel4winConfig)
            frame4resizable_width.grid(row = 80, column = 2)
            radioTrue4resizable_width = ttk.Radiobutton(frame4resizable_width, variable = bool_resizable_width, text = "Yes",
                                                        value = True, command = command4resizable_width)
            radioTrue4resizable_width.pack(side = LEFT, padx = 20)
            radioFalse4resizable_width = ttk.Radiobutton(frame4resizable_width, variable = bool_resizable_width, text = "No",
                                                         value = False, command = command4resizable_width)
            radioFalse4resizable_width.pack(side = RIGHT)

            ### is resizable height
            def command4resizable_height():
                global new_resizable_height
                new_resizable_height = bool_resizable_height.get()
                windowDesign.resizable(width = new_resizable_width, height = new_resizable_height)
                dictDesignWindowPropCollect["resizable"] = f"windowDesign.resizable(width = {new_resizable_width}, " \
                                                                 f"height = {new_resizable_height})"
            label4resizable_height = ttk.Label(self.toplevel4winConfig, text="Is height resizable?")
            label4resizable_height.grid(row=90, column=1)
            bool_resizable_height = BooleanVar(value=True)
            frame4resizable_height = ttk.Frame(self.toplevel4winConfig)
            frame4resizable_height.grid(row=90, column=2)
            radioTrue4resizable_height = ttk.Radiobutton(frame4resizable_height, variable=bool_resizable_height, text="Yes",
                                                        value=True, command = command4resizable_height)
            radioTrue4resizable_height.pack(side=LEFT, padx=20)
            radioFalse4resizable_height = ttk.Radiobutton(frame4resizable_height, variable=bool_resizable_height, text="No",
                                                         value=False, command = command4resizable_height)
            radioFalse4resizable_height.pack(side=RIGHT)

            ### override redirect flag
            def command4overrideredirect():
                global new_overrideredirect
                new_overrideredirect = bool_overrideredirect.get()
                windowDesign.overrideredirect(new_overrideredirect)
                dictDesignWindowPropCollect["overrideredirect"] = f"windowDesign.overrideredirect({new_overrideredirect})"
            label4overrideredirect = ttk.Label(self.toplevel4winConfig, text = "Set the override redirect flag?")
            label4overrideredirect.grid(row = 100, column = 1)
            bool_overrideredirect = BooleanVar(value = False)
            frame4overrideredirect = ttk.Frame(self.toplevel4winConfig)
            frame4overrideredirect.grid(row = 100, column =2)
            radioTrue4overrideredirect = ttk.Radiobutton(frame4overrideredirect, variable = bool_overrideredirect,
                                                         text="Yes", value = True, command = command4overrideredirect)
            radioTrue4overrideredirect.pack(side = LEFT, padx = 20)
            radioFalse4overrideredirect = ttk.Radiobutton(frame4overrideredirect, variable = bool_overrideredirect,
                                                          text = "No", value = False, command = command4overrideredirect)
            radioFalse4overrideredirect.pack(side = RIGHT)

            ### maxsize
            def command4maxsize():
                new_maxsize_width = entry4maxsize_width.get()
                new_maxsize_height = entry4maxsize_height.get()
                windowDesign.maxsize(width = new_maxsize_width, height = new_maxsize_height)
                dictDesignWindowPropCollect["maxsize"] = f"windowDesign.maxsize(width = {new_maxsize_width}, " \
                                                         f"height = {new_maxsize_height})"
            label4maxsize = ttk.Label(self.toplevel4winConfig, text = "Maximum size for the window")
            label4maxsize.grid(row = 110, column = 1)
            frame4maxsize = ttk.Frame(self.toplevel4winConfig)
            frame4maxsize.grid(row = 110, column = 2)
            label4maxsize_width = ttk.Label(frame4maxsize, text = "width:", font = ("TkDefaultFont", 9, "bold"))
            label4maxsize_width.grid(row = 1, column = 1)
            entry4maxsize_width = ttk.Entry(frame4maxsize, width = 7)
            entry4maxsize_width.grid(row = 2, column = 1, padx = 5)
            label4maxsize_height = ttk.Label(frame4maxsize, text = "height:", font = ("TkDefaultFont", 9, "bold"))
            label4maxsize_height.grid(row=1, column=2)
            entry4maxsize_height = ttk.Entry(frame4maxsize, width = 7)
            entry4maxsize_height.grid(row=2, column=2)
            button4maxsize = ttk.Button(frame4maxsize, width = 3, text = ">>", command = command4maxsize)
            button4maxsize.grid(row = 1, rowspan = 2, column = 3, padx = 10)

            ### minsize
            def command4minsize():
                new_minsize_width = entry4minsize_width.get()
                new_minsize_height = entry4minsize_height.get()
                windowDesign.minsize(width = new_minsize_width, height = new_minsize_height)
                dictDesignWindowPropCollect["minsize"] = f"windowDesign.minsize(width = {new_minsize_width}, " \
                                                         f"height = {new_minsize_height})"
            label4minsize = ttk.Label(self.toplevel4winConfig, text="Minimum size for the window")
            label4minsize.grid(row=120, column=1)
            frame4minsize = ttk.Frame(self.toplevel4winConfig)
            frame4minsize.grid(row=120, column=2)
            label4minsize_width = ttk.Label(frame4minsize, text="width:", font = ("TkDefaultFont", 9, "bold"))
            label4minsize_width.grid(row=1, column=1)
            entry4minsize_width = ttk.Entry(frame4minsize, width=7)
            entry4minsize_width.grid(row=2, column=1, padx=5)
            label4minsize_height = ttk.Label(frame4minsize, text="height:", font = ("TkDefaultFont", 9, "bold"))
            label4minsize_height.grid(row=1, column=2)
            entry4minsize_height = ttk.Entry(frame4minsize, width=7)
            entry4minsize_height.grid(row=2, column=2)
            button4minsize = ttk.Button(frame4minsize, width=3, text=">>", command = command4minsize)
            button4minsize.grid(row=1, rowspan=2, column=3, padx = 10)
            
            def command4okay_button():
                print(dictDesignWindowPropCollect)
                self.toplevel4winConfig.destroy()
            button4okay = ttk.Button(self.toplevel4winConfig, text = "Okay", command = command4okay_button)
            button4okay.grid(row = 130, column = 7)

        def exitDesignWindowSetup(self):
            pass

            

        # def destroy(self):
        #     self.toplevel4winConfig.destroy()

        
    class WidgetArrange:
        def __init__(self):
            global iswidget
            iswidget = 0  ### Variable to determine type of Widget to place on Design Window

            ###  Variables to count type of Widget placed on Design Window
            self.widget_button = 1
            self.widget_checkbutton = 1
            self.widget_entry = 1
            self.widget_label = 1
            self.widget_listbox = 1
            self.widget_menu = 1
            self.widget_menubutton = 1
            self.widget_message = 1
            self.widget_optionmenu = 1
            self.widget_scale = 1
            self.widget_scrollbar = 1
            self.widget_spinbox = 1
            self.widget_text = 1
            self.widget_radiobutton = 1
            self.widget_frame = 1
            self.widget_labelframe = 1
            self.widget_panedwindow = 1
            self.widget_toplevel = 1

            ### Variable List to hold handle Widgets that have been added to the Listbox
            self.list_widget_lists = []  ###

            ### Variable List to hold handle Widgets that have been paned to the PanedWindow
            self.dict_widget_panes = {} ###

            ### Dictionary that contains ATTRIBUTES and VALUES of a widget to be displayed
            self.dictCountWidget = {}

            ### Dictionary that contains place layout configurations of all the widgets
            self.dictLayoutConfig = {}

        def focusWidgetTree(self, event):

            self.focus_get = windowObject.tree4Widget.focus()
            
        def createList(self):

            for gg in windowObject.list_entry_list:
                try:
                    gg.get()
                    self.dictCountWidget[arrangeObject.focus_get].insert(END, gg.get())

                except:
                    pass

                else:
                    if gg.get() in self.list_widget_lists:
                        pass
                    else:
                        self.list_widget_lists.append(gg.get())

        def createPane(self):

            for gg in windowObject.pane_entry_list:
                try:
                    gg.get()
                    self.dictCountWidget[gg.get()].lift(self.dictCountWidget[arrangeObject.focus_get])
                    self.dictCountWidget[arrangeObject.focus_get].add(self.dictCountWidget[gg.get()])

                except:
                    pass

                else:
                    list_panes = list(self.dict_widget_panes.values())
                    print(list_panes)
                    if gg.get() in list_panes:
                        pass
                    else:
                        self.dict_widget_panes[gg.get()] = arrangeObject.focus_get


        def motionRelease(self,event):
            global iswidget
            iswidget = None
            try:
                self.focus_get = event.widget.widgetName
                try:
                    windowObject.tree4Widget.selection_set(self.focus_get)
                except:
                    if self.focus_get.startswith("FramePW"):
                        self.focus_get = event.widget.children["!panedwindow"].widgetName
                        windowObject.tree4Widget.selection_set(self.focus_get)

                event.widget.focus()
                windowObject.tree4Widget.focus(self.focus_get)

                if self.focus_get.startswith("Button"):
                    windowObject.determineButton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainButton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:

                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except:
                                eval(f"windowObject.bool_{k}.set(v[1])")


                elif self.focus_get.startswith("Checkbutton"):
                    windowObject.determineCheckbutton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainCheckbutton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")


                elif self.focus_get.startswith("Entry"):
                    windowObject.determineEntry(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainEntry()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("LabelFrame"):
                    windowObject.determineLabelFrame(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainLabelFrame()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        print(dictAttributeCollect)
                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except:
                                eval(f"windowObject.bool_{k}.set(v[1])")
                                
                                
                elif self.focus_get.startswith("Label"):
                    windowObject.determineLabel(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainLabel()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k,v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0,v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Listbox"):
                    windowObject.determineListbox(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                         "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainListbox()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Menubutton"):
                    windowObject.determineMenubutton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainMenubutton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))

                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, v[1])
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Message"):
                    windowObject.determineMessage(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainMessage()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        print(dictAttributeCollect)
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                try:
                                    dictAttributeCollect[k][0].delete(0, END)
                                    dictAttributeCollect[k][0].insert(0, v[1])
                                except AttributeError:
                                    eval(f"windowObject.bool_{k}.set(v[1])")
                            except:
                                eval(f"windowObject.int_{k}.set(v[1])")

                elif self.focus_get.startswith("Radiobutton"):
                    windowObject.determineRadiobutton(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainRadiobutton()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Scale"):
                    windowObject.determineScale(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}

                    if event.widget.winfo_name() == "!scale_h":
                        windowObject.spinbox4width.insert(END, int(res["height"])-70)
                    elif event.widget.winfo_name() == "!scale_v":
                        windowObject.spinbox4width.insert(END, int(res["width"])-70)
                    windowObject.mainScale()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        print(dictAttributeCollect)
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                try:
                                    dictAttributeCollect[k][0].delete(0, END)
                                    dictAttributeCollect[k][0].insert(0, v[1])
                                except AttributeError:
                                    eval(f"windowObject.bool_{k}.set(v[1])")
                            except:
                                eval(f"windowObject.int_{k}.set(v[1])")

                elif self.focus_get.startswith("Spinbox"):
                    windowObject.determineSpinbox(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Text"):
                    windowObject.determineText(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainText()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("Frame"):
                    windowObject.determineFrame(None)
                    res = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[self.focus_get] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    windowObject.mainFrame()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                dictAttributeCollect[k][0].delete(0, END)
                                dictAttributeCollect[k][0].insert(0, str(v[1]))
                            except AttributeError:
                                eval(f"windowObject.bool_{k}.set(v[1])")

                elif self.focus_get.startswith("PanedWindow"):

                    self.dictCountWidget[event.widget.master.widgetName].config(borderwidth = 2, relief = "solid")

                    windowObject.determinePanedWindow(None)
                    res = self.dictCountWidget[event.widget.master.widgetName].place_info()
                    res_sub = self.dictCountWidget[self.focus_get].place_info()
                    self.dictLayoutConfig[event.widget.master.widgetName] = {"x": res["x"], "y": res["y"], "width": res["width"],
                                                             "height": res["height"], "anchor": res["anchor"]}
                    self.dictLayoutConfig[self.focus_get] = {"relwidth": res_sub["relwidth"], "relheight": res_sub["relheight"],
                                                            "anchor": res_sub["anchor"]}
                    windowObject.mainPanedWindow()
                    windowObject.entry4widget_variable.insert(0, self.focus_get)
                    if self.focus_get in dictAttributeEditorUpdate:
                        dictAttributeCollect = dict(sorted(dictAttributeEditorUpdate[self.focus_get].items()))
                        for k, v in zip(dictAttributeCollect.keys(), dictAttributeCollect.values()):
                            try:
                                try:
                                    dictAttributeCollect[k][0].delete(0, END)
                                    dictAttributeCollect[k][0].insert(0, v[1])
                                except AttributeError:
                                    eval(f"windowObject.bool_{k}.set(v[1])")
                            except:
                                eval(f"windowObject.int_{k}.set(v[1])")



            except AttributeError:
                pass


        # def release(self, event):
        #     try:
        #         res = self.dictCountWidget[self.identifier].place_info()
        #         print(self.identifier, res)
        #     except AttributeError:
        #         pass

        def refreshAttributes(self):

            try:
                if arrangeObject.focus_get.startswith("Button") == True:
                    # self.dictCountWidget[arrangeObject.focus_get].focus()
                    # print(arrangeObject.focus_get)
                    DragDropResizeWidget.__bases__ = (Button,)

                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]

                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("default"); listAttr.remove("fg");
                    listAttr.remove("height"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.entry4command, windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image, windowObject.combo4justify,
                               windowObject.combo4overrelief, windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.spinbox4repeatdelay, windowObject.spinbox4repeatinterval,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable,
                               windowObject.entry4underline, windowObject.entry4wraplength]
                    for i,j in zip(listAttr, listVal):

                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j,j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                        
                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()

                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)
                    # print(dict_)
                    # print(dictAttributeCollect)
                    # print(dictAttributeEditorUpdate)

                elif arrangeObject.focus_get.startswith("Checkbutton") == True:
                    DragDropResizeWidget.__bases__ = (Checkbutton,)

                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("offvalue"); listAttr.remove("onvalue");
                    listAttr.remove("tristateimage"); listAttr.remove("tristatevalue"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.entry4command, windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image, windowObject.bool_indicatoron,
                               windowObject.combo4justify, windowObject.combo4offrelief,
                               windowObject.combo4overrelief, windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.entry4selectcolor, windowObject.entry4selectimage,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable, windowObject.entry4underline, windowObject.entry4variable,
                               windowObject.entry4wraplength]

                    for i, j in zip(listAttr, listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()

                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Entry") == True:
                    DragDropResizeWidget.__bases__ = (Entry,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg");  listAttr.remove("invcmd");
                    listAttr.remove("vcmd"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.entry4disabledbackground, windowObject.entry4disabledforeground,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4insertbackground,
                               windowObject.spinbox4insertborderwidth, windowObject.spinbox4insertofftime,
                               windowObject.spinbox4insertontime, windowObject.spinbox4insertwidth,
                               windowObject.entry4invalidcommand, windowObject.combo4justify,
                               windowObject.entry4readonlybackground, windowObject.combo4relief,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.entry4show, windowObject.combo4state,
                               windowObject.bool_takefocus, windowObject.entrytextvariable, windowObject.combo4validate,
                               windowObject.entry4validatecommand, windowObject.entry4xscrollcommand]
                    for i,j in zip(listAttr,listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("LabelFrame") == True:
                    DragDropResizeWidget.__bases__ = (LabelFrame,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("class");  listAttr.remove("colormap");
                    listAttr.remove("container"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("visual"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.entry4font, windowObject.entry4foreground, windowObject.entry4highlightbackground,
                               windowObject.entry4highlightcolor, windowObject.spinbox4highlightthickness,
                               windowObject.combo4labelanchor, windowObject.entry4labelwidget,
                               windowObject.spinbox4padx, windowObject.spinbox4pady, windowObject.combo4relief,
                               windowObject.bool_takefocus, windowObject.entry4text]

                    for i,j in zip(listAttr, listVal):
                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    
                    windowPRO.after(40, self.refreshAttributes)


                elif arrangeObject.focus_get.startswith("Label") == True:
                    DragDropResizeWidget.__bases__ = (Label,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image, windowObject.combo4justify,
                               windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable,
                               windowObject.entry4underline, windowObject.entry4wraplength]

                    for i, j in zip(listAttr, listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()
                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Listbox") == True:
                    DragDropResizeWidget.__bases__ = (Listbox,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("setgrid"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.combo4activestyle, windowObject.entry4background,
                               windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.entry4disabledforeground,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness,
                               windowObject.combo4justify, windowObject.entry4listvariable, windowObject.combo4relief,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.combo4selectmode, windowObject.combo4state,
                               windowObject.bool_takefocus, windowObject.entry4xscrollcommand,
                               windowObject.entry4yscrollcommand]

                    for i,j in zip(listAttr,listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Menubutton") == True:
                    DragDropResizeWidget.__bases__ = (Menubutton,)
                    self.dictCountWidget[arrangeObject.focus_get].focus()
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.combo4compound, windowObject.combo4cursor,
                               windowObject.combo4direction, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image,
                               windowObject.bool_indicatoron, windowObject.combo4justify, windowObject.entry4menu,
                               windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.combo4state, windowObject.bool_takefocus,
                               windowObject.entry4text, windowObject.entrytextvariable,
                               windowObject.entry4underline, windowObject.entry4wraplength]

                    for i,j in zip(listAttr, listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()
                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Message") == True:
                    DragDropResizeWidget.__bases__ = (Message,)
                    self.dictCountWidget[arrangeObject.focus_get].focus()

                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.combo4anchor, windowObject.int_aspect,
                               windowObject.entry4background, windowObject.spinbox4borderwidth,
                               windowObject.combo4cursor,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.combo4justify,
                               windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief,  windowObject.bool_takefocus,
                               windowObject.entry4text, windowObject.entrytextvariable, ]

                    for i,j in zip(listAttr, listVal):
                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Radiobutton") == True:
                    DragDropResizeWidget.__bases__ = (Radiobutton,)
                    self.dictCountWidget[arrangeObject.focus_get].focus()
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg"); listAttr.remove("height");
                    listAttr.remove("tristateimage"); listAttr.remove("tristatevalue"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground, windowObject.entry4activeforeground,
                               windowObject.combo4anchor,
                               windowObject.entry4background, windowObject.combo4bitmap, windowObject.spinbox4borderwidth,
                               windowObject.entry4command, windowObject.combo4compound,
                               windowObject.combo4cursor, windowObject.entry4disabledforeground,
                               windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4image,
                               windowObject.bool_indicatoron,
                               windowObject.combo4justify, windowObject.combo4offrelief,
                               windowObject.combo4overrelief, windowObject.spinbox4padx, windowObject.spinbox4pady,
                               windowObject.combo4relief, windowObject.entry4selectcolor, windowObject.entry4selectimage,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4text,
                               windowObject.entrytextvariable, windowObject.entry4underline, windowObject.entry4value,
                               windowObject.entry4variable, windowObject.entry4wraplength]

                    for i,j in zip(listAttr, listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "image") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "text") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0

                                if windowObject.implementImage_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    arrangeObject.dictCountWidget[arrangeObject.focus_get].image = j.get()
                                    windowObject.implementImage_determine = 0
                                    windowObject.count_image_instances += 1
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Scale") == True:
                # self.dictCountWidget[arrangeObject.focus_get].focus()
                # print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bigincrement"), listAttr.remove("bd"); listAttr.remove("bg"); listAttr.remove("fg");
                    listAttr.remove("length"); listAttr.remove("orient"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground,
                               windowObject.entry4background, windowObject.spinbox4borderwidth,
                               windowObject.entry4command,
                               windowObject.combo4cursor, windowObject.spinbox4digits,
                               windowObject.entry4font, windowObject.entry4foreground, windowObject.entry4from_,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4label,
                               windowObject.combo4relief, windowObject.spinbox4repeatdelay, windowObject.spinbox4repeatinterval,
                               windowObject.entry4resolution, windowObject.bool_showvalue, windowObject.int_sliderlength,
                               windowObject.combo4sliderrelief,
                               windowObject.combo4state, windowObject.bool_takefocus, windowObject.entry4tickinterval,
                               windowObject.entry4to, windowObject.entry4troughcolor, windowObject.entry4variable]
                    for i,j in zip(listAttr, listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        if (i == "label") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = ""
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Spinbox") == True:
                    DragDropResizeWidget.__bases__ = (Spinbox,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("fg");  listAttr.remove("invcmd");
                    listAttr.remove("vcmd"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4activebackground,windowObject.entry4background,
                               windowObject.spinbox4borderwidth, windowObject.entry4buttonbackground,
                               windowObject.combo4buttoncursor, windowObject.combo4buttondownrelief,
                               windowObject.combo4buttonuprelief, windowObject.entry4command,windowObject.combo4cursor,
                               windowObject.entry4disabledbackground, windowObject.entry4disabledforeground,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4format, windowObject.entry4from_,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4increment,
                               windowObject.entry4insertbackground,
                               windowObject.spinbox4insertborderwidth, windowObject.spinbox4insertofftime,
                               windowObject.spinbox4insertontime, windowObject.spinbox4insertwidth,
                               windowObject.entry4invalidcommand, windowObject.combo4justify,
                               windowObject.entry4readonlybackground, windowObject.combo4relief,
                               windowObject.spinbox4repeatdelay, windowObject.spinbox4repeatinterval,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.combo4state,
                               windowObject.bool_takefocus, windowObject.entrytextvariable, windowObject.entry4to,
                               windowObject.combo4validate, windowObject.entry4validatecommand,
                               windowObject.entry4values, windowObject.bool_wrap, windowObject.entry4xscrollcommand]
                    for i,j in zip(listAttr,listVal):
                        if i == "command":
                            if (i == "command") & (j.get() == ""):
                                windowObject.commands_all[arrangeObject.focus_get] = None
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]
                            else:
                                windowObject.commands_all[arrangeObject.focus_get] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    try:
                        del dict_[arrangeObject.focus_get]["command"]
                    except KeyError:
                        pass
                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Text") == True:
                    DragDropResizeWidget.__bases__ = (Text,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("endline"); listAttr.remove("fg");
                    listAttr.remove("height"); listAttr.remove("setgrid"); listAttr.remove("startline");
                    listAttr.remove("tabstyle"); listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.bool_autoseparators, windowObject.entry4background, windowObject.bool_blockcursor,
                               windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.bool_exportselection, windowObject.entry4font, windowObject.entry4foreground,
                               windowObject.entry4highlightbackground, windowObject.entry4highlightcolor,
                               windowObject.spinbox4highlightthickness, windowObject.entry4inactiveselectbackground,
                               windowObject.entry4insertbackground,
                               windowObject.spinbox4insertborderwidth, windowObject.spinbox4insertofftime,
                               windowObject.spinbox4insertontime, windowObject.combo4insertunfoccussed,
                               windowObject.spinbox4insertwidth, windowObject.entry4maxundo, windowObject.spinbox4padx,
                               windowObject.spinbox4pady, windowObject.combo4relief,
                               windowObject.entry4selectbackground, windowObject.spinbox4selectborderwidth,
                               windowObject.entry4selectforeground, windowObject.spinbox4spacing1, windowObject.spinbox4spacing2,
                               windowObject.spinbox4spacing3, windowObject.combo4state, windowObject.entry4tabs,
                               windowObject.bool_takefocus, windowObject.bool_undo, windowObject.combo4wrap_Text,
                               windowObject.entry4xscrollcommand, windowObject.entry4yscrollcommand]
                    for i,j in zip(listAttr,listVal):

                        if (i == "font") & (j.get() == ""):
                            dict_[arrangeObject.focus_get][i] = "TkDefaultFont"
                            dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, ""]

                        elif j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                if windowObject.implementFont_determine == 22:
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    windowObject.implementFont_determine = 0
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(1000, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("Frame") == True:
                    DragDropResizeWidget.__bases__ = (Frame,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("class");  listAttr.remove("colormap");
                    listAttr.remove("container"); listAttr.remove("height"); listAttr.remove("visual");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth,
                               windowObject.combo4cursor, windowObject.entry4highlightbackground,
                               windowObject.entry4highlightcolor, windowObject.spinbox4highlightthickness,
                               windowObject.spinbox4padx, windowObject.spinbox4pady, windowObject.combo4relief,
                               windowObject.bool_takefocus]

                    for i,j in zip(listAttr, listVal):

                        if j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)

                elif arrangeObject.focus_get.startswith("PanedWindow") == True:
                    DragDropResizeWidget.__bases__ = (Frame,)

                    #print(arrangeObject.focus_get)
                    listAttr = [x for x in self.dictCountWidget[arrangeObject.focus_get].keys()]
                    listAttr.remove("bd"); listAttr.remove("bg");  listAttr.remove("height");
                    listAttr.remove("proxybackground"); listAttr.remove("proxyborderwidth"); listAttr.remove("proxyrelief");
                    listAttr.remove("width")
                    listAttr.sort()
                    listVal = [windowObject.entry4background, windowObject.spinbox4borderwidth, windowObject.combo4cursor,
                               windowObject.spinbox4handlepad, windowObject.spinbox4handlesize,
                               windowObject.bool_opaqueresize, windowObject.combo4orient,
                               windowObject.combo4relief, windowObject.combo4sashcursor, windowObject.int_sashpad,
                               windowObject.combo4sashrelief, windowObject.int_sashwidth, windowObject.bool_showhandle]

                    for i,j in zip(listAttr, listVal):

                        if j.get() == "":
                            continue
                        else:
                            try:
                                try:
                                    assert type(j.get()) is bool
                                    dict_[arrangeObject.focus_get][i] = j.get()
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]
                                    
                                except:
                                    j_int = int(j.get())
                                    dict_[arrangeObject.focus_get][i] = j_int
                                    dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j_int]
                            except:
                                dict_[arrangeObject.focus_get][i] = j.get()
                                dictAttributeEditorUpdate[arrangeObject.focus_get][i] = [j, j.get()]

                    self.dictCountWidget[arrangeObject.focus_get].config(**dict_[arrangeObject.focus_get])
                    windowPRO.after(40, self.refreshAttributes)



            except (AttributeError, TclError,):
                # print("okay")
                windowPRO.after(10, self.refreshAttributes)


        def executeWidgetsOnDesignWindow(self, event):
            global iswidget

            try:
                if event.widget.widgetName.startswith("PanedWindow"):
                    self.dictCountWidget[event.widget.master.widgetName].config(borderwidth = 2, relief = SOLID)
                elif event.widget.widgetName.startswith("FramePW"):
                    self.dictCountWidget[event.widget.widgetName].config(borderwidth=2, relief=SOLID)

            except:
                 for ii in self.dictCountWidget:
                     if ii.startswith("FramePW"):
                         self.dictCountWidget[ii].config(borderwidth = 0, relief = SOLID)

            if iswidget == "button":

                dict_[list_button[self.widget_button]] = {"text": f"Button{self.widget_button}"}
                dictAttributeEditorUpdate[list_button[self.widget_button]] = {}     ### Initiate storage of Attributes for every widget

                if str(event.widget) == ".":
                    self.dictLayoutConfig[list_button[self.widget_button]] = {"x": event.x, "y": event.y, "width": 70,
                                                                              "height": 30, "anchor": "nw"}
                elif str(event.widget).startswith(".!scale") == True:
                    self.dictLayoutConfig[list_button[self.widget_button]] = {"x": event.widget.winfo_x() + event.x,
                                                        "y": event.widget.winfo_y() + event.y, "width": 70, "height": 30,
                                                                              "anchor": "nw"}
                elif str(event.widget).startswith(".!dragdropresizewidget") == True:
                    self.dictLayoutConfig[list_button[self.widget_button]] = {"x": event.widget.winfo_x() + event.x,
                                                                              "y": event.widget.winfo_y() + event.y,
                                                                              "width": 70, "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Button{self.widget_button}",
                                                text=f"Button{self.widget_button}")
                windowObject.tree4Widget.selection_set(f"Button{self.widget_button}")
                windowObject.tree4Widget.focus(f"Button{self.widget_button}")
                DragDropResizeWidget.__bases__ = (Button,)
                self.dictCountWidget[f"Button{self.widget_button}"] = DragDropResizeWidget(windowDesign,
                                                                             **dict_[list_button[self.widget_button]])
                self.dictCountWidget[f"Button{self.widget_button}"].place(**self.dictLayoutConfig[list_button[self.widget_button]])
                self.dictCountWidget[f"Button{self.widget_button}"].focus()

                self.dictCountWidget[f"Button{self.widget_button}"].widgetName = f"Button{self.widget_button}"
                windowObject.mainButton()
                windowObject.entry4text.delete(0, END)
                windowObject.entry4text.insert(0, f"Button{self.widget_button}")
                windowObject.entry4widget_variable.insert(END, f"Button{self.widget_button}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_button += 1


            elif iswidget == "checkbutton":
                dict_[list_checkbutton[self.widget_checkbutton]] = {"text": f"Checkbutton{self.widget_checkbutton}"}
                dictAttributeEditorUpdate[
                    list_checkbutton[self.widget_checkbutton]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_checkbutton[self.widget_checkbutton]] = {"x": event.x, "y": event.y, "width": 100,
                                                                                "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Checkbutton{self.widget_checkbutton}",
                                                text=f"Checkbutton{self.widget_checkbutton}")
                windowObject.tree4Widget.selection_set(f"Checkbutton{self.widget_checkbutton}")
                windowObject.tree4Widget.focus(f"Checkbutton{self.widget_checkbutton}")
                DragDropResizeWidget.__bases__ = (Checkbutton,)
                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"] = DragDropResizeWidget(windowDesign,
                                                                                            **dict_[list_checkbutton[self.widget_checkbutton]])
                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"].place(**self.dictLayoutConfig[list_checkbutton[self.widget_checkbutton]])
                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"].focus()

                self.dictCountWidget[f"Checkbutton{self.widget_checkbutton}"].widgetName = f"Checkbutton{self.widget_checkbutton}"
                windowObject.mainCheckbutton()
                windowObject.entry4text.insert(0, f"Checkbutton{self.widget_checkbutton}")
                windowObject.entry4widget_variable.insert(END, f"Checkbutton{self.widget_checkbutton}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_checkbutton += 1

            elif iswidget == "entry":
                dict_[list_entry[self.widget_entry]] = {}
                dictAttributeEditorUpdate[
                    list_entry[self.widget_entry]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_entry[self.widget_entry]] = {"x": event.x, "y": event.y, "width": 100,
                                                                        "height": 20, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index = END, iid = f"Entry{self.widget_entry}",
                                                text = f"Entry{self.widget_entry}")
                windowObject.tree4Widget.selection_set(f"Entry{self.widget_entry}")
                windowObject.tree4Widget.focus(f"Entry{self.widget_entry}")
                DragDropResizeWidget.__bases__ = (Entry,)
                self.dictCountWidget[f"Entry{self.widget_entry}"] = DragDropResizeWidget(windowDesign, **dict_[list_entry[
                                                                                                self.widget_entry]])
                self.dictCountWidget[f"Entry{self.widget_entry}"].place(**self.dictLayoutConfig[list_entry[self.widget_entry]])
                self.dictCountWidget[f"Entry{self.widget_entry}"].focus()

                self.dictCountWidget[f"Entry{self.widget_entry}"].widgetName = f"Entry{self.widget_entry}"
                windowObject.mainEntry()
                windowObject.entry4widget_variable.insert(END, f"Entry{self.widget_entry}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_entry += 1

            elif iswidget == "label":
                dict_[list_label[self.widget_label]] = {"text": f"Label{self.widget_label}"}
                dictAttributeEditorUpdate[
                    list_label[self.widget_label]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_label[self.widget_label]] = {"x": event.x, "y": event.y, "width": 70,
                                                                        "height": 30, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Label{self.widget_label}",
                                                text=f"Label{self.widget_label}")
                windowObject.tree4Widget.selection_set(f"Label{self.widget_label}")
                windowObject.tree4Widget.focus(f"Label{self.widget_label}")
                DragDropResizeWidget.__bases__ = (Label,)
                self.dictCountWidget[f"Label{self.widget_label}"] = DragDropResizeWidget(windowDesign, **dict_[list_label[
                    self.widget_label]])
                self.dictCountWidget[f"Label{self.widget_label}"].place(**self.dictLayoutConfig[list_label[self.widget_label]])
                self.dictCountWidget[f"Label{self.widget_label}"].focus()

                self.dictCountWidget[f"Label{self.widget_label}"].widgetName = f"Label{self.widget_label}"
                windowObject.mainLabel()
                windowObject.entry4text.insert(0, f"Label{self.widget_label}")
                windowObject.entry4widget_variable.insert(END, f"Label{self.widget_label}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_label += 1

            elif iswidget == "listbox":
                dict_[list_listbox[self.widget_listbox]] = {}
                dictAttributeEditorUpdate[
                    list_listbox[self.widget_listbox]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_listbox[self.widget_listbox]] = {"x": event.x, "y": event.y, "width": 120,
                                                                            "height": 150, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Listbox{self.widget_listbox}",
                                                text=f"Listbox{self.widget_listbox}")
                windowObject.tree4Widget.selection_set(f"Listbox{self.widget_listbox}")
                windowObject.tree4Widget.focus(f"Listbox{self.widget_listbox}")
                DragDropResizeWidget.__bases__ = (Listbox,)
                self.dictCountWidget[f"Listbox{self.widget_listbox}"] = DragDropResizeWidget(windowDesign,
                                                                                **dict_[list_listbox[self.widget_listbox]])
                self.dictCountWidget[f"Listbox{self.widget_listbox}"].place(**self.dictLayoutConfig[list_listbox[self.widget_listbox]])
                self.dictCountWidget[f"Listbox{self.widget_listbox}"].focus()

                self.dictCountWidget[f"Listbox{self.widget_listbox}"].widgetName = f"Listbox{self.widget_label}"
                windowObject.mainListbox()
                windowObject.entry4widget_variable.insert(END, f"Listbox{self.widget_listbox}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_listbox += 1

            elif iswidget == "menubutton":
                dict_[list_menubutton[self.widget_menubutton]] = {"text": f"Menubutton{self.widget_menubutton}"}
                dictAttributeEditorUpdate[
                    list_menubutton[self.widget_menubutton]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_menubutton[self.widget_menubutton]] = {"x": event.x, "y": event.y, "width": 110,
                                                                                  "height": 30, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Menubutton{self.widget_menubutton}",
                                                text=f"Menubutton{self.widget_menubutton}")
                windowObject.tree4Widget.selection_set(f"Menubutton{self.widget_menubutton}")
                windowObject.tree4Widget.focus(f"Menubutton{self.widget_menubutton}")
                DragDropResizeWidget.__bases__ = (Menubutton,)
                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"] = DragDropResizeWidget(windowDesign,
                                                                        **dict_[list_menubutton[self.widget_menubutton]])
                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"].place(**self.dictLayoutConfig[list_menubutton[self.widget_menubutton]])
                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"].focus()

                self.dictCountWidget[f"Menubutton{self.widget_menubutton}"].widgetName = f"Menubutton{self.widget_menubutton}"
                windowObject.mainMenubutton()
                windowObject.entry4text.insert(0, f"Menubutton{self.widget_menubutton}")
                windowObject.entry4widget_variable.insert(END, f"Menubutton{self.widget_menubutton}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_menubutton += 1

            elif iswidget == "message":
                dict_[list_message[self.widget_message]] = {"text": f"Message{self.widget_message}"}
                dictAttributeEditorUpdate[
                    list_message[self.widget_message]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_message[self.widget_message]] = {"x": event.x, "y": event.y, "width": 100,
                                                                            "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Message{self.widget_message}",
                                                text=f"Message{self.widget_message}")
                windowObject.tree4Widget.selection_set(f"Message{self.widget_message}")
                windowObject.tree4Widget.focus(f"Message{self.widget_message}")
                DragDropResizeWidget.__bases__ = (Message,)
                self.dictCountWidget[f"Message{self.widget_message}"] = DragDropResizeWidget(windowDesign,
                                                                            **dict_[list_message[self.widget_message]])
                self.dictCountWidget[f"Message{self.widget_message}"].place(**self.dictLayoutConfig[list_message[self.widget_message]])
                self.dictCountWidget[f"Message{self.widget_message}"].focus()

                self.dictCountWidget[f"Message{self.widget_message}"].widgetName = f"Message{self.widget_message}"
                windowObject.mainMessage()
                windowObject.entry4text.insert(0, f"Message{self.widget_message}")
                windowObject.entry4widget_variable.insert(END, f"Message{self.widget_message}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_message += 1

            elif iswidget == "radiobutton":
                dict_[list_radiobutton[self.widget_radiobutton]] = {"text": f"Radiobutton{self.widget_radiobutton}"}
                dictAttributeEditorUpdate[
                    list_radiobutton[self.widget_radiobutton]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_radiobutton[self.widget_radiobutton]] = {"x": event.x, "y": event.y, "width": 100,
                                                                            "height": 30, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Radiobutton{self.widget_radiobutton}",
                                                text=f"Radiobutton{self.widget_radiobutton}")
                windowObject.tree4Widget.selection_set(f"Radiobutton{self.widget_radiobutton}")
                windowObject.tree4Widget.focus(f"Radiobutton{self.widget_radiobutton}")
                DragDropResizeWidget.__bases__ = (Radiobutton,)
                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_radiobutton[
                                                                                                 self.widget_radiobutton]])
                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"].place(
                    **self.dictLayoutConfig[list_radiobutton[self.widget_radiobutton]])
                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"].focus()

                self.dictCountWidget[f"Radiobutton{self.widget_radiobutton}"].widgetName = f"Radiobutton{self.widget_radiobutton}"
                windowObject.mainRadiobutton()
                windowObject.entry4text.insert(0, f"Radiobutton{self.widget_radiobutton}")
                windowObject.entry4widget_variable.insert(END, f"Radiobutton{self.widget_radiobutton}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_radiobutton += 1

            elif iswidget == "scale_horizontal":
                dict_[list_scale[self.widget_scale]] = {"label": f"Scale{self.widget_scale}", "orient": "horizontal"}
                dictAttributeEditorUpdate[
                    list_scale[self.widget_scale]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_scale[self.widget_scale]] = {"x": event.x, "y": event.y, "width": 60,
                                                                            "height": 50, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Scale{self.widget_scale}",
                                                text=f"Scale{self.widget_scale}")
                windowObject.tree4Widget.selection_set(f"Scale{self.widget_scale}")
                windowObject.tree4Widget.focus(f"Scale{self.widget_scale}")
                self.dictCountWidget[f"Scale{self.widget_scale}"] = Scale_H(windowDesign, **dict_[list_scale[
                                                                                                 self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].place(
                    **self.dictLayoutConfig[list_scale[self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].focus()

                self.dictCountWidget[f"Scale{self.widget_scale}"].widgetName = f"Scale{self.widget_scale}"
                windowObject.mainScale()
                windowObject.entry4label.insert(0, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable.insert(END, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_scale += 1

            elif iswidget == "scale_vertical":
                dict_[list_scale[self.widget_scale]] = {"label": f"Scale{self.widget_scale}", "orient": "vertical"}
                dictAttributeEditorUpdate[
                    list_scale[self.widget_scale]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_scale[self.widget_scale]] = {"x": event.x, "y": event.y, "width": 60,
                                                                            "height": 100, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Scale{self.widget_scale}",
                                                text=f"Scale{self.widget_scale}")
                windowObject.tree4Widget.selection_set(f"Scale{self.widget_scale}")
                windowObject.tree4Widget.focus(f"Scale{self.widget_scale}")

                self.dictCountWidget[f"Scale{self.widget_scale}"] = Scale_V(windowDesign, **dict_[list_scale[
                                                                                                 self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].place(
                    **self.dictLayoutConfig[list_scale[self.widget_scale]])
                self.dictCountWidget[f"Scale{self.widget_scale}"].focus()

                self.dictCountWidget[f"Scale{self.widget_scale}"].widgetName = f"Scale{self.widget_scale}"
                windowObject.mainScale()
                windowObject.entry4label.insert(0, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable.insert(END, f"Scale{self.widget_scale}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_scale += 1

            elif iswidget == "spinbox":
                dict_[list_spinbox[self.widget_spinbox]] = {}
                dictAttributeEditorUpdate[
                    list_spinbox[self.widget_spinbox]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_spinbox[self.widget_spinbox]] = {"x": event.x, "y": event.y, "width": 150,
                                                                            "height": 20, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Spinbox{self.widget_spinbox}",
                                                text=f"Spinbox{self.widget_spinbox}")
                windowObject.tree4Widget.selection_set(f"Spinbox{self.widget_spinbox}")
                windowObject.tree4Widget.focus(f"Spinbox{self.widget_spinbox}")
                DragDropResizeWidget.__bases__ = (Spinbox,)
                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_spinbox[
                                                                                                 self.widget_spinbox]])
                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"].place(
                    **self.dictLayoutConfig[list_spinbox[self.widget_spinbox]])
                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"].focus()

                self.dictCountWidget[f"Spinbox{self.widget_spinbox}"].widgetName = f"Spinbox{self.widget_spinbox}"
                windowObject.mainSpinbox()
                windowObject.entry4widget_variable.insert(END, f"Spinbox{self.widget_spinbox}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_spinbox += 1

            elif iswidget == "text":
                dict_[list_text[self.widget_text]] = {}
                dictAttributeEditorUpdate[
                    list_text[self.widget_text]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_text[self.widget_text]] = {"x": event.x, "y": event.y, "width": 300,
                                                                      "height": 300, "anchor": "nw"}
                windowObject.tree4Widget.insert("Design Window", index = END, iid = f"Text{self.widget_text}",
                                                text = f"Text{self.widget_text}")
                windowObject.tree4Widget.selection_set(f"Text{self.widget_text}")
                windowObject.tree4Widget.focus(f"Text{self.widget_text}")
                DragDropResizeWidget.__bases__ = (Text,)
                self.dictCountWidget[f"Text{self.widget_text}"] = DragDropResizeWidget(windowDesign, **dict_[list_text[
                                                                                                self.widget_text]])
                self.dictCountWidget[f"Text{self.widget_text}"].place(**self.dictLayoutConfig[list_text[self.widget_text]])
                self.dictCountWidget[f"Text{self.widget_text}"].focus()

                self.dictCountWidget[f"Text{self.widget_text}"].widgetName = f"Text{self.widget_text}"
                windowObject.mainText()
                windowObject.entry4widget_variable.insert(END, f"Text{self.widget_text}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_text += 1

            elif iswidget == "frame":
                dict_[list_frame[self.widget_frame]] = {"borderwidth": 2, "relief": "solid"}
                dictAttributeEditorUpdate[
                    list_frame[self.widget_frame]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_frame[self.widget_frame]] = {"x": event.x, "y": event.y, "width": 200,
                                                                            "height": 200, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"Frame{self.widget_frame}",
                                                text=f"Frame{self.widget_frame}")
                windowObject.tree4Widget.selection_set(f"Frame{self.widget_frame}")
                windowObject.tree4Widget.focus(f"Frame{self.widget_frame}")
                DragDropResizeWidget.__bases__ = (Frame,)
                self.dictCountWidget[f"Frame{self.widget_frame}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_frame[
                                                                                                 self.widget_frame]])
                self.dictCountWidget[f"Frame{self.widget_frame}"].place(
                    **self.dictLayoutConfig[list_frame[self.widget_frame]])
                self.dictCountWidget[f"Frame{self.widget_frame}"].focus()

                self.dictCountWidget[f"Frame{self.widget_frame}"].widgetName = f"Frame{self.widget_frame}"
                windowObject.mainFrame()
                windowObject.spinbox4borderwidth.insert(END, 2)
                windowObject.combo4relief.insert(END, "solid")
                windowObject.entry4widget_variable.insert(END, f"Frame{self.widget_frame}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_frame += 1

            elif iswidget == "labelframe":
                dict_[list_labelframe[self.widget_labelframe]] = {"text": f"LabelFrame{self.widget_labelframe}"}
                dictAttributeEditorUpdate[
                    list_labelframe[self.widget_labelframe]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_labelframe[self.widget_labelframe]] = {"x": event.x, "y": event.y, "width": 200,
                                                                            "height": 200, "anchor": "nw"}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"LabelFrame{self.widget_labelframe}",
                                                text=f"LabelFrame{self.widget_labelframe}")
                windowObject.tree4Widget.selection_set(f"LabelFrame{self.widget_labelframe}")
                windowObject.tree4Widget.focus(f"LabelFrame{self.widget_labelframe}")
                DragDropResizeWidget.__bases__ = (LabelFrame,)
                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"] = DragDropResizeWidget(windowDesign,
                                                                                             **dict_[list_labelframe[
                                                                                                 self.widget_labelframe]])
                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"].place(
                    **self.dictLayoutConfig[list_labelframe[self.widget_labelframe]])
                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"].focus()

                self.dictCountWidget[f"LabelFrame{self.widget_labelframe}"].widgetName = f"LabelFrame{self.widget_labelframe}"
                windowObject.mainLabelFrame()
                windowObject.entry4text.insert(0, f"LabelFrame{self.widget_labelframe}")
                windowObject.entry4widget_variable.insert(END, f"LabelFrame{self.widget_labelframe}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_labelframe += 1

            elif iswidget == "panedwindow":
                dict_[f"FramePW{self.widget_panedwindow}"] = {"borderwidth": 2, "relief": "solid"}
                dict_[list_panedwindow[self.widget_panedwindow]] = {"background": "grey"}
                dictAttributeEditorUpdate[
                    list_panedwindow[self.widget_panedwindow]] = {}  ### Initiate storage of Attributes for every widget
                self.dictLayoutConfig[list_framepw[self.widget_panedwindow]] = {"x": event.x, "y": event.y, "width": 200,
                                                                            "height": 200, "anchor": "nw"}
                self.dictLayoutConfig[list_panedwindow[self.widget_panedwindow]] = {"relwidth": 0.8, "relheight": 1}

                windowObject.tree4Widget.insert("Design Window", index=END, iid=f"PanedWindow{self.widget_panedwindow}",
                                                text=f"PanedWindow{self.widget_panedwindow}")
                windowObject.tree4Widget.selection_set(f"PanedWindow{self.widget_panedwindow}")
                windowObject.tree4Widget.focus(f"PanedWindow{self.widget_panedwindow}")
                DragDropResizeWidget.__bases__ = (Frame,)
                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"] = DragDropResizeWidget(windowDesign,
                                                                            **dict_[f"FramePW{self.widget_panedwindow}"])

                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"].place(
                    **self.dictLayoutConfig[list_framepw[self.widget_panedwindow]])

                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"] = PanedWindow(
                                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"],
                                                                                             **dict_[list_panedwindow[
                                                                                                 self.widget_panedwindow]])
                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"].place(relwidth = 0.8, relheight = 1)

                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"].focus()

                self.dictCountWidget[f"FramePW{self.widget_panedwindow}"].widgetName = f"FramePW{self.widget_panedwindow}"
                self.dictCountWidget[f"PanedWindow{self.widget_panedwindow}"].widgetName = f"PanedWindow{self.widget_panedwindow}"
                windowObject.mainPanedWindow()
                windowObject.entry4background.insert(0, "grey")
                windowObject.entry4widget_variable.insert(END, f"PanedWindow{self.widget_panedwindow}")
                windowObject.entry4widget_variable["state"] = "disabled"
                iswidget = 0
                self.widget_panedwindow += 1


    class CodeGenerate:
        def __init__(self):
            self.compile2Shell()
            


        def compile2Text(self):
            toplevel4Text = Toplevel(master = windowPRO, name = "toplevel_textbox")
            toplevel4Text.geometry = ("400x400+500+500")
            toplevel4Text.resizable(False, False)

            def copy_gen_codes():
                windowPRO.clipboard_clear()
                windowPRO.clipboard_append(self.string_final_codes)
                label_copy = Label(toplevel4Text, text = "Copied Successfully", font = ("Segoe UI", 10, "bold"))
                label_copy.pack(fill = X, )

            menu4copy = Menu(tearoff = False)
            menu4copy.add_command(label = "Copy", command = copy_gen_codes)
            toplevel4Text.config(menu = menu4copy)

            scroll4CompileText = Scrollbar(master=toplevel4Text, orient="vertical", )
            scroll4CompileText.pack(side=RIGHT, fill=Y)

            text4CompileText = Text(master = toplevel4Text, yscrollcommand = scroll4CompileText.set)
            text4CompileText.insert(END, self.string_final_codes)
            text4CompileText.config(state = "disabled")
            text4CompileText.pack()
            scroll4CompileText.config(command = text4CompileText.yview)




        def compile2PythonFile(self):
            file_gen_code = filedialog.asksaveasfile("w", filetypes = [("Python file","*.py")], defaultextension = ".py")
            print(file_gen_code)
            file_open = open(file_gen_code.name, "w")
            file_open.write(self.string_final_codes)
            file_open.close()


        def compile2Shell(self):
            string_command_all = ""
            string_font_all = ""
            string_image_all = ""
            string_button_all = ""
            string_checkbutton_all = ""
            string_entry_all = ""
            string_frame_all = ""
            string_labelframe_all = ""
            string_label_all = ""
            string_listbox_all = ""
            string_menubutton_all = ""
            string_message_all = ""
            string_radiobutton_all = ""
            string_scale_all = ""
            string_spinbox_all = ""
            string_text_all = ""
            string_framepw_all = ""
            string_panedwindow_all = ""
            string_panes = ""
            ### Run main window and its properties
            string_window_prop = ""
            string_iconphoto = ""
            string_header = "from tkinter import *\nfrom tkinter import font \n\nwindowDesign = Tk()"
            string_commands = ''
            string_mainloop = "windowDesign.mainloop()"
            for k,v in zip(dictDesignWindowPropCollect.keys(), dictDesignWindowPropCollect.values()):
                if k == "iconphoto":
                    string_iconphoto = f"IconPhoto = {v})"
                    continue
                string_window_prop = string_window_prop + v + "\n"
            string_all_header = string_header+"\n"+string_iconphoto+"\n"+string_window_prop

            ##### Commands Output section for Design window widgets
            for com in windowObject.commands_all:
                string_commands = ""
                if windowObject.commands_all[com] == None:
                    continue
                else:
                    com_value = windowObject.commands_all[com]
                    string_commands = string_commands + f"def {com_value}():      # Command for {com}" + "\n"
                    string_commands = string_commands + "    pass"
                string_command_all = string_command_all + string_commands

            for i,j,k in zip(arrangeObject.dictCountWidget.keys(), dict_.items(), arrangeObject.dictLayoutConfig.items()):
                new_dict_main = {}
                new_dict_layout = {}
                if i.startswith("FramePW")|i.startswith("PanedWindow"):
                    continue;

                else:
                    string_font_button = ""
                    string_image_button = ""
                    if i.startswith("Button"):

                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_button = string_font_button + f"{n} = font.Font(name = '{font_name}', " \
                                                                f"family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_button

                        widget_image = j["image"]
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_button = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_button

                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Button("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                          f"anchor = '{k['anchor']}')"
                        widgetStr = f"{i} = {widgetStr}\n"
                        string_button_all = string_button_all + widgetStr


                    if i.startswith("Checkbutton"):
                        string_font_checkbutton = ""
                        string_image_checkbutton = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_checkbutton = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_checkbutton
                        widget_image = j["image"]
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_checkbutton = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_checkbutton

                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Checkbutton("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')"
                        widgetStr = f"{i} = {widgetStr}\n"
                        string_checkbutton_all = string_checkbutton_all + widgetStr


                    if i.startswith("Entry"):
                        string_font_entry = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_entry = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_entry
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Entry("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_entry_all = string_entry_all + widgetStr

                    if i.startswith("Frame"):

                        j = dict(sorted(j[1].items()))
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Frame("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_frame_all = string_frame_all + widgetStr
                        

                    if i.startswith("LabelFrame"):
                        string_font_labelframe = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_labelframe = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_labelframe
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"LabelFrame("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"

                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}," \
                              f"anchor = '{k['anchor']}')\n"
                        string_labelframe_all = string_labelframe_all + widgetStr
                    
                    if i.startswith("Label"):
                        string_font_label = ""
                        string_image_label = ""
                        try:
                            j = dict(sorted(j[1].items()))
                            widget_font = j["font"]
                            for n in windowObject.dictCountFont:
                                if widget_font == windowObject.dictCountFont[n].name:
                                    font_name = windowObject.dictCountFont[n].name
                                    actual = windowObject.dictCountFont[n].actual()
                                    string_font_label = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                          f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                          f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                          f"overstrike = {actual['overstrike']})\n"
                                else:
                                    pass
                            string_font_all = string_font_all + string_font_label
                            widget_image = j["image"]
                            for im in windowObject.dictCountImage:
                                if widget_image == windowObject.dictCountImage[im].name:
                                    image_name = windowObject.dictCountImage[im].name
                                    image_file = windowObject.dictCountImage[im].cget("file")
                                    string_image_label = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                                else:
                                    pass
                            string_image_all = string_image_all + string_image_label

                            k = arrangeObject.dictLayoutConfig[i]
                            widgetStr = f"Label("
                            for jj in j:
                                dd = jj.replace("'", "")
                                dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                                widgetStr = widgetStr + dd
                            widgetStr = widgetStr + ")"
                            widgetStr = f"{i} = {widgetStr}"
                            widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, "\
                                  f"anchor = '{k['anchor']}')\n"
                            string_label_all = string_label_all + widgetStr
                        except KeyError:
                            pass

                    if i.startswith("Listbox"):
                        string_font_listbox = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_listbox = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_listbox
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Listbox("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_listbox_all = string_listbox_all + widgetStr

                    if i.startswith("Menubutton"):
                        string_font_menubutton = ""
                        string_image_menubutton = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_menubutton = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                            widget_image = j["image"]
                        string_font_all = string_font_all + string_font_menubutton
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_menubutton = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_menubutton
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Menubutton("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_menubutton_all = string_menubutton_all + widgetStr

                    if i.startswith("Message"):
                        string_font_message = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_message = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_message
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Message("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_message_all = string_message_all + widgetStr

                    if i.startswith("Radiobutton"):
                        string_font_radiobutton = ""
                        string_image_radiobutton = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_radiobutton = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_radiobutton
                        widget_image = j["image"]
                        for im in windowObject.dictCountImage:
                            if widget_image == windowObject.dictCountImage[im].name:
                                image_name = windowObject.dictCountImage[im].name
                                image_file = windowObject.dictCountImage[im].cget("file")
                                string_image_radiobutton = f"{im} = PhotoImage(name = '{image_name}', file = '{image_file}')\n"
                            else:
                                pass
                        string_image_all = string_image_all + string_image_radiobutton

                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Radiobutton("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_radiobutton_all = string_radiobutton_all + widgetStr

                    if i.startswith("Scale"):
                        string_font_scale = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_scale = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_scale
                        k = arrangeObject.dictLayoutConfig[i]
                        if j["orient"] == "vertical":
                            k_width = int(k["width"])-70
                            widgetStr = f"Scale("
                            for jj in j:
                                dd = jj.replace("'", "")
                                dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                                widgetStr = widgetStr + dd
                            if windowObject.commands_all[i] == None:
                                widgetStr = widgetStr + f" width = {k_width})"
                            else:
                                widgetStr = widgetStr + f"width = {k_width}, command = {windowObject.commands_all[i]})"

                            widgetStr = f"{i} = {widgetStr}"
                            widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, anchor = '{k['anchor']}')\n"
                            string_scale_all = string_scale_all + widgetStr

                        elif j["orient"] == "horizontal":
                            k_height = int(k["height"])-70
                            widgetStr = f"Scale("
                            for jj in j:
                                dd = jj.replace("'", "")
                                dd = f"{dd} = {j[jj], }".replace("(","").replace(")"," ")
                                widgetStr = widgetStr + dd
                            if windowObject.commands_all[i] == None:
                                widgetStr = widgetStr + f" width = {k_height})"
                            else:
                                widgetStr = widgetStr + f"width = {k_height}, command = {windowObject.commands_all[i]})"

                            widgetStr = f"{i} = {widgetStr}"
                            widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, width = {k['width']}, anchor = '{k['anchor']}')\n"
                            string_scale_all = string_scale_all + widgetStr

                    if i.startswith("Spinbox"):
                        string_font_spinbox = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_spinbox = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_spinbox
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Spinbox("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        if windowObject.commands_all[i] == None:
                            widgetStr = widgetStr + f")"
                        else:
                            widgetStr = widgetStr + f"command = {windowObject.commands_all[i]})"

                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_scale_all = string_scale_all + widgetStr

                    if i.startswith("Text"):
                        string_font_text = ""
                        j = dict(sorted(j[1].items()))
                        widget_font = j["font"]
                        for n in windowObject.dictCountFont:
                            if widget_font == windowObject.dictCountFont[n].name:
                                font_name = windowObject.dictCountFont[n].name
                                actual = windowObject.dictCountFont[n].actual()
                                string_font_text = f"{n} = font.Font(name = '{font_name}', family = '{actual['family']}', " \
                                      f"size = {actual['size']}, weight = '{actual['weight']}', " \
                                      f"slant = '{actual['slant']}', underline = {actual['underline']}, " \
                                      f"overstrike = {actual['overstrike']})\n"
                            else:
                                pass
                        string_font_all = string_font_all + string_font_text
                        k = arrangeObject.dictLayoutConfig[i]
                        widgetStr = f"Text("
                        for jj in j:
                            dd = jj.replace("'", "")
                            dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                            widgetStr = widgetStr + dd
                        widgetStr = widgetStr + ")"
                        widgetStr = f"{i} = {widgetStr}"
                        widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                              f"anchor = '{k['anchor']}')\n"
                        string_text_all = string_text_all + widgetStr

            for i, j, k in zip(arrangeObject.dictCountWidget.keys(), dict_.items(), arrangeObject.dictLayoutConfig.items()):
                if i.startswith("FramePW"):
                    j = dict(sorted(j[1].items()))
                    k = arrangeObject.dictLayoutConfig[i]
                    widgetStr = f"Frame("
                    for jj in j:
                        dd = jj.replace("'", "")
                        dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                        widgetStr = widgetStr + dd
                    widgetStr = widgetStr + ")"
                    widgetStr = f"{i} = {widgetStr}"
                    widgetStr = widgetStr + f"\n{i}.place(x = {k['x']}, y = {k['y']}, height = {k['height']}, width = {k['width']}, " \
                          f"anchor = '{k['anchor']}')\n"
                    masterPW = i
                    string_framepw_all = string_framepw_all + widgetStr

                elif i.startswith("PanedWindow"):
                    j = dict(sorted(j[1].items()))
                    widgetStr = f"PanedWindow({masterPW}, "
                    for jj in j:
                        dd = jj.replace("'", "")
                        dd = f"{dd} = {j[jj], }".replace("(", "").replace(")", " ")
                        widgetStr = widgetStr + dd
                    widgetStr = widgetStr + ")"

                    widgetStr = f"{i} = {widgetStr}"
                    widgetStr = widgetStr + f"\n{i}.place(relheight = 1, relwidth = 0.8)\n"
                    for ke,val in zip(arrangeObject.dict_widget_panes.keys(), arrangeObject.dict_widget_panes.values()):
                        print(arrangeObject.dict_widget_panes)
                        string_panes = string_panes + f"{ke}.lift()\n"
                        string_panes = string_panes + f"{val}.add({ke})\n"
                    string_panedwindow_all = string_panedwindow_all + widgetStr


            self.string_final_codes = string_all_header + "\n" + string_command_all + "\n" + string_font_all + string_image_all + \
            string_button_all + string_checkbutton_all + string_entry_all + string_frame_all + string_labelframe_all + \
            string_label_all + string_listbox_all + string_menubutton_all + string_message_all + string_radiobutton_all + \
            string_scale_all + string_spinbox_all + string_text_all + string_framepw_all + string_panedwindow_all + \
            string_panes + "\n" + string_mainloop



    class DragDropResizeWidget(Button):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.bind("<Motion>", self.motion1Both)

        def cursorChange(self, event):
            self["cursor"] = windowObject.combo4cursor.get()

        def startDrag(self, event):
            self.start_drag_x = event.x
            self.start_drag_y = event.y

        def motionDrag(self, event):
            self["cursor"] = "bogosity"
            self.place_configure(anchor="nw")
            new_x = (self.winfo_x() + event.x) - self.start_drag_x
            new_y = (self.winfo_y() + event.y) - self.start_drag_y
            self.place(x=new_x, y=new_y)

        def motion1Both(self, event):
            self.xx = self.winfo_x() + int(self.place_info()["width"])
            self.yy = self.winfo_y() + int(self.place_info()["height"])
            self.ttx = event.x + self.winfo_x()
            self.tty = event.y + self.winfo_y()

            if ((self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)) & (
                    (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                self["cursor"] = "bottom_right_corner"
                self.bind("<Button1-Motion>", self.motionBottomRight)

            elif ((self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                    self.winfo_x() == self.ttx - 3)) & (
                    (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                self["cursor"] = "bottom_left_corner"
                self.bind("<Button1-Motion>", self.motionBottomLeft)

            elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                    self.winfo_y() == self.tty - 3)) & (
                    (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                    self.winfo_x() == self.ttx - 3)):
                self["cursor"] = "top_left_corner"
                self.bind("<Button1-Motion>", self.motionTopLeft)

            elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                    self.winfo_y() == self.tty - 3)) & (
                    (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)):
                self["cursor"] = "top_right_corner"
                self.bind("<Button1-Motion>", self.motionTopRight)

            elif (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3):
                self["cursor"] = "right_side"
                self.bind("<Button1-Motion>", self.motionRight)

            elif (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3):
                self["cursor"] = "bottom_side"
                self.bind("<Button1-Motion>", self.motionBottom)

            elif (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (self.winfo_x() == self.ttx - 3):
                self["cursor"] = "left_side"
                self.bind("<Button1-Motion>", self.motionLeft)

            elif (self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (self.winfo_y() == self.tty - 3):
                self["cursor"] = "top_side"
                self.bind("<Button1-Motion>", self.motionTop)


            else:
                self["cursor"] = windowObject.combo4cursor.get()
                self.bind("<Button-1>", self.startDrag)
                self.bind("<Button1-Motion>", self.motionDrag)
                self.bind("<ButtonRelease-1>", self.cursorChange)

        def motionTop(self, event):
            self.place_configure(x=self.winfo_x(), y=(self.winfo_y() + int(self.place_info()["height"])), anchor="sw")
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self.place_configure(height=new_height)

        def motionBottom(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self.place_configure(height=new_height)

        def motionLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = (0 - event.x) + int(self.place_info()["width"])
            self.place_configure(width=new_width)

        def motionRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            self.place_configure(width=new_width)

        def motionTopLeft(self, event):
            self.place_configure(x=self.winfo_x() + int(self.place_info()["width"]),
                                 y=self.winfo_y() + int(self.place_info()["height"]), anchor="se")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = 0 - event.y + int(self.place_info()["height"])
            self.place_configure(width=new_width, height=new_height)

        def motionTopRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y() + int(self.place_info()["height"]), anchor="sw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self.place_configure(width=new_width, height=new_height)

        def motionBottomLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self.place_configure(width=new_width, height=new_height)

        def motionBottomRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self.place_configure(width=new_width, height=new_height)


    class Scale_H(Scale):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.bind("<Motion>", self.motion1Both)

        def cursorChange(self, event):
            self["cursor"] = windowObject.combo4cursor.get()


        def startDrag(self, event):

            self.start_drag_x = event.x
            self.start_drag_y = event.y

        def motionDrag(self, event):
            self["cursor"] = "bogosity"
            self.place_configure(anchor="nw")
            new_x = (self.winfo_x() + event.x) - self.start_drag_x
            new_y = (self.winfo_y() + event.y) - self.start_drag_y
            self.place(x=new_x, y=new_y)

        def motion1Both(self, event):

            if self.identify(event.x, event.y) == "":
                self.xx = self.winfo_x() + int(self.place_info()["width"])
                self.yy = self.winfo_y() + int(self.place_info()["height"])
                self.ttx = event.x + self.winfo_x()
                self.tty = event.y + self.winfo_y()

                if ((self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_right_corner"
                    self.bind("<Button1-Motion>", self.motionBottomRight)

                elif ((self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_left_corner"
                    self.bind("<Button1-Motion>", self.motionBottomLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)):
                    self["cursor"] = "top_left_corner"
                    self.bind("<Button1-Motion>", self.motionTopLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)):
                    self["cursor"] = "top_right_corner"
                    self.bind("<Button1-Motion>", self.motionTopRight)

                elif (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3):
                    self["cursor"] = "right_side"
                    self.bind("<Button1-Motion>", self.motionRight)

                elif (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3):
                    self["cursor"] = "bottom_side"
                    self.bind("<Button1-Motion>", self.motionBottom)

                elif (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (self.winfo_x() == self.ttx - 3):
                    self["cursor"] = "left_side"
                    self.bind("<Button1-Motion>", self.motionLeft)

                elif (self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (self.winfo_y() == self.tty - 3):
                    self["cursor"] = "top_side"
                    self.bind("<Button1-Motion>", self.motionTop)


                else:
                    self["cursor"] = windowObject.combo4cursor.get()
                    self.bind("<Button-1>", self.startDrag)
                    self.bind("<Button1-Motion>", self.motionDrag)
                    self.bind("<ButtonRelease-1>", self.cursorChange)

            else:
                self.bind("<Button1-Motion>", lambda x: None)

        def motionTop(self, event):
            self.place_configure(x=self.winfo_x(), y=(self.winfo_y() + int(self.place_info()["height"])), anchor="sw")
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(height=new_height)

        def motionBottom(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(height=new_height)

        def motionLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = (0 - event.x) + int(self.place_info()["width"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width)

        def motionRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width)

        def motionTopLeft(self, event):
            self.place_configure(x=self.winfo_x() + int(self.place_info()["width"]),
                                 y=self.winfo_y() + int(self.place_info()["height"]), anchor="se")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = 0 - event.y + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)

        def motionTopRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y() + int(self.place_info()["height"]), anchor="sw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["height"]) - 33)
            self.place_configure(width=new_width, height=new_height)


    class Scale_V(Scale):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.bind("<Motion>", self.motion1Both)

        def cursorChange(self, event):
            self["cursor"] = windowObject.combo4cursor.get()

        def startDrag(self, event):

            self.start_drag_x = event.x
            self.start_drag_y = event.y

        def motionDrag(self, event):
            self["cursor"] = "bogosity"
            self.place_configure(anchor="nw")
            new_x = (self.winfo_x() + event.x) - self.start_drag_x
            new_y = (self.winfo_y() + event.y) - self.start_drag_y
            self.place(x=new_x, y=new_y)

        def motion1Both(self, event):

            if self.identify(event.x, event.y) == "":
                self.xx = self.winfo_x() + int(self.place_info()["width"])
                self.yy = self.winfo_y() + int(self.place_info()["height"])
                self.ttx = event.x + self.winfo_x()
                self.tty = event.y + self.winfo_y()

                if ((self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_right_corner"
                    self.bind("<Button1-Motion>", self.motionBottomRight)

                elif ((self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)) & (
                        (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3)):
                    self["cursor"] = "bottom_left_corner"
                    self.bind("<Button1-Motion>", self.motionBottomLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (
                        self.winfo_x() == self.ttx - 3)):
                    self["cursor"] = "top_left_corner"
                    self.bind("<Button1-Motion>", self.motionTopLeft)

                elif ((self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (
                        self.winfo_y() == self.tty - 3)) & (
                        (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3)):
                    self["cursor"] = "top_right_corner"
                    self.bind("<Button1-Motion>", self.motionTopRight)

                elif (self.ttx == self.xx - 1) | (self.ttx == self.xx - 2) | (self.ttx == self.xx - 3):
                    self["cursor"] = "right_side"
                    self.bind("<Button1-Motion>", self.motionRight)

                elif (self.tty == self.yy - 1) | (self.tty == self.yy - 2) | (self.tty == self.yy - 3):
                    self["cursor"] = "bottom_side"
                    self.bind("<Button1-Motion>", self.motionBottom)

                elif (self.winfo_x() == self.ttx - 1) | (self.winfo_x() == self.ttx - 2) | (self.winfo_x() == self.ttx - 3):
                    self["cursor"] = "left_side"
                    self.bind("<Button1-Motion>", self.motionLeft)

                elif (self.winfo_y() == self.tty - 1) | (self.winfo_y() == self.tty - 2) | (self.winfo_y() == self.tty - 3):
                    self["cursor"] = "top_side"
                    self.bind("<Button1-Motion>", self.motionTop)


                else:
                    self["cursor"] = windowObject.combo4cursor.get()
                    self.bind("<Button-1>", self.startDrag)
                    self.bind("<Button1-Motion>", self.motionDrag)
                    self.bind("<ButtonRelease-1>", self.cursorChange)

            else:
                self.bind("<Button1-Motion>", lambda x: None)

        def motionTop(self, event):
            self.place_configure(x=self.winfo_x(), y=(self.winfo_y() + int(self.place_info()["height"])), anchor="sw")
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(height=new_height)

        def motionBottom(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(height=new_height)

        def motionLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = (0 - event.x) + int(self.place_info()["width"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width)

        def motionRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width)

        def motionTopLeft(self, event):
            self.place_configure(x=self.winfo_x() + int(self.place_info()["width"]),
                                 y=self.winfo_y() + int(self.place_info()["height"]), anchor="se")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = 0 - event.y + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

        def motionTopRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y() + int(self.place_info()["height"]), anchor="sw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = (0 - event.y) + int(self.place_info()["height"])
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomLeft(self, event):
            self.place_configure(x=(self.winfo_x() + int(self.place_info()["width"])), y=self.winfo_y(), anchor="ne")
            new_width = 0 - event.x + int(self.place_info()["width"])
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

        def motionBottomRight(self, event):
            self.place_configure(x=self.winfo_x(), y=self.winfo_y(), anchor="nw")
            new_width = int(self.place_info()["width"]) + (event.x - int(self.place_info()["width"]))
            new_height = int(self.place_info()["height"]) + (event.y - int(self.place_info()["height"]))
            self["width"] = 0.9 * (int(self.place_info()["width"]) - 43)
            self.place_configure(width=new_width, height=new_height)

    windowPRO = Tk()  ######## Creates Main Window



    windowObject = pyPROApp(windowPRO)  ####### Instance Object for pyPROApp class
    windowObject.widgetTreeview()

    ##### Lists of widget control variables names
    list_button = [f"Button{x}" for x in range(0,1000)]    #### list to contain widget control variables names for Button
    list_checkbutton = [f"Checkbutton{x}" for x in range(0,1000)]   #### list to contain widget control variables names for Checkbutton
    list_entry = [f"Entry{x}" for x in range(0,1000)]
    list_label = [f"Label{x}" for x in range(0,1000)]
    list_listbox = [f"Listbox{x}" for x in range(0,1000)]
    list_menubutton = [f"Menubutton{x}" for x in range (0,1000)]
    list_message = [f"Message{x}" for x in range (0,1000)]
    list_radiobutton = [f"Radiobutton{x}" for x in range(0,1000)]
    list_scale = [f"Scale{x}" for x in range(0,1000)]
    list_scrollbar = [f"Scrollbar{x}" for x in range (0, 1000)]
    list_spinbox = [f"Spinbox{x}" for x in range(0,1000)]
    list_text = [f"Text{x}" for x in range(0,1000)]
    list_frame = [f"Frame{x}" for x in range(0,1000)]
    list_labelframe = [f"LabelFrame{x}" for x in range(0,1000)]
    list_framepw = [f"FramePW{x}" for x in range(0,1000)]
    list_panedwindow = [f"PanedWindow{x}" for x in range(0,1000)]

    dict_ = {}                                      #### Dictionary to hold attributes for control variables
    dictAttributeEditorUpdate = {}                  #### Dictionary to update Attribute Editor for any selected widget
    # dictAttributeCollect = {}                       #### Dictionary to collect attributes to display in Attribute Editor


    arrangeObject = WidgetArrange()  ####### Instance Object for WidgetArrange class
    arrangeObject.refreshAttributes()


    ####### Design Window - To Work On
    windowDesign = Tk()
    windowDesign.title("Design Window")
    windowDesign.geometry("%dx%d+%d+%d" % (screen_width / 2, screen_height / 1.57, screen_width / 4.5, screen_height / 3.36))


    ### Events For Design Window
    windowDesign.bind("<Button-1>", arrangeObject.executeWidgetsOnDesignWindow)
    windowObject.tree4Widget.bind("<<TreeviewSelect>>", arrangeObject.focusWidgetTree)  ### Event for Widget Tree
    windowDesign.bind_all("<ButtonRelease-1>", arrangeObject.motionRelease)

    implementFont_determine = None    ### Variable that determines whether to run implementFont command
    windowPRO.mainloop()
    
if zippassvar == 60:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    import tkinter as tk
    from tkinter import messagebox
    import tkinter as tk
    from tkinter import filedialog, messagebox, ttk
    from os import walk
    from pathlib import Path
    import threading
    import zlib
    from zipfile import ZipFile


    class File(object):
        def __init__(self, full_path):
            self.file_path = full_path
            self.name = None
            self.size = None
            self.file_type = None
            self.parent_folder = None
            self._setup()

        def __repr__(self):
            return f"{self.name}"

        def _setup(self):
            print(self.file_path)
            p = Path(self.file_path)
            self.name = p.name
            if p.suffix == "":
                raise FileNotFoundError(
                    f"{self.file_path} has to be a file not a folder"
                    )

            self.file_type = p.suffix
            self.size = p.stat().st_size  # size displayed in bytes
            self.parent_folder = str(p.parent)


    class Folder(object):
        def __init__(self, full_path, include_subfolders=False):
            self.folder_path = full_path
            self.includes_subfolders = include_subfolders
            self.folder_files = ()
            self._extract_files(include_subfolders)

        def __repr__(self):
            return f"{self.folder_path}"

        def _extract_files(self, seek_subfolders=False):
            all_files = []
            for (dirpath, dirnames, filenames) in walk(self.folder_path, topdown=True):
                for filename in filenames:
                    file_path = fr"{dirpath}\{filename}"
                    print(file_path)
                    file = File(file_path)
                    all_files.append(file)
                if not seek_subfolders:
                    break
            if all_files:
                self.folder_files = tuple(all_files)

        def show_files(self, pretty_print=False):
            print(self)
            if not pretty_print:
                print(self.folder_files)
            else:
                for file in self.folder_files:
                    print(f"Name: {file.name}\n  Size: {file.size}")


    class AttackTargets(object):
        def __init__(self):
            self.targets = []  # a list of file and folder object

        def add_target(self, target):
            # A target is a tuple in the form ["type", "include_subfolders", "target_path"]
            target_type = target[0]
            include_subfolders = target[1]
            target_path = target[2]
            if target_type == "File":
                self._add_target_file(target_path=target_path)
            else:
                self._add_target_folder(target_path=target_path,
                                        include_subfolders=include_subfolders)

        def _add_target_file(self, target_path):
            raw_target = fr"{target_path}"
            t = File(raw_target)
            self.targets.append(t)

        def _add_target_folder(self, target_path, include_subfolders=False):
            raw_target = fr"{target_path}"
            t = Folder(raw_target, include_subfolders)
            self.targets.append(t)

        def get_targets(self):
            return self.targets

        def show_targets(self, pretty_print=False):
            if not self.targets:
                print("There are no targets")
            for count, item in enumerate(self.targets, 1):
                if isinstance(item, File):
                    print(f"Target {count}.\n{item}")
                else:
                    print(f"Target {count}.\n")
                    item.show_files(pretty_print)


    class Controller(object):
        def __init__(self, view):
            super().__init__()
            self.view = view

        def launch_attack(self, password_file, save_destination, hash_type, targets):
            attack_targets = AttackTargets()
            for target in targets:
                attack_targets.add_target(target)
            attack = DictionaryAttack(
                        self.view, password_file, save_destination, hash_type, attack_targets
                    )
            attack.daemon = True
            attack.start()


    class DictionaryAttack(threading.Thread):
        def __init__(self, view, password_file, save_destination, hash_type, targets):
            threading.Thread.__init__(self)
            # Thread attributes
            self.threadID = 1
            self.name = "AttackThread"

            self.view = view
            self.password_file = password_file
            self.save_destination = save_destination
            self.hash_type = hash_type
            self.attack_targets = targets
            self.supported_types = frozenset([".zip"])

        def run(self):  # .start initiates this
            self.view.clear_text_output()  # clear the previous output if any
            self.view.insert_text_message(
                f"### INITIALISING ###",
                update_idle=True
            )
            targets = self.attack_targets.get_targets()
            for target in targets:
                if isinstance(target, File):
                    self._attack_file(target)
                else:
                    self._attack_folder(target)
            self.view.set_current_target("---------")
            self.view.insert_text_message(
                f"### PROGRAM END ###"
            )
            return None

        def _attack_folder(self, target_folder):
            self.view.insert_text_message(
                f"### TARGETING THE FOLDER {target_folder} ###"
            )
            self.view.set_current_target(target_folder)
            for file in target_folder.folder_files:
                self._attack_file(file)
            self.view.insert_text_message(
                f"### EXITING THE FOLDER {target_folder} ###"
            )

        def _attack_file(self, target_file):
            self.view.insert_text_message(
                f"## TARGETING THE FILE {target_file} ##"
            )
            self.view.set_current_target(target_file)

            is_supported_type = self._is_supported_file(target_file)
            if is_supported_type:
                pw_required = self._attempt_open_file(target_file)
                if pw_required:
                    self.view.insert_text_message(
                        f"{target_file} is password protected."
                    )
                    self._crack_file(target_file)
                else:
                    self.view.insert_text_message(
                        f"Ignore. {target_file} is not password protected.\n"
                    )
            else:
                self.view.insert_text_message(
                    f"Ignore {target_file}.\n{target_file.file_type} is not supported.\n"
                )

        def _is_supported_file(self, target):
            return (target.file_type in self.supported_types)

        def _attempt_open_file(self, target):
            path = target.file_path
            if target.file_type == ".zip":
                try:
                    zf = ZipFile(path).testzip()
                except RuntimeError as err:
                    msg = "password required for extraction"
                    if str(err).endswith(msg):
                        return True
                    else:
                        self.view.display_messagebox(err, "showerror")

            return False  # if its not in protected types

        def _crack_file(self, target_file):
            self.view.insert_text_message(f"# ATTEMPTING TO CRACK {target_file} #")
            self.view.insert_text_message("_____", update_idle=True)
            found = False
            last_attempt = 0
            found_password = ""
            # dont use readlines as it will store the whole file in memory..
            # just read line by line
            pws = open(self.password_file, "r", encoding="latin1")
            for attempt, password in enumerate(pws, 1):
                password = password.strip()
                

                if target_file.file_type == ".zip":
                    try:
                        password_byte = bytes(password, "latin1")
                        ZipFile(target_file.file_path).extractall(path=self.save_destination,
                                                                  pwd=password_byte)
                        found = True
                        found_password = password_byte.decode("latin1")
                        last_attempt = attempt
                        break
                    except RuntimeError as err:
                        if str(err).startswith("Bad password"):
                            update_idle = (attempt % 5 == 0)
                            self.view.insert_text_message(
                                f"Attempt {attempt}: '{password}' failed.",
                                update_idle=update_idle
                            )
                            if attempt % 250 == 0:
                                self.view.clear_text_output()
                        else:
                            self.view.display_messagebox(err, "showerror")
                            break
                    except zlib.error as zerr:
                        if str(zerr).startswith("Error -3"):
                            # If there are compression errors then skip
                            continue
                        else:
                            self.view.display_messagebox(zerr, "showerror")
                            break

            pws.close()
            if found:
                self.view.insert_text_message(
                    f"Attempt {last_attempt}: '{found_password}'"
                )
                self.view.insert_text_message("Password Found")
                self.view.insert_text_message(
                    f"The password [{found_password}] found after {last_attempt} attempts",
                    update_idle=True
                )
                self.view.insert_text_message(
                    f"{target_file} has been Cracked!!!"
                )
                self.view.insert_text_message(
                    f"files extracted to {self.save_destination}",
                    update_idle=True
                )
                self.view.insert_text_message(
                    f"password will be saved to {self.save_destination}"
                )
                self.view.insert_text_message(f"________________")
                self._store_password(found_password, target_file.file_path)

            else:
                self.view.insert_text_message(
                    f"Failed to Crack {target_file}",
                    update_idle=True
                )

        def _store_password(self, password, target_path):
            line = f"{password} | {target_path}\n"
            dest = fr"{self.save_destination}\extracted_passwords.txt"
            f = open(dest, "a+")
            f.write(line)
            f.close()
            self.view.insert_text_message(
                f"Found password stored to {dest}"
            )

    # This is our menu
    class NavBar(tk.Menu):
        def __init__(self, parent):
            super().__init__(parent)

            # File
            menu_file = tk.Menu(self, tearoff=0)
            self.add_cascade(label="File", menu=menu_file)
            menu_file.add_command(label="How to use WordSmith", command=parent.OpenHelpPage)
            menu_file.add_command(label="Disclaimer", command=parent.OpenDisclaimerPage)
            menu_file.add_separator()
            menu_file.add_command(label="Exit",
                                  command=parent.quit_application)


    class MainPage(tk.Frame):
        def __init__(self, parent):
            super().__init__(parent)
            MAIN_FONT = ("Yu Gothic UI", 9, "bold")

            frame_styles = {"relief": "groove",
                            "bd": 3,
                            "fg": "#073bb3", "font": MAIN_FONT}
            self.controller = Controller(view=self)

            label_header = tk.Label(parent, text="WordSmith", font=("Verdana Pro Cond Black", 25))
            label_header.place(rely=0.03, relx=0.02)
            label_author = tk.Label(parent, text="by Tudor Marmureanu", font=MAIN_FONT)
            label_author.place(rely=0.07, relx=0.20)

            label_dict_title = tk.Label(parent, text="Select your dictionary list", font=MAIN_FONT)
            label_dict_title.place(rely=0.12, relx=0.02)
            self.label_dict_file = tk.Label(parent, relief="ridge", anchor="w")
            self.label_dict_file.place(rely=0.15, relx=0.02, height=23, width=375)
            btn_dict_file = ttk.Button(parent, text="Browse...", command=self._set_dictionary_list)
            btn_dict_file.place(rely=0.15, relx=0.40)

            label_extract_title = tk.Label(parent, text="Select a path where cracked files will be extracted to", font=MAIN_FONT)
            label_extract_title.place(rely=0.22, relx=0.02)
            self.label_extract_dest = tk.Label(parent, relief="ridge", anchor="w")
            self.label_extract_dest.place(rely=0.25, relx=0.02, height=23, width=375)
            btn_extract_dest = ttk.Button(parent, text="Browse...", command=self._set_extract_path)
            btn_extract_dest.place(rely=0.25, relx=0.40)

            frame_targets = tk.LabelFrame(parent, frame_styles, text="Targets")
            frame_targets.place(rely=0.32, relx=0.02, height=300, width=470)
            btn_add_file = ttk.Button(parent, text="Add a File...", command=self._add_target_file_tv)
            btn_add_file.place(rely=0.84, relx=0.02)
            btn_add_folder = ttk.Button(parent, text="Add a Folder...", command=self._add_target_folder_tv)
            btn_add_folder.place(rely=0.84, relx=0.10)
            self.include_subfolders = tk.BooleanVar(parent)
            ckbtn_subfolders = tk.Checkbutton(parent, variable=self.include_subfolders)
            ckbtn_subfolders.place(rely=0.84, relx=0.20)
            label_subfolders = tk.Label(parent, text="Include Subfolders?", font=MAIN_FONT)

            label_subfolders.place(rely=0.84, relx=0.23)

            hash_types = ("Plain", "MD5")
            self.hash = tk.StringVar(parent)
            opt_menu_hash = ttk.OptionMenu(parent, self.hash, hash_types[0],
                                           *hash_types)
            opt_menu_hash.place(rely=0.90, relx=0.27)

            btn_launch_attack = ttk.Button(parent, text="Launch Dictionary Attack", command=self._launch_dictionary_attack)
            btn_launch_attack.place(rely=0.90, relx=0.12)

            frame_current_target = tk.LabelFrame(parent, frame_styles, text="Current Target")
            frame_current_target.place(rely=0.05, relx=0.50, height=50, width=500)
            self.label_current_target = tk.Label(frame_current_target, text="---------")
            self.label_current_target.pack(side="left")

            # TEXT BOX WIDGET
            frame_output = tk.LabelFrame(parent, frame_styles, text="Attack Output")
            frame_output.place(rely=0.15, relx=0.50, height=475, width=500)

            self.text_output = tk.Text(frame_output,wrap=tk.NONE)
            self.text_output.place(relheight=1, relwidth=1)
            text_scrolly = tk.Scrollbar(frame_output, orient="vertical", command=self.text_output.yview)
            text_scrollx = tk.Scrollbar(frame_output, orient="horizontal", command=self.text_output.xview)
            self.text_output.configure(yscrollcommand=text_scrolly.set, xscrollcommand=text_scrollx.set)
            text_scrolly.pack(side="right", fill="y")
            text_scrollx.pack(side="bottom", fill="x")

            # TREEVIEW WIDGET
            self.tv_target = ttk.Treeview(frame_targets)
            self.tv_target.place(relheight=1, relwidth=1)
            tv_scrolly = tk.Scrollbar(frame_targets, orient="vertical", command=self.tv_target.yview)
            tv_scrollx = tk.Scrollbar(frame_targets, orient="horizontal", command=self.tv_target.xview)
            self.tv_target.configure(yscrollcommand=tv_scrolly.set, xscrollcommand=tv_scrollx.set)
            tv_scrolly.pack(side="right", fill="y")
            tv_scrollx.pack(side="bottom", fill="x")
            self.tv_target["columns"] = ["Type", "Include SubFolders", "Target Path"]
            self.tv_target["show"] = "headings"  # removes empty column
            for col in self.tv_target["columns"]:
                self.tv_target.heading(col, text=col)
                col_width = 110
                if col == "Target Path":
                    col_width = 300
                self.tv_target.column(col, width=col_width)
            # when you double click the treeview item it will delete the row
            self.tv_target.bind("<Double-1>", self._delete_tv_row)

        def _windows_dialog(self, is_folder=False, only_text=False):
            selection = None
            if is_folder:
                selection = filedialog.askdirectory()
            else:
                type1 = ("All Files", "*.*") if not only_text else ("Text Files", "*.txt")
                selection = filedialog.askopenfilename(initialdir="/",
                                                       title="Select a File",
                                                       filetype=[type1])
            return selection

        def _set_dictionary_list(self):
            selection = self._windows_dialog(only_text=True)
            self.label_dict_file["text"] = selection

        def _set_extract_path(self):
            selection = self._windows_dialog(is_folder=True)
            self.label_extract_dest["text"] = selection

        def _add_target_file_tv(self):
            path = self._windows_dialog()
            if not path:
                return None
            row = ["File", "False", path]
            self.tv_target.insert("", "end", values=row)

        def _add_target_folder_tv(self):
            path = self._windows_dialog(is_folder=True)
            if not path:
                return None
            seek_subfolders = self.include_subfolders.get()
            row = ["Folder", str(seek_subfolders), path]
            self.tv_target.insert("", "end", values=row)

        def _delete_tv_row(self, event):
            row = self.tv_target.selection()
            if row:
                self.tv_target.delete(row[0])

        def insert_text_message(self, message, update_idle=False):
            self.text_output.insert("end", f"{message}\n")
            self.text_output.see("end")
            if update_idle:
                self.text_output.update_idletasks()  # prevents gui freezing

        def display_messagebox(self, message, type="showinfo"):
            if type == "showerror":
                messagebox.showerror(title="Error", message=message)
            else:
                messagebox.showinfo(title="Information", message=message)

        def clear_text_output(self):
            self.text_output.delete('1.0', "end")

        def set_current_target(self, current_target):
            self.label_current_target["text"] = current_target

        def _launch_dictionary_attack(self):
            password_hash_type = "Plain Text"  # self.hash.get()
            password_file = self.label_dict_file["text"]
            save_dest = self.label_extract_dest["text"]

            if not password_file or not save_dest:
                msg = "You need to provide a password file and save destination"
                self.display_messagebox(msg, type="showinfo")
                return None

            all_targets = []
            for row_id in self.tv_target.get_children():
                target_info = self.tv_target.item(row_id, "values")
                all_targets.append(target_info)
            # raise message box if there are no targets
            if not all_targets:
                self.display_messagebox("There are no targets", type="showinfo")
            else:
                self.controller.launch_attack(password_file=password_file,
                                              save_destination=save_dest,
                                              hash_type=password_hash_type,
                                              targets=all_targets)


    class BaseWindow(tk.Toplevel):
        def __init__(self):
            super().__init__()
            self.base_frame = tk.Frame(self)
            self.base_frame.pack_propagate(0)
            self.base_frame.pack(fill="both", expand="true")
            self.fonts = ("Trebuchet MS", 9)
            self.geometry("600x200")
            self.resizable(0, 0)


    class HelpPage(BaseWindow):
        def __init__(self):
            super().__init__()

            self.title("How to Use WordSmith")
            bio = (
                "Step 1: Select a file containing a list of passwords.\n"
                "Step 2: Select a Folder where you would like to extracted files "
                "to be saved.\n"
                "Step 3: Add File and/or Folders to the Targets list.\n"
                "Step 4: Choose whether you want to launch a plain text attack or "
                "MD5 attack.\n"
                "Step 5: Launch Attack \n\n"
                "Note: Once finished passwords and file paths will be saved to "
                "the destination you originally chose.\n"
                "Remember to have rights and don't use this for malicious purposes.\n"
                "Created by Tudor Marmureanu.   "
            )
            frame_about = tk.LabelFrame(self.base_frame, text="About WordSmith")
            frame_about.pack(expand=True, fill="both")
            label_about = tk.Label(frame_about, text=bio, font=self.fonts)
            label_about.pack(expand=True)


    class DisclaimerPage(BaseWindow):
        def __init__(self):
            super().__init__()
            self.title("Disclaimer")
            summary = (
                "DO NOT USE THIS FOR MALICIOUS PURPOSES\n"
                "i.e. Stealing the password belonging to a person "
                "or business/corporation is illegal\n"
                "This is a toy project for work purposes \n"
                "(example: A person has forgotten their password and needs those documents. )"
            )
            frame_disc = tk.LabelFrame(self.base_frame, text="WordSmith Disclaimer")
            frame_disc.pack(expand=True, fill="both")
            label_disc = tk.Label(frame_disc, text=summary, font=self.fonts)
            label_disc.pack(expand=True)


    APP_HEIGHT = 600
    APP_WIDTH = 1024


    class Application(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("WordSmith")
            main_frame = tk.Frame(self, height=APP_HEIGHT, width=APP_WIDTH)
            main_frame.pack_propagate(0)
            main_frame.pack(fill="both", expand="true")
            self.resizable(0, 0)
            self.geometry(f"{APP_WIDTH}x{APP_HEIGHT}")

            # Add menu to the application
            menubar = NavBar(self)
            tk.Tk.config(self, menu=menubar)

            # add the frames to the application
            page = MainPage(parent=main_frame)
            page.place(rely=0, relx=0)
            page.tkraise()
            self.protocol("WM_DELETE_WINDOW", self.quit_application)

        def OpenHelpPage(self):
            help = HelpPage()
            help.focus_set()
            help.grab_set()

        def OpenDisclaimerPage(self):
            disclaimer = DisclaimerPage()
            disclaimer.focus_set()
            disclaimer.grab_set()

        def quit_application(self):
            if messagebox.askyesno("Exit", "Do you want to quit the application?"):
                self.destroy()
    # parent is the parent frame that the object is tied to i.e. Frame(root)
    # MainPage(main_frame) means MainPage is tied to the main_frame in application)


    rootzp = Application()
    rootzp.mainloop()

if bkvar == 700:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    import shutil
    import os
    from datetime import datetime
    import tkinter as tk
    from tkinter import filedialog, messagebox

    def backup_files(source_dir, backup_dir):
        try:
            date_str = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_path = os.path.join(backup_dir, f'backup_{date_str}')
            shutil.copytree(source_dir, backup_path)
            messagebox.showinfo("Backup Completed", f'Backup completed: {backup_path}')
        except Exception as e:
            messagebox.showerror("Error", f'An error occurred: {e}')

    def select_source_directory():
        source_dir = filedialog.askdirectory()
        source_entry.delete(0, tk.END)
        source_entry.insert(0, source_dir)

    def select_backup_directory():
        backup_dir = filedialog.askdirectory()
        backup_entry.delete(0, tk.END)
        backup_entry.insert(0, backup_dir)

    def start_backup():
        source_dir = source_entry.get()
        backup_dir = backup_entry.get()
        if not source_dir or not backup_dir:
            messagebox.showwarning("Input Error", "Please select both source and backup directories.")
            return
        backup_files(source_dir, backup_dir)

    # Set up the main application window
    rootbkr = tk.Tk()
    rootbkr.title("Backup Utility")
    rootbkr.geometry("600x150")
    rootbkr.config(bg="gray20")
    rootbkr.resizable(False, False)

    # Configure the style of the labels and entries
    label_style = {'bg': 'gray20', 'fg': '#ccff66'}
    entry_style = {'bg': 'black', 'fg': '#ccff66', 'insertbackground': 'cyan'}

    # Source directory selection
    tk.Label(rootbkr, text="Source Directory:", **label_style).grid(row=0, column=0, padx=10, pady=5)
    source_entry = tk.Entry(rootbkr, width=50, **entry_style)
    source_entry.grid(row=0, column=1, padx=10, pady=5)
    tk.Button(rootbkr, text="Browse...", command=select_source_directory, bg="gray40", fg="#ccff66").grid(row=0, column=2, padx=10, pady=5)

    # Backup directory selection
    tk.Label(rootbkr, text="Backup Directory:", **label_style).grid(row=1, column=0, padx=10, pady=5)
    backup_entry = tk.Entry(rootbkr, width=50, **entry_style)
    backup_entry.grid(row=1, column=1, padx=10, pady=5)
    tk.Button(rootbkr, text="Browse...", command=select_backup_directory, bg="gray40", fg="#ccff66").grid(row=1, column=2, padx=10, pady=5)

    # Backup button
    tk.Button(rootbkr, text="Start Backup", command=start_backup, bg="gray40", fg="#ccff66").grid(row=2, column=0, columnspan=3, pady=20)

    # Run the application
    rootbkr.mainloop()

if rnvar == 710:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    import os
    import tkinter as tk
    from tkinter import filedialog, simpledialog, messagebox

    def rename_files(directory, selected_files, prefix, suffix):
        try:
            for file in selected_files:
                file_path = os.path.join(directory, file)
                if os.path.isfile(file_path):
                    base, ext = os.path.splitext(file)
                    new_name = base
                    if prefix:
                        new_name = f"{prefix}_{new_name}"
                    if suffix:
                        new_name = f"{new_name}_{suffix}"
                    new_name = f"{new_name}{ext}"
                    new_path = os.path.join(directory, new_name)
                    os.rename(file_path, new_path)
            messagebox.showinfo("Success", "Files have been renamed successfully.")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def select_directory():
        directory = filedialog.askdirectory()
        if directory:
            directory_entry.delete(0, tk.END)
            directory_entry.insert(0, directory)
            update_file_list(directory)

    def update_file_list(directory):
        files = os.listdir(directory)
        file_listbox.delete(0, tk.END)
        for file in files:
            file_listbox.insert(tk.END, file)

    def start_renaming():
        directory = directory_entry.get()
        if not directory:
            messagebox.showwarning("Input Error", "Please select a directory.")
            return
        
        selected_files = [file_listbox.get(i) for i in file_listbox.curselection()]
        if not selected_files:
            messagebox.showwarning("Input Error", "Please select at least one file.")
            return

        prefix = prefix_entry.get()
        suffix = suffix_entry.get()

        rename_files(directory, selected_files, prefix, suffix)
        update_file_list(directory)  # Refresh the file list after renaming

    # Set up the main application window
    rootrn = tk.Tk()
    rootrn.title("Batch File Renamer")
    rootrn.configure(bg='gray20')
    rootrn.resizable(False, False)

    # Directory selection
    tk.Label(rootrn, text="Directory:", bg='gray20', fg='#ccff66').grid(row=0, column=0, padx=10, pady=5)
    directory_entry = tk.Entry(rootrn, width=50, bg='black', fg='#ccff66', insertbackground='cyan')
    directory_entry.grid(row=0, column=1, padx=10, pady=5)
    tk.Button(rootrn, text="Browse...", command=select_directory, bg='gray40', fg='#ccff66').grid(row=0, column=2, padx=10, pady=5)

    # File list
    tk.Label(rootrn, text="Files:", bg='gray20', fg='#ccff66', font=('bold')).grid(row=1, column=0, padx=10, pady=5)
    file_listbox = tk.Listbox(rootrn, selectmode=tk.MULTIPLE, width=50, height=15, bg='black', fg='#ccff66', bd=25)
    file_listbox.grid(row=1, column=1, padx=10, pady=5, columnspan=2)

    # Prefix option
    tk.Label(rootrn, text="Prefix:", bg='gray20', fg='#ccff66').grid(row=2, column=0, padx=10, pady=5)
    prefix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
    prefix_entry.grid(row=2, column=1, padx=10, pady=5)

    # Suffix option
    tk.Label(rootrn, text="Suffix:", bg='gray20', fg='#ccff66').grid(row=3, column=0, padx=10, pady=5)
    suffix_entry = tk.Entry(rootrn, width=30, bg='gray30', fg='#ccff66', insertbackground="cyan")
    suffix_entry.grid(row=3, column=1, padx=10, pady=5)

    # Rename button
    tk.Button(rootrn, text="Rename Files", command=start_renaming, bg='gray40', fg='#ccff66').grid(row=4, column=0, columnspan=3, pady=20)

    # Run the application
    rootrn.mainloop()

if kbvar == 1000:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    import tkinter as tk
    from tkinter import messagebox
    from tkinter import filedialog
    from tkinter import ttk
    import json
    import os
    
    class KnowledgeBaseApp:
        def __init__(self, master):
            self.master = master
            self.master.title("Knowledge Base")
            self.master.geometry("920x520")
            self.master.configure(bg="gray20")
            self.master.resizable(False, False)
    
            self.title_label = tk.Label(master, text="Title:", bg="gray20", font=("Arial", 12, "bold"), fg="#ccff66")
            self.title_label.grid(row=0, column=0, sticky=tk.W, padx=10, pady=10)
    
            self.title_entry = tk.Entry(master, font=("Arial", 12), width=40)
            self.title_entry.grid(row=0, column=1, padx=10, pady=10, sticky=tk.W)
    
            self.category_label = tk.Label(master, text="Category:", bg="gray20", font=("Arial", 12, "bold"), fg="#ccff66")
            self.category_label.grid(row=0, column=2, padx=10, pady=10)
    
            self.category_combo = ttk.Combobox(master, values=["Networking", "Hardware", "Linux", "Programming", "Printers", "Apps", "Others"], font=("Arial", 12))
            self.category_combo.grid(row=0, column=3, pady=10, sticky=tk.W)
    
            self.text_label = tk.Label(master, text="Text:", bg="gray20", font=("Arial", 12, "bold"), fg="#ccff66")
            self.text_label.grid(row=1, column=0, sticky=tk.W, padx=10, pady=10)
    
            self.text_entry = tk.Text(master, height=20, width=80, font=("Arial", 12), bd=14, bg="black", fg="cyan", insertbackground="#ccff66", highlightbackground="gray40", highlightcolor="gray40", highlightthickness=7)
            self.text_entry.grid(row=1, column=1, columnspan=4, padx=10, pady=10, sticky=tk.W + tk.E)
    
            self.scrollbar = tk.Scrollbar(master, command=self.text_entry.yview)
            self.scrollbar.grid(row=1, column=5, sticky='nsew')
            self.text_entry.config(yscrollcommand=self.scrollbar.set)
    
            self.save_button = tk.Button(master, text="Save", command=self.save_knowledge, bg="#ff9900", fg="white", font=("Arial", 12))
            self.save_button.grid(row=2, column=0, pady=10, padx=10, sticky=tk.W)
    
            self.open_button = tk.Button(master, text="Open", command=self.open_file, bg="#ff9933", fg="white", font=("Arial", 12))
            self.open_button.grid(row=2, column=1, pady=10, padx=10, sticky=tk.W)
    
            self.folder_combo = ttk.Combobox(master, font=("Arial", 12))
            self.folder_combo.grid(row=2, column=2, padx=10, pady=10, sticky=tk.W)
            self.update_folder_combo()
    
            self.delete_button = tk.Button(master, text="Delete", command=self.delete_file, bg="red", fg="white", font=("Arial", 12))
            self.delete_button.grid(row=2, column=3, pady=10, padx=10, sticky=tk.W)
    
        def save_knowledge(self):
            title = self.title_entry.get()
            text = self.text_entry.get("1.0", tk.END)
            category = self.category_combo.get()
    
            if title.strip() == "" or text.strip() == "":
                messagebox.showerror("Error", "Please enter a title and text to save.")
                return
    
            if category == "":
                messagebox.showerror("Error", "Please select a category.")
                return
    
            knowledge_data = {"title": title, "text": text, "category": category}
    
            # Create the directory based on the selected category if it doesn't exist
            directory = f"KB/{category}"
            if not os.path.exists(directory):
                os.makedirs(directory)
    
            file_name = f"{title}.json"
            file_path = os.path.join(directory, file_name)
    
            if os.path.exists(file_path):
                overwrite = messagebox.askyesno("File Exists", f"A file with the name '{title}.json' already exists in the '{category}' category. Do you want to overwrite its content?")
                if not overwrite:
                    file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON Files", "*.json")], initialdir=directory, initialfile=file_name)
                    if not file_path:
                        return
    
            with open(file_path, "w") as json_file:
                json.dump(knowledge_data, json_file)
    
            self.update_folder_combo()
            messagebox.showinfo("Success", f"Information has been saved to {file_path}.")
    
            # Clear the input fields after saving
            self.title_entry.delete(0, tk.END)
            self.text_entry.delete("1.0", tk.END)
            self.category_combo.set("")
    
        def update_folder_combo(self):
            if not os.path.exists("KB"):
                os.makedirs("KB")
            folders = [f for f in os.listdir("KB") if os.path.isdir(os.path.join("KB", f))]
            self.folder_combo['values'] = folders
    
        def open_file(self):
            file_path = filedialog.askopenfilename(filetypes=[("JSON Files", "*.json")])
    
            if file_path:
                with open(file_path, "r") as json_file:
                    data = json.load(json_file)
                    self.title_entry.delete(0, tk.END)
                    self.title_entry.insert(0, data["title"])
                    self.text_entry.delete("1.0", tk.END)
                    self.text_entry.insert(tk.END, data["text"])
                    if "category" in data:
                        self.category_combo.set(data["category"])
                messagebox.showinfo("Success", f"File {file_path} has been opened.")
    
        def delete_file(self):
            category = self.folder_combo.get()
            if category == "":
                messagebox.showerror("Error", "Please select a category to delete.")
                return
    
            directory = f"KB/{category}"
            file_path = filedialog.askopenfilename(initialdir=directory, filetypes=[("JSON Files", "*.json")])
    
            if file_path:
                os.remove(file_path)
                self.update_folder_combo()
                messagebox.showinfo("Success", f"File {file_path} has been deleted.")
    
    def main():
        root = tk.Tk()
        app = KnowledgeBaseApp(root)
        root.mainloop()
    
    if __name__ == "__main__":
        main()

if passmngrr == 2000:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
        
    import hashlib
    from tkinter.constants import BOTH, CENTER, END, LEFT, RIGHT, VERTICAL, Y
    from tkinter import Button, Canvas, Entry, Frame, Label, Scrollbar, Tk, Checkbutton, BooleanVar
    from functools import partial
    from tkinter import simpledialog
    import string
    from secrets import choice
    import sqlite3
    from tkinter import LabelFrame
    
    
    UPPERCASE = list(string.ascii_uppercase)
    LOWERCASE = list(string.ascii_lowercase)
    NUMBER = list(string.digits)
    SYMBOLS = ['@', '#', '$', '%', '&', '_']
    
    class PasswordGenerator:
    
        def __init__(self):
            self.window = Tk()
            self.window.title("Password Generator")
            self.window.geometry("450x350")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
            # Label Frame for password length
            self.length_frame = LabelFrame(
                self.window, text="Enter the number of characters", bg="gray20", fg="#ccff66")
            self.length_frame.pack(pady=20)
    
            # Label and entry for password length
            self.length_label = Label(
                self.length_frame, text="Password Length:", bg="gray20", fg="#ccff66")
            self.length_label.grid(row=0, column=0, padx=10, pady=5, sticky="w")
            self.length_entry_box = Entry(self.length_frame, width=20, bg="black", fg="lime green", insertbackground="cyan")
            self.length_entry_box.grid(row=1, column=0, padx=10, pady=5)
    
            # Label for custom characters
            self.custom_chars_label = Label(
                self.window, text="Custom Characters:", bg="gray20", fg="#ccff66")
            self.custom_chars_label.pack(anchor='w', padx=20)
    
            # Entry for custom characters
            self.custom_chars_entry = Entry(self.window, width=50, bg="black", fg="lime green", insertbackground="cyan")
            self.custom_chars_entry.pack(pady=5)
    
            # Label for generated password
            self.password_label = Label(
                self.window, text="Generated Password:", bg="gray20", fg="#ccff66")
            self.password_label.pack(anchor='w', padx=20)
    
            # Entry for generated password
            self.password_entry_box = Entry(
                self.window, text="", width=50, bg="black", fg="lime green", insertbackground="cyan")
            self.password_entry_box.pack(pady=5)
    
            # Feedback label
            self.feedback = Label(self.window, bg="gray20")
    
            # Frame for buttons
            self.button_frame = Frame(self.window, bg="gray20")
            self.button_frame.pack(pady=20)
    
            # Generate Password Button
            generate_btn = Button(
                self.button_frame, text="Generate Password", command=self.generate_random_password, bg="gray40", fg="cyan", bd=5)
            generate_btn.grid(row=0, column=0, padx=10)
    
            # Copy Password Button
            copy_btn = Button(self.button_frame,
                            text="Copy Password", command=self.copy_password, bg="gray40", fg="cyan", bd=5)
            copy_btn.grid(row=0, column=1, padx=10)
    
        def generate_random_password(self):
            self.password_entry_box.delete(0, END)
            try:
                password_length = int(self.length_entry_box.get())
                if password_length <= 0:
                    raise ValueError("Password length must be a positive integer")
    
                self.feedback.destroy()  # Destroy feedback if length is there
    
                # Get custom characters from entry box
                custom_chars = self.custom_chars_entry.get()
    
                data = custom_chars if custom_chars else string.ascii_letters + string.digits + string.punctuation
                password = ''.join(choice(data) for _ in range(password_length))
                self.password_entry_box.insert(0, password)
            except ValueError as e:
                self.feedback.destroy()  # Destroy previous feedback if any
                self.feedback = Label(self.window, fg="red", text=str(e))
                self.feedback.place(x=130, y=100)
    
        def copy_password(self):
            self.window.clipboard_clear()
            self.window.clipboard_append(self.password_entry_box.get())
    
    def init_database():
        with sqlite3.connect("password_vault.db") as db:
            cursor = db.cursor()
        cursor.execute("""
                CREATE TABLE IF NOT EXISTS master(
                id INTEGER PRIMARY KEY,
                password TEXT NOT NULL);
                """)
    
        cursor.execute("""
                CREATE TABLE IF NOT EXISTS vault(
                id INTEGER PRIMARY KEY,
                platform TEXT NOT NULL,
                userid TEXT NOT NULL,
                password TEXT NOT NULL);
                """)
        return db, cursor
    
    class VaultMethods:
    
        def __init__(self):
            self.db, self.cursor = init_database()
    
        def popup_entry(self, heading):
            answer = simpledialog.askstring("Enter details", heading)
            return answer
    
        def add_password(self, vault_screen):
            platform = self.popup_entry("Platform")
            userid = self.popup_entry("Username/Email")
            password = self.popup_entry("Password")
    
            insert_cmd = """INSERT INTO vault(platform, userid, password) VALUES (?, ?, ?)"""
            self.cursor.execute(insert_cmd, (platform, userid, password))
            self.db.commit()
            vault_screen()
    
        def update_password(self, id, vault_screen):
            password = self.popup_entry("Enter New Password")
            self.cursor.execute("UPDATE vault SET password = ? WHERE id = ?", (password, id))
            self.db.commit()
            vault_screen()
    
        def remove_password(self, id, vault_screen):
            self.cursor.execute("DELETE FROM vault WHERE id = ?", (id,))
            self.db.commit()
            vault_screen()
    
    class PasswordManager:
    
        def __init__(self):
            self.db, self.cursor = init_database()
            self.window = Tk()
            self.window.update()
            self.window.title("Password Manager")
            self.window.geometry("650x350")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
        def welcome_new_user(self):
            self.window.geometry("450x200")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
            label1 = Label(self.window, text="Create New Master Password", bg="gray20", fg="#ccff66")
            label1.config(anchor=CENTER)
            label1.pack(pady=10)
    
            mp_entry_box = Entry(self.window, width=20, show="*", bg="black", fg="lime green", insertbackground="cyan")
            mp_entry_box.pack()
            mp_entry_box.focus()
    
            label2 = Label(self.window, text="Enter the password again", bg="gray20", fg="#ccff66")
            label2.config(anchor=CENTER)
            label2.pack(pady=10)
    
            rmp_entry_box = Entry(self.window, width=20, show="*", bg="black", fg="lime green", insertbackground="cyan")
            rmp_entry_box.pack()
    
            self.feedback = Label(self.window, bg="gray20")
            self.feedback.pack()
    
            save_btn = Button(self.window, text="Create Password", command=partial(self.save_master_password, mp_entry_box, rmp_entry_box), bg="gray40", fg="cyan", bd=5)
            save_btn.pack(pady=5)
    
        def login_user(self):
            for widget in self.window.winfo_children():
                widget.destroy()
    
            self.window.geometry("450x200")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
    
            label1 = Label(self.window, text="Enter your master password", bg="gray20", fg="#ccff66")
            label1.config(anchor=CENTER)
            label1.place(x=150, y=50)
    
            self.password_entry_box = Entry(self.window, width=20, show="*", bg="black", fg="lime green", insertbackground="cyan")
            self.password_entry_box.place(x=160, y=80)
            self.password_entry_box.focus()
    
            self.feedback = Label(self.window, bg="gray20")
            self.feedback.place(x=170, y=105)
    
            login_btn = Button(self.window, text="Log In", command=partial(self.check_master_password, self.password_entry_box), bg="gray40", fg="cyan", bd=5)
            login_btn.place(x=200, y=130)
    
        def save_master_password(self, eb1, eb2):
            password1 = eb1.get()
            password2 = eb2.get()
            if password1 == password2:
                hashed_password = self.encrypt_password(password1)
                insert_command = """INSERT INTO master(password) VALUES(?) """
                self.cursor.execute(insert_command, [hashed_password])
                self.db.commit()
                self.login_user()
            else:
                self.feedback.config(text="Passwords do not match", fg="red")
    
        def check_master_password(self, eb):
            hashed_password = self.encrypt_password(eb.get())
            self.cursor.execute("SELECT * FROM master WHERE id = 1 AND password = ?", [hashed_password])
            if self.cursor.fetchall():
                self.password_vault_screen()
            else:
                self.password_entry_box.delete(0, END)
                self.feedback.config(text="Incorrect password", fg="red")
    
        def password_vault_screen(self):
            for widget in self.window.winfo_children():
                widget.destroy()
    
            vault_methods = VaultMethods()
    
            self.window.geometry("850x350")
            self.window.resizable(False, False)
            self.window.config(bg="gray20")
            main_frame = Frame(self.window, bg="gray20")
            main_frame.pack(fill=BOTH, expand=1)
    
            main_canvas = Canvas(main_frame, bg="gray20")
            main_canvas.pack(side=LEFT, fill=BOTH, expand=1)
    
            main_scrollbar = Scrollbar(main_frame, orient=VERTICAL, command=main_canvas.yview)
            main_scrollbar.pack(side=RIGHT, fill=Y)
    
            main_canvas.configure(yscrollcommand=main_scrollbar.set)
            main_canvas.bind('<Configure>', lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all")))
    
            second_frame = Frame(main_canvas, bg="gray20")
            main_canvas.create_window((0, 0), window=second_frame, anchor="nw")
    
            generate_password_btn = Button(second_frame, text="Generate Password", command=PasswordGenerator, bg="gray40", fg="cyan", bd=5)
            generate_password_btn.grid(row=1, column=2, pady=10)
    
            add_password_btn = Button(second_frame, text="Add New Password", command=partial(vault_methods.add_password, self.password_vault_screen), bg="gray40", fg="cyan", bd=5)
            add_password_btn.grid(row=1, column=3, pady=10)
    
            lbl = Label(second_frame, text="Platform", bg="gray20", fg="#ccff66")
            lbl.grid(row=2, column=0, padx=40, pady=10)
            lbl = Label(second_frame, text="Email/Username", bg="gray20", fg="#ccff66")
            lbl.grid(row=2, column=1, padx=40, pady=10)
            lbl = Label(second_frame, text="Password", bg="gray20", fg="#ccff66")
            lbl.grid(row=2, column=2, padx=40, pady=10)
    
            self.cursor.execute("SELECT * FROM vault")
    
            if self.cursor.fetchall():
                i = 0
                while True:
                    self.cursor.execute("SELECT * FROM vault")
                    array = self.cursor.fetchall()
    
                    platform_label = Label(second_frame, text=(array[i][1]), bg="gray20", fg="#ccff66")
                    platform_label.grid(column=0, row=i + 3)
    
                    account_label = Label(second_frame, text=(array[i][2]), bg="gray20", fg="#ccff66")
                    account_label.grid(column=1, row=i + 3)
    
                    password_label = Label(second_frame, text=(array[i][3]), bg="gray20", fg="#ccff66")
                    password_label.grid(column=2, row=i + 3)
    
                    copy_btn = Button(second_frame, text="Copy Password", command=partial(self.copy_text, array[i][3]), bg="gray40", fg="cyan", bd=5)
                    copy_btn.grid(column=3, row=i + 3, pady=10, padx=10)
                    update_btn = Button(second_frame, text="Update Password", command=partial(vault_methods.update_password, array[i][0], self.password_vault_screen), bg="gray40", fg="cyan", bd=5)
                    update_btn.grid(column=4, row=i + 3, pady=10, padx=10)
                    remove_btn = Button(second_frame, text="Delete Password", command=partial(vault_methods.remove_password, array[i][0], self.password_vault_screen), bg="gray40", fg="cyan", bd=5)
                    remove_btn.grid(column=5, row=i + 3, pady=10, padx=10)
    
                    i += 1
    
                    self.cursor.execute("SELECT * FROM vault")
                    if len(self.cursor.fetchall()) <= i:
                        break
    
        def encrypt_password(self, password):
            password = password.encode("utf-8")
            encoded_text = hashlib.md5(password).hexdigest()
            return encoded_text
    
        def copy_text(self, text):
            self.window.clipboard_clear()
            self.window.clipboard_append(text)
    
    if __name__ == '__main__':
        db, cursor = init_database()
        cursor.execute("SELECT * FROM master")
        manager = PasswordManager()
        if cursor.fetchall():
            manager.login_user()
        else:
            manager.welcome_new_user()
        manager.window.mainloop()

if pausevar == 10000:
    def pausemain1():
        import tkinter as tk
        from tkinter import ttk, simpledialog, messagebox
        import json
        import os
        from datetime import datetime, timedelta

        messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
        validation.destroy()

        # Define the file name
        file_name = "ChooseLocationForPause.txt"
        
        # Check if the file already exists
        if not os.path.exists(file_name):
            # Open the file in write mode and immediately close it
            with open(file_name, 'w'):
                pass
            print(f"File {file_name} has been created. Restart aplication is required...")
            input()
        else:
            print(f"Opening file {file_name}... Done!")
        
        class HelpPopup:
            def __init__(self, parent):
                self.parent = parent
                self.popup = tk.Toplevel(parent)
                self.popup.title("Help")
                #self.popup.geometry("500x500")
                self.popup.resizable(False, False)
        
                help_text = """
                Welcome to the Break Info App!
        
                This application allows you to manage break information for employees or persons.
        
                How to use:
                1. Select a person from the drop-down menu.
                2. Choose a break time from the drop-down menu.
                3. Click on 'Set Break Time' to update the break time for the selected person.
                4. Optionally, click on 'Back to Work' to set the return time after the break.
                5. Use 'Refresh' to see updated information.
                6. Use 'Reset Data' to clear all break and return times for all persons.
                7. Use 'JSON Generator' to generate JSON data for persons and their break times.
                8. Click on 'Save to JSON' in the JSON Generator window to save the generated data to a JSON file.
        
                Configuration File for Path Selection:
                --------------------------------------
                This application uses a configuration file ('ChooseLocationForPause.txt') to store the path for saving JSON files. If the file doesn't exist or is not correctly configured, an error message will be displayed.
        
                To Use:
                --------
                1. Ensure the 'ChooseLocationForPause.txt' file exists in the same directory as this application.
                2. Open the file in a text editor.
                3. Enter the desired path where you want to save JSON files on a new line in the text file.
                4. Save and close the text file.
        
                Note: If the path is invalid or the file is not properly formatted, an error will prompt upon application startup.
        
                For more information or issues, please contact Tudor Marmureanu.
                """
        
                label = ttk.Label(self.popup, text=help_text, wraplength=400, justify="left")
                label.pack(padx=20, pady=20)
        
                ok_button = ttk.Button(self.popup, text="OK", command=self.popup.destroy)
                ok_button.pack(pady=10)
        
        class JSONGeneratorApp:
            def __init__(self, root, parent_app):
                self.root = root
                self.root.title("JSON Generator")
                self.parent_app = parent_app
        
                # Entry for number of persons
                self.num_label = ttk.Label(self.root, text="Number of Persons:")
                self.num_label.pack(padx=20, pady=5)
                self.num_entry = ttk.Entry(self.root)
                self.num_entry.pack(padx=20, pady=5)
        
                # Button to generate entry fields for names
                self.generate_button = ttk.Button(self.root, text="Generate Fields", command=self.generate_fields)
                self.generate_button.pack(padx=20, pady=10)
        
                # Frame to hold the dynamically generated entry fields
                self.names_frame = ttk.Frame(self.root)
                self.names_frame.pack(padx=20, pady=10)
        
                # Save button to save the data to JSON file
                self.save_button = ttk.Button(self.root, text="Save to JSON", command=self.save_to_json)
                self.save_button.pack(padx=20, pady=10)
        
                self.name_entries = []
        
            def generate_fields(self):
                # Clear any existing entry fields
                for widget in self.names_frame.winfo_children():
                    widget.destroy()
        
                self.name_entries = []
                try:
                    num_persons = int(self.num_entry.get())
                    for i in range(num_persons):
                        label = ttk.Label(self.names_frame, text=f"Person {i + 1} Name:")
                        label.pack(padx=5, pady=2)
                        entry = ttk.Entry(self.names_frame)
                        entry.pack(padx=5, pady=2)
                        self.name_entries.append(entry)
                except ValueError:
                    messagebox.showerror("Invalid input", "Please enter a valid number.")
        
            def save_to_json(self):
                persons = [entry.get() for entry in self.name_entries if entry.get().strip()]
                if persons:
                    data = {person: {"break_time": "--", "return_time": ""} for person in persons}
                    with open(self.parent_app.file_path, 'w') as file:
                        json.dump(data, file, indent=4)
                    self.parent_app.persons = persons
                    self.parent_app.update_combobox_values()
                    self.root.destroy()
                else:
                    messagebox.showerror("Input Error", "Please enter valid names for all persons.")
        
        class BreakInfoApp:
            def __init__(self, root):
                self.root = root
                self.root.title("Break Info")
        
                self.file_path = self.get_file_path()
                self.persons = self.load_persons_from_json()
        
                # Create combobox for selecting person
                self.person_label = ttk.Label(self.root, text="Select Person:")
                self.person_label.pack(padx=20, pady=5)
                self.person_combobox = ttk.Combobox(self.root, values=self.persons)
                self.person_combobox.pack(padx=20, pady=5)
        
                # Create combobox for selecting break time
                self.break_time_label = ttk.Label(self.root, text="Select Break Time:")
                self.break_time_label.pack(padx=20, pady=5)
                self.break_time_combobox = ttk.Combobox(self.root, values=self.generate_break_times())
                self.break_time_combobox.pack(padx=20, pady=5)
        
                # Create button to update JSON file
                self.update_button = ttk.Button(self.root, text="Set Break Time", command=self.update_json_file)
                self.update_button.pack(padx=20, pady=10)
        
                # Create button to refresh data
                self.refresh_button = ttk.Button(self.root, text="Refresh", command=self.update_data)
                self.refresh_button.pack(padx=20, pady=10)
        
                # Create button to open return menu
                self.return_button = ttk.Button(self.root, text="Back to Work", command=self.open_return_menu)
                self.return_button.pack(padx=20, pady=10)
        
                # Create button to reset all data
                self.reset_button = ttk.Button(self.root, text="Reset Data", command=self.reset_data)
                self.reset_button.pack(padx=20, pady=10)
        
                # Create button to open JSON generator window
                self.create_users_button = ttk.Button(self.root, text="JSON Generator", command=self.open_json_generator)
                self.create_users_button.pack(padx=20, pady=10)
        
                # Create button to open help popup
                self.help_button = ttk.Button(self.root, text="Help", command=self.open_help_popup)
                self.help_button.pack(padx=20, pady=10)
        
                # Create label to display break info
                self.label = ttk.Label(self.root, text="No data", font=("Helvetica", 16))
                self.label.pack(padx=20, pady=20)
        
                self.ensure_json_file()
                self.update_data()
        
            def open_help_popup(self):
                help_popup = HelpPopup(self.root)
        
            def get_file_path(self):
                config_file = 'ChooseLocationForPause.txt'
                if os.path.exists(config_file):
                    with open(config_file, 'r') as file:
                        return file.readline().strip()
                else:
                    messagebox.showerror("Error", f"Configuration file {config_file} not found.")
                    self.root.destroy()
        
            def load_persons_from_json(self):
                if os.path.exists(self.file_path):
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return list(data.keys())
                else:
                    return []
        
            def generate_break_times(self):
                times = []
                start_hour, start_minute = 7, 45
                end_hour, end_minute = 16, 45
        
                current_hour = start_hour
                current_minute = start_minute
        
                while (current_hour < end_hour) or (current_hour == end_hour and current_minute <= end_minute):
                    times.append(f"{current_hour:02d}:{current_minute:02d}")
                    current_minute += 1
                    if current_minute == 60:
                        current_minute = 0
                        current_hour += 1
        
                return times
        
            def ensure_json_file(self):
                if not os.path.exists(self.file_path):
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                else:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    modified = False
                    for person in self.persons:
                        if person not in data:
                            data[person] = {"break_time": "--", "return_time": ""}
                            modified = True
                        else:
                            if "break_time" not in data[person]:
                                data[person]["break_time"] = "--"
                                modified = True
                            if "return_time" not in data[person]:
                                data[person]["return_time"] = ""
                                modified = True
                    if modified:
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
        
            def read_json_file(self):
                try:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return data
                except Exception as e:
                    return str(e)
        
            def update_json_file(self):
                person = self.person_combobox.get()
                break_time = self.break_time_combobox.get()
                if person and break_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["break_time"] = break_time
                        data[person]["return_time"] = ""  # Clear return time when setting a new break time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and break time")
        
            def update_return_time(self, return_window, person_combobox, return_time_combobox):
                person = person_combobox.get()
                return_time = return_time_combobox.get()
                if person and return_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["return_time"] = return_time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                        return_window.destroy()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and return time")
        
            def open_return_menu(self):
                return_window = tk.Toplevel(self.root)
                return_window.title("Set Return Time")
        
                person_label = ttk.Label(return_window, text="Select Person:")
                person_label.pack(padx=20, pady=5)
                person_combobox = ttk.Combobox(return_window, values=self.persons)
                person_combobox.pack(padx=20, pady=5)
        
                return_time_label = ttk.Label(return_window, text="Select Return Time:")
                return_time_label.pack(padx=20, pady=5)
        
                # Generate times for return time combobox
                break_times = self.generate_break_times()
                return_time_combobox = ttk.Combobox(return_window, values=break_times)
                return_time_combobox.pack(padx=20, pady=5)
        
                # Set default return time to break time + 1 hour
                def set_default_return_time(event):
                    person = person_combobox.get()
                    if person:
                        data = self.read_json_file()
                        if isinstance(data, dict):
                            break_time_str = data[person]["break_time"]
                            break_time = datetime.strptime(break_time_str, "%H:%M")
                            default_return_time = break_time + timedelta(hours=1)
                            default_return_time_str = default_return_time.strftime("%H:%M")
                            if default_return_time_str in break_times:
                                return_time_combobox.set(default_return_time_str)
        
                person_combobox.bind("<<ComboboxSelected>>", set_default_return_time)
        
                update_return_button = ttk.Button(return_window, text="Set Return Time",
                                                command=lambda: self.update_return_time(return_window, person_combobox, return_time_combobox))
                update_return_button.pack(padx=20, pady=10)
        
            def reset_data(self):
                confirmation = messagebox.askyesno("Reset Data", "Are you sure you want to reset all data?")
                if confirmation:
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                    self.update_data()
        
            def update_data(self):
                data = self.read_json_file()
                if isinstance(data, dict):
                    display_text = ""
                    for person, info in data.items():
                        break_time = info.get("break_time", "N/A")
                        return_time = info.get("return_time", "")
                        if return_time:
                            display_text += f"Name: {person}, Break Time: {break_time}, Return Time: {return_time} (Back)\n"
                        else:
                            display_text += f"Name: {person}, Break Time: {break_time}\n"
                    self.label.config(text=display_text)
                else:
                    self.label.config(text=f"Error: {data}")
        
                self.root.after(1000, self.update_data)  # Update every 10 seconds
        
            def open_json_generator(self):
                json_generator_window = tk.Toplevel(self.root)
                JSONGeneratorApp(json_generator_window, self)
        
            def update_combobox_values(self):
                self.person_combobox['values'] = self.persons
        
        if __name__ == "__main__":
            root = tk.Tk()
            app = BreakInfoApp(root)
            root.mainloop()
            
    def pausemain2():
        import tkinter as tk
        from tkinter import ttk, simpledialog, messagebox
        import json
        import os
        from datetime import datetime, timedelta

        messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
        validation.destroy()
        
        # Define the file name
        file_name = "ChooseLocationForPause.txt"
        
        # Check if the file already exists
        if not os.path.exists(file_name):
            # Open the file in write mode and immediately close it
            with open(file_name, 'w'):
                pass
            print(f"File {file_name} has been created. Restart aplication is required...")
            input()
        else:
            print(f"Opening file {file_name}... Done!")
        
        class HelpPopup:
            def __init__(self, parent):
                self.parent = parent
                self.popup = tk.Toplevel(parent)
                self.popup.title("Help")
                #self.popup.geometry("500x500")
                self.popup.resizable(False, False)
        
                help_text = """
                Welcome to the Break Info App!
        
                This application allows you to manage break information for employees or persons.
        
                How to use:
                1. Select a person from the drop-down menu.
                2. Choose a break time from the drop-down menu.
                3. Click on 'Set Break Time' to update the break time for the selected person.
                4. Optionally, click on 'Back to Work' to set the return time after the break.
                5. Use 'Refresh' to see updated information.
                6. Use 'Reset Data' to clear all break and return times for all persons.
                7. Use 'JSON Generator' to generate JSON data for persons and their break times.
                8. Click on 'Save to JSON' in the JSON Generator window to save the generated data to a JSON file.
        
                Configuration File for Path Selection:
                --------------------------------------
                This application uses a configuration file ('ChooseLocationForPause.txt') to store the path for saving JSON files. If the file doesn't exist or is not correctly configured, an error message will be displayed.
        
                To Use:
                --------
                1. Ensure the 'ChooseLocationForPause.txt' file exists in the same directory as this application.
                2. Open the file in a text editor.
                3. Enter the desired path where you want to save JSON files on a new line in the text file.
                4. Save and close the text file.
        
                Note: If the path is invalid or the file is not properly formatted, an error will prompt upon application startup.
        
                For more information or issues, please contact Tudor Marmureanu.
                """
        
                label = ttk.Label(self.popup, text=help_text, wraplength=400, justify="left")
                label.pack(padx=20, pady=20)
        
                ok_button = ttk.Button(self.popup, text="OK", command=self.popup.destroy)
                ok_button.pack(pady=10)
        
        class JSONGeneratorApp:
            def __init__(self, root, parent_app):
                self.root = root
                self.root.title("JSON Generator")
                self.parent_app = parent_app
        
                # Entry for number of persons
                self.num_label = ttk.Label(self.root, text="Number of Persons:")
                self.num_label.pack(padx=20, pady=5)
                self.num_entry = ttk.Entry(self.root)
                self.num_entry.pack(padx=20, pady=5)
        
                # Button to generate entry fields for names
                self.generate_button = ttk.Button(self.root, text="Generate Fields", command=self.generate_fields)
                self.generate_button.pack(padx=20, pady=10)
        
                # Frame to hold the dynamically generated entry fields
                self.names_frame = ttk.Frame(self.root)
                self.names_frame.pack(padx=20, pady=10)
        
                # Save button to save the data to JSON file
                self.save_button = ttk.Button(self.root, text="Save to JSON", command=self.save_to_json)
                self.save_button.pack(padx=20, pady=10)
        
                self.name_entries = []
        
            def generate_fields(self):
                # Clear any existing entry fields
                for widget in self.names_frame.winfo_children():
                    widget.destroy()
        
                self.name_entries = []
                try:
                    num_persons = int(self.num_entry.get())
                    for i in range(num_persons):
                        label = ttk.Label(self.names_frame, text=f"Person {i + 1} Name:")
                        label.pack(padx=5, pady=2)
                        entry = ttk.Entry(self.names_frame)
                        entry.pack(padx=5, pady=2)
                        self.name_entries.append(entry)
                except ValueError:
                    messagebox.showerror("Invalid input", "Please enter a valid number.")
        
            def save_to_json(self):
                persons = [entry.get() for entry in self.name_entries if entry.get().strip()]
                if persons:
                    data = {person: {"break_time": "--", "return_time": ""} for person in persons}
                    with open(self.parent_app.file_path, 'w') as file:
                        json.dump(data, file, indent=4)
                    self.parent_app.persons = persons
                    self.parent_app.update_combobox_values()
                    self.root.destroy()
                else:
                    messagebox.showerror("Input Error", "Please enter valid names for all persons.")
        
        class BreakInfoApp:
            def __init__(self, root):
                self.root = root
                self.root.title("Break Info")
        
                self.file_path = self.get_file_path()
                self.persons = self.load_persons_from_json()
        
                # Create combobox for selecting person
                self.person_label = ttk.Label(self.root, text="Select Person:")
                self.person_label.pack(padx=20, pady=5)
                self.person_combobox = ttk.Combobox(self.root, values=self.persons)
                self.person_combobox.pack(padx=20, pady=5)
        
                # Create combobox for selecting break time
                self.break_time_label = ttk.Label(self.root, text="Select Break Time:")
                self.break_time_label.pack(padx=20, pady=5)
                self.break_time_combobox = ttk.Combobox(self.root, values=self.generate_break_times())
                self.break_time_combobox.pack(padx=20, pady=5)
        
                # Create button to update JSON file
                self.update_button = ttk.Button(self.root, text="Set Break Time", command=self.update_json_file)
                self.update_button.pack(padx=20, pady=10)
        
                # Create button to refresh data
                self.refresh_button = ttk.Button(self.root, text="Refresh", command=self.update_data)
                self.refresh_button.pack(padx=20, pady=10)
        
                # Create button to open return menu
                self.return_button = ttk.Button(self.root, text="Back to Work", command=self.open_return_menu)
                self.return_button.pack(padx=20, pady=10)
        
                # Create button to reset all data
                self.reset_button = ttk.Button(self.root, text="Reset Data", command=self.reset_data)
                self.reset_button.pack(padx=20, pady=10)
        
                # Create button to open JSON generator window
                self.create_users_button = ttk.Button(self.root, text="JSON Generator", command=self.open_json_generator, state="disabled")
                self.create_users_button.pack(padx=20, pady=10)
        
                # Create button to open help popup
                self.help_button = ttk.Button(self.root, text="Help", command=self.open_help_popup)
                self.help_button.pack(padx=20, pady=10)
        
                # Create label to display break info
                self.label = ttk.Label(self.root, text="No data", font=("Helvetica", 16))
                self.label.pack(padx=20, pady=20)
        
                self.ensure_json_file()
                self.update_data()
        
            def open_help_popup(self):
                help_popup = HelpPopup(self.root)
        
            def get_file_path(self):
                config_file = 'ChooseLocationForPause.txt'
                if os.path.exists(config_file):
                    with open(config_file, 'r') as file:
                        return file.readline().strip()
                else:
                    messagebox.showerror("Error", f"Configuration file {config_file} not found.")
                    self.root.destroy()
        
            def load_persons_from_json(self):
                if os.path.exists(self.file_path):
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return list(data.keys())
                else:
                    return []
        
            def generate_break_times(self):
                times = []
                start_hour, start_minute = 7, 45
                end_hour, end_minute = 16, 45
        
                current_hour = start_hour
                current_minute = start_minute
        
                while (current_hour < end_hour) or (current_hour == end_hour and current_minute <= end_minute):
                    times.append(f"{current_hour:02d}:{current_minute:02d}")
                    current_minute += 1
                    if current_minute == 60:
                        current_minute = 0
                        current_hour += 1
        
                return times
        
            def ensure_json_file(self):
                if not os.path.exists(self.file_path):
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                else:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    modified = False
                    for person in self.persons:
                        if person not in data:
                            data[person] = {"break_time": "--", "return_time": ""}
                            modified = True
                        else:
                            if "break_time" not in data[person]:
                                data[person]["break_time"] = "--"
                                modified = True
                            if "return_time" not in data[person]:
                                data[person]["return_time"] = ""
                                modified = True
                    if modified:
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
        
            def read_json_file(self):
                try:
                    with open(self.file_path, 'r') as file:
                        data = json.load(file)
                    return data
                except Exception as e:
                    return str(e)
        
            def update_json_file(self):
                person = self.person_combobox.get()
                break_time = self.break_time_combobox.get()
                if person and break_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["break_time"] = break_time
                        data[person]["return_time"] = ""  # Clear return time when setting a new break time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and break time")
        
            def update_return_time(self, return_window, person_combobox, return_time_combobox):
                person = person_combobox.get()
                return_time = return_time_combobox.get()
                if person and return_time:
                    data = self.read_json_file()
                    if isinstance(data, dict):
                        data[person]["return_time"] = return_time
                        with open(self.file_path, 'w') as file:
                            json.dump(data, file, indent=4)
                        self.update_data()
                        return_window.destroy()
                    else:
                        self.label.config(text=f"Error: {data}")
                else:
                    self.label.config(text="Please select both person and return time")
        
            def open_return_menu(self):
                return_window = tk.Toplevel(self.root)
                return_window.title("Set Return Time")
        
                person_label = ttk.Label(return_window, text="Select Person:")
                person_label.pack(padx=20, pady=5)
                person_combobox = ttk.Combobox(return_window, values=self.persons)
                person_combobox.pack(padx=20, pady=5)
        
                return_time_label = ttk.Label(return_window, text="Select Return Time:")
                return_time_label.pack(padx=20, pady=5)
        
                # Generate times for return time combobox
                break_times = self.generate_break_times()
                return_time_combobox = ttk.Combobox(return_window, values=break_times)
                return_time_combobox.pack(padx=20, pady=5)
        
                # Set default return time to break time + 1 hour
                def set_default_return_time(event):
                    person = person_combobox.get()
                    if person:
                        data = self.read_json_file()
                        if isinstance(data, dict):
                            break_time_str = data[person]["break_time"]
                            break_time = datetime.strptime(break_time_str, "%H:%M")
                            default_return_time = break_time + timedelta(hours=1)
                            default_return_time_str = default_return_time.strftime("%H:%M")
                            if default_return_time_str in break_times:
                                return_time_combobox.set(default_return_time_str)
        
                person_combobox.bind("<<ComboboxSelected>>", set_default_return_time)
        
                update_return_button = ttk.Button(return_window, text="Set Return Time",
                                                command=lambda: self.update_return_time(return_window, person_combobox, return_time_combobox))
                update_return_button.pack(padx=20, pady=10)
        
            def reset_data(self):
                confirmation = messagebox.askyesno("Reset Data", "Are you sure you want to reset all data?")
                if confirmation:
                    initial_data = {person: {"break_time": "--", "return_time": ""} for person in self.persons}
                    with open(self.file_path, 'w') as file:
                        json.dump(initial_data, file, indent=4)
                    self.update_data()
        
            def update_data(self):
                data = self.read_json_file()
                if isinstance(data, dict):
                    display_text = ""
                    for person, info in data.items():
                        break_time = info.get("break_time", "N/A")
                        return_time = info.get("return_time", "")
                        if return_time:
                            display_text += f"Name: {person}, Break Time: {break_time}, Return Time: {return_time} (Back)\n"
                        else:
                            display_text += f"Name: {person}, Break Time: {break_time}\n"
                    self.label.config(text=display_text)
                else:
                    self.label.config(text=f"Error: {data}")
        
                self.root.after(1000, self.update_data)  # Update every 10 seconds
        
            def open_json_generator(self):
                json_generator_window = tk.Toplevel(self.root)
                JSONGeneratorApp(json_generator_window, self)
        
            def update_combobox_values(self):
                self.person_combobox['values'] = self.persons
        
        if __name__ == "__main__":
            root = tk.Tk()
            app = BreakInfoApp(root)
            root.mainloop()

    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

if taskmngrvar == 1000000:
    import tkinter as tk
    from tkinter import ttk, messagebox
    import psutil
    import threading
    import time
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    class CustomTaskManager:
        def __init__(self, root):
            self.root = root
            self.root.title("Task Manager")

            # Stilizare pentru butoane
            style = ttk.Style()
            style.configure("TButton",
                            #foreground="#333333",    # Text mai deschis
                            #background="#2E7D32",    # Fundal mai închis (verde închis)
                            #font=("Helvetica", 12),
                            padding=10,
                            width=15)

            # Stilizare pentru Treeview
            style.configure("Treeview",
                            background="#f0f0f0",
                            foreground="black",
                            rowheight=25,
                            fieldbackground="#f0f0f0")

            # Crearea notebook-ului pentru taburi
            self.notebook = ttk.Notebook(root)
            self.notebook.pack(fill=tk.BOTH, expand=True)

            # Tabul pentru procese
            self.process_frame = ttk.Frame(self.notebook)
            self.notebook.add(self.process_frame, text="Processes")

            # Crearea treeview pentru a afișa procesele
            self.tree = ttk.Treeview(self.process_frame, columns=("pid", "name", "status", "cpu", "memory", "disk"), show='headings')
            self.tree.heading("pid", text="PID")
            self.tree.heading("name", text="Process Name")
            self.tree.heading("status", text="Status")
            self.tree.heading("cpu", text="CPU (%)")
            self.tree.heading("memory", text="Memory (MB)")
            self.tree.heading("disk", text="Disk Read/Write (MB)")

            self.tree.column("pid", width=50)
            self.tree.column("name", width=200)
            self.tree.column("status", width=100)
            self.tree.column("cpu", width=50)
            self.tree.column("memory", width=100)
            self.tree.column("disk", width=150)

            self.tree.pack(fill=tk.BOTH, expand=True)

            # Butoane pentru funcționalități avansate
            self.button_frame = ttk.Frame(self.process_frame)
            self.button_frame.pack(fill=tk.X, pady=10)

            self.kill_button = ttk.Button(self.button_frame, text="Kill Process", command=self.kill_process)
            self.kill_button.pack(side=tk.LEFT, padx=10)

            self.refresh_button = ttk.Button(self.button_frame, text="Refresh", command=self.update_process_list)
            self.refresh_button.pack(side=tk.LEFT, padx=10)

            self.search_entry = ttk.Entry(self.button_frame, width=30)
            self.search_entry.pack(side=tk.LEFT, padx=10)

            self.search_button = ttk.Button(self.button_frame, text="Search", command=self.search_process)
            self.search_button.pack(side=tk.LEFT, padx=10)

            # Tabul pentru resursele sistemului (CPU, Memorie, Rețea, Disc)
            self.resources_frame = ttk.Frame(self.notebook)
            self.notebook.add(self.resources_frame, text="System Resources")

            # Adăugarea unui treeview pentru resursele sistemului
            self.resources_tree = ttk.Treeview(self.resources_frame, columns=("resource", "usage"), show='headings')
            self.resources_tree.heading("resource", text="Resource")
            self.resources_tree.heading("usage", text="Usage")

            self.resources_tree.column("resource", width=200)
            self.resources_tree.column("usage", width=200)

            self.resources_tree.pack(fill=tk.BOTH, expand=True)

            # Inițializarea listei de procese și resurse
            self.update_process_list()
            self.update_system_resources()

            # Inițializarea diagramelor
            self.init_plots()

        def update_process_list(self):
            threading.Thread(target=self._update_process_list, daemon=True).start()

        def _update_process_list(self):
            # Ștergerea tuturor elementelor din treeview
            for item in self.tree.get_children():
                self.tree.delete(item)

            # Obținerea și adăugarea informațiilor despre procese
            processes = []
            for proc in psutil.process_iter(['pid', 'name', 'status', 'cpu_percent', 'memory_info', 'io_counters']):
                try:
                    pid = proc.info['pid']
                    name = proc.info['name']
                    status = proc.info['status']
                    cpu = proc.info['cpu_percent']
                    memory = proc.info['memory_info'].rss / (1024 * 1024)  # Convertirea din bytes în MB
                    io_counters = proc.info['io_counters']
                    disk = (io_counters.read_bytes + io_counters.write_bytes) / (1024 * 1024)  # Convertirea din bytes în MB

                    processes.append((pid, name, status, cpu, memory, disk))
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    print(f"Error accessing process {proc.info['pid']}: {e}")
                    continue

            # Sortare alfabetică după nume
            processes.sort(key=lambda x: x[1].lower())

            # Adăugarea proceselor în Treeview
            for process in processes:
                self.tree.insert("", tk.END, values=process)

        def update_system_resources(self):
            threading.Thread(target=self._update_system_resources, daemon=True).start()

        def _update_system_resources(self):
            while True:
                # Ștergerea tuturor elementelor din treeview-ul resurselor
                for item in self.resources_tree.get_children():
                    self.resources_tree.delete(item)

                # Obținerea informațiilor despre resursele sistemului
                cpu_usage = psutil.cpu_percent(interval=1)
                memory_usage = psutil.virtual_memory().percent
                disk_usage = psutil.disk_usage('/').percent
                net_io = psutil.net_io_counters()
                net_usage = f"Sent: {net_io.bytes_sent / (1024 * 1024):.2f} MB, Received: {net_io.bytes_recv / (1024 * 1024):.2f} MB"

                self.resources_tree.insert("", tk.END, values=("CPU Usage", f"{cpu_usage} %"))
                self.resources_tree.insert("", tk.END, values=("Memory Usage", f"{memory_usage} %"))
                self.resources_tree.insert("", tk.END, values=("Disk Usage", f"{disk_usage} %"))
                self.resources_tree.insert("", tk.END, values=("Network Usage", net_usage))

                # Actualizarea diagramei
                self.update_plots(cpu_usage, memory_usage, disk_usage)

                time.sleep(5)

        def init_plots(self):
            # Inițializarea figurii pentru diagramă
            self.fig, self.ax = plt.subplots(figsize=(4, 4))

            # Crearea unei diagrame goale inițiale
            self.ax.set_title('System Resources')
            self.ax.set_xlabel('Resource')
            self.ax.set_ylabel('Usage (%)')

            # Bară de afișare a diagramei în tkinter
            self.canvas = FigureCanvasTkAgg(self.fig, master=self.resources_frame)
            self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        def update_plots(self, cpu_usage, memory_usage, disk_usage):
            # Actualizarea datelor diagramei
            resources = ['CPU', 'Memory', 'Disk']
            usages = [cpu_usage, memory_usage, disk_usage]

            # Ștergerea datelor anterioare
            self.ax.clear()

            # Re-desenarea diagramei actualizate
            self.ax.bar(resources, usages, color=['#1f77b4', '#ff7f0e', '#2ca02c'])  # Culori pentru fiecare bară

            # Adăugarea unor detalii suplimentare pentru diagrame
            self.ax.set_title('System Resources')
            self.ax.set_xlabel('Resource')
            self.ax.set_ylabel('Usage (%)')

            # Setarea limitei superioare a axei y la 100%
            self.ax.set_ylim(0, 100)

            # Actualizarea vizualizării în fereastră
            self.canvas.draw()

        def kill_process(self):
            selected_item = self.tree.selection()
            if selected_item:
                pid = self.tree.item(selected_item)["values"][0]
                try:
                    proc = psutil.Process(pid)
                    proc.terminate()
                    messagebox.showinfo("Success", f"Process {pid} terminated.")
                    self.update_process_list()
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    messagebox.showerror("Error", str(e))

            else:
                messagebox.showwarning("Warning", "Please select a process to kill.")

        def search_process(self):
            search_query = self.search_entry.get().lower()
            threading.Thread(target=self._search_process, args=(search_query,), daemon=True).start()

        def _search_process(self, search_query):
            for item in self.tree.get_children():
                self.tree.delete(item)

            for proc in psutil.process_iter(['pid', 'name', 'status', 'cpu_percent', 'memory_info', 'io_counters']):
                try:
                    if search_query in proc.info['name'].lower():
                        pid = proc.info['pid']
                        name = proc.info['name']
                        status = proc.info['status']
                        cpu = proc.info['cpu_percent']
                        memory = proc.info['memory_info'].rss / (1024 * 1024)  # Convertirea din bytes în MB
                        io_counters = proc.info['io_counters']
                        disk = (io_counters.read_bytes + io_counters.write_bytes) / (1024 * 1024)  # Convertirea din bytes în MB

                        self.tree.insert("", tk.END, values=(pid, name, status, cpu, memory, disk))
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    print(f"Error accessing process {proc.info['pid']}: {e}")
                    continue

    if __name__ == "__main__":
        roottm = tk.Tk()

        # Stilizare pentru fundalul general al aplicației
        roottm.configure(background="#f0f0f0")

        app = CustomTaskManager(roottm)
        roottm.mainloop()

if junkvar == 77777:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    import os
    import shutil
    from tkinter import *
    from threading import *
    from PIL import ImageTk, Image
    from tkinter import messagebox, filedialog

    file_types = {
    'Documents': ('.pdf', '.doc', '.xls', '.xlsx', '.txt', '.csv', '.xml', '.zip', '.docx', '.DOCX', '.odt', 
                  '.ppt', '.pptx', '.rtf', '.tex', '.epub', '.mobi'),
    'Pictures': ('.jpg', '.jpeg', '.png', '.JPG', '.webp', '.ico', '.gif', '.bmp', '.tiff', '.svg', '.heic'),
    'Videos': ('.mp4', '.mkv', '.3gp', '.flv', '.mpeg', '.avi', '.mov', '.wmv', '.mpg', '.webm', '.m4v'),
    'Music': ('.mp3', '.wav', '.m4a', '.webm', '.flac', '.aac', '.ogg', '.wma'),
    'Programs': ('.py', '.cpp', '.c', '.sh', '.js', '.htm', '.html', '.css', '.java', '.cs', '.php', '.rb', 
                 '.swift', '.go', '.pl', '.json', '.xml', '.sql', '.bat', '.cmd', '.ps1'),
    'Apps': ('.exe', '.apk', '.dmg', '.deb', '.rpm', '.msi', '.bin')
}
    
    class File_Organizer:
        def __init__(self, root):
            # Setting the Tkinter main window
            self.window = root
            self.window.geometry("720x500")
            self.window.title('File Organizer')
            self.window.resizable(width = False, height = False)
            self.window.configure(bg='#cccccc')
            self.selected_dir = ''
            self.browsed = False
            # Frame 1: For the Logo
            try:
                self.frame_1 = Frame(self.window,bg='gray90',
                width=280, height=70)
                self.frame_1.pack()
                self.frame_1.place(x=20, y=20)
                self.display_logo()
            except:
                pass
            # About Button
            About_Btn = Button(self.window, text="About", 
            font=("Kokila", 10, 'bold'), bg="dodger blue", 
            fg="white", width=5, command=self.about_window)
            About_Btn.place(x=600, y=20)
            # Exit Button
            Exit_Btn = Button(self.window, text="Exit", 
            font=("Kokila", 10, 'bold'), bg="dodger blue", 
            fg="white", width=5, command=self.exit_window)
            Exit_Btn.place(x=600, y=60)
            # Frame 2: For the Main Page Widgets
            self.frame_2 = Frame(self.window, bg="#cccccc",
            width=720,height=480)
            self.frame_2.place(x=0, y=110)
            self.main_window()
            
        def display_logo(self):
            image = Image.open('img/junk_logo.png')
            resized_image = image.resize((280, 70))
            self.logo = ImageTk.PhotoImage(resized_image)
            label = Label(self.frame_1, bg='gray90',image=self.logo)
            label.pack()
            
        def main_window(self):
            Heading_Label = Label(self.frame_2, 
            text="Please Select the Folder", 
            font=("Kokila", 20, 'bold'), bg='white')
            Heading_Label.place(x=160, y=20)
            Folder_Button = Button(self.frame_2, text="Select Folder", 
            font=("Kokila", 10, 'bold'), bg="gold", width=10, 
            command=self.select_directory)
            Folder_Button.place(x=130, y=80)
            self.Folder_Entry = Entry(self.frame_2, 
            font=("Helvetica", 12), width=32)
            self.Folder_Entry.place(x=256, y=85)
            Status = Label(self.frame_2, text="Status: ", 
            font=("Kokila", 12, 'bold'), bg='white')
            Status.place(x=180, y=130)
            # Status Label:
            self.Status_Label = Label(self.frame_2, text="Not Started Yet", 
            font=("Kokila", 12), bg="white", fg="red")
            self.Status_Label.place(x=256, y=130)
            Start_Button = Button(self.frame_2, text="Start", 
            font=("Kokila", 13, 'bold'), bg="dodger blue", fg="white", 
            width=8, command=self._threading)
            Start_Button.place(x=300, y=230)
            
        def select_directory(self):
            self.selected_dir = filedialog.askdirectory(title = 
            "Select a location")
            self.Folder_Entry.insert(0, self.selected_dir)
            self.selected_dir = str(self.selected_dir)
            # Checking if the folder path is exists or not
            if os.path.exists(self.selected_dir):
                self.browsed = True
                
        def _threading(self):
            self.x = Thread(target=self.organizer, daemon=True)
            self.x.start()
        
        def organizer(self):
            # If no directory is chosen
            if not self.browsed:
                messagebox.showwarning('No folders are choosen', 
                'Please Select a Folder First')
                return
            try:
                # Showing the current status of the operation
                self.Status_Label.config(text='Processing...')
                self.Current_Path = self.selected_dir
                if os.path.exists(self.Current_Path):
                # self.Folder_List1: stores all the folders that 
                # are already presented in the selected directory
                    self.Folder_List1 = []
                    # self.Folder_List2: stores newly created folders
                    self.Folder_List2 = []
                    self.flag = False
                    for folder, extensions in file_types.items():
                        self.folder_name = folder
                        self.folder_path = os.path.join(self.Current_Path, self.folder_name)
                        # Change the directory to the current 
                        # folder path that we've selected
                        os.chdir(self.Current_Path)
                        # If the folder is already present in that directory
                        if os.path.exists(self.folder_name):
                            self.Folder_List1.append(self.folder_name)
                        # If the folder is not present in that directory,
                        # then create a new folder
                        else:
                            self.Folder_List2.append(self.folder_name)
                            os.mkdir(self.folder_path)
                        
                        # Calling the 'file_finder' function to
                        # find a specific type of file (or extension)
                        # and change their old path to new path.
                        for item in self.file_finder(self.Current_Path, extensions):
                            self.Old_File_Path = os.path.join(self.Current_Path,item)
                            self.New_File_Path = os.path.join(self.folder_path,item)
                            # Moving each file to their new location
                            shutil.move(self.Old_File_Path, self.New_File_Path)
                            self.flag = True
                else:
                    messagebox.showerror('Error!','Please Enter a Valid Path!')
                # Checking if the files are separated or not
                # If `flag` is True: It means the program discovered
                # matching files and they have been organized.
                if self.flag:
                    self.Status_Label.config(text='Done!')
                    messagebox.showinfo('Done!', 'Operation Successful!')
                    self.reset()
                # If `flag` is False: It means the program didn't find
                # any matching files there; only empty folders are created.
                if not self.flag:
                    self.Status_Label.config(text='Complete!')
                    messagebox.showinfo('Done!', 
                    'Folders have been creatednNo Files were there to move')
                    self.reset()
            # If any error occurs
            except Exception as es:
                messagebox.showerror("Error!",f"Error due to {str(es)}")
        
        def file_finder(self, folder_path, file_extensions):
            self.files = []
            for file in os.listdir(folder_path):
                for extension in file_extensions:
                    if file.endswith(extension):
                        self.files.append(file)
            return self.files
            
        def reset(self):
            self.Status_Label.config(text='Not Started Yet')
            self.Folder_Entry.delete(0, END)
            self.selected_dir = ''
            
        def about_window(self):
            info_text = (
                "Developed by Tudor Marmureanu\n\n"
                "File types:\n"
                "Documents: .pdf, .doc, .xls, .xlsx, .txt, .csv, .xml, .zip, .docx, .DOCX, .odt, "
                ".ppt, .pptx, .rtf, .tex, .epub, .mobi\n\n"
                "Pictures: .jpg, .jpeg, .png, .JPG, .webp, .ico, .gif, .bmp, .tiff, .svg, .heic\n\n"
                "Videos: .mp4, .mkv, .3gp, .flv, .mpeg, .avi, .mov, .wmv, .mpg, .webm, .m4v\n\n"
                "Music: .mp3, .wav, .m4a, .webm, .flac, .aac, .ogg, .wma\n\n"
                "Programs: .py, .cpp, .c, .sh, .js, .htm, .html, .css, .java, .cs, .php, .rb, "
                ".swift, .go, .pl, .json, .xml, .sql, .bat, .cmd, .ps1\n\n"
                "Apps: .exe, .apk, .dmg, .deb, .rpm, .msi, .bin"
            )
            messagebox.showinfo("File Organizer", info_text)
        
        def exit_window(self):
            self.window.destroy()
            
    if __name__ == "__main__":
        rootjk = Tk()
        obj = File_Organizer(rootjk)
        rootjk.mainloop()
        
if wbpvar == 123456789:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    from tkinter import *
    from tkinter import ttk
    import tkinter as tk
    from tkinter import filedialog
    import os

    rootwbp = Tk()
    rootwbp.title("Whiteboard Presentation")
    rootwbp.geometry("1050x600+150+50")
    rootwbp.config(bg="#f2f3f5")
    rootwbp.resizable(False, False)

    current_x = 0
    current_y = 0
    color = "black"

    def locate_xy(work):
        global current_x, current_y
        current_x = work.x
        current_y = work.y

    def addline(work):
        global current_x, current_y
        canvas.create_line((current_x, current_y, work.x, work.y), width=get_current_value(), fill=color, capstyle=ROUND, smooth=True)
        current_x, current_y = work.x, work.y

    def show_color(new_color):
        global color
        color = new_color
        
    def new_canvas():
        canvas.delete('all')
        display_palette()

    def insertimage():
        global filename, f_img
        filename = filedialog.askopenfilename(initialdir=os.getcwd(), title="Select image file", filetypes=(("PNG file", "*.png"), ("JPG file", "*.jpg"), ("JPEG file", "*.jpeg"), ("ICON file", "*.ico"), ("All files", "*.*")))
        f_img = tk.PhotoImage(file=filename)
        canvas.create_image(180, 50, image=f_img)
        rootwbp.bind("<B3-Motion>", my_callback)

    def my_callback(event):
        global f_img
        f_img = tk.PhotoImage(file=filename)
        canvas.create_image(event.x, event.y, image=f_img)

    #image_icon = PhotoImage(file="img/paintpalette.png")
    #rootwbp.iconphoto(False, image_icon)

    eraser = PhotoImage(file="img/eraser.png")
    Button(rootwbp, image=eraser, bg="#f2f3f5", command=new_canvas).place(x=30, y=400)

    importimage = PhotoImage(file="img/insert_picture_icon.png")
    Button(rootwbp, image=importimage, bg="white", command=insertimage).place(x=30, y=450)

    colors = Canvas(rootwbp, bg="#fff", width=37, height=305, bd=0)
    colors.place(x=30, y=60)

    def display_palette():
        color_values = ["black", "gray", "red", "orange", "yellow", "green", "blue", "purple", "#9900ff", "cyan"]
        for i, color_value in enumerate(color_values):
            id = colors.create_rectangle((10, 10 + i * 30, 30, 30 + i * 30), fill=color_value)
            colors.tag_bind(id, '<Button-1>', lambda x, c=color_value: show_color(c))

    display_palette()

    # Frame pentru a conține canvasul și scrollbarul vertical
    canvas_frame = Frame(rootwbp, bd=2, relief=RIDGE)
    canvas_frame.place(x=100, y=10, width=930, height=470)  # Înălțime redusă pentru a face loc scrollbar-ului orizontal

    # Canvas-ul principal
    canvas = Canvas(canvas_frame, background="white", cursor="hand2", scrollregion=(0, 0, 2000, 2000))
    canvas.pack(side=LEFT, fill=BOTH, expand=True)

    # Scrollbar vertical
    v_scroll = Scrollbar(canvas_frame, orient=VERTICAL, command=canvas.yview)
    v_scroll.pack(side=RIGHT, fill=Y)
    canvas.config(yscrollcommand=v_scroll.set)

    # Scrollbar orizontal poziționat sub fereastra albă
    h_scroll = Scrollbar(rootwbp, orient=HORIZONTAL, command=canvas.xview)
    h_scroll.place(x=100, y=480, width=930)  # Poziționat sub fereastra albă
    canvas.config(xscrollcommand=h_scroll.set)

    canvas.bind('<Button-1>', locate_xy)
    canvas.bind('<B1-Motion>', addline)

    # Slider pentru dimensiunea liniei mutat jos
    current_value = tk.DoubleVar()
    def get_current_value():
        return '{:.2f}'.format(current_value.get())

    def slider_changed(event=None):
        value_label.configure(text=get_current_value())

    slider = ttk.Scale(rootwbp, from_=0, to=100, orient="horizontal", variable=current_value, command=slider_changed)
    slider.place(x=450, y=550)  # Mutat la coordonatele de jos

    value_label = ttk.Label(rootwbp, text=get_current_value())
    value_label.place(x=600, y=550)  # Mutat lângă slider, în partea de jos

    rootwbp.mainloop()

if cmvar == 3333:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    import sqlite3
    from tkinter import *
    import tkinter.ttk as ttk
    import tkinter.messagebox as tkMessageBox

    # ============================ SETUP ======================================
    rootcm = Tk()
    rootcm.title("Contact List")
    width = 700
    height = 600
    screen_width = rootcm.winfo_screenwidth()
    screen_height = rootcm.winfo_screenheight()
    x = (screen_width / 2) - (width / 2)
    y = (screen_height / 2) - (height / 2)
    rootcm.geometry(f"{width}x{height}+{int(x)}+{int(y)}")
    rootcm.resizable(0, 0)
    rootcm.config(bg="gray40")

    # ============================ VARIABLES ==================================
    NAME = StringVar()
    SURNAME = StringVar()
    EMAIL = StringVar()
    POSITION = StringVar()
    PHONE = StringVar()
    DETAILS = StringVar()

    # ============================ DATABASE ===================================
    def update_database_schema():
        conn = sqlite3.connect("contacts.db")
        cursor = conn.cursor()
        columns = {
            'surname': 'TEXT',
            'email': 'TEXT',
            'position': 'TEXT',
            'phone': 'TEXT',
            'details': 'TEXT'
        }
        for column, datatype in columns.items():
            try:
                cursor.execute(f"ALTER TABLE `member` ADD COLUMN `{column}` {datatype}")
            except sqlite3.OperationalError:
                pass  # Coloana există deja

        conn.commit()
        cursor.close()
        conn.close()

    update_database_schema()

    def Database():
        conn = sqlite3.connect("contacts.db")
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS `member` (
                mem_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                surname TEXT,
                email TEXT,
                position TEXT,
                phone TEXT,
                details TEXT
            )
        """)
        cursor.execute("SELECT * FROM `member` ORDER BY `surname` ASC")
        fetch = cursor.fetchall()
        for data in fetch:
            tree.insert('', 'end', values=(data))
        cursor.close()
        conn.close()

    # ============================ METHODS ====================================
    def SubmitData():
        if all([NAME.get(), SURNAME.get(), EMAIL.get(), POSITION.get(), PHONE.get(), DETAILS.get()]):
            tree.delete(*tree.get_children())
            conn = sqlite3.connect("contacts.db")
            cursor = conn.cursor()
            cursor.execute("INSERT INTO `member` (name, surname, email, position, phone, details) VALUES (?, ?, ?, ?, ?, ?)", 
                        (NAME.get(), SURNAME.get(), EMAIL.get(), POSITION.get(), PHONE.get(), DETAILS.get()))
            conn.commit()
            cursor.execute("SELECT * FROM `member` ORDER BY `surname` ASC")
            fetch = cursor.fetchall()
            for data in fetch:
                tree.insert('', 'end', values=(data))
            cursor.close()
            conn.close()
            NAME.set("")
            SURNAME.set("")
            EMAIL.set("")
            POSITION.set("")
            PHONE.set("")
            DETAILS.set("")
        else:
            tkMessageBox.showwarning('', 'Please Complete The Required Field', icon="warning")

    def UpdateData():
        if EMAIL.get():
            tree.delete(*tree.get_children())
            conn = sqlite3.connect("contacts.db")
            cursor = conn.cursor()
            cursor.execute("UPDATE `member` SET `name` = ?, `surname` = ?, `email` = ?, `position` = ?, `phone` = ?, `details` = ? WHERE `mem_id` = ?",
                        (NAME.get(), SURNAME.get(), EMAIL.get(), POSITION.get(), PHONE.get(), DETAILS.get(), mem_id))
            conn.commit()
            cursor.execute("SELECT * FROM `member` ORDER BY `surname` ASC")
            fetch = cursor.fetchall()
            for data in fetch:
                tree.insert('', 'end', values=(data))
            cursor.close()
            conn.close()
            NAME.set("")
            SURNAME.set("")
            EMAIL.set("")
            POSITION.set("")
            PHONE.set("")
            DETAILS.set("")
        else:
            tkMessageBox.showwarning('', 'Please Complete The Required Field', icon="warning")

    def OnSelected(event):
        global mem_id, UpdateWindow
        curItem = tree.focus()
        contents = (tree.item(curItem))
        selecteditem = contents['values']
        mem_id = selecteditem[0]
        NAME.set(selecteditem[1])
        SURNAME.set(selecteditem[2])
        EMAIL.set(selecteditem[3])
        POSITION.set(selecteditem[4])
        PHONE.set(selecteditem[5])
        DETAILS.set(selecteditem[6])
        
        UpdateWindow = Toplevel()
        UpdateWindow.title("Update Contact")
        width = 400
        height = 300
        x = (screen_width / 2 + 450) - (width / 2)
        y = (screen_height / 2 + 20) - (height / 2)
        #UpdateWindow.resizable(0, 0)
        UpdateWindow.geometry(f"{width}x{height}+{int(x)}+{int(y)}")

        if 'NewWindow' in globals():
            NewWindow.destroy()

        # Frames and Labels for Update Window
        FormTitle = Frame(UpdateWindow)
        FormTitle.pack(side=TOP)
        ContactForm = Frame(UpdateWindow)
        ContactForm.pack(side=TOP, pady=10)
        
        lbl_title = Label(FormTitle, text="Updating Contacts", font=('arial', 16), bg="orange", width=300)
        lbl_title.pack(fill=X)

        labels = ["Name", "Surname", "Email", "Job Title", "Phone", "Other Details"]
        for idx, label in enumerate(labels):
            Label(ContactForm, text=label, font=('arial', 14), bd=5).grid(row=idx, sticky=W)
            Entry(ContactForm, textvariable=[NAME, SURNAME, EMAIL, POSITION, PHONE, DETAILS][idx], font=('arial', 14)).grid(row=idx, column=1)

        Button(ContactForm, text="Update", width=50, command=UpdateData).grid(row=6, columnspan=2, pady=10)

    def DeleteData():
        if tree.selection():
            result = tkMessageBox.askquestion('', 'Are you sure you want to delete this record?', icon="warning")
            if result == 'yes':
                curItem = tree.focus()
                contents = (tree.item(curItem))
                selecteditem = contents['values']
                tree.delete(curItem)
                conn = sqlite3.connect("contacts.db")
                cursor = conn.cursor()
                cursor.execute("DELETE FROM `member` WHERE `mem_id` = ?", (selecteditem[0],))
                conn.commit()
                cursor.close()
                conn.close()
        else:
            tkMessageBox.showwarning('', 'Please Select Something First!', icon="warning")

    def AddNewWindow():
        global NewWindow
        for var in [NAME, SURNAME, EMAIL, POSITION, PHONE, DETAILS]:
            var.set("")
            
        NewWindow = Toplevel()
        NewWindow.title("Add New Contact")
        width = 400
        height = 300
        x = (screen_width / 2 - 455) - (width / 2)
        y = (screen_height / 2 + 20) - (height / 2)
        #NewWindow.resizable(0, 0)
        NewWindow.geometry(f"{width}x{height}+{int(x)}+{int(y)}")

        if 'UpdateWindow' in globals():
            UpdateWindow.destroy()
        
        # Frames and Labels for Add Window
        FormTitle = Frame(NewWindow)
        FormTitle.pack(side=TOP)
        ContactForm = Frame(NewWindow)
        ContactForm.pack(side=TOP, pady=10)
        
        lbl_title = Label(FormTitle, text="Adding New Contacts", font=('arial', 16), bg="orange", width=300)
        lbl_title.pack(fill=X)

        labels = ["Name", "Surname", "Email", "Position", "Phone", "Other Details"]
        for idx, label in enumerate(labels):
            Label(ContactForm, text=label, font=('arial', 14), bd=5).grid(row=idx, sticky=W)
            Entry(ContactForm, textvariable=[NAME, SURNAME, EMAIL, POSITION, PHONE, DETAILS][idx], font=('arial', 14)).grid(row=idx, column=1)

        Button(ContactForm, text="Save", width=50, command=SubmitData).grid(row=6, columnspan=2, pady=10)

    # ============================ GUI ELEMENTS =================================
    Top = Frame(rootcm, width=500, bd=1, relief=SOLID)
    Top.pack(side=TOP)
    Mid = Frame(rootcm, width=500, bg="gray40")
    Mid.pack(side=TOP)
    MidLeft = Frame(Mid, width=100)
    MidLeft.pack(side=LEFT, pady=10)
    MidLeftPadding = Frame(Mid, width=370, bg="gray40")
    MidLeftPadding.pack(side=LEFT)
    MidRight = Frame(Mid, width=100)
    MidRight.pack(side=RIGHT, pady=10)
    TableMargin = Frame(rootcm, width=500)
    TableMargin.pack(side=TOP)

    lbl_title = Label(Top, text="Contact Management System", font=('arial', 16), bg="gray", width=500)
    lbl_title.pack(fill=X)

    btn_add = Button(MidLeft, text="+ ADD NEW", bg="lightgreen", command=AddNewWindow)
    btn_add.pack()

    btn_delete = Button(MidRight, text="DELETE", bg="red", command=DeleteData)
    btn_delete.pack()

    # Scrollbar and Treeview
    scrollbarx = Scrollbar(TableMargin, orient=HORIZONTAL)
    scrollbary = Scrollbar(TableMargin, orient=VERTICAL)

    tree = ttk.Treeview(TableMargin, columns=("MemberID", "Name", "Surname", "Email", "Position", "Phone", "Details"),
                        height=400, selectmode="extended", yscrollcommand=scrollbary.set, xscrollcommand=scrollbarx.set)
    scrollbary.config(command=tree.yview)
    scrollbary.pack(side=RIGHT, fill=Y)
    scrollbarx.config(command=tree.xview)
    scrollbarx.pack(side=BOTTOM, fill=X)

    tree.heading('MemberID', text="MemberID", anchor=W)
    tree.heading('Name', text="Name", anchor=W)
    tree.heading('Surname', text="Surname", anchor=W)
    tree.heading('Email', text="Email", anchor=W)
    tree.heading('Position', text="Position", anchor=W)
    tree.heading('Phone', text="Phone", anchor=W)
    tree.heading('Details', text="Other Details", anchor=W)

    tree.column('#0', stretch=NO, minwidth=0, width=0)
    tree.column('#1', stretch=NO, minwidth=0, width=80)
    tree.column('#2', stretch=NO, minwidth=0, width=120)
    tree.column('#3', stretch=NO, minwidth=0, width=120)
    tree.column('#4', stretch=NO, minwidth=0, width=120)
    tree.column('#5', stretch=NO, minwidth=0, width=120)
    tree.column('#6', stretch=NO, minwidth=0, width=120)
    tree.column('#7', stretch=NO, minwidth=0, width=150)

    tree.pack()
    tree.bind('<Double-Button-1>', OnSelected)

    # ============================ INITIALIZATION =============================
    if __name__ == '__main__':
        Database()
        rootcm.mainloop()

if pingalivevar == 5566:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    import tkinter as tk
    import subprocess
    import threading
    import time
    import os
    import json
    from queue import Queue
    from tkinter import filedialog, simpledialog, messagebox

    class PingWorker(threading.Thread):
        def __init__(self, ip, queue):
            super().__init__()
            self.ip = ip
            self.queue = queue

        def run(self):
            try:
                response = subprocess.run(['ping', '-n', '1', self.ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=2)
                status = "Online" if "TTL=" in response.stdout.decode('utf-8') else "Offline"
            except subprocess.TimeoutExpired:
                status = "Offline"
            except Exception as e:
                status = "Error"
            self.queue.put((self.ip, status))

    class PingApp:
        def __init__(self, rootSA):
            self.rootSA = rootSA
            self.rootSA.title("Listener - Device Checking")
            self.rootSA.geometry("1000x600")
            self.rootSA.config(bg="gray40")  # #cccccc
            
            self.search_label = tk.Label(rootSA, font=("Arial", 12, "bold"), text="Search:", fg="#ccff66", bg="gray40")
            self.search_label.pack(pady=5)
            
            self.search_entry = tk.Entry(rootSA, fg="cyan", bg="#333333", bd=4, insertbackground="#ccff66")
            self.search_entry.pack(pady=5)
            
            self.search_button = tk.Button(rootSA, text="Filter", fg="cyan", bg="gray20", bd=6, command=self.update_labels)
            self.search_button.pack(pady=5)
            
            # Canvas pentru scroll
            self.canvas = tk.Canvas(rootSA)
            self.canvas.config(bg="#cccccc")
            self.scroll_y = tk.Scrollbar(rootSA, orient="vertical", command=self.canvas.yview)
            self.scroll_y.pack(side="right", fill="y")
            self.canvas.pack(side="left", fill="both", expand=True)
            
            # Frame pentru conținutul scrollabil
            self.frame = tk.Frame(self.canvas)
            self.frame.config(bg="#cccccc")
            self.canvas.create_window((0, 0), window=self.frame, anchor='nw')
            self.frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
            self.canvas.configure(yscrollcommand=self.scroll_y.set)
            
            # Bind mousewheel event
            self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
            
            self.results = {"groups": []}
            self.queue = Queue()
            
            if not os.path.exists("Results_IP"):
                os.makedirs("Results_IP")
            
            self.update_interval = 10
            self.schedule_update()
            
            self.create_menu()
            
            # Load the JSON file if it exists
            #self.load_initial_json()
        
        def _on_mousewheel(self, event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        '''
        def load_initial_json(self):
            json_file_path = "cantare.json"
            if os.path.exists(json_file_path):
                with open(json_file_path, 'r', encoding='utf-8') as file:
                    data = json.load(file)
                    self.results = {"groups": []}
                    for group in data.get("groups", []):
                        group_name = group.get("name")
                        ips = group.get("ips", {})
                        if group_name and ips:
                            self.results["groups"].append({
                                "name": group_name,
                                "ips": {ip: "Unknown" for ip in ips}
                            })
                    self.update_labels()
            else:
                print(f"{json_file_path} not found.")
        '''
        
        def create_menu(self):
            menu = tk.Menu(self.rootSA)
            #menu.config(bg="gray40")
            self.rootSA.config(menu=menu)
            
            file_menu = tk.Menu(menu, tearoff=0)
            menu.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="Open JSON", command=self.open_json)
            file_menu.add_command(label="Create JSON", command=self.create_json)
            file_menu.add_command(label="Edit JSON", command=self.open_edit_json)

        def open_json(self):
            file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
            if file_path:
                with open(file_path, 'r', encoding='utf-8') as file:
                    data = json.load(file)
                    self.results = {"groups": []}
                    for group in data.get("groups", []):
                        group_name = group.get("name")
                        ips = group.get("ips", [])
                        if group_name and ips:
                            self.results["groups"].append({
                                "name": group_name,
                                "ips": {ip: "Unknown" for ip in ips}
                            })
                    self.update_labels()
        
        def create_json(self):
            num_groups = simpledialog.askinteger("Create JSON", "Enter the number of groups:")
            if num_groups and num_groups > 0:
                groups = []
                for i in range(num_groups):
                    group_name = simpledialog.askstring("Create JSON", f"Enter the name of group {i+1}:")
                    ips_input = simpledialog.askstring("Create JSON", f"Enter IP addresses for group '{group_name}' separated by commas:")
                    if group_name and ips_input:
                        ips = [ip.strip() for ip in ips_input.split(',') if ip.strip()]
                        if ips:
                            groups.append({
                                "name": group_name,
                                "ips": {ip: "Unknown" for ip in ips}  # Convertim lista în dicționar
                            })
                if groups:
                    data = {
                        "groups": groups
                    }
                    file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
                    if file_path:
                        with open(file_path, 'w', encoding='utf-8') as file:
                            json.dump(data, file, indent=4)
                    self.results = {"groups": groups}
                    self.update_labels()

        def open_edit_json(self):
            self.edit_window = tk.Toplevel(self.rootSA)
            self.edit_window.title("Edit JSON")
            self.edit_window.geometry("800x400")
            self.edit_window.config(bg="gray40")
            
            self.json_text = tk.Text(self.edit_window, wrap='word', undo=True, bg="black", fg="cyan", bd=6, insertbackground="#ccff66")
            self.json_text.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Button to load JSON content
            load_button = tk.Button(self.edit_window, text="Load JSON", command=self.load_json, bg="gray40", fg="#ccff66", bd=4)
            load_button.pack(side='left', padx=10, pady=5)
            
            # Button to save JSON content
            save_button = tk.Button(self.edit_window, text="Save JSON", command=self.save_json, bg="gray40", fg="#ccff66", bd=4)
            save_button.pack(side='left', padx=10, pady=5)
            
            # Button to close the edit window
            close_button = tk.Button(self.edit_window, text="Close", command=self.edit_window.destroy, bg="gray40", fg="red", bd=4)
            close_button.pack(side='right', padx=10, pady=5)
        
        def load_json(self):
            file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
            if file_path:
                with open(file_path, 'r', encoding='utf-8') as file:
                    json_content = file.read()
                    self.json_text.delete(1.0, tk.END)
                    self.json_text.insert(tk.END, json_content)
        
        def save_json(self):
            try:
                json_content = self.json_text.get(1.0, tk.END)
                data = json.loads(json_content)  # Validate JSON
                file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
                if file_path:
                    with open(file_path, 'w', encoding='utf-8') as file:
                        file.write(json.dumps(data, indent=4))
                    messagebox.showinfo("Success", "JSON saved successfully!")
            except json.JSONDecodeError:
                messagebox.showerror("Error", "Invalid JSON format. Please check your JSON content.")

        def schedule_update(self):
            threading.Thread(target=self.update_results, daemon=True).start()
            self.rootSA.after(self.update_interval * 1000, self.schedule_update)
        
        def update_results(self):
            try:
                ips = [ip for group in self.results.get("groups", []) for ip in group.get("ips", {}).keys()]
                
                self.results = {"groups": [{ "name": group["name"], "ips": {ip: "Unknown" for ip in group["ips"].keys()}} for group in self.results.get("groups", [])]}
                
                ips.sort()
                
                threads = []
                for ip in ips:
                    worker = PingWorker(ip, self.queue)
                    worker.start()
                    threads.append(worker)
                
                for thread in threads:
                    thread.join()
                
                while not self.queue.empty():
                    ip, status = self.queue.get()
                    for group in self.results.get("groups", []):
                        if ip in group["ips"]:
                            group["ips"][ip] = status
                
                timestamp = time.strftime('%Y%m%d-%H%M%S')
                result_file = f"Results_IP/Scann_{timestamp}.json"
                
                with open(result_file, 'w', encoding='utf-8') as output_file:
                    json.dump({
                        "timestamp": time.strftime('%H:%M:%S'),
                        "results": self.results
                    }, output_file, indent=4)
                        
                self.rootSA.after(0, self.update_labels)
                
                if not os.path.exists('Results'):
                    os.makedirs('Results')
                
                timestamp = time.strftime('%Y%m%d-%H%M%S')
                result_file = f"Results_IP/Scann_{timestamp}.json"
                
                with open(result_file, 'w', encoding='utf-8') as output_file:
                    json.dump({
                        "timestamp": time.strftime('%H:%M:%S'),
                        "results": self.results
                    }, output_file, indent=4)
                        
                self.rootSA.after(0, self.update_labels)
            
            except Exception as e:
                print(f"Error: {str(e)}")
        
        def update_labels(self):
            for widget in self.frame.winfo_children():
                widget.destroy()

            search_term = self.search_entry.get().strip().lower()

            max_groups_per_column = 30  # Numărul maxim de grupuri per coloană
            row = 0
            col = 0
            groups_displayed = 0  # Numără grupurile afișate în coloană
            column_spacing = 50  # Spațiul între coloane

            # Afișează grupurile și IP-urile aferente
            for group in self.results.get("groups", []):
                group_name = group.get("name")
                ips = group.get("ips", {})

                # Filtrare IP-uri pe baza termenului de căutare
                filtered_ips = {ip: status for ip, status in ips.items() if search_term in ip}

                if filtered_ips:  # Afișează grupul doar dacă are IP-uri care se potrivesc căutării
                    if groups_displayed >= max_groups_per_column:
                        groups_displayed = 0
                        row = 0
                        col += 2  # Treci la următoarea pereche de coloane

                    tk.Label(self.frame, text=f"Group: {group_name}", font=('Arial', 12, 'bold')).grid(row=row, column=col, columnspan=2, padx=(column_spacing, 20), pady=10, sticky="w")
                    row += 1

                    for ip, status in filtered_ips.items():
                        color = 'green' if status == "Online" else 'red'

                        ip_label = tk.Label(self.frame, text=ip, bg='white', borderwidth=1, relief="solid", padx=5, pady=2)
                        ip_label.grid(row=row, column=col, padx=(column_spacing, 5), pady=2, sticky="w")

                        status_label = tk.Label(self.frame, text=status, bg=color, fg='white', borderwidth=1, relief="solid", padx=5, pady=2)
                        status_label.grid(row=row, column=col + 1, padx=(5, 20), pady=2, sticky="w")

                        row += 1

                    groups_displayed += 1

                    # Reinițializare rând la finalul grupului
                    if row >= max_groups_per_column:
                        row = 0
                        col += 2
                        groups_displayed = 0

    if __name__ == "__main__":
        rootSA = tk.Tk()
        app = PingApp(rootSA)
        rootSA.mainloop()
        
if launchervar == 1990:
    class MultiAppLauncher(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("Multiapp Launcher")
            self.geometry("600x450")
            self.resizable(False, False)
            self.config(bg="#1a1a1a")

            self.processes = []

            # Adăugare Label pentru a lansa aplicațiile
            self.label = tk.Label(self, text="Launch multiple instances of Multiapp.exe", fg="#c2c2d6", bg="#1a1a1a")
            self.label.pack(pady=10)

            self.launch_button = tk.Button(self, text="Launch Applications", fg="#ccff66", bg="#333333", bd=5, command=self.launch_apps)
            self.launch_button.pack(pady=10)

            self.instances_label = tk.Label(self, text="Number of instances:", fg="#c2c2d6", bg="#1a1a1a")
            self.instances_label.pack(pady=5)

            self.instances_entry = tk.Entry(self, fg="#ccff66", bg="#404040", insertbackground="#ccff66")
            self.instances_entry.pack(pady=5)

            self.stop_button = tk.Button(self, text="Stop Applications", fg="#ff6666", bg="#333333", bd=5, command=self.stop_apps)
            self.stop_button.pack(pady=10)

            # Cadru principal pentru conturi cu scrollbar
            self.accounts_canvas = tk.Canvas(self, bg="#1a1a1a")
            self.accounts_frame = tk.Frame(self.accounts_canvas, bg="#1a1a1a")
            self.scrollbar = tk.Scrollbar(self, orient="vertical", command=self.accounts_canvas.yview)
            self.accounts_canvas.configure(yscrollcommand=self.scrollbar.set)

            self.scrollbar.pack(side="right", fill="y")
            self.accounts_canvas.pack(side="left", fill="both", expand=True)
            self.accounts_canvas.create_window((0, 0), window=self.accounts_frame, anchor="nw")

            self.accounts_frame.bind("<Configure>", self.on_frame_configure)

            # Creează cadrele separate pentru conturi
            self.frame_no_key = tk.LabelFrame(self.accounts_frame, text="Accounts without Product Key", fg="#ccff66", bg="#1a1a1a", bd=5, padx=10, pady=10)
            self.frame_with_key = tk.LabelFrame(self.accounts_frame, text="Accounts with Product Key", fg="#ff6666", bg="#1a1a1a", bd=5, padx=10, pady=10)

            self.frame_no_key.pack(pady=10, fill=tk.BOTH, expand=True)
            self.frame_with_key.pack(pady=10, fill=tk.BOTH, expand=True)

            # Citește și afișează conturile
            self.load_accounts()

        def launch_apps(self):
            try:
                multiapp_path = os.path.join(os.getcwd(), "Multiapp.exe")

                if not os.path.exists(multiapp_path):
                    raise FileNotFoundError("Multiapp.exe not found in the current directory.")

                num_instances = int(self.instances_entry.get())
                if num_instances <= 0:
                    raise ValueError("The number must be positive")

                for _ in range(num_instances):
                    process = subprocess.Popen([multiapp_path], cwd=os.getcwd())
                    self.processes.append(process)

                messagebox.showinfo("Success", f"{num_instances} instances have been launched.")
            except FileNotFoundError as fnf_error:
                messagebox.showerror("Error", fnf_error)
            except ValueError as ve:
                messagebox.showerror("Error", f"Invalid value: {ve}")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")

        def stop_apps(self):
            try:
                for proc in psutil.process_iter(['pid', 'name']):
                    if proc.info['name'] == 'Multiapp.exe':
                        proc.terminate()
                        proc.wait()

                self.processes = []
                messagebox.showinfo("Stopped", "All instances of Multiapp.exe have been stopped.")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to stop processes: {e}")

        def load_accounts(self):
            try:
                with open("Accounts.txt", "r") as file:
                    lines = file.readlines()

                # Variabile pentru organizarea layout-ului
                row_no_key = 0
                col_no_key = 0
                row_with_key = 0
                col_with_key = 0

                for line in lines:
                    line = line.strip()
                    if line and '|' not in line and not line.startswith('---'):
                        user_info, password = line.split()[:2]
                        
                        if "product_key" in line:
                            account_label = tk.Label(self.frame_with_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_with_key, column=col_with_key, padx=10, pady=10)
                            col_with_key += 1
                            if col_with_key == 3:
                                col_with_key = 0
                                row_with_key += 1
                        else:
                            account_label = tk.Label(self.frame_no_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_no_key, column=col_no_key, padx=10, pady=10)
                            col_no_key += 1
                            if col_no_key == 3:
                                col_no_key = 0
                                row_no_key += 1

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load accounts: {e}")

        def copy_to_clipboard(self, password):
            self.clipboard_clear()
            self.clipboard_append(password)
            self.update()  # Este necesar pentru ca clipboard-ul să fie actualizat imediat
            messagebox.showinfo("Success", "Password copied to clipboard!")

        def on_frame_configure(self, event):
            """Reconfigurează scroll-ul pentru canvas."""
            self.accounts_canvas.configure(scrollregion=self.accounts_canvas.bbox("all"))

    if __name__ == "__main__":
        appL = MultiAppLauncher()
        appL.mainloop()

if launchervar_admin == 1991:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    class MultiAppLauncher(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("Multiapp Admin Launcher")
            self.geometry("600x450")
            self.resizable(False, False)
            self.config(bg="#1a1a1a")

            self.processes = []

            # Adăugare Label pentru a lansa aplicațiile
            self.label = tk.Label(self, text="Launch multiple instances of Multiapp.exe", fg="#c2c2d6", bg="#1a1a1a")
            self.label.pack(pady=10)

            self.launch_button = tk.Button(self, text="Launch Applications", fg="#ccff66", bg="#333333", bd=5, command=self.launch_apps)
            self.launch_button.pack(pady=10)

            self.instances_label = tk.Label(self, text="Number of instances:", fg="#c2c2d6", bg="#1a1a1a")
            self.instances_label.pack(pady=5)

            self.instances_entry = tk.Entry(self, fg="#ccff66", bg="#404040", insertbackground="#ccff66")
            self.instances_entry.pack(pady=5)

            self.stop_button = tk.Button(self, text="Stop Applications", fg="#ff6666", bg="#333333", bd=5, command=self.stop_apps)
            self.stop_button.pack(pady=10)

            # Cadru principal pentru conturi cu scrollbar
            self.accounts_canvas = tk.Canvas(self, bg="#1a1a1a")
            self.accounts_frame = tk.Frame(self.accounts_canvas, bg="#1a1a1a")
            self.scrollbar = tk.Scrollbar(self, orient="vertical", command=self.accounts_canvas.yview)
            self.accounts_canvas.configure(yscrollcommand=self.scrollbar.set)

            self.scrollbar.pack(side="right", fill="y")
            self.accounts_canvas.pack(side="left", fill="both", expand=True)
            self.accounts_canvas.create_window((0, 0), window=self.accounts_frame, anchor="nw")

            self.accounts_frame.bind("<Configure>", self.on_frame_configure)

            # Creează cadrele separate pentru conturi
            self.frame_no_key = tk.LabelFrame(self.accounts_frame, text="Accounts without Product Key", fg="#ccff66", bg="#1a1a1a", bd=5, padx=10, pady=10)
            self.frame_with_key = tk.LabelFrame(self.accounts_frame, text="Accounts with Product Key", fg="#ff6666", bg="#1a1a1a", bd=5, padx=10, pady=10)

            self.frame_no_key.pack(pady=10, fill=tk.BOTH, expand=True)
            self.frame_with_key.pack(pady=10, fill=tk.BOTH, expand=True)

            # Citește și afișează conturile
            self.load_accounts()

        def launch_apps(self):
            try:
                multiapp_path = os.path.join(os.getcwd(), "Multiapp.exe")

                if not os.path.exists(multiapp_path):
                    raise FileNotFoundError("Multiapp.exe not found in the current directory.")

                num_instances = int(self.instances_entry.get())
                if num_instances <= 0:
                    raise ValueError("The number must be positive")

                for _ in range(num_instances):
                    process = subprocess.Popen([multiapp_path], cwd=os.getcwd())
                    self.processes.append(process)

                messagebox.showinfo("Success", f"{num_instances} instances have been launched.")
            except FileNotFoundError as fnf_error:
                messagebox.showerror("Error", fnf_error)
            except ValueError as ve:
                messagebox.showerror("Error", f"Invalid value: {ve}")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")

        def stop_apps(self):
            try:
                for proc in psutil.process_iter(['pid', 'name']):
                    if proc.info['name'] == 'Multiapp.exe':
                        proc.terminate()
                        proc.wait()

                self.processes = []
                messagebox.showinfo("Stopped", "All instances of Multiapp.exe have been stopped.")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to stop processes: {e}")

        def load_accounts(self):
            self.create_accounts_file()
            try:
                with open("Accounts.txt", "r") as file:
                    lines = file.readlines()

                # Variabile pentru organizarea layout-ului
                row_no_key = 0
                col_no_key = 0
                row_with_key = 0
                col_with_key = 0

                for line in lines:
                    line = line.strip()
                    if line and '|' not in line and not line.startswith('---'):
                        user_info, password = line.split()[:2]
                        
                        if "product_key" in line:
                            account_label = tk.Label(self.frame_with_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_with_key, column=col_with_key, padx=10, pady=10)
                            col_with_key += 1
                            if col_with_key == 3:
                                col_with_key = 0
                                row_with_key += 1
                        else:
                            account_label = tk.Label(self.frame_no_key, text=user_info, fg="#ccff66", bg="#333333", width=20, height=2, bd=5, relief="groove")
                            account_label.bind("<Button-1>", lambda e, pwd=password: self.copy_to_clipboard(pwd))
                            account_label.grid(row=row_no_key, column=col_no_key, padx=10, pady=10)
                            col_no_key += 1
                            if col_no_key == 3:
                                col_no_key = 0
                                row_no_key += 1

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load accounts: {e}")

        def copy_to_clipboard(self, password):
            self.clipboard_clear()
            self.clipboard_append(password)
            self.update()  # Este necesar pentru ca clipboard-ul să fie actualizat imediat
            messagebox.showinfo("Success", "Password copied to clipboard!")

        def on_frame_configure(self, event):
            """Reconfigurează scroll-ul pentru canvas."""
            self.accounts_canvas.configure(scrollregion=self.accounts_canvas.bbox("all"))
        
        def create_accounts_file(self):
            installation_directory = os.getcwd()
            if not installation_directory:
                return
            
            accounts_file_path = os.path.join(installation_directory, "Accounts.txt")
            
            accounts_data = """|___user___|            |___password___|

    user            nopass
    it              copy (+- product_key)
    passgen         passgen
    quiz            test
    quizmaker       quizmaker
    pausemanager    pauze (+- product_key)
    taskmanager     terminator
    launcher        launcher
    hardware        lite
    eventviewer     eventviewer
    xml             editor

    --------------------------------------------
    terminal        terminal (+ product_key)
    passgenV2     	passgenV2 (+ product_key)
    system         	realtime (+ product_key)
    screenrec      	screenrec (+ product_key)
    zipmanager     	zipmngr (+ product_key)
    comparator     	comparator (+ product_key)
    convertorpdf   	toword (+ product_key)
    textreplace    	textfind (+ product_key)
    pdftools      	enjoyit (+ product_key)
    pdfviewer       pdfviewer (+ product_key)
    bandmonitoring 	networking (+ product_key)
    cryptoV2      	security (+ product_key)
    chatbot        	aichatbot (+ product_key)
    notepad        	notepad (+ product_key)
    paint          	paint (+ product_key)
    zippass        	wordsmith (+ product_key)
    backupmanager   	backupmngr (+ product_key)
    renamemanager  	renamer (+ product_key)
    kbmanager      	knowladgebase (+ product_key)
    kbretro         kbretro (+ product_key)
    password       	manager (+ product_key)
    junk           	manager (+ product_key)
    whiteboard     	presentation (+ product_key)
    contact        	manager (+ product_key)
    check          	devices (+ product_key)
    excel           lite (+ product_key)
    reader          office (+ product_key)
    fetcher         repair (+ product_key)
    shell           integrator (+ product_key)
    tudor           fosfataza (+ product_key)
    ide             pycharm (+ product_key)
    ide             vscode (+ produce_key)
    tudor           fosfatazaaa (+ product_key)
    tudor           adminlauncher (+ product_key)
    tudor           vnc (+ product_key)
    tudor           assembly (+ product_key)
    sql             editor (+ product_key)
    diagram         canvas (+ product_key)
    tudor           explorer (+ product_key)
    commander		total (+ product_key)
    calendar        calendar (+ product_key)
    alert           monitor (+ product_key)
    process         viewer (+ produck_key)
    md		        mdviewer (+ product_key)
    history         files (+ product_key)
    expense	        tracker (+ product_key)
    script	        agent (+ product_key)
    recovery	    tunnel (+ product_key)
    fisher	        file (+ product_key)
    multifile       editor (+ product_key)
    safe            checker (+ product_key)
    traffic         network (+ product_key)
        """

            with open(accounts_file_path, "w") as accounts_file:
                accounts_file.write(accounts_data.strip())  # Scrie datele în fișier

    if __name__ == "__main__":
        appLA = MultiAppLauncher()
        appLA.mainloop()

if excelvar == 1992:
    import sys
    import subprocess
    import re
    import math
    from PyQt5.QtWidgets import QInputDialog, QApplication, QMainWindow, QTabWidget, QTableView, QFileDialog, QAction, QMenuBar, QMessageBox, QLineEdit, QVBoxLayout, QWidget, QDialog, QVBoxLayout, QTextEdit, QPushButton
    from PyQt5.QtCore import QAbstractTableModel, Qt, QModelIndex
    from openpyxl import load_workbook, Workbook
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class ExcelTableModel(QAbstractTableModel):
        def __init__(self, data, total_rows, total_columns):
            super().__init__()
            self._data = data
            self.total_rows = total_rows
            #self.total_columns = total_columns
            self.total_columns = min(total_columns, 26)

        def rowCount(self, parent=QModelIndex()):
            return self.total_rows

        def columnCount(self, parent=QModelIndex()):
            return self.total_columns

        def data(self, index, role=Qt.DisplayRole):
            if role == Qt.DisplayRole:
                if index.row() < len(self._data) and index.column() < len(self._data[index.row()]):
                    value = self._data[index.row()][index.column()]
                    if isinstance(value, str) and value.startswith('='):
                        return self.evaluate_formula(value)  # Evaluate the formula for display
                    return value if value is not None else ""
                return ""
            elif role == Qt.EditRole:
                return self._data[index.row()][index.column()]  # Return the raw data for editing
            
        def headerData(self, section, orientation, role=Qt.DisplayRole):
            if role == Qt.DisplayRole:
                if orientation == Qt.Horizontal:
                    # Afișează litere pentru coloane, A, B, C, ..., Z
                    return chr(ord('A') + section)
                elif orientation == Qt.Vertical:
                    # Afișează numere pentru rânduri
                    return str(section + 1)
            return None

        def evaluate_formula(self, formula):
            try:
                if formula.startswith(('=SUM', '=AVERAGE', '=MIN', '=MAX', '=COUNT', '=PRODUCT', '=MEDIAN', '=CONCAT', '=POW', '=SQRT')):
                    # Extragem intervalul de celule
                    numbers = re.findall(r'\((.*?)\)', formula)
                    if numbers:
                        cell_range = numbers[0]
                        cells = cell_range.split(':')
                        start_cell = cells[0]
                        end_cell = cells[1]
                        start_col = ord(start_cell[0]) - ord('A')
                        start_row = int(start_cell[1:]) - 1
                        end_col = ord(end_cell[0]) - ord('A')
                        end_row = int(end_cell[1:]) - 1
                        
                        values = []
                        for row in range(start_row, end_row + 1):
                            for col in range(start_col, end_col + 1):
                                cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                                values.append(cell_value)

                        # Evaluăm în funcție de tipul formulei
                        if formula.startswith('=SUM'):
                            return sum(values)
                        elif formula.startswith('=AVERAGE'):
                            return sum(values) / len(values) if values else 0
                        elif formula.startswith('=MIN'):
                            return min(values)
                        elif formula.startswith('=MAX'):
                            return max(values)
                        elif formula.startswith('=COUNT'):
                            return len([v for v in values if v != 0])
                        elif formula.startswith('=PRODUCT'):
                            result = 1
                            for v in values:
                                result *= v
                            return result
                        elif formula.startswith('=MEDIAN'):
                            sorted_values = sorted(values)
                            n = len(sorted_values)
                            if n == 0:
                                return 0
                            if n % 2 == 1:
                                return sorted_values[n // 2]
                            else:
                                return (sorted_values[n // 2 - 1] + sorted_values[n // 2]) / 2
                        elif formula.startswith('=POW'):
                            formula = re.sub(r'[A-Z]\d+', cell_value, formula)
                            # Extragem baza și exponentul
                            base, exponent = map(float, re.findall(r'\((.*?)\)', formula)[0].split(','))
                            return math.pow(base, exponent)

                        # Evaluarea pentru SQRT
                        elif formula.startswith('=SQRT'):
                            formula = re.sub(r'[A-Z]\d+', cell_value, formula)
                            value = float(re.findall(r'\((.*?)\)', formula)[0])
                            return math.sqrt(value)

                # Formula IF (de forma: =IF(conditie, valoare_adevarata, valoare_falsa))
                if formula.startswith('=IF'):
                    condition, true_value, false_value = re.findall(r'\((.*?),(.*?),(.*?)\)', formula)[0]
                    # Înlocuim celulele cu valori în condiție
                    matches = re.findall(r'([A-Z]+)(\d+)', condition)
                    for match in matches:
                        col = ord(match[0]) - ord('A')
                        row = int(match[1]) - 1
                        if 0 <= row < len(self._data) and 0 <= col < len(self._data[row]):
                            cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                            condition = condition.replace(match[0] + match[1], str(cell_value))

                    # Evaluăm condiția și returnăm valoarea corespunzătoare
                    if eval(condition):
                        return eval(true_value)
                    else:
                        return eval(false_value)
                    
                if formula.startswith('=CONCAT'):
                    # Extragem intervalul de celule din formula, între paranteze
                    cell_range = re.findall(r'\((.*?)\)', formula)
                    if cell_range:
                        cell_range = cell_range[0]  # Aici obținem intervalul de celule
                        cells = cell_range.split(':')  # Divizăm după ':', dacă este un interval
                        
                        start_cell = cells[0]
                        end_cell = cells[1] if len(cells) > 1 else start_cell  # Dacă e doar o celulă

                        # Convertim celulele în coordonate de rând și coloană
                        start_col = ord(start_cell[0]) - ord('A')
                        start_row = int(start_cell[1:]) - 1
                        end_col = ord(end_cell[0]) - ord('A')
                        end_row = int(end_cell[1:]) - 1

                        # Concatenăm toate valorile (considerând text și numerice)
                        concatenated_text = ""
                        for row in range(start_row, end_row + 1):
                            for col in range(start_col, end_col + 1):
                                cell_value = self._data[row][col]
                                if cell_value is not None:
                                    concatenated_text += str(cell_value)

                        return concatenated_text
                    

                # Înlocuirea referințelor la celule cu valorile lor pentru alte formule (ex: =A1 + B2)
                matches = re.findall(r'([A-Z]+)(\d+)', formula)
                for match in matches:
                    col = ord(match[0]) - ord('A')
                    row = int(match[1]) - 1
                    if 0 <= row < len(self._data) and 0 <= col < len(self._data[row]):
                        cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                        formula = formula.replace(match[0] + match[1], str(cell_value))
                
                return eval(formula[1:])  # Evaluăm formula fără "="
            except Exception:
                return formula  # Returnăm formula în caz de eroare

        '''
        def evaluate_formula(self, formula):
            # Example evaluation logic (keep as is)
            try:
                # Handle SUM function
                if formula.startswith('=SUM'):
                    # Extract cell range
                    numbers = re.findall(r'\((.*?)\)', formula)
                    if numbers:
                        cell_range = numbers[0]
                        cells = cell_range.split(':')
                        start_cell = cells[0]
                        end_cell = cells[1]
                        start_col = ord(start_cell[0]) - ord('A')
                        start_row = int(start_cell[1:]) - 1
                        end_col = ord(end_cell[0]) - ord('A')
                        end_row = int(end_cell[1:]) - 1
                        
                        total = 0
                        for row in range(start_row, end_row + 1):
                            for col in range(start_col, end_col + 1):
                                total += self._data[row][col] if self._data[row][col] is not None else 0
                        return total
                
                # Replace cell references with their values
                matches = re.findall(r'([A-Z]+)(\d+)', formula)
                for match in matches:
                    col = ord(match[0]) - ord('A')
                    row = int(match[1]) - 1
                    if 0 <= row < len(self._data) and 0 <= col < len(self._data[row]):
                        cell_value = self._data[row][col] if self._data[row][col] is not None else 0
                        formula = formula.replace(match[0] + match[1], str(cell_value))
                return eval(formula[1:])  # Evaluate the formula without the '='
            except Exception:
                return formula  # Return the formula if evaluation fails
        '''

        def setData(self, index, value, role=Qt.EditRole):
            if role == Qt.EditRole:
                if index.isValid():
                    if index.row() < len(self._data) and index.column() < len(self._data[index.row()]):
                        # Check if the value is a formula
                        if isinstance(value, str) and value.startswith('='):
                            self._data[index.row()][index.column()] = value
                        else:
                            try:
                                # Try to convert the value to a number
                                if isinstance(value, str):
                                    value = float(value) if '.' in value else int(value)
                                # If value is already an int or float, just assign it
                                self._data[index.row()][index.column()] = value
                            except ValueError:
                                # Handle non-numeric values as necessary
                                self._data[index.row()][index.column()] = value  # Store the original value

                        self.dataChanged.emit(index, index)
                        return True
            return False


        def flags(self, index):
            if index.isValid():
                return Qt.ItemIsEditable | Qt.ItemIsEnabled | Qt.ItemIsSelectable
            return Qt.NoItemFlags

    class ExcelViewer(QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle('Excel Lite')
            self.setGeometry(100, 100, 800, 600)

            self.main_widget = QWidget()
            self.setCentralWidget(self.main_widget)

            self.layout = QVBoxLayout()
            self.main_widget.setLayout(self.layout)

            self.formula_line_edit = QLineEdit()
            self.formula_line_edit.setReadOnly(True)
            self.layout.addWidget(self.formula_line_edit)

            self.tabs = QTabWidget()
            self.layout.addWidget(self.tabs)

            self.create_menu()
            self.create_empty_sheet()

            self.clipboard_data = []

            self.setStyleSheet("""
            QMainWindow {
                background-color: #2D2D2D;  /* Fundal întunecat */
            }
            QWidget {
                background-color: #3C3F41;  /* Fundal pentru widget-uri */
                color: #ffffff;  /* Text alb */
            }
            QWidget::item:hover {
                background-color: #ccff66;
            }
            QWidget::item:selected {
                background-color: #121212;
            }
            QLineEdit {
                background-color: #4C4F51;  /* Fundal pentru QLineEdit */
                color: #FFFFFF;  /* Text alb */
                border: 1px solid #666;  /* Bordură */
            }
            QTabWidget::pane {
                background: #4d4d4d;  /* Fundal pentru tab-uri */
            }
            QTabBar::tab {
                background: #4d4d4d;  /* Fundal pentru tab-uri */
                color: #ccff66;  /* Text alb */
                padding: 10px;
                border: 2px solid #000000;
            }
            QTabBar::tab:selected {
                background: #121212;  /* Fundal tab selectat */
                color: cyan;
            }
            QPushButton {
                background-color: #4C4F51;  /* Fundal pentru butoane */
                color: #FFFFFF;  /* Text alb */
                border: none;  /* Fără bordură */
                padding: 5px;
            }
            QPushButton:hover {
                background-color: #5A5E61;  /* Fundal la hover */
            }
            QMessageBox {
                background-color: #3C3F41;  /* Fundal pentru QMessageBox */
                color: #FFFFFF;  /* Text alb */
            }
            QTableWidget {
                border: 2px solid #000000;  /* Contur negru pentru tabel */
                gridline-color: #666666;    /* Culoarea liniilor din interiorul tabelului */
                background-color: #3C3F41;  /* Fundal întunecat pentru tabel */
                color: #FFFFFF;              /* Text alb în tabel */
            }
            QTableWidget::item {
                border: 1px solid #666666;  /* Bordură pentru celule */
            }
            QTableWidget::item:selected {
                background-color: #121212;  /* Fundal pentru celule selectate */
            }
            QHeaderView::section {
                background-color: #4C4F51;  /* Fundal pentru antetele rândurilor și coloanelor */
                color: #FFFFFF;              /* Culoare text pentru antete (alb) */
                font-weight: bold;           /* Text îngroșat pentru antete */
            }
        """)

        def create_menu(self):
            menubar = self.menuBar()
            
            file_menu = menubar.addMenu('File')
            
            new_file_action = QAction('New', self)
            new_file_action.triggered.connect(self.open_new_instance)
            file_menu.addAction(new_file_action)

            new_sheet_action = QAction('New Sheet', self)
            new_sheet_action.triggered.connect(self.create_new_sheet)
            file_menu.addAction(new_sheet_action)

            open_action = QAction('Open', self)
            open_action.triggered.connect(self.load_excel_file)
            file_menu.addAction(open_action)

            save_action = QAction('Save', self)
            save_action.triggered.connect(self.save_all_sheets)
            file_menu.addAction(save_action)

            delete_sheet_action = QAction('Delete Sheet', self)
            delete_sheet_action.triggered.connect(self.delete_sheet)
            file_menu.addAction(delete_sheet_action)  # Dacă ai un meniu

            # Edit Menu for Copy, Paste
            edit_menu = menubar.addMenu('Edit')

            # Copy action
            copy_action = QAction('Copy', self)
            copy_action.triggered.connect(self.copy_selected_cells)
            edit_menu.addAction(copy_action)

            # Paste action
            paste_action = QAction('Paste', self)
            paste_action.triggered.connect(self.paste_to_selected_cells)
            edit_menu.addAction(paste_action)
            
            # Help Menu
            help_menu = menubar.addMenu('Help')

            about_action = QAction('About', self)
            about_action.triggered.connect(self.show_about_dialog)
            help_menu.addAction(about_action)

        def show_about_dialog(self):
            dialog = QDialog(self)
            dialog.setWindowTitle("Help - Excel Lite")
            dialog.setGeometry(200, 200, 500, 400)  # Dimensiuni inițiale ale ferestrei

            layout = QVBoxLayout()

            help_text = (
                "Help Menu - Available Functions\n\n"
                "1. SUM (Sum of values in a range)\n"
                "   Formula: =SUM(A1:C3)\n"
                "   Description: Calculates the sum of all values in the range A1 to C3.\n"
                "   Example: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n\n"
                
                "2. AVERAGE (Arithmetic mean)\n"
                "   Formula: =AVERAGE(A1:C3)\n"
                "   Description: Computes the average of the values in the range A1 to C3.\n"
                "   Example: (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9) / 9 = 5\n\n"
                
                "3. MIN (Minimum value)\n"
                "   Formula: =MIN(A1:C3)\n"
                "   Description: Returns the smallest value in the range A1 to C3.\n"
                "   Example: Min value = 1\n\n"
                
                "4. MAX (Maximum value)\n"
                "   Formula: =MAX(A1:C3)\n"
                "   Description: Returns the largest value in the range A1 to C3.\n"
                "   Example: Max value = 9\n\n"
                
                "5. COUNT (Number of non-empty cells)\n"
                "   Formula: =COUNT(A1:C3)\n"
                "   Description: Counts the number of non-empty cells in the range A1 to C3.\n"
                "   Example: 9 (all cells contain values)\n\n"
                
                "6. PRODUCT (Multiplication of values)\n"
                "   Formula: =PRODUCT(A1:C3)\n"
                "   Description: Multiplies all values in the range A1 to C3.\n"
                "   Example: 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 × 9 = 362880\n\n"
                
                "7. MEDIAN (Middle value in a sorted list)\n"
                "   Formula: =MEDIAN(A1:C3)\n"
                "   Description: Returns the median value of the range A1 to C3.\n"
                "   Example: Sorted values: 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
                "   Median = 5\n\n"
                
                "8. CONCAT (Concatenation of values)\n"
                "   Formula: =CONCAT(A1:B2)\n"
                "   Description: Joins all values in the range A1 to B2 into a single string.\n"
                "   Example: Values in A1, B1, A2, B2 are 1, 2, 4, 5\n"
                "   Result: '1245'\n\n"
                
                "Shortcuts:\n"
                "   - Copy: CTRL+C\n"
                "   - Paste: CTRL+V\n"
            )

            text_edit = QTextEdit()
            text_edit.setText(help_text)
            text_edit.setReadOnly(True)  # Face textul non-editabil
            layout.addWidget(text_edit)

            close_button = QPushButton("Close")
            close_button.clicked.connect(dialog.accept)
            layout.addWidget(close_button)

            dialog.setLayout(layout)
            dialog.exec_()  # Afișează fereastra modal


        def keyPressEvent(self, event):
            if event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_C:
                self.copy_selected_cells()
            elif event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_V:
                self.paste_to_selected_cells()

        def copy_selected_cells(self):
            """Copie datele din celulele selectate în clipboard."""
            current_sheet = self.tabs.currentWidget()
            selection_model = current_sheet.selectionModel()
            selected_indexes = selection_model.selectedIndexes()

            if not selected_indexes:
                return

            self.clipboard_data.clear()
            rows = {}
            for index in selected_indexes:
                row = index.row()
                col = index.column()
                if row not in rows:
                    rows[row] = {}
                rows[row][col] = current_sheet.model().data(index, Qt.DisplayRole)
            
            # Organizăm datele copiate într-o listă de liste pentru a păstra ordinea
            sorted_rows = sorted(rows.keys())
            for row in sorted_rows:
                sorted_cols = sorted(rows[row].keys())
                row_data = [rows[row][col] for col in sorted_cols]
                self.clipboard_data.append(row_data)
            
        def paste_to_selected_cells(self):
            """Lipește datele din clipboard în celulele selectate."""
            if not self.clipboard_data:
                return
            
            current_sheet = self.tabs.currentWidget()
            selection_model = current_sheet.selectionModel()
            selected_indexes = selection_model.selectedIndexes()

            if not selected_indexes:
                return
            
            # Vom începe lipirea de la prima celulă selectată
            start_index = selected_indexes[0]
            start_row = start_index.row()
            start_col = start_index.column()

            # Iterăm prin clipboard și lipim în tabel
            for i, row_data in enumerate(self.clipboard_data):
                for j, value in enumerate(row_data):
                    if start_row + i < current_sheet.model().rowCount() and start_col + j < current_sheet.model().columnCount():
                        index = current_sheet.model().index(start_row + i, start_col + j)
                        current_sheet.model().setData(index, value, Qt.EditRole)

        def open_new_instance(self):
            subprocess.Popen([sys.executable, __file__])

        def create_empty_sheet(self):
            # Prompt for the initial sheet name
            sheet_name, ok = QInputDialog.getText(self, 'Input Sheet Name', 'Enter the name of the sheet:')
            if ok and sheet_name:
                data = [[None] * 100 for _ in range(100)]
                self.add_sheet(sheet_name, data)

        def create_new_sheet(self):
            while True:
                sheet_name, ok = QInputDialog.getText(self, 'New Sheet Name', 'Enter the name of the new sheet:')
                if ok and sheet_name:
                    # Check if the name already exists
                    if not any(sheet_name == self.tabs.tabText(i) for i in range(self.tabs.count())):
                        data = [[None] * 100 for _ in range(100)]
                        self.add_sheet(sheet_name, data)
                        break
                    else:
                        QMessageBox.warning(self, 'Warning', 'Sheet name already exists. Please choose another name.')
                else:
                    QMessageBox.warning(self, 'Warning', 'Sheet name cannot be empty. Please enter a valid name.')

        def delete_sheet(self):
            current_index = self.tabs.currentIndex()  # Obține indexul tab-ului curent
            if current_index == -1:
                QMessageBox.warning(self, 'Warning', 'No sheet selected to delete.')
                return
            
            sheet_name = self.tabs.tabText(current_index)  # Obține numele sheet-ului curent

            # Confirmare de ștergere
            reply = QMessageBox.question(self, 'Confirm Delete', f'Are you sure you want to delete the sheet "{sheet_name}"?',
                                        QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            
            if reply == QMessageBox.Yes:
                self.tabs.removeTab(current_index)  # Șterge tab-ul
                # Șterge datele asociate, dacă este cazul
                # self.data.remove(sheet_name)  # De exemplu, dacă ai o dict pentru date
                QMessageBox.information(self, 'Deleted', f'Sheet "{sheet_name}" has been deleted.')


        def load_excel_file(self):
            if self.has_unsaved_changes():
                reply = QMessageBox.warning(self, 'Warning',
                    'Data that has not been saved will be lost. Do you want to continue?',
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if reply == QMessageBox.No:
                    return

            self.tabs.clear()
            options = QFileDialog.Options()
            file_path, _ = QFileDialog.getOpenFileName(self, "Select Excel File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
            
            # Define number of rows and columns
            num_rows, num_columns = 100, 100
            
            if file_path:
                workbook = load_workbook(file_path)
                for sheet_name in workbook.sheetnames:
                    sheet = workbook[sheet_name]
                    data = [[None] * num_columns for _ in range(num_rows)]  # Preallocate with None
                    for row in sheet.iter_rows(max_row=num_rows, max_col=num_columns):
                        for cell in row:
                            data[cell.row - 1][cell.column - 1] = cell.value
                    self.add_sheet(sheet_name, data)


        def add_sheet(self, sheet_name, data):
            model = ExcelTableModel(data, 100, 100)
            table_view = QTableView()
            table_view.setModel(model)
            table_view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
            table_view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
            table_view.setStyleSheet("QTableView { selection-background-color: #121212; }")  # Custom styling for selected cells
            table_view.setStyleSheet("QTableView { background-color: #121212; }")
            table_view.setStyleSheet("QTableView { border: 2px solid #000000;}")
            table_view.setStyleSheet("QTableView { gridline-color: #808080;}")
            table_view.setStyleSheet("QTableView { color: #ffffff;}")
            table_view.setStyleSheet("QTableWidget::item:selected { background-color: #121212;}")

            # Conectează selecția celulei cu funcția de actualizare a QLineEdit
            table_view.selectionModel().selectionChanged.connect(lambda: self.update_formula_display(table_view, model))

            self.tabs.addTab(table_view, sheet_name)

        def update_formula_display(self, table_view, model):
            index = table_view.currentIndex()
            if index.isValid():
                value = model.data(index, Qt.EditRole)  # Obține datele brute (care pot fi o formulă)
                if isinstance(value, str) and value.startswith('='):
                    self.formula_line_edit.setText(value)  # Arată formula în QLineEdit
                else:
                    self.formula_line_edit.setText(str(value))  # Arată valoarea evaluată


        def save_all_sheets(self):
            options = QFileDialog.Options()
            file_path, _ = QFileDialog.getSaveFileName(self, "Save Excel File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
            if file_path:
                workbook = Workbook()
                if "Sheet" in workbook.sheetnames:
                    del workbook["Sheet"]

                for i in range(self.tabs.count()):
                    current_tab = self.tabs.widget(i)
                    model = current_tab.model()
                    sheet_name = self.tabs.tabText(i)
                    sheet = workbook.create_sheet(title=sheet_name)

                    for row_index in range(model.rowCount()):
                        for column_index in range(model.columnCount()):
                            value = model.data(model.index(row_index, column_index), Qt.EditRole)
                            sheet.cell(row=row_index + 1, column=column_index + 1, value=value)

                workbook.save(file_path)

        def has_unsaved_changes(self):
            for i in range(self.tabs.count()):
                current_tab = self.tabs.widget(i)
                model = current_tab.model()
                if any(model.data(model.index(row, column), Qt.EditRole) is not None for row in range(model.rowCount()) for column in range(model.columnCount())):
                    return True
            return False

    if __name__ == '__main__':
        app = QApplication(sys.argv)
        viewer = ExcelViewer()
        viewer.show()
        sys.exit(app.exec_())

if readervar == 1993:
    import tkinter as tk
    from tkinter import filedialog, messagebox, scrolledtext, ttk
    import os
    import re
    import threading
    from pathlib import Path
    from datetime import datetime
    import tempfile
    import zipfile

    # For reading Office files
    try:
        import openpyxl  # For Excel
        from docx import Document  # For Word
        from pptx import Presentation  # For PowerPoint
        import pandas as pd  # For advanced Excel processing
        OFFICE_SUPPORT = True
        PANDAS_SUPPORT = True
    except ImportError as e:
        OFFICE_SUPPORT = False
        PANDAS_SUPPORT = False
        missing_libs = str(e)

    # For PDF support
    try:
        import PyPDF2
        import fitz  # PyMuPDF for better PDF handling
        PDF_SUPPORT = True
    except ImportError:
        PDF_SUPPORT = False

    # For RTF support
    try:
        from striprtf.striprtf import rtf_to_text
        RTF_SUPPORT = True
    except ImportError:
        RTF_SUPPORT = False

    if PANDAS_SUPPORT:
        pd.set_option('display.max_rows', None)
        pd.set_option('display.max_columns', None)
        pd.set_option('display.width', None)
        pd.set_option('display.max_colwidth', None)
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class EnhancedOfficeReader:
        def __init__(self):
            self.rootofficereader = tk.Tk()
            self.rootofficereader.title("Office Reader")
            self.rootofficereader.geometry("900x700")
            
            # Retro Windows 95 styling
            self.setup_retro_style()
            
            # Variables
            self.current_file = None
            self.file_content = ""
            self.search_results = []
            self.current_search_index = 0
            self.excel_sheets = {}
            self.excel_file_path = None
            self.sheets_btn = None  # Referință la butonul sheets
            self.view_menu = None  # Referință la meniul view
            self.excel_menu_index = 4  # Index pentru inserarea opțiunii Excel
            
            # Create interface
            self.create_widgets()
            
            # Check if Office libraries are installed
            if not OFFICE_SUPPORT:
                self.show_install_instructions()
        
        def select_excel_sheet(self):
            """Select and display specific Excel sheet"""
            if not hasattr(self, 'excel_sheets') or not self.excel_sheets:
                messagebox.showinfo("No Excel File", "No Excel file with multiple sheets loaded")
                return
            
            # Creează fereastră pentru selectarea sheet-ului
            sheet_window = tk.Toplevel(self.rootofficereader)
            sheet_window.title("Select Excel Sheet")
            sheet_window.geometry("400x300")
            sheet_window.configure(bg="#c0c0c0")
            sheet_window.resizable(False, False)
            
            # Centrează fereastra
            sheet_window.transient(self.rootofficereader)
            sheet_window.grab_set()
            
            tk.Label(sheet_window, text="Select a sheet to view:", 
                     bg="#c0c0c0", font=("MS Sans Serif", 10, "bold")).pack(pady=10)
            
            # Lista cu sheet-uri
            listbox_frame = tk.Frame(sheet_window, bg="#c0c0c0")
            listbox_frame.pack(fill='both', expand=True, padx=20, pady=10)
            
            listbox = tk.Listbox(listbox_frame, font=("MS Sans Serif", 9),
                                bg="#ffffff", fg="#000000")
            scrollbar = tk.Scrollbar(listbox_frame, orient=tk.VERTICAL, command=listbox.yview)
            listbox.configure(yscrollcommand=scrollbar.set)
            
            # Adaugă sheet-urile în listă
            for sheet_name in self.excel_sheets.keys():
                df = self.excel_sheets[sheet_name]
                listbox.insert(tk.END, f"{sheet_name} ({len(df)} rows, {len(df.columns)} cols)")
            
            listbox.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
            
            # Selectează primul item implicit
            if listbox.size() > 0:
                listbox.selection_set(0)
            
            # Butoane
            button_frame = tk.Frame(sheet_window, bg="#c0c0c0")
            button_frame.pack(fill='x', padx=20, pady=10)
            
            def view_selected_sheet():
                selection = listbox.curselection()
                if selection:
                    sheet_name = list(self.excel_sheets.keys())[selection[0]]
                    self.display_excel_sheet(sheet_name)
                    sheet_window.destroy()
            
            def view_all_sheets():
                # Reîncarcă toate sheet-urile
                content = self.read_excel_with_pandas(self.excel_file_path)
                self.text_area.config(state='normal')  # ACTIVEAZĂ ÎNAINTE
                self.text_area.delete(1.0, tk.END)
                self.text_area.insert(1.0, content)
                self.text_area.config(state='disabled')  # DEZACTIVEAZĂ DUPĂ
                sheet_window.destroy()
            
            tk.Button(button_frame, text="View Selected", command=view_selected_sheet,
                      bg="#c0c0c0", relief='raised', bd=2, font=("MS Sans Serif", 8),
                      width=12).pack(side='left', padx=5)
            
            tk.Button(button_frame, text="View All", command=view_all_sheets,
                      bg="#c0c0c0", relief='raised', bd=2, font=("MS Sans Serif", 8),
                      width=12).pack(side='left', padx=5)
            
            tk.Button(button_frame, text="Cancel", command=sheet_window.destroy,
                      bg="#c0c0c0", relief='raised', bd=2, font=("MS Sans Serif", 8),
                      width=12).pack(side='right', padx=5)
            
            # Double-click pentru a deschide sheet-ul
            listbox.bind('<Double-Button-1>', lambda e: view_selected_sheet())

        def display_excel_sheet(self, sheet_name):
            """Display a specific Excel sheet"""
            if sheet_name not in self.excel_sheets:
                return
            
            df = self.excel_sheets[sheet_name]
            
            content = []
            content.append("=" * 80)
            content.append(f"EXCEL SHEET: {sheet_name}")
            content.append("=" * 80)
            content.append(f"Rows: {len(df)}, Columns: {len(df.columns)}")
            content.append(f"File: {os.path.basename(self.excel_file_path)}")
            content.append("")
            
            if not df.empty:
                content.append(df.to_string(index=False, max_rows=None, max_cols=None))
            else:
                content.append("(Empty sheet)")
            
            # Actualizează text area
            self.text_area.config(state='normal')  # ACTIVEAZĂ ÎNAINTE
            self.text_area.delete(1.0, tk.END)
            self.text_area.insert(1.0, "\n".join(content))
            self.text_area.config(state='disabled')  # DEZACTIVEAZĂ DUPĂ
            
            self.status_label.config(text=f"Viewing sheet: {sheet_name}")
            
        def setup_retro_style(self):
            """Configure retro Windows 95 style"""
            # Windows 95 colors
            bg_color = "#c0c0c0"  # Classic Windows 95 gray
            button_color = "#c0c0c0"
            text_bg = "#ffffff"
            
            self.rootofficereader.configure(bg=bg_color)
            
            # Configure style for widgets
            style = ttk.Style()
            style.theme_use('clam')
            
            # Customize styles
            style.configure('Retro.TButton', 
                           background=button_color,
                           relief='raised',
                           borderwidth=2)
            
            style.configure('Retro.TFrame', 
                           background=bg_color,
                           relief='raised',
                           borderwidth=1)
        
        def create_widgets(self):
            """Create interface widgets"""
            
            # Menu bar
            self.create_menu()
            
            # Toolbar
            self.create_toolbar()
            
            # Search bar
            self.create_search_bar()
            
            # Main frame
            main_frame = tk.Frame(self.rootofficereader, bg="#c0c0c0", relief='sunken', bd=2)
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Frame for file information
            info_frame = tk.Frame(main_frame, bg="#c0c0c0", relief='raised', bd=1)
            info_frame.pack(fill='x', padx=2, pady=2)
            
            tk.Label(info_frame, text="File:", bg="#c0c0c0", font=("MS Sans Serif", 8)).pack(side='left')
            self.file_label = tk.Label(info_frame, text="No file loaded", 
                                      bg="#c0c0c0", font=("MS Sans Serif", 8), fg="#000080")
            self.file_label.pack(side='left', padx=5)
            
            # Progress bar for loading
            self.progress = ttk.Progressbar(info_frame, mode='indeterminate', length=100)
            
            # Text area for content with monospace font for formatting
            text_frame = tk.Frame(main_frame, bg="#c0c0c0", relief='sunken', bd=2)
            text_frame.pack(fill='both', expand=True, padx=2, pady=2)
            
            self.text_area = scrolledtext.ScrolledText(
                text_frame,
                wrap=tk.NONE,  # No wrap to preserve formatting
                font=("Courier New", 9),  # Monospace font for alignment
                bg="#ffffff",
                fg="#000000",
                relief='sunken',
                bd=1,
                insertbackground="#000000",
            )
            self.text_area.pack(fill='both', expand=True, padx=2, pady=2)
            
            # Scrollbar vertical
            #v_scrollbar = tk.Scrollbar(text_frame, orient=tk.VERTICAL, command=self.text_area.yview)
            #self.text_area.configure(yscrollcommand=v_scrollbar.set)

            # Scrollbar orizontal
            h_scrollbar = tk.Scrollbar(text_frame, orient=tk.HORIZONTAL, command=self.text_area.xview)
            self.text_area.configure(xscrollcommand=h_scrollbar.set)

            # Plasează widget-urile cu grid
            self.text_area.grid(row=0, column=0, sticky='nsew', padx=2, pady=2)
            #v_scrollbar.grid(row=0, column=1, sticky='ns')
            h_scrollbar.grid(row=1, column=0, sticky='ew')

            # Configurează grid weights pentru redimensionare
            text_frame.grid_rowconfigure(0, weight=1)
            text_frame.grid_columnconfigure(0, weight=1)
            
            # Configure text tags for highlighting
            self.text_area.tag_configure("highlight", background="#ffff00", foreground="#000000")
            self.text_area.tag_configure("search_result", background="#00ff00", foreground="#000000")
            
            # Status bar
            self.create_status_bar()
        
        def create_menu(self):
            """Create retro menu bar"""
            menubar = tk.Menu(self.rootofficereader, bg="#c0c0c0", fg="#000000", 
                             activebackground="#0000ff", activeforeground="#ffffff")
            
            # File menu
            file_menu = tk.Menu(menubar, tearoff=0, bg="#c0c0c0", fg="#000000",
                               activebackground="#0000ff", activeforeground="#ffffff")
            file_menu.add_command(label="Open...", command=self.open_file, accelerator="Ctrl+O")
            file_menu.add_separator()
            file_menu.add_command(label="Export as Text...", command=self.export_text, accelerator="Ctrl+E")
            file_menu.add_command(label="Print Preview", command=self.print_preview)
            file_menu.add_separator()
            file_menu.add_command(label="Recent Files", command=self.show_recent_files)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootofficereader.quit, accelerator="Alt+F4")
            menubar.add_cascade(label="File", menu=file_menu)
            
            # Edit menu
            edit_menu = tk.Menu(menubar, tearoff=0, bg="#c0c0c0", fg="#000000",
                               activebackground="#0000ff", activeforeground="#ffffff")
            edit_menu.add_command(label="Find...", command=self.show_search, accelerator="Ctrl+F")
            edit_menu.add_command(label="Find Next", command=self.find_next, accelerator="F3")
            edit_menu.add_command(label="Select All", command=self.select_all, accelerator="Ctrl+A")
            edit_menu.add_command(label="Copy", command=self.copy_text, accelerator="Ctrl+C")
            menubar.add_cascade(label="Edit", menu=edit_menu)
            
            # View menu
            view_menu = tk.Menu(menubar, tearoff=0, bg="#c0c0c0", fg="#000000",
                               activebackground="#0000ff", activeforeground="#ffffff")
            view_menu.add_command(label="Clear Text", command=self.clear_text)
            view_menu.add_command(label="File Information", command=self.show_file_info)
            view_menu.add_command(label="Document Statistics", command=self.show_document_stats)
            view_menu.add_separator()
            #view_menu.add_command(label="Select Excel Sheet", command=self.select_excel_sheet)  # ADAUGĂ ACEASTĂ LINIE
            view_menu.add_separator()
            view_menu.add_command(label="Zoom In", command=self.zoom_in, accelerator="Ctrl++")
            view_menu.add_command(label="Zoom Out", command=self.zoom_out, accelerator="Ctrl+-")
            view_menu.add_command(label="Reset Zoom", command=self.reset_zoom, accelerator="Ctrl+0")
            menubar.add_cascade(label="View", menu=view_menu)
            
            # Tools menu
            tools_menu = tk.Menu(menubar, tearoff=0, bg="#c0c0c0", fg="#000000",
                                activebackground="#0000ff", activeforeground="#ffffff")
            tools_menu.add_command(label="Extract Images", command=self.extract_images)
            tools_menu.add_command(label="Extract Tables", command=self.extract_tables)
            tools_menu.add_command(label="Word Frequency", command=self.word_frequency)
            #tools_menu.add_command(label="Spell Check", command=self.spell_check)
            menubar.add_cascade(label="Tools", menu=tools_menu)
            
            # Help menu
            help_menu = tk.Menu(menubar, tearoff=0, bg="#c0c0c0", fg="#000000",
                               activebackground="#0000ff", activeforeground="#ffffff")
            help_menu.add_command(label="Supported Formats", command=self.show_supported_formats)
            help_menu.add_command(label="Keyboard Shortcuts", command=self.show_shortcuts)
            help_menu.add_command(label="About...", command=self.show_about)
            menubar.add_cascade(label="Help", menu=help_menu)
            
            self.rootofficereader.config(menu=menubar)
            
            # Keyboard shortcuts
            self.rootofficereader.bind('<Control-o>', lambda e: self.open_file())
            self.rootofficereader.bind('<Control-f>', lambda e: self.show_search())
            self.rootofficereader.bind('<Control-e>', lambda e: self.export_text())
            self.rootofficereader.bind('<Control-a>', lambda e: self.select_all())
            self.rootofficereader.bind('<Control-c>', lambda e: self.copy_text())
            self.rootofficereader.bind('<F3>', lambda e: self.find_next())
            self.rootofficereader.bind('<Control-plus>', lambda e: self.zoom_in())
            self.rootofficereader.bind('<Control-minus>', lambda e: self.zoom_out())
            self.rootofficereader.bind('<Control-0>', lambda e: self.reset_zoom())
            
            self.excel_menu_index = 4
        
        def show_excel_controls(self):
            """Show Excel-specific controls"""
            # Afișează butonul după butonul Info
            self.sheets_btn.pack(side='left', padx=2, pady=2, after=self.sheets_btn.master.children['!button4'])
            
            # Adaugă opțiunea în meniu
            try:
                self.view_menu.insert_command(self.excel_menu_index, 
                                             label="Select Excel Sheet", 
                                             command=self.select_excel_sheet)
            except:
                pass

        def hide_excel_controls(self):
            """Hide Excel-specific controls"""
            # Ascunde butonul
            self.sheets_btn.pack_forget()
            
            # Elimină opțiunea din meniu
            try:
                self.view_menu.delete(self.excel_menu_index)
            except:
                pass
        
        def show_excel_controls(self):
            """Show Excel-specific controls"""
            # Afișează butonul
            if not self.sheets_btn.winfo_ismapped():  # Verifică dacă nu e deja afișat
                self.sheets_btn.pack(side='left', padx=2, pady=2)
            
            # Adaugă opțiunea în meniu
            try:
                self.view_menu.insert_command(self.excel_menu_index, 
                                             label="Select Excel Sheet", 
                                             command=self.select_excel_sheet)
            except:
                pass
        
        def create_toolbar(self):
            """Create retro toolbar"""
            toolbar = tk.Frame(self.rootofficereader, bg="#c0c0c0", relief='raised', bd=1)
            toolbar.pack(fill='x', padx=2, pady=1)
            
            # Toolbar buttons
            open_btn = tk.Button(toolbar, text="Open", command=self.open_file,
                                bg="#c0c0c0", relief='raised', bd=2, 
                                font=("MS Sans Serif", 8), padx=10)
            open_btn.pack(side='left', padx=2, pady=2)
            
            export_btn = tk.Button(toolbar, text="Export", command=self.export_text,
                                  bg="#c0c0c0", relief='raised', bd=2,
                                  font=("MS Sans Serif", 8), padx=10)
            export_btn.pack(side='left', padx=2, pady=2)
            
            clear_btn = tk.Button(toolbar, text="Clear", command=self.clear_text,
                                 bg="#c0c0c0", relief='raised', bd=2,
                                 font=("MS Sans Serif", 8), padx=10)
            clear_btn.pack(side='left', padx=2, pady=2)
            
            # Separator
            separator = tk.Frame(toolbar, width=2, bg="#808080", relief='sunken', bd=1)
            separator.pack(side='left', fill='y', padx=5, pady=2)
            
            search_btn = tk.Button(toolbar, text="Search", command=self.show_search,
                                  bg="#c0c0c0", relief='raised', bd=2,
                                  font=("MS Sans Serif", 8), padx=10)
            search_btn.pack(side='left', padx=2, pady=2)
            
            info_btn = tk.Button(toolbar, text="Info", command=self.show_file_info,
                                bg="#c0c0c0", relief='raised', bd=2,
                                font=("MS Sans Serif", 8), padx=10)
            info_btn.pack(side='left', padx=2, pady=2)
            
            # Butonul sheets - CREEAZĂ dar nu-l afișa încă
            self.sheets_btn = tk.Button(toolbar, text="Sheets", command=self.select_excel_sheet,
                                       bg="#c0c0c0", relief='raised', bd=2,
                                       font=("MS Sans Serif", 8), padx=10)
            # NU apela pack() încă - va fi afișat doar când e nevoie
            
            # Separator
            separator2 = tk.Frame(toolbar, width=2, bg="#808080", relief='sunken', bd=1)
            separator2.pack(side='left', fill='y', padx=5, pady=2)
            
            zoom_out_btn = tk.Button(toolbar, text="Zoom Out -", command=self.zoom_out,
                                    bg="#c0c0c0", relief='raised', bd=2,
                                    font=("MS Sans Serif", 8), padx=5)
            zoom_out_btn.pack(side='left', padx=1, pady=2)
            
            zoom_in_btn = tk.Button(toolbar, text="Zoom In +", command=self.zoom_in,
                                   bg="#c0c0c0", relief='raised', bd=2,
                                   font=("MS Sans Serif", 8), padx=5)
            zoom_in_btn.pack(side='left', padx=1, pady=2)
        
        def create_search_bar(self):
            """Create search bar"""
            self.search_frame = tk.Frame(self.rootofficereader, bg="#c0c0c0", relief='raised', bd=1)
            
            tk.Label(self.search_frame, text="Search:", bg="#c0c0c0", 
                    font=("MS Sans Serif", 8)).pack(side='left', padx=5)
            
            self.search_var = tk.StringVar()
            self.search_entry = tk.Entry(self.search_frame, textvariable=self.search_var,
                                        font=("MS Sans Serif", 9), width=30)
            self.search_entry.pack(side='left', padx=2)
            
            search_btn = tk.Button(self.search_frame, text="Find", command=self.perform_search,
                                  bg="#c0c0c0", relief='raised', bd=1,
                                  font=("MS Sans Serif", 8))
            search_btn.pack(side='left', padx=2)
            
            next_btn = tk.Button(self.search_frame, text="Next", command=self.find_next,
                                bg="#c0c0c0", relief='raised', bd=1,
                                font=("MS Sans Serif", 8))
            next_btn.pack(side='left', padx=2)
            
            close_btn = tk.Button(self.search_frame, text="✕", command=self.hide_search,
                                 bg="#c0c0c0", relief='raised', bd=1,
                                 font=("MS Sans Serif", 8), width=2)
            close_btn.pack(side='right', padx=5)
            
            self.search_results_label = tk.Label(self.search_frame, text="", 
                                               bg="#c0c0c0", font=("MS Sans Serif", 8))
            self.search_results_label.pack(side='right', padx=10)
            
            # Bind Enter key to search
            self.search_entry.bind('<Return>', lambda e: self.perform_search())
        
        def create_status_bar(self):
            """Create retro status bar"""
            self.status_bar = tk.Frame(self.rootofficereader, bg="#c0c0c0", relief='sunken', bd=1)
            self.status_bar.pack(fill='x', side='bottom')
            
            self.status_label = tk.Label(self.status_bar, text="Ready", 
                                        bg="#c0c0c0", font=("MS Sans Serif", 8),
                                        anchor='w')
            self.status_label.pack(side='left', padx=5, pady=2)
            
            # Information on the right
            self.file_type_label = tk.Label(self.status_bar, text="", 
                                           bg="#c0c0c0", font=("MS Sans Serif", 8))
            self.file_type_label.pack(side='right', padx=5, pady=2)
            
            self.zoom_label = tk.Label(self.status_bar, text="100%", 
                                      bg="#c0c0c0", font=("MS Sans Serif", 8))
            self.zoom_label.pack(side='right', padx=5, pady=2)
            
            # Current zoom level
            self.current_zoom = 100
        
        def show_search(self):
            """Show search bar"""
            self.search_frame.pack(fill='x', padx=2, pady=1, after=self.status_bar.master.children['!frame'])
            self.search_entry.focus()
        
        def hide_search(self):
            """Hide search bar"""
            self.search_frame.pack_forget()
            self.clear_search_highlights()
        
        def perform_search(self):
            """Perform text search"""
            search_term = self.search_var.get().strip()
            if not search_term or not self.file_content:
                return
            
            # Clear previous highlights
            self.clear_search_highlights()
            
            # Find all occurrences
            self.search_results = []
            text_content = self.text_area.get(1.0, tk.END)
            
            start_pos = 0
            while True:
                pos = text_content.lower().find(search_term.lower(), start_pos)
                if pos == -1:
                    break
                
                # Convert to tkinter text widget coordinates
                lines_before = text_content[:pos].count('\n')
                char_in_line = pos - text_content.rfind('\n', 0, pos) - 1
                
                start_index = f"{lines_before + 1}.{char_in_line}"
                end_index = f"{lines_before + 1}.{char_in_line + len(search_term)}"
                
                self.search_results.append((start_index, end_index))
                start_pos = pos + 1
            
            # Highlight all results
            for start, end in self.search_results:
                self.text_area.tag_add("search_result", start, end)
            
            # Update results label
            if self.search_results:
                self.current_search_index = 0
                self.search_results_label.config(text=f"1/{len(self.search_results)}")
                # Scroll to first result
                self.text_area.see(self.search_results[0][0])
            else:
                self.search_results_label.config(text="Not found")
        
        def find_next(self):
            """Find next search result"""
            if not self.search_results:
                return
            
            self.current_search_index = (self.current_search_index + 1) % len(self.search_results)
            start, end = self.search_results[self.current_search_index]
            
            # Scroll to result
            self.text_area.see(start)
            
            # Update counter
            self.search_results_label.config(
                text=f"{self.current_search_index + 1}/{len(self.search_results)}"
            )
        
        def clear_search_highlights(self):
            """Clear search highlights"""
            self.text_area.tag_remove("search_result", 1.0, tk.END)
        
        def open_file(self):
            """Open and read an Office file"""
            file_types = [
                ("All Supported", "*.docx;*.xlsx;*.pptx;*.pdf;*.rtf;*.txt"),
                ("Word Documents", "*.docx"),
                ("Excel Spreadsheets", "*.xlsx"),
                ("PowerPoint Presentations", "*.pptx"),
            ]
            
            if PDF_SUPPORT:
                file_types.append(("PDF Documents", "*.pdf"))
            if RTF_SUPPORT:
                file_types.append(("RTF Documents", "*.rtf"))
            
            file_types.extend([
                ("Text Files", "*.txt"),
                ("All Files", "*.*")
            ])
            
            filename = filedialog.askopenfilename(
                title="Open Office File",
                filetypes=file_types
            )
            
            if filename:
                self.current_file = filename
                self.file_label.config(text=os.path.basename(filename))
                
                # Show progress bar
                self.progress.pack(side='right', padx=5)
                self.progress.start()
                self.status_label.config(text="Loading file...")
                
                # Load file in separate thread to prevent UI freezing
                threading.Thread(target=self.load_file_thread, args=(filename,), daemon=True).start()
        
        def load_file_thread(self, filename):
            """Load file in separate thread"""
            try:
                content = self.read_office_file(filename)
                
                # Update UI in main thread
                self.rootofficereader.after(0, self.file_loaded_callback, content, filename)
                
            except Exception as e:
                self.rootofficereader.after(0, self.file_error_callback, str(e))
        
        def file_loaded_callback(self, content, filename):
            """Callback when file is loaded successfully"""
            self.progress.stop()
            self.progress.pack_forget()
            
            self.file_content = content
            self.text_area.config(state='normal')
            self.text_area.delete(1.0, tk.END)
            self.text_area.insert(1.0, content)
            self.text_area.config(state='disabled')
            
            # Update status
            file_ext = Path(filename).suffix.upper()
            self.file_type_label.config(text=f"Type: {file_ext}")
            self.status_label.config(text="File loaded successfully")
            
            # Controlează vizibilitatea controalelor Excel
            if file_ext == '.XLSX':
                self.show_excel_controls()
            else:
                self.hide_excel_controls()
        
        def file_error_callback(self, error_message):
            """Callback when file loading fails"""
            self.progress.stop()
            self.progress.pack_forget()
            
            messagebox.showerror("Error", f"Could not read file:\n{error_message}")
            self.status_label.config(text="Error loading file")
        
        def read_office_file(self, filename):
            """Read content from an Office file"""
            file_ext = Path(filename).suffix.lower()
            
            if file_ext == '.docx':
                return self.read_word_file(filename)
            elif file_ext == '.xlsx':
                return self.read_excel_file(filename)
            elif file_ext == '.pptx':
                return self.read_powerpoint_file(filename)
            elif file_ext == '.pdf' and PDF_SUPPORT:
                return self.read_pdf_file(filename)
            elif file_ext == '.rtf' and RTF_SUPPORT:
                return self.read_rtf_file(filename)
            elif file_ext == '.txt':
                return self.read_text_file(filename)
            else:
                raise ValueError(f"Unsupported file type: {file_ext}")
        
        def read_word_file(self, filename):
            """Read a Word file (.docx) with enhanced error handling"""
            try:
                # Încercare normală
                doc = Document(filename)
                return self._process_word_document(doc, filename)
            
            except Exception as e:
                if "no relationship of type" in str(e).lower():
                    try:
                        # Metodă alternativă - citește ca ZIP și extrage textul manual
                        import zipfile
                        import xml.etree.ElementTree as ET
                        
                        content = []
                        content.append("=" * 80)
                        content.append("WORD DOCUMENT (Manual Extraction)")
                        content.append("=" * 80)
                        content.append("")
                        
                        with zipfile.ZipFile(filename, 'r') as docx:
                            # Extrage document.xml
                            try:
                                xml_content = docx.read('word/document.xml')
                                rootofficereader = ET.fromstring(xml_content)
                                
                                # Găsește toate textele
                                for elem in rootofficereader.iter():
                                    if elem.text:
                                        text = elem.text.strip()
                                        if text and len(text) > 1:
                                            content.append(text)
                            except:
                                # Dacă nu merge nici așa, încearcă să citești orice text din ZIP
                                for file_name in docx.namelist():
                                    if 'document' in file_name and file_name.endswith('.xml'):
                                        try:
                                            xml_data = docx.read(file_name).decode('utf-8')
                                            # Extrage text simplu folosind regex
                                            import re
                                            texts = re.findall(r'>([^<>]+)<', xml_data)
                                            for text in texts:
                                                if len(text.strip()) > 3:
                                                    content.append(text.strip())
                                        except:
                                            continue
                        
                        return "\n".join(content) if len(content) > 4 else "Could not extract text from document"
                        
                    except Exception as e2:
                        return f"Error reading Word file: {str(e2)}"
                else:
                    return f"Error reading Word file: {str(e)}"

        def _process_word_document(self, doc, filename):
            """Process a successfully opened Word document"""
            content = []
            
            # Document properties
            props = doc.core_properties
            content.append("=" * 80)
            content.append("WORD DOCUMENT")
            content.append("=" * 80)
            if props.title:
                content.append(f"Title: {props.title}")
            if props.author:
                content.append(f"Author: {props.author}")
            if props.created:
                content.append(f"Created: {props.created}")
            content.append("")
            
            # Rest of your existing _process_word_document code...
            # (copiază restul codului din metoda read_word_file originală)
            
            for paragraph in doc.paragraphs:
                para_text = ""
                for run in paragraph.runs:
                    text = run.text
                    if run.bold:
                        text = f"**{text}**"
                    if run.italic:
                        text = f"*{text}*"
                    if run.underline:
                        text = f"_{text}_"
                    para_text += text
                
                if para_text.strip():
                    if paragraph.alignment is not None:
                        alignment = str(paragraph.alignment)
                        if "CENTER" in alignment:
                            para_text = f"        {para_text}"
                        elif "RIGHT" in alignment:
                            para_text = f"                    {para_text}"
                    content.append(para_text)
                else:
                    content.append("")
            
            # Process tables (restul codului pentru tabele...)
            for table in doc.tables:
                content.append("\n" + "="*60)
                content.append("TABLE")
                content.append("="*60)
                
                table_data = []
                for row in table.rows:
                    row_data = []
                    for cell in row.cells:
                        cell_text = cell.text.strip()
                        row_data.append(cell_text)
                    table_data.append(row_data)
                
                if table_data:
                    num_cols = len(table_data[0])
                    max_widths = [0] * num_cols
                    
                    for row_data in table_data:
                        for i, cell_text in enumerate(row_data):
                            if i < len(max_widths):
                                max_widths[i] = max(max_widths[i], len(cell_text))
                    
                    for i, row_data in enumerate(table_data):
                        formatted_row = ""
                        for j, cell_text in enumerate(row_data):
                            if j < len(max_widths):
                                width = max(max_widths[j], 10)
                                formatted_row += cell_text.ljust(width + 2)
                        content.append(formatted_row)
                        
                        if i == 0:
                            separator = ""
                            for width in max_widths:
                                separator += "-" * (max(width, 10) + 2)
                            content.append(separator)
            
            return "\n".join(content)

        def read_excel_file(self, filename):
            """Read an Excel file (.xlsx) with advanced processing"""
            if PANDAS_SUPPORT:
                return self.read_excel_with_pandas(filename)
            else:
                return self.read_excel_basic(filename)
        
        def read_excel_with_pandas(self, filename):
            """Read Excel with pandas for better data handling"""
            content = []
            
            try:
                # Read all sheets
                excel_file = pd.ExcelFile(filename)
                
                # Salvează informațiile despre sheet-uri pentru accesul ulterior
                self.excel_sheets = {}
                self.excel_file_path = filename
                
                content.append("=" * 80)
                content.append("EXCEL WORKBOOK")
                content.append("=" * 80)
                content.append(f"Total sheets: {len(excel_file.sheet_names)}")
                content.append("")
                content.append("Available sheets:")
                for i, sheet_name in enumerate(excel_file.sheet_names, 1):
                    content.append(f"  {i}. {sheet_name}")
                content.append("")
                content.append("Click 'View' > 'Select Sheet' to open a specific sheet")
                content.append("=" * 80)
                content.append("")
                
                # Citește toate sheet-urile și le salvează
                for sheet_name in excel_file.sheet_names:
                    df = pd.read_excel(filename, sheet_name=sheet_name)
                    self.excel_sheets[sheet_name] = df
                    
                    content.append("■" * 60)
                    content.append(f"SHEET: {sheet_name}")
                    content.append("■" * 60)
                    content.append(f"Rows: {len(df)}, Columns: {len(df.columns)}")
                    content.append("")
                    
                    if not df.empty:
                        # ELIMINĂ TOATE LIMITĂRILE - afișează totul
                        content.append(df.to_string(index=False, max_rows=None, max_cols=None))
                    else:
                        content.append("(Empty sheet)")
                    
                    content.append("")
                        
            except Exception as e:
                content.append(f"Error reading with pandas: {e}")
                return self.read_excel_basic(filename)
            
            return "\n".join(content)
        
        def read_excel_basic(self, filename):
            """Basic Excel reading without pandas"""
            workbook = openpyxl.load_workbook(filename, data_only=True)
            content = []
            
            for sheet_name in workbook.sheetnames:
                sheet = workbook[sheet_name]
                
                # Header for current sheet
                content.append("=" * 80)
                content.append(f"SHEET: {sheet_name}")
                content.append("=" * 80)
                content.append("")
                
                # Find useful dimensions of the sheet
                max_row = sheet.max_row
                max_col = sheet.max_column
                
                # Collect all data to calculate column widths
                sheet_data = []
                col_widths = [0] * max_col
                
                # ELIMINĂ LIMITAREA DE 100 DE RÂNDURI - citește toate rândurile
                for row_num in range(1, max_row + 1):
                    row_data = []
                    for col_num in range(1, max_col + 1):
                        cell = sheet.cell(row=row_num, column=col_num)
                        
                        # Format cell value
                        if cell.value is None:
                            cell_text = ""
                        elif isinstance(cell.value, (int, float)):
                            # Preserve number formatting
                            if cell.number_format and cell.number_format != 'General':
                                try:
                                    # Try to apply formatting
                                    if '%' in cell.number_format:
                                        cell_text = f"{cell.value:.2%}"
                                    elif "$" in cell.number_format or "EUR" in cell.number_format or '€' in cell.number_format:
                                        cell_text = f"{cell.value:.2f}"
                                    else:
                                        cell_text = str(cell.value)
                                except:
                                    cell_text = str(cell.value)
                            else:
                                cell_text = str(cell.value)
                        else:
                            cell_text = str(cell.value)
                        
                        row_data.append(cell_text)
                        
                        # Update column width
                        col_widths[col_num - 1] = max(col_widths[col_num - 1], len(cell_text))
                    
                    # Add row only if it has data
                    if any(cell.strip() for cell in row_data if cell):
                        sheet_data.append(row_data)
                
                # Format and display data as table
                if sheet_data:
                    # Adjust minimum widths
                    col_widths = [max(width, 8) for width in col_widths]
                    
                    # Create column headers
                    header_row = ""
                    for i, width in enumerate(col_widths):
                        header_row += f"Col{i+1}".ljust(width + 2)
                    content.append(header_row)
                    
                    # Separator line
                    separator = ""
                    for width in col_widths:
                        separator += "-" * (width + 2)
                    content.append(separator)
                    
                    # AFIȘEAZĂ TOATE RÂNDURILE - elimină limitarea
                    for row_data in sheet_data:
                        formatted_row = ""
                        for i, cell_text in enumerate(row_data):
                            if i < len(col_widths):
                                formatted_row += cell_text.ljust(col_widths[i] + 2)
                        content.append(formatted_row)
                        
                    # ELIMINĂ MESAJUL "... and X more rows"
                else:
                    content.append("(Empty sheet)")
                
                content.append("")  # Space between sheets
            
            return "\n".join(content)
        
        def read_powerpoint_file(self, filename):
            """Read a PowerPoint file (.pptx) preserving structure"""
            prs = Presentation(filename)
            content = []
            
            content.append("=" * 80)
            content.append("POWERPOINT PRESENTATION")
            content.append("=" * 80)
            content.append(f"Total slides: {len(prs.slides)}")
            content.append("")
            
            for slide_num, slide in enumerate(prs.slides, 1):
                # Header for slide
                content.append("■" * 60)
                content.append(f"SLIDE {slide_num}")
                content.append("■" * 60)
                content.append("")
                
                # Identify and separate content types
                titles = []
                text_blocks = []
                bullet_points = []
                
                for shape in slide.shapes:
                    if not hasattr(shape, "text"):
                        continue
                        
                    shape_text = shape.text.strip()
                    if not shape_text:
                        continue
                    
                    # Detect titles and organize content
                    if hasattr(shape, 'text_frame') and shape.text_frame:
                        paragraphs = list(shape.text_frame.paragraphs)
                        
                        for para_idx, paragraph in enumerate(paragraphs):
                            para_text = paragraph.text.strip()
                            if not para_text:
                                continue
                            
                            # Detect if it's a title (first paragraph or short text)
                            if para_idx == 0 and len(para_text) < 100:
                                titles.append(para_text)
                            else:
                                # Detect bullet points
                                if paragraph.level > 0 or para_text.startswith(('•', '-', '*', 'o')):
                                    indent = "    " * paragraph.level
                                    bullet_points.append(f"{indent}• {para_text}")
                                else:
                                    # Normal text
                                    if len(para_text) > 100:  # Long text
                                        text_blocks.append(para_text)
                                    elif para_text not in titles:  # Avoid duplicates
                                        text_blocks.append(para_text)
                
                # Display organized content
                if titles:
                    for title in titles:
                        content.append(f"TITLE: {title.upper()}")
                        content.append("")
                
                if text_blocks:
                    for text in text_blocks:
                        content.append(text)
                        content.append("")
                
                if bullet_points:
                    content.append("KEY POINTS:")
                    for bullet in bullet_points:
                        content.append(bullet)
                    content.append("")
                
                # If nothing organized was found, display raw text
                if not (titles or text_blocks or bullet_points):
                    for shape in slide.shapes:
                        if hasattr(shape, "text") and shape.text.strip():
                            content.append(shape.text.strip())
                            content.append("")
                
                content.append("")  # Space between slides
            
            return "\n".join(content)
        
        def read_pdf_file(self, filename):
            """Read a PDF file"""
            content = []
            
            try:
                # Try PyMuPDF first (better text extraction)
                doc = fitz.open(filename)
                
                content.append("=" * 80)
                content.append("PDF DOCUMENT")
                content.append("=" * 80)
                content.append(f"Total pages: {len(doc)}")
                content.append("")
                
                for page_num in range(len(doc)):
                    page = doc.load_page(page_num)
                    page_text = page.get_text()
                    
                    content.append(f"PAGE {page_num + 1}")
                    content.append("-" * 20)
                    content.append(page_text)
                    content.append("")
                
                doc.close()
                
            except:
                # Fallback to PyPDF2
                try:
                    with open(filename, 'rb') as file:
                        pdf_reader = PyPDF2.PdfReader(file)
                        
                        content.append("=" * 80)
                        content.append("PDF DOCUMENT")
                        content.append("=" * 80)
                        content.append(f"Total pages: {len(pdf_reader.pages)}")
                        content.append("")
                        
                        for page_num, page in enumerate(pdf_reader.pages):
                            page_text = page.extract_text()
                            
                            content.append(f"PAGE {page_num + 1}")
                            content.append("-" * 20)
                            content.append(page_text)
                            content.append("")
                except Exception as e:
                    raise Exception(f"Could not read PDF: {e}")
            
            return "\n".join(content)
        
        def read_rtf_file(self, filename):
            """Read an RTF file"""
            with open(filename, 'r', encoding='utf-8') as file:
                rtf_content = file.read()
            
            plain_text = rtf_to_text(rtf_content)
            
            content = []
            content.append("=" * 80)
            content.append("RTF DOCUMENT")
            content.append("=" * 80)
            content.append("")
            content.append(plain_text)
            
            return "\n".join(content)
        
        def read_text_file(self, filename):
            """Read a plain text file"""
            encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
            
            for encoding in encodings:
                try:
                    with open(filename, 'r', encoding=encoding) as file:
                        content = file.read()
                        
                    header = []
                    header.append("=" * 80)
                    header.append("TEXT DOCUMENT")
                    header.append("=" * 80)
                    header.append(f"Encoding: {encoding}")
                    header.append("")
                    
                    return "\n".join(header) + content
                except UnicodeDecodeError:
                    continue
            
            raise Exception("Could not decode text file with any supported encoding")
        
        # Additional features
        def export_text(self):
            """Export current content as text file"""
            if not self.file_content:
                messagebox.showwarning("Warning", "No content to export")
                return
            
            filename = filedialog.asksaveasfilename(
                title="Export as Text",
                defaultextension=".txt",
                filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
            )
            
            if filename:
                try:
                    with open(filename, 'w', encoding='utf-8') as file:
                        file.write(self.file_content)
                    messagebox.showinfo("Success", "File exported successfully")
                except Exception as e:
                    messagebox.showerror("Error", f"Could not export file:\n{e}")
        
        def zoom_in(self):
            """Increase font size"""
            self.current_zoom += 10
            if self.current_zoom > 200:
                self.current_zoom = 200
            
            font_size = int(9 * (self.current_zoom / 100))
            self.text_area.configure(font=("Courier New", font_size))
            self.zoom_label.config(text=f"{self.current_zoom}%")
        
        def zoom_out(self):
            """Decrease font size"""
            self.current_zoom -= 10
            if self.current_zoom < 50:
                self.current_zoom = 50
            
            font_size = int(9 * (self.current_zoom / 100))
            self.text_area.configure(font=("Courier New", font_size))
            self.zoom_label.config(text=f"{self.current_zoom}%")
        
        def reset_zoom(self):
            """Reset zoom to 100%"""
            self.current_zoom = 100
            self.text_area.configure(font=("Courier New", 9))
            self.zoom_label.config(text="100%")
        
        def select_all(self):
            """Select all text"""
            self.text_area.tag_add(tk.SEL, "1.0", tk.END)
            self.text_area.mark_set(tk.INSERT, "1.0")
            self.text_area.see(tk.INSERT)
        
        def copy_text(self):
            """Copy selected text to clipboard"""
            try:
                selected_text = self.text_area.selection_get()
                self.rootofficereader.clipboard_clear()
                self.rootofficereader.clipboard_append(selected_text)
            except tk.TclError:
                # No selection, copy all
                self.rootofficereader.clipboard_clear()
                self.rootofficereader.clipboard_append(self.text_area.get(1.0, tk.END))
        
        def show_document_stats(self):
            """Show document statistics"""
            if not self.file_content:
                messagebox.showinfo("Statistics", "No document loaded")
                return
            
            # Calculate statistics
            text = self.file_content
            lines = len(text.split('\n'))
            words = len(text.split())
            chars = len(text)
            chars_no_spaces = len(text.replace(' ', '').replace('\n', '').replace('\t', ''))
            
            # Most common words
            word_freq = {}
            for word in text.lower().split():
                # Clean word
                word = re.sub(r'[^\w]', '', word)
                if len(word) > 3:  # Only words longer than 3 characters
                    word_freq[word] = word_freq.get(word, 0) + 1
            
            top_words = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:10]
            
            stats = f"""Document Statistics:

    Lines: {lines:,}
    Words: {words:,}
    Characters: {chars:,}
    Characters (no spaces): {chars_no_spaces:,}

    Most Common Words:
    """
            
            for word, count in top_words:
                stats += f"  {word}: {count}\n"
            
            # Show in a new window
            stats_window = tk.Toplevel(self.rootofficereader)
            stats_window.title("Document Statistics")
            stats_window.geometry("400x500")
            stats_window.configure(bg="#c0c0c0")
            
            text_widget = scrolledtext.ScrolledText(stats_window, wrap=tk.WORD,
                                                  font=("MS Sans Serif", 9),
                                                  bg="#ffffff", fg="#000000")
            text_widget.pack(fill='both', expand=True, padx=10, pady=10)
            text_widget.insert(1.0, stats)
            text_widget.configure(state='disabled')
        
        def word_frequency(self):
            """Show word frequency analysis"""
            if not self.file_content:
                messagebox.showinfo("Word Frequency", "No document loaded")
                return
            
            # Calculate word frequency
            words = re.findall(r'\b\w+\b', self.file_content.lower())
            word_freq = {}
            
            for word in words:
                if len(word) > 2:  # Only words longer than 2 characters
                    word_freq[word] = word_freq.get(word, 0) + 1
            
            # Sort by frequency
            sorted_words = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)
            
            # Show in new window
            freq_window = tk.Toplevel(self.rootofficereader)
            freq_window.title("Word Frequency Analysis")
            freq_window.geometry("500x600")
            freq_window.configure(bg="#c0c0c0")
            
            # Create text widget with scrollbar
            text_widget = scrolledtext.ScrolledText(freq_window, wrap=tk.NONE,
                                                  font=("Courier New", 9),
                                                  bg="#ffffff", fg="#000000")
            text_widget.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Add content
            content = f"Word Frequency Analysis ({len(sorted_words)} unique words)\n"
            content += "=" * 50 + "\n\n"
            content += f"{'Word':<20} {'Count':<10} {'Percentage':<10}\n"
            content += "-" * 50 + "\n"
            
            total_words = sum(word_freq.values())
            for word, count in sorted_words[:100]:  # Top 100 words
                percentage = (count / total_words) * 100
                content += f"{word:<20} {count:<10} {percentage:<10.2f}%\n"
            
            text_widget.insert(1.0, content)
            text_widget.configure(state='disabled')
        
        def extract_images(self):
            """Extract images from document"""
            if not self.current_file:
                messagebox.showinfo("Extract Images", "No file loaded")
                return
            
            try:
                file_ext = Path(self.current_file).suffix.lower()
                
                if file_ext == '.docx':
                    self.extract_images_from_docx()
                elif file_ext == '.pptx':
                    self.extract_images_from_pptx()
                else:
                    messagebox.showinfo("Extract Images", f"Image extraction not supported for {file_ext} files")
            
            except Exception as e:
                messagebox.showerror("Error", f"Could not extract images:\n{e}")
        
        def extract_images_from_docx(self):
            """Extract images from Word document"""
            doc = Document(self.current_file)
            
            # Create output directory
            file_stem = Path(self.current_file).stem
            output_dir = Path(self.current_file).parent / f"{file_stem}_images"
            output_dir.mkdir(exist_ok=True)
            
            image_count = 0
            
            # Extract images from document
            for rel in doc.part.rels.values():
                if "image" in rel.target_ref:
                    image_data = rel.target_part.blob
                    image_ext = rel.target_ref.split('.')[-1]
                    
                    image_path = output_dir / f"image_{image_count + 1}.{image_ext}"
                    with open(image_path, 'wb') as img_file:
                        img_file.write(image_data)
                    
                    image_count += 1
            
            if image_count > 0:
                messagebox.showinfo("Success", f"Extracted {image_count} images to:\n{output_dir}")
            else:
                messagebox.showinfo("No Images", "No images found in the document")
        
        def extract_images_from_pptx(self):
            """Extract images from PowerPoint presentation"""
            prs = Presentation(self.current_file)
            
            # Create output directory
            file_stem = Path(self.current_file).stem
            output_dir = Path(self.current_file).parent / f"{file_stem}_images"
            output_dir.mkdir(exist_ok=True)
            
            image_count = 0
            
            # Extract images from presentation
            for slide_num, slide in enumerate(prs.slides):
                for shape in slide.shapes:
                    if hasattr(shape, 'image'):
                        image = shape.image
                        image_bytes = image.blob
                        image_ext = image.ext
                        
                        image_path = output_dir / f"slide_{slide_num + 1}_image_{image_count + 1}.{image_ext}"
                        with open(image_path, 'wb') as img_file:
                            img_file.write(image_bytes)
                        
                        image_count += 1
            
            if image_count > 0:
                messagebox.showinfo("Success", f"Extracted {image_count} images to:\n{output_dir}")
            else:
                messagebox.showinfo("No Images", "No images found in the presentation")
        
        def extract_tables(self):
            """Extract tables from document as CSV"""
            if not self.current_file:
                messagebox.showinfo("Extract Tables", "No file loaded")
                return
            
            try:
                file_ext = Path(self.current_file).suffix.lower()
                
                if file_ext == '.docx':
                    self.extract_tables_from_docx()
                elif file_ext == '.xlsx':
                    messagebox.showinfo("Info", "Excel files are already in table format")
                else:
                    messagebox.showinfo("Extract Tables", f"Table extraction not supported for {file_ext} files")
            
            except Exception as e:
                messagebox.showerror("Error", f"Could not extract tables:\n{e}")
        
        def extract_tables_from_docx(self):
            """Extract tables from Word document as CSV"""
            doc = Document(self.current_file)
            
            if not doc.tables:
                messagebox.showinfo("No Tables", "No tables found in the document")
                return
            
            # Create output directory
            file_stem = Path(self.current_file).stem
            output_dir = Path(self.current_file).parent / f"{file_stem}_tables"
            output_dir.mkdir(exist_ok=True)
            
            table_count = 0
            
            for table_num, table in enumerate(doc.tables):
                table_data = []
                
                for row in table.rows:
                    row_data = []
                    for cell in row.cells:
                        row_data.append(cell.text.strip())
                    table_data.append(row_data)
                
                if table_data:
                    csv_path = output_dir / f"table_{table_num + 1}.csv"
                    
                    with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                        import csv
                        writer = csv.writer(csvfile)
                        writer.writerows(table_data)
                    
                    table_count += 1
            
            if table_count > 0:
                messagebox.showinfo("Success", f"Extracted {table_count} tables to:\n{output_dir}")
            else:
                messagebox.showinfo("No Tables", "No tables found in the document")
        
        def spell_check(self):
            """Basic spell check (placeholder)"""
            messagebox.showinfo("Spell Check", "Spell check feature would require additional libraries like pyspellchecker")
        
        def print_preview(self):
            """Show print preview"""
            if not self.file_content:
                messagebox.showinfo("Print Preview", "No document loaded")
                return
            
            # Create print preview window
            preview_window = tk.Toplevel(self.rootofficereader)
            preview_window.title("Print Preview")
            preview_window.geometry("700x900")
            preview_window.configure(bg="#c0c0c0")
            
            # Create text widget with print-like appearance
            text_widget = scrolledtext.ScrolledText(preview_window, wrap=tk.WORD,
                                                  font=("Times New Roman", 10),
                                                  bg="#ffffff", fg="#000000",
                                                  padx=50, pady=50)
            text_widget.pack(fill='both', expand=True, padx=20, pady=20)
            text_widget.insert(1.0, self.file_content)
            text_widget.configure(state='disabled')
            
            # Print button
            print_btn = tk.Button(preview_window, text="Print", 
                                 bg="#c0c0c0", relief='raised', bd=2,
                                 font=("MS Sans Serif", 8),
                                 command=lambda: messagebox.showinfo("Print", "Printing would require additional print libraries"))
            print_btn.pack(pady=10)
        
        def show_recent_files(self):
            """Show recent files (placeholder)"""
            messagebox.showinfo("Recent Files", "Recent files feature not implemented yet")
        
        def show_supported_formats(self):
            """Show supported file formats"""
            formats = """Supported File Formats:

    ✓ Microsoft Word (.docx)
    ✓ Microsoft Excel (.xlsx)
    ✓ Microsoft PowerPoint (.pptx)
    ✓ Plain Text (.txt)"""
            
            if PDF_SUPPORT:
                formats += "\n✓ PDF Documents (.pdf)"
            if RTF_SUPPORT:
                formats += "\n✓ Rich Text Format (.rtf)"
            
            formats += "\n\nLibrary Status:"
            formats += f"\n• Office Support: {'✓' if OFFICE_SUPPORT else '✗'}"
            formats += f"\n• PDF Support: {'✓' if PDF_SUPPORT else '✗'}"
            formats += f"\n• RTF Support: {'✓' if RTF_SUPPORT else '✗'}"
            formats += f"\n• Pandas Support: {'✓' if PANDAS_SUPPORT else '✗'}"
            
            messagebox.showinfo("Supported Formats", formats)
        
        def show_shortcuts(self):
            """Show keyboard shortcuts"""
            shortcuts = """Keyboard Shortcuts:

    File Operations:
      Ctrl+O    Open file
      Ctrl+E    Export as text
      Alt+F4    Exit

    Edit Operations:
      Ctrl+F    Find/Search
      F3        Find next
      Ctrl+A    Select all
      Ctrl+C    Copy

    View Operations:
      Ctrl++    Zoom in
      Ctrl+-    Zoom out
      Ctrl+0    Reset zoom"""
            
            messagebox.showinfo("Keyboard Shortcuts", shortcuts)
        
        def clear_text(self):
            """Clear text area"""
            self.text_area.config(state='normal')
            self.text_area.delete(1.0, tk.END)
            self.text_area.config(state='disabled')
            self.current_file = None
            self.file_content = ""
            self.file_label.config(text="No file loaded")
            self.file_type_label.config(text="")
            self.status_label.config(text="Text cleared")
            self.clear_search_highlights()
            
            # Ascunde controalele Excel
            self.hide_excel_controls()
            
            # Resetează datele Excel
            self.excel_sheets = {}
            self.excel_file_path = None
        
        def show_file_info(self):
            """Show information about current file"""
            if not self.current_file:
                messagebox.showinfo("Information", "No file loaded")
                return
            
            file_path = Path(self.current_file)
            file_size = file_path.stat().st_size
            modified_time = datetime.fromtimestamp(file_path.stat().st_mtime)
            
            newline = '\n'
            info = f"""File Information:

    Name: {file_path.name}
    Location: {file_path.parent}
    Size: {file_size:,} bytes
    Type: {file_path.suffix.upper()}
    Modified: {modified_time.strftime('%Y-%m-%d %H:%M:%S')}

    Content Statistics:
    Lines: {len(self.file_content.split(newline)):,}
    Words: {len(self.file_content.split()):,}
    Characters: {len(self.file_content):,}
    """
            
            messagebox.showinfo("File Information", info)
        
        def show_about(self):
            """Show About dialog"""
            about_text = """Office Reader v2.0

    A powerful reader for Office files with advanced features:

    Supported Formats:
    • Microsoft Word (.docx)
    • Microsoft Excel (.xlsx)  
    • Microsoft PowerPoint (.pptx)
    • PDF Documents (.pdf) *
    • Rich Text Format (.rtf) *
    • Plain Text (.txt)

    Features:
    • Advanced text search
    • Document statistics
    • Word frequency analysis
    • Image extraction
    • Table extraction
    • Export functionality
    • Zoom controls
    • Print preview

    * Requires additional libraries

    © 2024 - Tudor Marmureanu"""
            
            messagebox.showinfo("About Enhanced Office Reader", about_text)
        
        def show_install_instructions(self):
            """Show installation instructions for Office libraries"""
            instructions = """To read Office files, install required libraries:

    Basic Office support:
    pip install python-docx openpyxl python-pptx

    Enhanced Excel support:
    pip install pandas

    PDF support:
    pip install PyPDF2 PyMuPDF

    RTF support:
    pip install striprtf

    Then restart the application."""
            
            messagebox.showwarning("Missing Libraries", instructions)
        
        def run(self):
            """Start the application"""
            self.status_label.config(text="Ready - Open an Office file to begin")
            self.rootofficereader.mainloop()

    if __name__ == "__main__":
        app = EnhancedOfficeReader()
        app.run()
        
if hardmvar == 1994:
    import tkinter as tk
    from tkinter import ttk
    import psutil
    import threading
    import time
    from datetime import datetime
    import platform

    try:
        import GPUtil
        gpu_available = True
    except ImportError:
        gpu_available = False

    class CyberpunkSystemMonitor:
        def __init__(self, roothwmn):
            self.roothwmn = roothwmn
            self.roothwmn.title("Hardware Monitor")
            self.roothwmn.geometry("800x800")
            self.roothwmn.resizable(True, True)
            
            # Set window to always be on top
            self.roothwmn.attributes('-topmost', True)
            
            # Cyberpunk neon colors (dark theme)
            self.colors = {
                "bg": "#0f111a",           # Very dark background
                "card_bg": "#1a1c25",      # Slightly lighter card background
                "text": "#ffffff",         # Main white text
                "subtitle": "#8a8d98",     # Secondary light gray text
                "accent": "#8a2be2",       # Dark purple accent
                "cpu": "#00ffff",          # Neon cyan for CPU
                "ram": "#ff00ff",          # Neon magenta for RAM
                "disk": "#7df9ff",         # Light cyan for Disk
                "gpu": "#bf00ff",          # Bright purple for GPU
                "border": "#2a2d3a",       # Card border color
                "highlight": "#614BC0"     # Highlight color
            }
            
            # Window configuration
            self.roothwmn.configure(bg=self.colors["bg"])
            
            # Style configuration
            style = ttk.Style()
            style.theme_use('clam')
            
            # Progressbar styling
            style.configure("CPU.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["cpu"])
            
            style.configure("RAM.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["ram"])
                            
            style.configure("Disk.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["disk"])
                            
            style.configure("GPU.Horizontal.TProgressbar", 
                            troughcolor=self.colors["border"], 
                            background=self.colors["gpu"])
            
            # Main frame
            main_frame = tk.Frame(roothwmn, bg=self.colors["bg"], padx=20, pady=20)
            main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Header
            header_frame = tk.Frame(main_frame, bg=self.colors["bg"])
            header_frame.pack(fill=tk.X, pady=(0, 20))
            
            title_label = tk.Label(header_frame, 
                                  text="HARDWARE·MONITOR", 
                                  font=("Consolas", 24, "bold"), 
                                  bg=self.colors["bg"], 
                                  fg=self.colors["cpu"])
            title_label.pack(side=tk.LEFT)
            
            # Display real time and additional data
            time_frame = tk.Frame(header_frame, bg=self.colors["bg"])
            time_frame.pack(side=tk.RIGHT)
            
            self.time_label = tk.Label(time_frame, 
                                      text="", 
                                      font=("Consolas", 12), 
                                      bg=self.colors["bg"], 
                                      fg=self.colors["ram"])
            self.time_label.pack(side=tk.TOP, anchor=tk.E)
            
            self.uptime_label = tk.Label(time_frame, 
                                        text="", 
                                        font=("Consolas", 10), 
                                        bg=self.colors["bg"], 
                                        fg=self.colors["subtitle"])
            self.uptime_label.pack(side=tk.TOP, anchor=tk.E)
            
            # Create grid for cards
            resources_frame = tk.Frame(main_frame, bg=self.colors["bg"])
            resources_frame.pack(fill=tk.BOTH, expand=True)
            
            # Grid layout for cards
            resources_frame.columnconfigure(0, weight=1)
            resources_frame.columnconfigure(1, weight=1)
            resources_frame.rowconfigure(0, weight=1)
            resources_frame.rowconfigure(1, weight=1)
            
            # Card dimensions - ensure all cards have the same size
            card_width = 350
            card_height = 200
            
            # CPU Card
            self.cpu_card = self.create_card(resources_frame, "CPU", self.colors["cpu"], 0, 0, width=card_width, height=card_height)
            
            # RAM Card
            self.ram_card = self.create_card(resources_frame, "RAM", self.colors["ram"], 0, 1, width=card_width, height=card_height)
            
            # Disk Card
            self.disk_card = self.create_card(resources_frame, "STORAGE", self.colors["disk"], 1, 0, width=card_width, height=card_height)
            
            # GPU Card
            if gpu_available:
                self.gpu_card = self.create_card(resources_frame, "GPU", self.colors["gpu"], 1, 1, width=card_width, height=card_height)
            else:
                # If GPU is not available, create a network card
                self.network_card = self.create_card(resources_frame, "NETWORK", self.colors["gpu"], 1, 1, width=card_width, height=card_height)
                self.prev_net_io = psutil.net_io_counters()
                self.network_speed = {"download": 0, "upload": 0}
            
            # Footer with advanced statistics
            footer_frame = tk.Frame(main_frame, bg=self.colors["bg"], pady=10)
            footer_frame.pack(fill=tk.X)
            
            # Processes
            self.processes_label = tk.Label(footer_frame, 
                                          text="Processes: 0", 
                                          font=("Consolas", 10), 
                                          bg=self.colors["bg"], 
                                          fg=self.colors["text"])
            self.processes_label.pack(side=tk.LEFT, padx=(0, 20))
            
            # Temperature (if available)
            self.temp_label = tk.Label(footer_frame, 
                                      text="", 
                                      font=("Consolas", 10), 
                                      bg=self.colors["bg"], 
                                      fg=self.colors["text"])
            self.temp_label.pack(side=tk.LEFT, padx=(0, 20))
            
            # Top processes
            top_processes_frame = tk.Frame(main_frame, bg=self.colors["bg"], pady=10)
            top_processes_frame.pack(fill=tk.X)
            
            top_label = tk.Label(top_processes_frame,
                               text="TOP PROCESSES (CPU)",
                               font=("Consolas", 10, "bold"),
                               bg=self.colors["bg"],
                               fg=self.colors["cpu"])
            top_label.pack(anchor=tk.W)
            
            self.processes_info = tk.Label(top_processes_frame,
                                         text="",
                                         font=("Consolas", 9),
                                         bg=self.colors["bg"],
                                         fg=self.colors["text"],
                                         justify=tk.LEFT)
            self.processes_info.pack(anchor=tk.W, pady=(5, 0))
            
            # Thread for updating data
            self.running = True
            self.update_thread = threading.Thread(target=self.update_stats)
            self.update_thread.daemon = True
            self.update_thread.start()
            
            # When closing the window
            self.roothwmn.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        def create_card(self, parent, title, color, row, column, width=None, height=None):
            # Card frame with fixed dimensions
            card = tk.Frame(parent, bg=self.colors["card_bg"], padx=15, pady=15, 
                           highlightbackground=color, highlightthickness=1, 
                           relief=tk.FLAT, bd=0, width=width, height=height)
            card.grid(row=row, column=column, padx=10, pady=10, sticky="nsew")
            
            # Ensure the card maintains its size
            if width and height:
                card.pack_propagate(False)
            
            # Card title with icon
            title_frame = tk.Frame(card, bg=self.colors["card_bg"])
            title_frame.pack(fill=tk.X, pady=(0, 10))
            
            title_label = tk.Label(title_frame, text=title, 
                                  font=("Consolas", 16, "bold"), 
                                  fg=color, bg=self.colors["card_bg"])
            title_label.pack(side=tk.LEFT)
            
            value_label = tk.Label(title_frame, text="0%", 
                                  font=("Consolas", 16), 
                                  fg=self.colors["text"], bg=self.colors["card_bg"])
            value_label.pack(side=tk.RIGHT)
            
            # Progress bar
            if title == "CPU":
                progress = ttk.Progressbar(card, style="CPU.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            elif title == "RAM":
                progress = ttk.Progressbar(card, style="RAM.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            elif title == "STORAGE":
                progress = ttk.Progressbar(card, style="Disk.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            else:  # GPU or NETWORK
                progress = ttk.Progressbar(card, style="GPU.Horizontal.TProgressbar", 
                                         length=200, mode="determinate")
            
            progress.pack(fill=tk.X, pady=10)
            
            # Advanced: small histograms for history
            history_frame = tk.Frame(card, bg=self.colors["card_bg"], height=30)
            history_frame.pack(fill=tk.X, pady=(10, 5))
            
            # Create 20 small bars for history
            history_bars = []
            for i in range(20):
                bar = tk.Frame(history_frame, width=8, bg=self.colors["border"])
                bar.pack(side=tk.LEFT, padx=1)
                bar.place(rely=1.0, relheight=0.1, x=i*10, anchor="sw", width=8)
                history_bars.append(bar)
            
            # Info labels
            info_frame = tk.Frame(card, bg=self.colors["card_bg"])
            info_frame.pack(fill=tk.X, pady=5)
            
            info_label = tk.Label(info_frame, text="", 
                                 font=("Consolas", 10), 
                                 fg=self.colors["text"], bg=self.colors["card_bg"])
            info_label.pack(anchor=tk.W)
            
            detail_label = tk.Label(info_frame, text="", 
                                  font=("Consolas", 9), 
                                  fg=self.colors["subtitle"], bg=self.colors["card_bg"])
            detail_label.pack(anchor=tk.W, pady=(5, 0))
            
            # Extra label for advanced details
            extra_label = tk.Label(info_frame, text="", 
                                 font=("Consolas", 9), 
                                 fg=self.colors["subtitle"], bg=self.colors["card_bg"])
            extra_label.pack(anchor=tk.W, pady=(5, 0))
            
            return {
                "frame": card,
                "title": title_label,
                "value": value_label,
                "progress": progress,
                "info": info_label,
                "detail": detail_label,
                "extra": extra_label,
                "history": history_bars,
                "history_data": [0] * 20  # Store history for the graph
            }
        
        def update_stats(self):
            # History data for graphs
            history = {
                "cpu": [0] * 20,
                "ram": [0] * 20,
                "disk": [0] * 20,
                "gpu": [0] * 20 if gpu_available else None,
                "network": None if gpu_available else [0] * 20
            }
            
            while self.running:
                # Update time
                current_time = datetime.now().strftime("%H:%M:%S")
                uptime_seconds = time.time() - psutil.boot_time()
                uptime_days = int(uptime_seconds // 86400)
                uptime_hours = int((uptime_seconds % 86400) // 3600)
                uptime_minutes = int((uptime_seconds % 3600) // 60)
                
                # Update CPU
                cpu_percent = psutil.cpu_percent(interval=0.1)
                cpu_count_physical = psutil.cpu_count(logical=False)
                cpu_count_logical = psutil.cpu_count()
                
                # Add data to history
                history["cpu"].pop(0)
                history["cpu"].append(cpu_percent)
                
                cpu_freq = psutil.cpu_freq()
                if cpu_freq:
                    cpu_freq_current = cpu_freq.current
                    cpu_freq_min = cpu_freq.min if hasattr(cpu_freq, 'min') else "N/A"
                    cpu_freq_max = cpu_freq.max if hasattr(cpu_freq, 'max') else "N/A"
                else:
                    cpu_freq_current = cpu_freq_min = cpu_freq_max = "N/A"
                
                # Update RAM
                ram = psutil.virtual_memory()
                ram_percent = ram.percent
                ram_used = ram.used / (1024 ** 3)  # Convert to GB
                ram_total = ram.total / (1024 ** 3)
                ram_available = ram.available / (1024 ** 3)
                ram_cached = ram.cached / (1024 ** 3) if hasattr(ram, 'cached') else 0
                
                # Add data to history
                history["ram"].pop(0)
                history["ram"].append(ram_percent)
                
                # Update Disk
                disk = psutil.disk_usage('/')
                disk_percent = disk.percent
                disk_used = disk.used / (1024 ** 3)
                disk_total = disk.total / (1024 ** 3)
                
                # IO Info
                try:
                    disk_io = psutil.disk_io_counters()
                    disk_read_mb = disk_io.read_bytes / (1024 ** 2)
                    disk_write_mb = disk_io.write_bytes / (1024 ** 2)
                except:
                    disk_read_mb = disk_write_mb = 0
                
                # Add data to history
                history["disk"].pop(0)
                history["disk"].append(disk_percent)
                
                # Process network information if we don't have GPU
                if not gpu_available:
                    net_io = psutil.net_io_counters()
                    net_sent = (net_io.bytes_sent - self.prev_net_io.bytes_sent) / 1024  # KB/s
                    net_recv = (net_io.bytes_recv - self.prev_net_io.bytes_recv) / 1024  # KB/s
                    self.network_speed["upload"] = net_sent
                    self.network_speed["download"] = net_recv
                    self.prev_net_io = net_io
                    
                    # Add data to history (use download as primary value)
                    net_percent = min(net_recv / 1000 * 100, 100)  # Limit to 100%
                    history["network"].pop(0)
                    history["network"].append(net_percent)
                
                # Processes
                num_processes = len(psutil.pids())
                
                # Top 3 processes by CPU usage
                top_processes = []
                for proc in sorted(psutil.process_iter(['pid', 'name', 'cpu_percent']), 
                                 key=lambda p: p.info['cpu_percent'] if p.info['cpu_percent'] is not None else 0, 
                                 reverse=True)[:3]:
                    try:
                        if proc.info['cpu_percent'] > 0:
                            top_processes.append(f"{proc.info['name'][:15]:<15} - {proc.info['cpu_percent']:>5.1f}%")
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        pass
                
                # Temperatures (if available)
                temp_info = ""
                try:
                    temps = psutil.sensors_temperatures()
                    if temps:
                        for name, entries in temps.items():
                            for entry in entries:
                                temp_info += f"{name}: {entry.current}°C | "
                                break  # only the first temperature per sensor
                except:
                    pass
                
                # Update GUI (in the main thread)
                self.roothwmn.after(10, self.update_gui, current_time, 
                               uptime_days, uptime_hours, uptime_minutes,
                               cpu_percent, cpu_count_physical, cpu_count_logical, 
                               cpu_freq_current, cpu_freq_min, cpu_freq_max,
                               ram_percent, ram_used, ram_total, ram_available, ram_cached,
                               disk_percent, disk_used, disk_total, disk_read_mb, disk_write_mb,
                               num_processes, top_processes, temp_info, history)
                
                # Update GPU (if available)
                if gpu_available:
                    try:
                        gpus = GPUtil.getGPUs()
                        if gpus:
                            gpu = gpus[0]  # Use the first GPU
                            gpu_percent = gpu.load * 100
                            gpu_mem_percent = (gpu.memoryUsed / gpu.memoryTotal) * 100
                            gpu_mem_used = gpu.memoryUsed
                            gpu_mem_total = gpu.memoryTotal
                            gpu_temp = gpu.temperature
                            
                            # Add data to history
                            history["gpu"].pop(0)
                            history["gpu"].append(gpu_percent)
                            
                            self.roothwmn.after(10, self.update_gpu_gui, 
                                           gpu_percent, gpu_mem_percent, 
                                           gpu_mem_used, gpu_mem_total, 
                                           gpu.name, gpu_temp, history["gpu"])
                    except Exception as e:
                        print(f"Error updating GPU information: {e}")
                else:
                    # Update Network GUI if we don't have GPU
                    self.roothwmn.after(10, self.update_network_gui, 
                                   self.network_speed["download"], 
                                   self.network_speed["upload"], 
                                   history["network"])
                
                time.sleep(0.5)  # Update every 0.5 seconds
        
        def update_history_bars(self, history_bars, history_data, color):
            # Update history bars
            for i, value in enumerate(history_data):
                # Calculate relative height (0.1 - 1.0) based on percentage (0-100)
                height = max(0.1, value / 100)
                # Update bar height and color
                alpha = int(min(255, value * 2.55))  # 0-255 based on value
                bar_color = color  # base color with alpha
                history_bars[i].place(relheight=height, relwidth=1.0)
        
        def update_gui(self, current_time, uptime_days, uptime_hours, uptime_minutes,
                      cpu_percent, cpu_count_physical, cpu_count_logical, 
                      cpu_freq_current, cpu_freq_min, cpu_freq_max,
                      ram_percent, ram_used, ram_total, ram_available, ram_cached,
                      disk_percent, disk_used, disk_total, disk_read_mb, disk_write_mb,
                      num_processes, top_processes, temp_info, history):
            # Update time and uptime
            self.time_label.config(text=f"{current_time}")
            uptime_text = f"Uptime: "
            if uptime_days > 0:
                uptime_text += f"{uptime_days}d "
            uptime_text += f"{uptime_hours}h {uptime_minutes}m"
            self.uptime_label.config(text=uptime_text)
            
            # Update processes and temperature
            self.processes_label.config(text=f"Processes: {num_processes}")
            if temp_info:
                self.temp_label.config(text=temp_info)
            
            # Update top processes
            if top_processes:
                self.processes_info.config(text="\n".join(top_processes))
            
            # Update CPU
            self.cpu_card["value"].config(text=f"{cpu_percent:.1f}%")
            self.cpu_card["progress"]["value"] = cpu_percent
            self.cpu_card["info"].config(text=f"Physical: {cpu_count_physical} cores | Logical: {cpu_count_logical} threads")
            
            # Format for CPU frequency
            freq_text = f"Frequency: {cpu_freq_current:.0f} MHz" if isinstance(cpu_freq_current, (int, float)) else f"Frequency: {cpu_freq_current}"
            if isinstance(cpu_freq_min, (int, float)) and isinstance(cpu_freq_max, (int, float)):
                self.cpu_card["extra"].config(text=f"Min: {cpu_freq_min:.0f} MHz | Max: {cpu_freq_max:.0f} MHz")
            
            self.cpu_card["detail"].config(text=freq_text)
            
            # Update CPU history bars
            self.update_history_bars(self.cpu_card["history"], history["cpu"], self.colors["cpu"])
            
            # Update RAM
            self.ram_card["value"].config(text=f"{ram_percent:.1f}%")
            self.ram_card["progress"]["value"] = ram_percent
            self.ram_card["info"].config(text=f"Used: {ram_used:.2f} GB of {ram_total:.2f} GB")
            self.ram_card["detail"].config(text=f"Available: {ram_available:.2f} GB")
            self.ram_card["extra"].config(text=f"Cache: {ram_cached:.2f} GB")
            
            # Update RAM history bars
            self.update_history_bars(self.ram_card["history"], history["ram"], self.colors["ram"])
            
            # Update Disk
            self.disk_card["value"].config(text=f"{disk_percent:.1f}%")
            self.disk_card["progress"]["value"] = disk_percent
            self.disk_card["info"].config(text=f"Used: {disk_used:.2f} GB of {disk_total:.2f} GB")
            self.disk_card["detail"].config(text=f"Available: {disk_total - disk_used:.2f} GB")
            self.disk_card["extra"].config(text=f"I/O: {disk_read_mb:.1f} MB read | {disk_write_mb:.1f} MB written")
            
            # Update Disk history bars
            self.update_history_bars(self.disk_card["history"], history["disk"], self.colors["disk"])
        
        def update_gpu_gui(self, gpu_percent, gpu_mem_percent, gpu_mem_used, gpu_mem_total, gpu_name, gpu_temp, history_data):
            if gpu_available:
                self.gpu_card["value"].config(text=f"{gpu_percent:.1f}%")
                self.gpu_card["progress"]["value"] = gpu_percent
                self.gpu_card["info"].config(text=f"{gpu_name}")
                self.gpu_card["detail"].config(text=f"Memory: {gpu_mem_used:.0f}/{gpu_mem_total:.0f} MB ({gpu_mem_percent:.1f}%)")
                self.gpu_card["extra"].config(text=f"Temperature: {gpu_temp}°C")
                
                # Update GPU history bars
                self.update_history_bars(self.gpu_card["history"], history_data, self.colors["gpu"])
        
        def update_network_gui(self, download_speed, upload_speed, history_data):
            if not gpu_available:
                # Calculate a relative percentage for the progress bar
                # Assume 10 MB/s = 100%
                download_percent = min(download_speed / 10000 * 100, 100)
                
                self.network_card["value"].config(text=f"{download_percent:.1f}%")
                self.network_card["progress"]["value"] = download_percent
                
                # Format units of measurement
                if download_speed > 1024:
                    download_text = f"{download_speed/1024:.2f} MB/s"
                else:
                    download_text = f"{download_speed:.2f} KB/s"
                    
                if upload_speed > 1024:
                    upload_text = f"{upload_speed/1024:.2f} MB/s"
                else:
                    upload_text = f"{upload_speed:.2f} KB/s"
                
                self.network_card["info"].config(text=f"Download: {download_text}")
                self.network_card["detail"].config(text=f"Upload: {upload_text}")
                
                # Packet information
                try:
                    net_stats = psutil.net_io_counters()
                    self.network_card["extra"].config(text=f"Packets: {net_stats.packets_recv} received | {net_stats.packets_sent} sent")
                except:
                    pass
                
                # Update Network history bars
                self.update_history_bars(self.network_card["history"], history_data, self.colors["gpu"])
        
        def on_closing(self):
            self.running = False
            self.roothwmn.destroy()

    def main():
        roothwmn = tk.Tk()
        app = CyberpunkSystemMonitor(roothwmn)
        roothwmn.mainloop()

    if __name__ == "__main__":
        main()
        
if fetchervar == 1995:
    import os
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    import socket
    import random
    import configparser
     
    class SetupWizard(tk.Tk):
        def __init__(self):
            super().__init__()
     
            self.title("Repair Setup - Fetcher")
            self.geometry("500x400")
            self.resizable(False, False)
     
            self.steps = []
            self.current_step = 0
     
            self.container = ttk.Frame(self)
            self.container.pack(fill="both", expand=True)
     
            self.create_steps()
            self.show_step(0)
     
            self.navigation_frame = ttk.Frame(self)
            self.navigation_frame.pack(side="bottom", fill="x")
     
            self.back_button = ttk.Button(self.navigation_frame, text="Back", command=self.back)
            self.next_button = ttk.Button(self.navigation_frame, text="Next", command=self.next)
            self.finish_button = ttk.Button(self.navigation_frame, text="Finish", command=self.finish, state="disabled")
     
            self.back_button.pack(side="left", padx=(10, 0), pady=10)
            self.finish_button.pack(side="right", padx=(0, 10), pady=10)
            self.next_button.pack(side="right", padx=(0, 10), pady=10)
     
            self.update_buttons()
     
        def create_steps(self):
            # Step 1: Welcome
            frame1 = ttk.Frame(self.container)
            label1 = ttk.Label(frame1, text="Welcome to the Repair Setup for Multiapp.exe", font=("Arial", 14))
            label1.pack(pady=20)
            self.steps.append(frame1)
     
            # Step 2: Accept Terms and Conditions
            frame2 = ttk.Frame(self.container)
            label2 = ttk.Label(frame2, text="Please read and accept the terms and conditions to continue.", font=("Arial", 12))
            label2.pack(pady=10)
     
            terms_frame = ttk.Frame(frame2)
            terms_frame.pack(fill="both", expand=True, pady=(0, 10))
     
            self.terms_text = tk.Text(terms_frame, wrap="word", width=60, height=10)
            self.terms_text.insert("1.0", "End-User License Agreement (EULA) for Multiapp.exe\n\n"
                                          "This End-User License Agreement (EULA) is a legal agreement "
                                          "between you and Tudor Marmureanu.\n\n"
                                          "This software repair program is provided 'as-is' and without "
                                          "warranty of any kind. By using this software, you agree to the "
                                          "terms and conditions outlined in this agreement.\n\n"
                                          "1. GRANT OF LICENSE. This EULA grants you the following rights: "
                                          "You may use this software to repair the Multiapp.exe program.\n"
                                          "2. DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS.\n"
                                          "   - Maintenance of Copyright Notices. You must not remove or alter any copyright "
                                          "notices on any copies of the software.\n"
                                          "   - Distribution. You may not distribute copies of the software to third parties.\n"
                                          "   - Prohibition on Reverse Engineering, Decompilation, and Disassembly. You may not "
                                          "reverse engineer, decompile, or disassemble the software.\n\n"
                                          "Tudor Marmureanu reserves all rights not expressly granted to you in this EULA.\n\n"
                                          "If you do not agree to these terms, do not install or use this software.")
            self.terms_text.config(state="disabled")  # Make the text read-only
            self.terms_text.pack(side="left", fill="both", expand=True)
     
            scrollbar = ttk.Scrollbar(terms_frame, command=self.terms_text.yview)
            scrollbar.pack(side="right", fill="y")
            self.terms_text.config(yscrollcommand=scrollbar.set)
     
            self.terms_var = tk.BooleanVar()
            terms_check = ttk.Checkbutton(frame2, text="I accept the terms and conditions", variable=self.terms_var)
            terms_check.pack(pady=10)
            self.steps.append(frame2)
     
            # Step 3: Choose Installation Directory
            frame3 = ttk.Frame(self.container)
            label3 = ttk.Label(frame3, text="Choose the installation directory (Multiapp).", font=("Arial", 12))
            label3.pack(pady=20)
            self.directory_var = tk.StringVar()
            directory_entry = ttk.Entry(frame3, textvariable=self.directory_var, width=40)
            directory_entry.pack(pady=5)
            browse_button = ttk.Button(frame3, text="Browse...", command=self.browse_directory)
            browse_button.pack(pady=5)
            self.steps.append(frame3)
     
            # Step 4: Validation Window
            frame4 = ttk.Frame(self.container)
            label4 = ttk.Label(frame4, text="Serial number validation", font=("Arial", 18, "bold"))
            label4.pack(pady=20)
     
            validation_frame = ttk.Frame(frame4)
            validation_frame.pack(expand=True)
     
            self.entry_vars = [tk.StringVar() for _ in range(5)]
            self.entries = []
            for i in range(5):
                entry = ttk.Entry(validation_frame, textvariable=self.entry_vars[i], width=8)  # Adjusted width to 5
                entry.grid(row=0, column=2 * i)
                self.entries.append(entry)
                if i < 4:
                    dash_label = ttk.Label(validation_frame, text="-")
                    dash_label.grid(row=0, column=2 * i + 1)
     
            self.steps.append(frame4)
     
            # Step 5: Installation Progress
            frame5 = ttk.Frame(self.container)
            label5 = ttk.Label(frame5, text="Running Driver...", font=("Arial", 14))
            label5.pack(pady=20)
            self.progress = ttk.Progressbar(frame5, orient="horizontal", length=300, mode="determinate")
            self.progress.pack(pady=10)
            self.steps.append(frame5)
     
        def show_step(self, step):
            for frame in self.steps:
                frame.pack_forget()
            self.steps[step].pack(fill="both", expand=True)
     
        def next(self):
            if self.current_step == 1 and not self.terms_var.get():
                messagebox.showwarning("Warning", "You must accept the terms and conditions to continue.")
                return
            if self.current_step == 2 and not self.directory_var.get():
                messagebox.showwarning("Warning", "Please choose an installation directory.")
                return
            if self.current_step == 3 and not self.validate_entries():
                messagebox.showwarning("Warning", "Validation failed. Please enter valid serial number.")
                return
     
            if self.current_step < len(self.steps) - 1:
                self.current_step += 1
                self.show_step(self.current_step)
                self.update_buttons()
     
        def back(self):
            if self.current_step > 0:
                self.current_step -= 1
                self.show_step(self.current_step)
                self.update_buttons()

        def create_accounts_file(self):
            installation_directory = self.directory_var.get()
            if not installation_directory:
                return
            
            accounts_file_path = os.path.join(installation_directory, "Accounts.txt")
            
            accounts_data = """|___user___|            |___password___|

    user            nopass
    it              copy (+- product_key)
    passgen         passgen
    quiz            test
    pausemanager    pauze (+- product_key)
    taskmanager     terminator
    launcher        launcher
    hardware        lite
    eventviewer     eventviewer
    xml             editor

    --------------------------------------------
    terminal        terminal (+ product_key)
    passgenV2     	passgenV2 (+ product_key)
    system         	realtime (+ product_key)
    screenrec      	screenrec (+ product_key)
    zipmanager     	zipmngr (+ product_key)
    comparator     	comparator (+ product_key)
    convertorpdf   	toword (+ product_key)
    textreplace    	textfind (+ product_key)
    pdftools      	enjoyit (+ product_key)
    pdfviewer       pdfviewer (+ product_key)
    bandmonitoring 	networking (+ product_key)
    cryptoV2      	security (+ product_key)
    chatbot        	aichatbot (+ product_key)
    notepad        	notepad (+ product_key)
    paint          	paint (+ product_key)
    zippass        	wordsmith (+ product_key)
    backupmanager   	backupmngr (+ product_key)
    renamemanager  	renamer (+ product_key)
    kbmanager      	knowladgebase (+ product_key)
    kbretro         kbretro (+ product_key)
    password       	manager (+ product_key)
    junk           	manager (+ product_key)
    whiteboard     	presentation (+ product_key)
    contact        	manager (+ product_key)
    check          	devices (+ product_key)
    excel           lite (+ product_key)
    reader          office (+ product_key)
    fetcher         repair (+ product_key)
    shell           integrator (+ product_key)
    sql             editor (+ product_key)
    ide             pycharm (+ product_key)
    ide             vscode (+ produce_key)
    diagram         beta (+ product_key)
    mindmap         diagram (+ product_key)
    commander		total (+ product_key)
    calendar        calendar (+ product_key)
    alert           monitor (+ product_key)
    process         viewer (+ produck_key)
    md		        mdviewer (+ product_key)
    history         files (+ product_key)
    expense	        tracker (+ product_key)
    script	        agent (+ product_key)
    recovery	    tunnel (+ product_key)
    fisher	        file (+ product_key)
    multifile       editor (+ product_key)
    safe            checker (+ product_key)
    traffic         network (+ product_key)
        """

            with open(accounts_file_path, "w") as accounts_file:
                accounts_file.write(accounts_data.strip())  # Scrie datele în fișier

     
        def finish(self):
            # Your existing code for handling 'Finish' button clicks goes here
            self.log_messages()
            self.create_accounts_file()
            messagebox.showinfo("Info", "Installation completed successfully!")
            self.quit()
     
        def browse_directory(self):
            directory = filedialog.askdirectory()
            if directory:
                if not os.path.exists(os.path.join(directory, "Multiapp.exe")):
                    messagebox.showerror("Error", "Multiapp.exe not found in the selected directory.")
                    self.directory_var.set("")
                else:
                    self.directory_var.set(directory)
     
        def install_application(self):
            self.progress["value"] = 0
            self.back_button.config(state="disabled")
            self.next_button.config(state="disabled")
            self.simulate_progress()
     
        def simulate_progress(self):
            current_value = self.progress["value"]
            if current_value < 100:
                # Generăm o valoare aleatorie între 1 și 10 pentru progres
                next_value = current_value + random.randint(1, 20)
                self.progress["value"] = min(next_value, 100)  # Limităm la 100%
                self.after(900, self.simulate_progress)  # Programăm următoarea actualizare
            else:
                self.finish_button.config(state="normal")  # Activați butonul Finish
                self.back_button.config(state="normal")    # Activați butonul Back
     
     
        def validate_entries(self):
            expected_values_sets = [
                ["R46BX", "JHR2J", "PG7ER", "24QFG", "MWKVR"]
            ]
            for expected_values in expected_values_sets:
                valid = True
                for entry_var, expected in zip(self.entry_vars, expected_values):
                    if entry_var.get() != expected:
                        valid = False
                        break
                if valid:
                    return True
            return False
     
     
        def update_buttons(self):
            if self.current_step == 0:
                self.back_button.config(state="disabled")
            else:
                self.back_button.config(state="normal")
     
            if self.current_step == len(self.steps) - 1:
                self.next_button.config(state="disabled")
                self.install_application()  # Start the progress simulation
            else:
                self.next_button.config(state="normal")
                self.finish_button.config(state="disabled")
     
     
        def log_messages(self):
            messages = [
                "11002: TEXT ERROR",
                "11004: Assembly media failed",
                "11005: Running instance",
                "11009: mopad.ini running...",
                "11010: Active patch",
                "11011: Service redirection to the core",
                "11013: Data sent",
                "11014: Matching Packages",
                "11025: Assembly #-N#",
                "11027: None",
                "11028: None",
                "11029: None",
                "11030: None",
                "11031: None",
                "11032: None",
                "11033: None",
                "11034: None",
                "11035: None",
                "11036: None",
                "11037: None",
                "11038: None",
                "11039: None",
                "11040: None",
                "11041: None",
                "11042: Assembly media running...",
                "11043: Product repairing...",
                "11044: Configparser active",
                "11045: Logging successfully",
                "11056: SUCCES",
                " ",
                "DETAILES:",
                "11082: Check port connectivity - sesion 1",
                "Port: 80 open",
                "Port: 443 open",
                "11083: Check port connectivity - sesion 2",
                "Port: 21 open",
                "Port: 22 open",
                "Port: 53 close (#managed_for_this_session#: ID 3)",
                "11088: Data integrity verified",
                "11092: Configuration file updated",
                "11191: User session terminated",
                " ",
                "ENCRYPTED HEX LOG VIEW:",
                "1A SD 8U 3E 7C 91 F0 D2",
                "B5 SD 8U 9B 6A 56 CF D8 37",
                "7C SD 8U A1 B0 62 8D F0 D2",
                "F0 SD 8U 3E 84 56 CF 9B 6A",
                "3E SD 8U 7C 91 A1 B0 D8 37",
                "5F SD 8U 2A 7B E4 F9 C3",
                "A8 SD 8U 6D 3C 1F B2 9E",
                "D1 SD 8U 8E 47 F6 A9 2B",
                "7E SD 8U BC 53 DA 61 9F",
                "32 SD 8U 9D 4A 78 CE E1",
                "Timeout",
                "F5 SD 8U B8 A2 6D 1E C7",
                "8B SD 8U 37 9F E4 5C A1",
                "6E SD 8U D9 24 5A F3 81",
                "-#-",
                "-#-",
                "A7 SD 8U 12 C6 73 9F BD",
                "-#-",
                "2F SD 8U 7D 56 18 E9 A4",
                "NA",
                "NA",
                "NA",
                "FF FF FF FF FF FF FF FF"
            ]
     
            # Write messages to RepairLog.txt
            with open("RepairLog.txt", "w") as file:
                for message in messages:
                    file.write(message + "\n")
     
            def create_default_ini_file(file_path):
                if not os.path.exists(file_path):
                    mopad_ini_content = """
    [Run]
    mate = mate-terminal -x sh -c "python3 {}; exec bash"
    gnome = gnome-terminal -- sh -c "python3 {}; exec bash"
    kde = konsole --hold -e "python3 {}"
    xterm = xterm -hold -e "python3 {}"
    windows = start cmd /K python {}
    mac = open -a Terminal ./python3 {}
     
    [Terminal]
    mate = mate-terminal
    gnome = gnome-terminal
    kde = konsole
    xterm = xterm
    windows = start cmd
    mac = open -a Terminal ./
     
    [Interpreter]
    mate = mate-terminal -x "python3"
    gnome = gnome-terminal -- "python3"
    kde = konsole -e python3
    xterm = xterm python3
    windows = start cmd /K python
    mac = open -a Terminal ./python3
     
    [System]
    system = windows
     
    [Password]
    password = 
            """
                    with open(file_path, 'w') as config_file:
                        config_file.write(mopad_ini_content)
     
            # Verifică și creează fișierul ini implicit dacă nu există
            create_default_ini_file('mopad.ini')
     
            # Continuă cu citirea și procesarea configurației din fișierul ini
            config = configparser.ConfigParser()
            config.read('mopad.ini')
     
     
    def check_internet_connection():
        try:
            socket.create_connection(("www.google.com", 80))
            return True
        except OSError:
            return False
     
    if __name__ == "__main__":
        if check_internet_connection():
            app = SetupWizard()
            app.mainloop()
        else:
            messagebox.showerror("Error", "No internet connection detected. Please check your connection and try again.")
            exit()

if shellvar == 1996:
    import os
    import sys
    import socket
    import time
    import random
    import subprocess
    from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                                 QPushButton, QLineEdit, QTextEdit, QMessageBox)
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    # Commands and simulated messages
    messages = {
        "init": "The precondition has been initialized.",
        "powercli Multiapp.exe -t":"On",
        "getscan register mov eax, eay: shell True":"",
        "getscan register mov eax, eay: shell False":"",
        "getscan register mov ebx, eby: shell True":"",
        "getscan register mov ebx, eby: shell False":"",
        "getscan register mov ecx, ecy: shell True":"",
        "getscan register mov ecx, ecy: shell False":"",
        "getscan register add eax, eay: shell True":"",
        "getscan register add eax, eay: shell False":"",
        "getscan register add ebx, eby: shell True":"",
        "getscan register add ebx, eby: shell False":"",
        "getscan register add ecx, ecy: shell True":"",
        "getscan register add ecx, ecy: shell False":"",
        "getscan register div eax, eay: shell True":"",
        "getscan register div eax, eay: shell False":"",
        "getscan register div ebx, eby: shell True":"",
        "getscan register div ebx, eby: shell False":"",
        "getscan register div ecx, ecy: shell True":"",
        "getscan register div ecx, ecy: shell False":"",
        "1/0,12": "Register OK.",
        "0/0,8": "Register OK.",
        "1/0,12": "None",
        "1/0,8": "None",
        "0/0,12": "None",
        "0/0,8": "None",
        "0/0,12": "None",
        "1/0,8": "None",
        "start,1/0/0": "eax=1;\neay=0;",
        "start,1/1/0": "eax=1;\neay=1;",
        "start,1/1/0": "eax=1;\neay=1;",
        "start,0/1/0": "eax=0;\neay=1;",
        "restart_service": "The service has been restarted.",
        "X/1,0": "256 Bytes",
        "X/1,1": "16 Bytes",
        "X/0,1": "8 Bytes",
        "X/0,0": "None",
        "CLI/1/0/0,t": "Positive_Response()",
        "cfg,0/0/1":"Session terminated.",
        "cfg,0/1/1":"Session restarted.",
        "cfg,1/0/1":"Error: No edx value.",
        "cfg,1/1/1":"Error: Failed configuration.",
        "launch_multiapp": "Launching Multiapp.exe..."
    }

    app = QApplication(sys.argv)

    file_path = os.getcwd()

    def create_accounts_file():
        installation_directory = os.getcwd()
        if not installation_directory:
            return
            
        accounts_file_path = os.path.join(installation_directory, "Accounts.txt")
            
        accounts_data = """|___user___|            |___password___|

    user            nopass
    it              copy (+- product_key)
    passgen         passgen
    quiz            test
    pausemanager    pauze (+- product_key)
    taskmanager     terminator
    launcher        launcher
    hardware        lite
    eventviewer     eventviewer
    xml             editor

    --------------------------------------------
    terminal        terminal (+ product_key)
    passgenV2     	passgenV2 (+ product_key)
    system         	realtime (+ product_key)
    screenrec      	screenrec (+ product_key)
    zipmanager     	zipmngr (+ product_key)
    comparator     	comparator (+ product_key)
    convertorpdf   	toword (+ product_key)
    textreplace    	textfind (+ product_key)
    pdftools      	enjoyit (+ product_key)
    pdfviewer       pdfviewer (+ product_key)
    bandmonitoring 	networking (+ product_key)
    cryptoV2      	security (+ product_key)
    chatbot        	aichatbot (+ product_key)
    notepad        	notepad (+ product_key)
    paint          	paint (+ product_key)
    zippass        	wordsmith (+ product_key)
    backupmanager   	backupmngr (+ product_key)
    renamemanager  	renamer (+ product_key)
    kbmanager      	knowladgebase (+ product_key)
    kbretro         kbretro (+ product_key)
    password       	manager (+ product_key)
    junk           	manager (+ product_key)
    whiteboard     	presentation (+ product_key)
    contact        	manager (+ product_key)
    check          	devices (+ product_key)
    excel           lite (+ product_key)
    reader          office (+ product_key)
    fetcher         repair (+ product_key)
    shell           integrator (+ product_key)
    sql             editor (+ product_key)
    ide             pycharm (+ product_key)
    ide             vscode (+ produce_key)
    diagram         beta (+ product_key)
    mindmap         diagram (+ product_key)
    commander		total (+ product_key)
    calendar        calendar (+ product_key)
    alert           monitor (+ product_key)
    process         viewer (+ produck_key)
    md		        mdviewer (+ product_key)
    history         files (+ product_key)
    expense	        tracker (+ product_key)
    script	        agent (+ product_key)
    recovery	    tunnel (+ product_key)
    fisher	        file (+ product_key)
    multifile       editor (+ product_key)
    safe            checker (+ product_key)
    traffic         network (+ product_key)
        """

        with open(accounts_file_path, "w") as accounts_file:
            accounts_file.write(accounts_data.strip())  # Scrie datele în fișier

    create_accounts_file()

    # Display error as a popup window using PyQt5
    def show_error(title, message):
        error_box = QMessageBox()
        error_box.setIcon(QMessageBox.Critical)
        error_box.setWindowTitle(title)
        error_box.setText(message)
        error_box.exec_()
        sys.exit(1)  # Close application after showing error

    # Check internet connection
    def check_internet():
        try:
            socket.create_connection(("www.google.com", 80), timeout=5)
            return True
        except OSError:
            show_error("Error", "You are not connected to the internet.")
            return False
    '''
    # Check if 'Multiapp.exe' exists in the same folder
    def check_file():
        if os.path.isfile("Multiapp.exe"):
            return True
        else:
            show_error("Error", "'Multiapp.exe' file not found in the same folder.")
            return False
    '''

    # Save each output to log.txt
    def save_to_log(command, response):
        with open("log.txt", "a") as log:
            log.write(f"Command: {command}\nResponse: {response}\n---\n")

    # Process command and save to log
    def process_command(command):
        if command in messages:
            response = messages[command]
            if command == "launch_multiapp":  # Launch Multiapp.exe
                try:
                    subprocess.Popen(["Multiapp.exe"], shell=True)  # Start the executable
                except Exception as e:
                    response = f"Failed to launch Multiapp.exe: {str(e)}"
        else:
            response = "Unknown command. Please try again."
        save_to_log(command, response)
        return response

    # Simulate commands in command line
    def simulate_command_cli():
        while True:
            command = input("Enter a command: ")
            response = process_command(command)

            # Introduce a random delay between 1 and 3 seconds
            time.sleep(random.randint(1, 3))

            print(f"Response: {response}")

    # GUI application class
    class CommandSimulatorApp(QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle("Shell Integrator")
            self.setGeometry(100, 100, 400, 300)

            self.central_widget = QWidget()
            self.setCentralWidget(self.central_widget)

            self.layout = QVBoxLayout()
            self.central_widget.setLayout(self.layout)

            self.command_input = QLineEdit(self)
            self.command_input.setPlaceholderText("Enter a command...")
            self.command_input.returnPressed.connect(self.submit_command)  # Connect Enter key
            self.layout.addWidget(self.command_input)

            self.submit_button = QPushButton("Submit", self)
            self.submit_button.clicked.connect(self.submit_command)
            self.layout.addWidget(self.submit_button)

            self.response_display = QTextEdit(self)
            self.response_display.setReadOnly(True)
            self.layout.addWidget(self.response_display)

        def submit_command(self):
            command = self.command_input.text()
            response = process_command(command)

            # Introduce a random delay between 1 and 3 seconds
            time.sleep(random.randint(1, 3))

            self.response_display.append(f"Command: {command}\nResponse: {response}\n")
            self.command_input.clear()

    # CLI mode function
    def run_cli_mode():
        simulate_command_cli()

    # GUI mode function
    def run_gui_mode():
        window = CommandSimulatorApp()
        window.show()
        sys.exit(app.exec_())

    # Main function
    def main():
        # Initial checks
        if not check_internet(): # or not check_file()
            sys.exit(1)  # Close the application if any check fails

        # Ask user to choose mode
        mode = input("Choose mode: Enter '1' for Command Line or '2' for GUI: ")
        if mode == '1':
            run_cli_mode()
        elif mode == '2':
            run_gui_mode()
        else:
            print("Invalid choice. Please restart the application and choose 1 or 2.")

    if __name__ == "__main__":
        main()
        
if w95var == 1997:
    #import tkinter as tk
    #from tkinter import messagebox, filedialog
    #import time
    #import platform
    #import psutil
    #import os
    import glob
    import winreg
    from collections import defaultdict
    import ctypes
    from ctypes import wintypes
    from pathlib import Path
    import hashlib
    import struct
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    def check_and_create_counter():
        pass
    
    def run_instance_checker():
        from tkinter import ttk, messagebox, filedialog, colorchooser, simpledialog
        from datetime import datetime, timedelta
        import tempfile
        try:
            import openpyxl
        except ImportError:
            pass

        class Windows95Desktop:
            def __init__(self):
                self.rootW95dist = tk.Tk()
                self.rootW95dist.title("Multiapp 95 Professional Desktop")
                
                # Setează fereastra să fie fullscreen fără bara de titlu
                self.rootW95dist.overrideredirect(True)
                self.rootW95dist.state('zoomed')  # Pentru Windows - fullscreen
                # Pentru Linux/Mac folosește: self.rootW95dist.attributes('-fullscreen', True)
                
                self.rootW95dist.configure(bg="#008080")  # Teal background
                
                # Variables pentru Start Menu
                self.start_menu_visible = True
                self.start_menu = None
                self.show_title_bar = False

                
                # Lista de ferestre deschise pentru taskbar
                self.open_windows = []
                
                # Variables for monitoring
                self.network_history = []
                self.cpu_history = []
                self.memory_history = []
                self.monitoring_active = False
                
                # Paint application variables
                self.current_color = "black"
                self.brush_size = 2
                self.paint_tool = "pencil"
                
                self.setup_desktop()
                self.setup_taskbar()
                self.setup_start_menu()  # Start menu permanent
                self.setup_clock()
                
            def setup_desktop(self):
                # Desktop background cu pattern
                self.desktop_frame = tk.Frame(self.rootW95dist, bg="#008080")
                self.desktop_frame.pack(fill="both", expand=True)
                
                # Definește poziția x pentru stânga și dreapta
                left_x = 50
                right_x = self.rootW95dist.winfo_screenwidth() - 120

                # Definește distanța y între icoane (pentru aliniere uniformă)
                icon_spacing = 70

                # Icoane pe desktop (partea stângă)
                self.create_desktop_icon("My Computer", left_x, 50, "computer")
                self.create_desktop_icon("Text Editor", left_x, 50 + icon_spacing, "editor")
                self.create_desktop_icon("Calculator", left_x, 50 + icon_spacing * 2, "calculator")
                self.create_desktop_icon("Network Monitor", left_x, 50 + icon_spacing * 3, "network")
                self.create_desktop_icon("Hardware Info", left_x, 50 + icon_spacing * 4, "hardware")
                self.create_desktop_icon("Paint", left_x, 50 + icon_spacing * 5, "paint")
                self.create_desktop_icon("Excel Lite", left_x, 50 + icon_spacing * 6, "excel")
                self.create_desktop_icon("Word Lite", left_x, 50 + icon_spacing * 7, "word")
                self.create_desktop_icon("Command Prompt", left_x, 50 + icon_spacing * 8, "terminal")
                self.create_desktop_icon("SQL Explorer", left_x, 50 + icon_spacing * 9, "database")
                self.create_desktop_icon("File Fisher", left_x, 50 + icon_spacing * 10, "recovery")
                self.create_desktop_icon("Recover Tunnel", left_x+100, 50 + icon_spacing * 10, "recover")

                # Icoane pe desktop (partea dreaptă)
                self.create_desktop_icon("Activate Product", right_x, 50, "activation")
                self.create_desktop_icon("System Requirements", right_x, 50 + icon_spacing, "sysinfo")
            
            def make_window_draggable(self, window, title_bar):
                """Make a window draggable by its title bar"""
                def start_move(event):
                    window.x = event.x
                    window.y = event.y

                def stop_move(event):
                    window.x = None
                    window.y = None

                def do_move(event):
                    if hasattr(window, 'x') and window.x is not None:
                        deltax = event.x - window.x
                        deltay = event.y - window.y
                        x = window.winfo_x() + deltax
                        y = window.winfo_y() + deltay
                        window.geometry(f"+{x}+{y}")

                title_bar.bind("<Button-1>", start_move)
                title_bar.bind("<ButtonRelease-1>", stop_move)
                title_bar.bind("<B1-Motion>", do_move)
                
                # Bind și pe label-ul din title bar
                for child in title_bar.winfo_children():
                    if isinstance(child, tk.Label):
                        child.bind("<Button-1>", start_move)
                        child.bind("<ButtonRelease-1>", stop_move)
                        child.bind("<B1-Motion>", do_move)
            
            def create_desktop_icon(self, name, x, y, icon_type="normal"):
                icon_frame = tk.Frame(self.desktop_frame, bg="#008080")
                icon_frame.place(x=x, y=y)
                
                # Simulează o iconiță (folosim un dreptunghi colorat)
                icon_canvas = tk.Canvas(icon_frame, width=32, height=32, bg="#008080", highlightthickness=0)
                icon_canvas.pack()
                
                # Culori diferite pentru tipuri diferite de icoane
                if icon_type == "editor":
                    fill_color = "#ffff66"  # Galben pentru text editor
                elif icon_type == "calculator":
                    fill_color = "#66ff66"  # Verde pentru calculator
                elif icon_type == "network":
                    fill_color = "#66ccff"  # Albastru pentru network
                elif icon_type == "hardware":
                    fill_color = "#ff9966"  # Orange pentru hardware
                elif icon_type == "paint":
                    fill_color = "#ff6699"  # Roz pentru paint
                elif icon_type == "excel":
                    fill_color = "#00cc66"
                elif icon_type == "activation":
                    fill_color = "#ff6666"
                elif icon_type == "database":
                    fill_color = "#3366cc"  # Albastru pentru database
                elif icon_type == "sysinfo":
                    fill_color = "#5c5c5c"  # Gri închis pentru system info
                elif icon_type == "recovery":
                    fill_color = "#ff9900"
                elif icon_type == "recover":
                    fill_color = "#6600cc" 
                else:
                    fill_color = "#c0c0c0"  # Gri standard
                    
                icon_canvas.create_rectangle(2, 2, 30, 30, fill=fill_color, outline="#808080")
                icon_canvas.create_rectangle(4, 4, 28, 28, fill="#ffffff", outline="#404040")
                
                # Adaugă simboluri pentru icoane
                if icon_type == "network":
                    icon_canvas.create_oval(8, 8, 24, 24, outline="#000080", width=2)
                    icon_canvas.create_line(16, 8, 16, 24, fill="#000080", width=2)
                    icon_canvas.create_line(8, 16, 24, 16, fill="#000080", width=2)
                elif icon_type == "hardware":
                    icon_canvas.create_rectangle(8, 8, 24, 24, fill="#404040", outline="#000000")
                    icon_canvas.create_rectangle(10, 10, 22, 22, fill="#808080", outline="#000000")
                    icon_canvas.create_rectangle(12, 12, 20, 20, fill="#c0c0c0", outline="#000000")
                elif icon_type == "paint":
                    # Draw a simple paint brush icon
                    icon_canvas.create_rectangle(10, 6, 14, 18, fill="#8B4513", outline="#000000")  # Handle
                    icon_canvas.create_oval(8, 18, 16, 26, fill="#ff0000", outline="#000000")  # Brush
                    icon_canvas.create_oval(18, 10, 24, 16, fill="#0000ff", outline="#000000")  # Blue paint
                    icon_canvas.create_oval(16, 18, 22, 24, fill="#00ff00", outline="#000000")  # Green paint
                elif icon_type == "excel":
                    # Desenează un simbol tabel pentru Excel
                    icon_canvas.create_rectangle(6, 6, 26, 26, fill="#008000", outline="#000000")
                    # Linii verticale
                    icon_canvas.create_line(13, 6, 13, 26, fill="#FFFFFF", width=1)
                    icon_canvas.create_line(19, 6, 19, 26, fill="#FFFFFF", width=1)
                    # Linii orizontale
                    icon_canvas.create_line(6, 13, 26, 13, fill="#FFFFFF", width=1)
                    icon_canvas.create_line(6, 19, 26, 19, fill="#FFFFFF", width=1)
                elif icon_type == "word":
                    # Desenează un simbol pentru Word (document cu linii text)
                    icon_canvas.create_rectangle(6, 6, 26, 26, fill="#0000CC", outline="#000000")
                    # Linii text
                    icon_canvas.create_line(9, 11, 23, 11, fill="#FFFFFF", width=1)
                    icon_canvas.create_line(9, 15, 23, 15, fill="#FFFFFF", width=1)
                    icon_canvas.create_line(9, 19, 23, 19, fill="#FFFFFF", width=1)
                    icon_canvas.create_line(9, 23, 18, 23, fill="#FFFFFF", width=1)
                elif icon_type == "terminal":
                    # Desenează un simbol pentru Command Prompt
                    icon_canvas.create_rectangle(6, 6, 26, 26, fill="#000000", outline="#404040")
                    # Simbolul prompt-ului >_
                    icon_canvas.create_text(16, 16, text=">_", fill="#FFFFFF", font=("Courier", 10, "bold"))
                elif icon_type == "activation":
                    # Desenează un simbol pentru activare (un cheie sau un lacăt)
                    icon_canvas.create_rectangle(8, 8, 24, 24, fill="#ffcc00", outline="#000000")
                    icon_canvas.create_line(16, 8, 16, 16, fill="#000000", width=2)  # Partea superioară a cheii
                    icon_canvas.create_rectangle(12, 16, 20, 20, fill="#ffcc00", outline="#000000")  # Partea inferioară a cheii
                elif icon_type == "database":
                    # Desenează un simbol pentru bază de date
                    icon_canvas.create_rectangle(8, 10, 24, 26, fill="#3366cc", outline="#000000")
                    # Linii orizontale pentru a reprezenta înregistrările
                    icon_canvas.create_line(10, 14, 22, 14, fill="#ffffff", width=1)
                    icon_canvas.create_line(10, 18, 22, 18, fill="#ffffff", width=1)
                    icon_canvas.create_line(10, 22, 22, 22, fill="#ffffff", width=1)
                elif icon_type == "sysinfo":
                    # Desenează un simbol pentru informații sistem
                    icon_canvas.create_rectangle(8, 8, 24, 24, fill="#5c5c5c", outline="#000000")
                    # Desenează un simbol "i" pentru informații
                    icon_canvas.create_text(16, 16, text="i", fill="white", font=("Arial", 12, "bold"))
                elif icon_type == "recovery":
                    # Desenează un simbol pentru recuperare fișiere
                    icon_canvas.create_rectangle(8, 8, 24, 24, fill="#ff9900", outline="#000000")
                    # Desenează un simbol stilizat de disc și undă
                    icon_canvas.create_oval(10, 10, 22, 22, fill="#ffffff", outline="#000000")
                    icon_canvas.create_arc(12, 12, 20, 20, start=0, extent=270, fill="#ff9900", outline="#000000")
                    # Desenează un simbol de undiță/pescuit
                    icon_canvas.create_line(10, 6, 22, 6, fill="#000000", width=2)
                    icon_canvas.create_line(16, 6, 16, 10, fill="#000000", width=1)
                elif icon_type == "recover":
                    # Desenează un simbol pentru recuperare avansată
                    icon_canvas.create_rectangle(8, 8, 24, 24, fill="#6600cc", outline="#000000")
                    # Desenează un simbol de hard disk și restaurare
                    icon_canvas.create_rectangle(10, 10, 22, 18, fill="#c0c0c0", outline="#000000")
                    icon_canvas.create_oval(12, 12, 20, 16, fill="#ffffff", outline="#000000")
                    # Adaugă o săgeată de restaurare
                    icon_canvas.create_line(12, 20, 16, 24, fill="#00ff00", width=2)
                    icon_canvas.create_line(16, 24, 20, 20, fill="#00ff00", width=2)
                
                # Label pentru numele iconitei
                label = tk.Label(icon_frame, text=name, bg="#008080", fg="white", 
                                font=("MS Sans Serif", 8))
                label.pack()
                
                # Event pentru dublu-click
                icon_canvas.bind("<Double-Button-1>", lambda e: self.handle_icon_click(name, icon_type))
                label.bind("<Double-Button-1>", lambda e: self.handle_icon_click(name, icon_type))
            
            def handle_icon_click(self, name, icon_type):
                if icon_type == "editor":
                    if not any(title == "Text Editor" for title, _, _ in self.open_windows):
                        self.create_text_editor()
                elif icon_type == "calculator":
                    if not any(title == "Calculator" for title, _, _ in self.open_windows):
                        self.create_calculator()
                elif icon_type == "network":
                    if not any(title == "Network Monitor" for title, _, _ in self.open_windows):
                        self.create_network_monitor()
                elif icon_type == "hardware":
                    if not any(title == "Hardware Info" for title, _, _ in self.open_windows):
                        self.create_hardware_info()
                elif icon_type == "paint":
                    if not any(title == "Paint" for title, _, _ in self.open_windows):
                        self.create_paint_app()
                elif icon_type == "computer":
                    if not any(title == "My Computer" for title, _, _ in self.open_windows):
                        self.create_file_explorer()
                elif icon_type == "excel":
                    if not any(title == "Excel Lite" for title, _, _ in self.open_windows):
                        self.create_excel_lite()
                elif icon_type == "word":
                    if not any(title == "Word Lite" for title, _, _ in self.open_windows):
                        self.create_word_lite()
                elif icon_type == "terminal":
                    if not any(title == "Command Prompt" for title, _, _ in self.open_windows):
                        self.create_terminal()
                elif icon_type == "activation":
                    if not any(title == "Activation Wizard" for title, _, _ in self.open_windows):
                        self.create_activation_window()
                elif icon_type == "database":
                    if not any(title == "SQL Explorer" for title, _, _ in self.open_windows):
                        self.open_sql_explorer()
                elif icon_type == "sysinfo":
                    if not any(title == "System Requirements" for title, _, _ in self.open_windows):
                        self.create_about_window()
                elif icon_type == "recovery":
                    if not any(title == "File Fisher" for title, _, _ in self.open_windows):
                        self.create_file_recovery()
                elif icon_type == "recover":
                    if not any(title == "Recover Tunnel" for title, _, _ in self.open_windows):
                        self.create_retro_recover()
                else:
                    self.open_window(name)
            
            def create_retro_recover(self):
                """Creează aplicația RetroRecover pentru recuperarea avansată a fișierelor"""
                # Creare fereastră principală
                recover_window = tk.Toplevel(self.rootW95dist)
                recover_window.title("Recover Tunnel")
                recover_window.overrideredirect(True)
                recover_window.geometry("900x700+200+100")
                recover_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(recover_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Recover Tunnel", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Recover Tunnel", recover_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(recover_window, title_bar)
                
                # Creare clase interne pentru a implementa funcționalitatea RetroRecover
                class RealFileRecoveryEngine:
                    """Engine real pentru recuperarea fișierelor"""
                    
                    def __init__(self):
                        self.stopped = False
                        self.file_extensions = {
                            'Documents': ['.txt', '.doc', '.docx', '.pdf', '.rtf', '.odt'],
                            'Images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.ico'],
                            'Videos': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm'],
                            'Audio': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma'],
                            'Archives': ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2']
                        }
                        
                    def scan_recycle_bin(self, callback):
                        """Scanează Coșul de Reciclare pentru fișiere șterse"""
                        self.stopped = False
                        found_files = []
                        
                        try:
                            # Obține toate unitățile de disc
                            drives = [f"{chr(i)}:\\" for i in range(65, 91) if os.path.exists(f"{chr(i)}:\\")]
                            
                            total_drives = len(drives)
                            
                            for i, drive in enumerate(drives):
                                if self.stopped:
                                    break
                                    
                                progress = int((i / total_drives) * 100)
                                callback(progress, f"Scanning drive {drive}...")
                                
                                # Verifică folderele Recycle Bin
                                recycle_paths = [
                                    os.path.join(drive, '$Recycle.Bin'),
                                    os.path.join(drive, 'RECYCLER'),
                                    os.path.join(drive, 'Recycled')
                                ]
                                
                                for recycle_path in recycle_paths:
                                    if self.stopped:
                                        break
                                        
                                    if os.path.exists(recycle_path):
                                        self._scan_directory_recursive(recycle_path, callback, found_files, "Recycle Bin")
                                        
                        except Exception as e:
                            print(f"Error scanning recycle bin: {e}")
                            
                        callback(100, "Recycle bin scan completed")
                        
                    def scan_temp_files(self, callback):
                        """Scanează locațiile de fișiere temporare"""
                        self.stopped = False
                        found_files = []
                        
                        try:
                            temp_paths = [
                                tempfile.gettempdir(),
                                os.environ.get('TEMP', ''),
                                os.environ.get('TMP', ''),
                                os.path.join(os.environ.get('USERPROFILE', ''), 'AppData', 'Local', 'Temp'),
                                r'C:\Windows\Temp'
                            ]
                            
                            # Elimină duplicatele și căile goale
                            temp_paths = list(set([path for path in temp_paths if path and os.path.exists(path)]))
                            total_paths = len(temp_paths)
                            
                            for i, temp_path in enumerate(temp_paths):
                                if self.stopped:
                                    break
                                    
                                progress = int((i / total_paths) * 100)
                                callback(progress, f"Scanning {temp_path}...")
                                
                                self._scan_directory_recursive(temp_path, callback, found_files, "Temp Files")
                                
                        except Exception as e:
                            print(f"Error scanning temp files: {e}")
                            
                        callback(100, "Temp files scan completed")
                        
                    def scan_recent_files(self, callback):
                        """Scanează fișierele recente din diverse surse"""
                        self.stopped = False
                        found_files = []
                        
                        try:
                            user_profile = os.environ.get('USERPROFILE', '')
                            
                            # Căile documentelor recente
                            recent_paths = [
                                os.path.join(user_profile, 'Recent'),
                                os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Recent'),
                                os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Office', 'Recent'),
                            ]
                            
                            total_paths = len(recent_paths) + 1  # +1 pentru scanarea registrului
                            current_path = 0
                            
                            for recent_path in recent_paths:
                                if self.stopped:
                                    break
                                    
                                progress = int((current_path / total_paths) * 100)
                                callback(progress, f"Scanning recent files...")
                                
                                if os.path.exists(recent_path):
                                    self._scan_directory_recursive(recent_path, callback, found_files, "Recent Files")
                                    
                                current_path += 1
                                
                            # Scanează registrul pentru fișiere recente
                            if not self.stopped and hasattr(winreg, 'OpenKey'):
                                progress = int((current_path / total_paths) * 100)
                                try:
                                    self._scan_registry_recent_files(callback, found_files)
                                except:
                                    pass
                                
                        except Exception as e:
                            print(f"Error scanning recent files: {e}")
                            
                        callback(100, "Recent files scan completed")
                    
                    def scan_browser_cache(self, callback):
                        """Scanează directoarele cache ale browserelor"""
                        self.stopped = False
                        found_files = []
                        
                        try:
                            user_profile = os.environ.get('USERPROFILE', '')
                            cache_paths = [
                                # Chrome
                                os.path.join(user_profile, 'AppData', 'Local', 'Google', 'Chrome', 'User Data', 'Default', 'Cache'),
                                # Firefox
                                os.path.join(user_profile, 'AppData', 'Local', 'Mozilla', 'Firefox', 'Profiles'),
                                # Edge
                                os.path.join(user_profile, 'AppData', 'Local', 'Microsoft', 'Edge', 'User Data', 'Default', 'Cache'),
                                # Internet Explorer
                                os.path.join(user_profile, 'AppData', 'Local', 'Microsoft', 'Windows', 'INetCache'),
                            ]
                            
                            total_paths = len(cache_paths)
                            
                            for i, cache_path in enumerate(cache_paths):
                                if self.stopped:
                                    break
                                    
                                progress = int((i / total_paths) * 100)
                                callback(progress, f"Scanning browser cache...")
                                
                                if os.path.exists(cache_path):
                                    self._scan_directory_recursive(cache_path, callback, found_files, "Browser Cache")
                                    
                        except Exception as e:
                            print(f"Error scanning browser cache: {e}")
                            
                        callback(100, "Browser cache scan completed")
                        
                    def _scan_directory_recursive(self, directory, callback, found_files, source):
                        """Scanează recursiv directorul pentru fișiere recuperabile"""
                        try:
                            total_files = 0
                            processed_files = 0
                            
                            # Prima trecere: numără fișierele pentru calculul progresului
                            try:
                                for root, dirs, files in os.walk(directory):
                                    total_files += len(files)
                                    # Limitează adâncimea pentru a evita numărarea prea multor fișiere
                                    if len(root.split(os.sep)) - len(directory.split(os.sep)) > 3:
                                        dirs.clear()
                            except:
                                total_files = 100  # Estimare de rezervă
                            
                            # A doua trecere: procesează fișierele
                            for root, dirs, files in os.walk(directory):
                                if self.stopped:
                                    break
                                    
                                for file_name in files:
                                    if self.stopped:
                                        break
                                        
                                    processed_files += 1
                                    progress = min(99, int((processed_files / max(total_files, 1)) * 100))
                                    callback(progress, f"Scanning: {file_name[:30]}...")
                                    
                                    file_path = os.path.join(root, file_name)
                                    
                                    try:
                                        if os.path.exists(file_path) and os.path.isfile(file_path):
                                            file_info = self._get_file_info(file_path, source)
                                            if file_info:
                                                found_files.append(file_info)
                                                callback(progress, f"Found: {file_name}", file_info)
                                                
                                    except (OSError, PermissionError):
                                        continue
                                        
                                # Limitează adâncimea pentru a evita buclele infinite
                                if len(root.split(os.sep)) - len(directory.split(os.sep)) > 3:
                                    dirs.clear()
                                    
                        except (OSError, PermissionError):
                            pass
                            
                    def _get_file_info(self, file_path, source):
                        """Obține informații detaliate despre un fișier"""
                        try:
                            stat_info = os.stat(file_path)
                            file_size = stat_info.st_size
                            
                            # Ignoră fișierele foarte mici (probabil nu sunt date utilizator)
                            if file_size < 100:
                                return None
                                
                            # Ignoră fișierele sistem
                            file_name = os.path.basename(file_path)
                            if file_name.startswith('.') or file_name.startswith('~'):
                                return None
                                
                            file_ext = os.path.splitext(file_name)[1].lower()
                            file_type = self._get_file_type(file_ext)
                            
                            # Formatează dimensiunea fișierului
                            size_str = self._format_file_size(file_size)
                            
                            # Formatează data
                            mod_time = datetime.fromtimestamp(stat_info.st_mtime)
                            date_str = mod_time.strftime("%Y-%m-%d %H:%M")
                            
                            # Determină starea de recuperabilitate
                            status = "Recoverable"
                            if not os.access(file_path, os.R_OK):
                                status = "Access Denied"
                            elif file_size == 0:
                                status = "Empty File"
                                
                            return {
                                'name': file_name,
                                'size': size_str,
                                'type': file_type,
                                'location': source,
                                'date': date_str,
                                'status': status,
                                'full_path': file_path,
                                'file_size': file_size
                            }
                            
                        except (OSError, PermissionError):
                            return None
                            
                    def _get_file_type(self, extension):
                        """Determină tipul de fișier din extensie"""
                        for file_type, extensions in self.file_extensions.items():
                            if extension in extensions:
                                return file_type
                        return "Other"
                        
                    def _format_file_size(self, size_bytes):
                        """Formatează dimensiunea fișierului în format uman"""
                        if size_bytes == 0:
                            return "0 B"
                        size_names = ["B", "KB", "MB", "GB"]
                        i = 0
                        while size_bytes >= 1024 and i < len(size_names) - 1:
                            size_bytes /= 1024.0
                            i += 1
                        return f"{size_bytes:.1f} {size_names[i]}"
                        
                    def _scan_registry_recent_files(self, callback, found_files):
                        """Scanează registrul Windows pentru intrări de fișiere recente"""
                        try:
                            if not hasattr(winreg, 'OpenKey'):
                                return
                                
                            # Cheia registrului pentru documente recente
                            reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 
                                                   r"Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs")
                            
                            callback(50, "Scanning registry recent files...")
                            
                            i = 0
                            while True:
                                try:
                                    value_name, value_data, value_type = winreg.EnumValue(reg_key, i)
                                    
                                    # Încearcă să extragă calea fișierului din datele registrului
                                    if isinstance(value_data, bytes) and len(value_data) > 0:
                                        # Decodează ca UTF-16 și curăță
                                        try:
                                            path_str = value_data.decode('utf-16le', errors='ignore').strip('\x00')
                                            if path_str and os.path.exists(path_str):
                                                file_info = self._get_file_info(path_str, "Registry Recent")
                                                if file_info:
                                                    found_files.append(file_info)
                                                    callback(50, f"Found registry entry: {os.path.basename(path_str)}", file_info)
                                        except:
                                            pass
                                            
                                    i += 1
                                except Exception:
                                    break
                                    
                            winreg.CloseKey(reg_key)
                            
                        except Exception as e:
                            print(f"Error scanning registry: {e}")
                
                # Inițializăm variabilele
                default_font = ("MS Sans Serif", 8)
                bold_font = ("MS Sans Serif", 8, "bold")
                title_font = ("MS Sans Serif", 10, "bold")
                
                scan_progress = tk.DoubleVar()
                status_text = tk.StringVar(value="Ready")
                current_operation = tk.StringVar(value="")
                files_found = tk.IntVar(value=0)
                recoverable_files = []
                is_scanning = False
                
                # Engine pentru recuperare
                recovery_engine = RealFileRecoveryEngine()
                
                # Creare meniu
                menubar = tk.Menu(recover_window, bg='#c0c0c0', relief='raised', bd=1)
                recover_window.config(menu=menubar)
                
                # Meniul File
                file_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0')
                menubar.add_cascade(label="File", menu=file_menu, underline=0)
                
                # Meniul Tools
                tools_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0')
                menubar.add_cascade(label="Tools", menu=tools_menu, underline=0)
                
                # Meniul Help
                help_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0')
                menubar.add_cascade(label="Help", menu=help_menu, underline=0)
                
                # Creare toolbar
                toolbar = tk.Frame(recover_window, bg='#c0c0c0', relief='raised', bd=1, height=40)
                toolbar.pack(fill='x', pady=2)
                
                # Butoane toolbar cu efect 3D
                btn_new = tk.Button(toolbar, text="New Scan", font=default_font,
                                   relief='raised', bd=2, padx=10, pady=2,
                                   bg='#c0c0c0')
                btn_new.pack(side='left', padx=2, pady=2)
                
                btn_recycle = tk.Button(toolbar, text="Recycle Bin", font=default_font,
                                       relief='raised', bd=2, padx=10, pady=2,
                                       bg='#c0c0c0')
                btn_recycle.pack(side='left', padx=2, pady=2)
                
                btn_temp = tk.Button(toolbar, text="Temp Files", font=default_font,
                                    relief='raised', bd=2, padx=10, pady=2,
                                    bg='#c0c0c0')
                btn_temp.pack(side='left', padx=2, pady=2)
                
                btn_recover = tk.Button(toolbar, text="Recover Selected", font=default_font,
                                       relief='raised', bd=2, padx=10, pady=2,
                                       bg='#c0c0c0')
                btn_recover.pack(side='left', padx=2, pady=2)
                
                btn_preview = tk.Button(toolbar, text="Preview", font=default_font,
                                       relief='raised', bd=2, padx=10, pady=2,
                                       bg='#c0c0c0')
                btn_preview.pack(side='left', padx=2, pady=2)
                
                # Separator
                separator = tk.Frame(toolbar, width=2, bg='#808080', relief='sunken', bd=1)
                separator.pack(side='left', fill='y', padx=5, pady=2)
                
                btn_clear = tk.Button(toolbar, text="Clear", font=default_font,
                                     relief='raised', bd=2, padx=10, pady=2,
                                     bg='#c0c0c0')
                btn_clear.pack(side='left', padx=2, pady=2)
                
                btn_stop = tk.Button(toolbar, text="Stop", font=default_font,
                                    relief='raised', bd=2, padx=10, pady=2,
                                    bg='#c0c0c0')
                btn_stop.pack(side='left', padx=2, pady=2)
                
                # Container principal
                main_frame = tk.Frame(recover_window, bg='#c0c0c0')
                main_frame.pack(fill='both', expand=True, padx=5, pady=5)
                
                # Panoul din stânga - Opțiuni scanare
                left_panel = tk.LabelFrame(main_frame, text="Recovery Options", font=bold_font,
                                         bg='#c0c0c0', relief='groove', bd=2)
                left_panel.pack(side='left', fill='y', padx=(0, 5))
                
                # Tipurile de recuperare
                tk.Label(left_panel, text="Recovery Types:", font=bold_font, bg='#c0c0c0').pack(anchor='w', padx=5, pady=5)
                
                recovery_types = {
                    'Recycle Bin Files': tk.BooleanVar(value=True),
                    'Temporary Files': tk.BooleanVar(value=True),
                    'Recent Documents': tk.BooleanVar(value=True),
                    'Browser Cache': tk.BooleanVar(value=False),
                    'System Restore Points': tk.BooleanVar(value=False)
                }
                
                for recovery_type, var in recovery_types.items():
                    cb = tk.Checkbutton(left_panel, text=recovery_type, variable=var,
                                      font=default_font, bg='#c0c0c0')
                    cb.pack(anchor='w', padx=10, pady=1)
                    
                # Tipurile de fișiere
                tk.Label(left_panel, text="File Types:", font=bold_font, bg='#c0c0c0').pack(anchor='w', padx=5, pady=(15,2))
                
                file_types = {
                    'Documents': tk.BooleanVar(value=True),
                    'Images': tk.BooleanVar(value=True),
                    'Videos': tk.BooleanVar(value=True),
                    'Audio': tk.BooleanVar(value=True),
                    'Archives': tk.BooleanVar(value=True),
                    'All Files': tk.BooleanVar(value=False)
                }
                
                for file_type, var in file_types.items():
                    cb = tk.Checkbutton(left_panel, text=file_type, variable=var,
                                      font=default_font, bg='#c0c0c0')
                    cb.pack(anchor='w', padx=10, pady=1)
                    
                # Acțiuni rapide
                tk.Label(left_panel, text="Quick Actions:", font=bold_font, bg='#c0c0c0').pack(anchor='w', padx=5, pady=(15,5))
                
                btn_quick_recycle = tk.Button(left_panel, text="Quick Recycle Scan", 
                                            font=default_font, relief='raised', bd=2,
                                            bg='#c0c0c0')
                btn_quick_recycle.pack(fill='x', padx=5, pady=2)
                
                btn_quick_temp = tk.Button(left_panel, text="Quick Temp Scan", 
                                         font=default_font, relief='raised', bd=2,
                                         bg='#c0c0c0')
                btn_quick_temp.pack(fill='x', padx=5, pady=2)
                
                # Panoul din dreapta - Rezultate
                right_panel = tk.Frame(main_frame, bg='#c0c0c0')
                right_panel.pack(side='right', fill='both', expand=True)
                
                # Eticheta rezultatelor
                results_label = tk.Label(right_panel, text="Recoverable Files", 
                                       font=bold_font, bg='#c0c0c0')
                results_label.pack(anchor='w', pady=(0,5))
                
                # Treeview pentru rezultate
                tree_frame = tk.Frame(right_panel, relief='sunken', bd=2)
                tree_frame.pack(fill='both', expand=True)
                
                # Creează treeview cu stilul clasic
                style = ttk.Style()
                style.configure("Classic.Treeview", background="white", foreground="black")
                style.configure("Classic.Treeview.Heading", background="#c0c0c0", foreground="black")
                
                tree = ttk.Treeview(tree_frame, style="Classic.Treeview")
                tree['columns'] = ('Size', 'Type', 'Location', 'Date Modified', 'Status')
                tree.heading('#0', text='File Name')
                tree.heading('Size', text='Size')
                tree.heading('Type', text='Type')
                tree.heading('Location', text='Original Location')
                tree.heading('Date Modified', text='Date Modified')
                tree.heading('Status', text='Status')
                
                # Lățimile coloanelor
                tree.column('#0', width=200)
                tree.column('Size', width=80)
                tree.column('Type', width=80)
                tree.column('Location', width=200)
                tree.column('Date Modified', width=120)
                tree.column('Status', width=100)
                
                # Bare de derulare
                v_scrollbar = tk.Scrollbar(tree_frame, orient='vertical', command=tree.yview)
                h_scrollbar = tk.Scrollbar(tree_frame, orient='horizontal', command=tree.xview)
                tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
                
                tree.pack(side='left', fill='both', expand=True)
                v_scrollbar.pack(side='right', fill='y')
                h_scrollbar.pack(side='bottom', fill='x')
                
                # Cadrul de progres
                progress_frame = tk.Frame(right_panel, bg='#c0c0c0')
                progress_frame.pack(fill='x', pady=(5,0))
                
                # Bara de progres
                progress_bar = tk.Canvas(progress_frame, height=20, bg='white', relief='sunken', bd=2)
                progress_bar.pack(fill='x', pady=2)
                
                # Statusul operației
                operation_label = tk.Label(progress_frame, textvariable=current_operation,
                                         font=default_font, bg='#c0c0c0')
                operation_label.pack(anchor='w')
                
                # Bara de status
                status_frame = tk.Frame(recover_window, bg='#c0c0c0', relief='sunken', bd=1)
                status_frame.pack(fill='x', side='bottom')
                
                status_label = tk.Label(status_frame, textvariable=status_text,
                                      font=default_font, bg='#c0c0c0', anchor='w')
                status_label.pack(side='left', padx=5)
                
                separator1 = tk.Frame(status_frame, width=2, bg='#808080', relief='sunken', bd=1)
                separator1.pack(side='left', fill='y', padx=2)
                
                files_label = tk.Label(status_frame, text="Files found: 0",
                                     font=default_font, bg='#c0c0c0')
                files_label.pack(side='left', padx=5)
                
                separator2 = tk.Frame(status_frame, width=2, bg='#808080', relief='sunken', bd=1)
                separator2.pack(side='left', fill='y', padx=2)
                
                time_label = tk.Label(status_frame, text=datetime.now().strftime("%H:%M:%S"),
                                    font=default_font, bg='#c0c0c0')
                time_label.pack(side='right', padx=5)
                
                # Funcția pentru actualizarea orei
                def update_time():
                    time_label.config(text=datetime.now().strftime("%H:%M:%S"))
                    recover_window.after(1000, update_time)
                
                update_time()
                
                # Funcția pentru actualizarea progresului
                def update_progress(value, operation=""):
                    # Actualizează bara de progres
                    progress_bar.delete("all")
                    
                    # Forțează canvas-ul să-și actualizeze dimensiunile mai întâi
                    progress_bar.update_idletasks()
                    width = progress_bar.winfo_width()
                    height = progress_bar.winfo_height()
                    
                    if width > 1 and height > 1:
                        fill_width = int((value / 100) * (width - 4))
                        if fill_width > 0:
                            block_width = 8
                            blocks = max(1, fill_width // block_width)
                            for i in range(blocks):
                                x1 = 2 + i * block_width
                                x2 = min(x1 + block_width - 1, width - 2)
                                if x2 > x1:
                                    progress_bar.create_rectangle(x1, 2, x2, height-2,
                                                               fill='#0000ff', outline='#0000ff')
                    
                    if operation:
                        current_operation.set(operation)
                    
                    # Forțează actualizarea imediată a tuturor elementelor UI
                    recover_window.update()
                
                # Funcția pentru afișarea ferestrei de setări
                def show_settings():
                    settings_window = tk.Toplevel(recover_window)
                    settings_window.title("Settings")
                    settings_window.overrideredirect(True)
                    settings_window.geometry("400x300")
                    settings_window.configure(bg='#c0c0c0')
                    settings_window.resizable(False, False)
                    
                    # Windows 95 style title bar
                    title_bar = tk.Frame(settings_window, bg="#000080", height=25)
                    title_bar.pack(fill="x", side="top")
                    title_label = tk.Label(title_bar, text="Settings", fg="white", bg="#000080",
                                        font=("MS Sans Serif", 8, "bold"))
                    title_label.pack(side="left", padx=5, pady=2)
                    
                    # Close button for title bar
                    close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                          font=("Arial", 8, "bold"), width=2, height=1,
                                          relief="raised", bd=1,
                                          command=settings_window.destroy)
                    close_button.pack(side="right", padx=2, pady=1)
                    
                    # Make window draggable
                    self.make_window_draggable(settings_window, title_bar)
                    
                    tk.Label(settings_window, text="RetroRecover Pro Settings", 
                           font=title_font, bg='#c0c0c0').pack(pady=10)
                    
                    # Setări recuperare
                    frame1 = tk.LabelFrame(settings_window, text="Recovery Options", 
                                         font=bold_font, bg='#c0c0c0')
                    frame1.pack(fill='x', padx=10, pady=5)
                    
                    create_log = tk.BooleanVar(value=True)
                    verify_files = tk.BooleanVar(value=True)
                    
                    tk.Checkbutton(frame1, text="Create recovery log", variable=create_log,
                                 font=default_font, bg='#c0c0c0').pack(anchor='w', padx=5)
                    tk.Checkbutton(frame1, text="Verify recovered files", variable=verify_files,
                                 font=default_font, bg='#c0c0c0').pack(anchor='w', padx=5)
                    
                    # Setări scanare
                    frame2 = tk.LabelFrame(settings_window, text="Scan Settings", 
                                         font=bold_font, bg='#c0c0c0')
                    frame2.pack(fill='x', padx=10, pady=5)
                    
                    tk.Label(frame2, text="Max file age (days):", font=default_font, bg='#c0c0c0').pack(anchor='w', padx=5)
                    max_age_var = tk.StringVar(value="30")
                    tk.Entry(frame2, textvariable=max_age_var, width=10).pack(anchor='w', padx=5, pady=2)
                    
                    # Butoane
                    btn_frame = tk.Frame(settings_window, bg='#c0c0c0')
                    btn_frame.pack(pady=20)
                    
                    tk.Button(btn_frame, text="OK", font=default_font, 
                           relief='raised', bd=2, padx=20, command=settings_window.destroy).pack(side='left', padx=5)
                    tk.Button(btn_frame, text="Cancel", font=default_font, 
                           relief='raised', bd=2, padx=20, command=settings_window.destroy).pack(side='left', padx=5)
                
                # Funcția pentru afișarea ferestrei about
                def show_about():
                    about_window = tk.Toplevel(recover_window)
                    about_window.title("About RetroRecover Pro")
                    about_window.overrideredirect(True)
                    about_window.geometry("450x350")
                    about_window.configure(bg='#c0c0c0')
                    about_window.resizable(False, False)
                    
                    # Windows 95 style title bar
                    title_bar = tk.Frame(about_window, bg="#000080", height=25)
                    title_bar.pack(fill="x", side="top")
                    title_label = tk.Label(title_bar, text="About RetroRecover Pro", fg="white", bg="#000080",
                                        font=("MS Sans Serif", 8, "bold"))
                    title_label.pack(side="left", padx=5, pady=2)
                    
                    # Close button for title bar
                    close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                          font=("Arial", 8, "bold"), width=2, height=1,
                                          relief="raised", bd=1,
                                          command=about_window.destroy)
                    close_button.pack(side="right", padx=2, pady=1)
                    
                    # Make window draggable
                    self.make_window_draggable(about_window, title_bar)
                    
                    tk.Label(about_window, text="RetroRecover Pro", 
                           font=("MS Sans Serif", 14, "bold"), 
                           bg='#c0c0c0').pack(pady=20)
                    
                    tk.Label(about_window, text="Version 1.0 - Real Recovery", 
                           font=default_font, bg='#c0c0c0').pack()
                    
                    tk.Label(about_window, text="Advanced Real File Recovery Tool", 
                           font=default_font, bg='#c0c0c0').pack(pady=5)
                    
                    info_text = """
            This software helps you recover real deleted files from:
            - Recycle Bin (including hidden files)
            - Temporary file locations
            - Recent document lists
            - Browser cache files
            - System restore points

            Features:
            - Multiple recovery sources
            - File preview capabilities
            - Batch recovery operations

            CAUTION: This tool accesses real system files and folders.
            Use responsibly and ensure you have proper permissions.

            Copyright © 2024 Tudor Marmureanu
                    """
                    
                    text_widget = tk.Text(about_window, bg='white', font=default_font, 
                                        wrap='word', height=12, width=50)
                    text_widget.pack(padx=20, pady=10)
                    text_widget.insert('1.0', info_text)
                    text_widget.config(state='disabled')
                    
                    tk.Button(about_window, text="OK", font=default_font, 
                           relief='raised', bd=2, padx=20, 
                           command=about_window.destroy).pack(pady=10)
                
                # Funcția pentru a curăța rezultatele
                def clear_results():
                    """Curăță toate rezultatele curente"""
                    for item in tree.get_children():
                        tree.delete(item)
                        
                    recoverable_files.clear()
                    files_found.set(0)
                    files_label.config(text="Files found: 0")
                    status_text.set("Results cleared")
                    current_operation.set("")
                    update_progress(0, "Ready")
                
                # Funcția pentru scanarea callback
                def scan_callback(progress, operation, found_file=None):
                    update_progress(progress, operation)
                    
                    if found_file:
                        # Adaugă fișierul găsit în tree
                        tree.insert('', 'end', text=found_file['name'],
                                   values=(found_file['size'], found_file['type'],
                                         found_file['location'], found_file['date'], found_file['status']))
                        recoverable_files.append(found_file)
                        files_found.set(len(recoverable_files))
                        files_label.config(text=f"Files found: {files_found.get()}")
                
                # Funcția pentru scanarea Recycle Bin
                def scan_recycle_bin():
                    nonlocal is_scanning
                    if is_scanning:
                        return
                        
                    recovery_engine.stopped = False  # Reset stop flag
                    is_scanning = True
                    status_text.set("Scanning Recycle Bin...")
                    
                    scan_thread = threading.Thread(target=_scan_recycle_bin_thread)
                    scan_thread.daemon = True
                    scan_thread.start()
                    
                def _scan_recycle_bin_thread():
                    nonlocal is_scanning
                    try:
                        recovery_engine.scan_recycle_bin(scan_callback)
                    finally:
                        is_scanning = False
                        status_text.set("Recycle Bin scan completed")
                
                # Funcția pentru scanarea fișierelor temporare
                def scan_temp_files():
                    nonlocal is_scanning
                    if is_scanning:
                        return
                        
                    recovery_engine.stopped = False  # Reset stop flag
                    is_scanning = True
                    status_text.set("Scanning temporary files...")
                    
                    scan_thread = threading.Thread(target=_scan_temp_files_thread)
                    scan_thread.daemon = True
                    scan_thread.start()
                    
                def _scan_temp_files_thread():
                    nonlocal is_scanning
                    try:
                        recovery_engine.scan_temp_files(scan_callback)
                    finally:
                        is_scanning = False
                        status_text.set("Temporary files scan completed")
                
                # Funcția pentru scanarea fișierelor recente
                def scan_recent_files():
                    nonlocal is_scanning
                    if is_scanning:
                        return
                        
                    recovery_engine.stopped = False  # Reset stop flag
                    is_scanning = True
                    status_text.set("Scanning recent files...")
                    
                    scan_thread = threading.Thread(target=_scan_recent_files_thread)
                    scan_thread.daemon = True
                    scan_thread.start()
                    
                def _scan_recent_files_thread():
                    nonlocal is_scanning
                    try:
                        recovery_engine.scan_recent_files(scan_callback)
                    finally:
                        is_scanning = False
                        status_text.set("Recent files scan completed")
                
                # Funcția pentru scanare completă
                def new_scan():
                    nonlocal is_scanning
                    if is_scanning:
                        messagebox.showwarning("Scan in Progress", "Please stop the current scan before starting a new one.")
                        return
                        
                    # Reset stop flag
                    recovery_engine.stopped = False
                    
                    # Curăță rezultatele anterioare
                    for item in tree.get_children():
                        tree.delete(item)
                        
                    recoverable_files.clear()
                    files_found.set(0)
                    
                    # Începe scanarea cuprinzătoare
                    is_scanning = True
                    status_text.set("Starting comprehensive scan...")
                    
                    scan_thread = threading.Thread(target=perform_comprehensive_scan)
                    scan_thread.daemon = True
                    scan_thread.start()
                    
                def perform_comprehensive_scan():
                    nonlocal is_scanning
                    try:
                        selected_types = [rtype for rtype, var in recovery_types.items() if var.get()]
                        total_operations = len(selected_types)
                        current_op_index = 0  # Redenumit din 'current_operation' în 'current_op_index'
                        
                        if 'Recycle Bin Files' in selected_types and not recovery_engine.stopped:
                            current_op_index += 1  # Folosește noua denumire
                            base_progress = int(((current_op_index - 1) / total_operations) * 100)
                            recovery_engine.scan_recycle_bin(lambda p, op, f=None: scan_callback(
                                base_progress + (p // total_operations), op, f))
                            
                        if 'Temporary Files' in selected_types and not recovery_engine.stopped:
                            current_op_index += 1  # Folosește noua denumire
                            base_progress = int(((current_op_index - 1) / total_operations) * 100)
                            recovery_engine.scan_temp_files(lambda p, op, f=None: scan_callback(
                                base_progress + (p // total_operations), op, f))
                            
                        if 'Recent Documents' in selected_types and not recovery_engine.stopped:
                            current_op_index += 1  # Folosește noua denumire
                            base_progress = int(((current_op_index - 1) / total_operations) * 100)
                            recovery_engine.scan_recent_files(lambda p, op, f=None: scan_callback(
                                base_progress + (p // total_operations), op, f))
                            
                        if 'Browser Cache' in selected_types and not recovery_engine.stopped:
                            current_op_index += 1  # Folosește noua denumire
                            base_progress = int(((current_op_index - 1) / total_operations) * 100)
                            recovery_engine.scan_browser_cache(lambda p, op, f=None: scan_callback(
                                base_progress + (p // total_operations), op, f))
                            
                    except Exception as e:
                        messagebox.showerror("Scan Error", f"An error occurred during scanning: {str(e)}")
                    finally:
                        is_scanning = False
                        recovery_engine.stopped = False  # Reset pentru următoarea scanare
                        if recovery_engine.stopped:
                            status_text.set("Scan stopped by user")
                            current_operation.set("Scan cancelled")  # Aici folosim variabila globală
                        else:
                            status_text.set("Scan completed")
                            current_operation.set("Scan finished successfully")  # Aici folosim variabila globală
                        update_progress(100, "")
                
                # Funcția pentru oprirea scanării
                def stop_scan():
                    nonlocal is_scanning
                    is_scanning = False
                    recovery_engine.stopped = True
                    status_text.set("Stopping scan...")
                    current_operation.set("Scan stopped by user")
                    update_progress(0, "Scan stopped")
                
                # Funcția pentru previzualizarea fișierului
                def preview_file():
                    selected_item = tree.selection()
                    if not selected_item:
                        messagebox.showwarning("No Selection", "Please select a file to preview.")
                        return
                        
                    file_name = tree.item(selected_item[0])['text']
                    
                    # Găsește informațiile despre fișier
                    file_info = None
                    for f in recoverable_files:
                        if f['name'] == file_name:
                            file_info = f
                            break
                            
                    if file_info and 'full_path' in file_info:
                        show_preview_window(file_name, file_info['full_path'])
                    else:
                        messagebox.showwarning("Preview Error", "Cannot preview this file.")
                
                def show_preview_window(file_name, file_path):
                    preview_window = tk.Toplevel(recover_window)
                    preview_window.title(f"Preview: {file_name}")
                    preview_window.overrideredirect(True)
                    preview_window.geometry("500x400")
                    preview_window.configure(bg='#c0c0c0')
                    
                    # Windows 95 style title bar
                    title_bar = tk.Frame(preview_window, bg="#000080", height=25)
                    title_bar.pack(fill="x", side="top")
                    title_label = tk.Label(title_bar, text=f"Preview: {file_name}", fg="white", bg="#000080",
                                        font=("MS Sans Serif", 8, "bold"))
                    title_label.pack(side="left", padx=5, pady=2)
                    
                    # Close button for title bar
                    close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                          font=("Arial", 8, "bold"), width=2, height=1,
                                          relief="raised", bd=1,
                                          command=preview_window.destroy)
                    close_button.pack(side="right", padx=2, pady=1)
                    
                    # Make window draggable
                    self.make_window_draggable(preview_window, title_bar)
                    
                    # Conținutul previzualizării
                    text_area = tk.Text(preview_window, bg='white', font=default_font, wrap='word')
                    scrollbar = tk.Scrollbar(preview_window, orient='vertical', command=text_area.yview)
                    text_area.configure(yscrollcommand=scrollbar.set)
                    
                    text_area.pack(side='left', fill='both', expand=True, padx=10, pady=10)
                    scrollbar.pack(side='right', fill='y', pady=10)
                    
                    try:
                        if os.path.exists(file_path):
                            file_size = os.path.getsize(file_path)
                            if file_size < 1024 * 1024:  # Mai puțin de 1MB
                                try:
                                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                        content = f.read()
                                        text_area.insert('1.0', content)
                                except:
                                    text_area.insert('1.0', f"File: {file_name}\nPath: {file_path}\n\n")
                                    text_area.insert('end', "Binary file or unsupported format.\nUse external application to view.")
                            else:
                                text_area.insert('1.0', f"File: {file_name}\nPath: {file_path}\nSize: {file_size} bytes\n\n")
                                text_area.insert('end', "File too large to preview.")
                        else:
                            text_area.insert('1.0', f"File: {file_name}\nPath: {file_path}\n\n")
                            text_area.insert('end', "File no longer exists at this location.")
                    except Exception as e:
                        text_area.insert('1.0', f"Error previewing file: {str(e)}")
                        
                    text_area.config(state='disabled')
                
                # Funcția pentru recuperarea fișierelor selectate
                def recover_selected():
                    selected_items = tree.selection()
                    if not selected_items:
                        messagebox.showwarning("No Selection", "Please select files to recover.")
                        return
                        
                    # Cere folderul de destinație
                    dest_folder = filedialog.askdirectory(title="Select Recovery Destination")
                    if not dest_folder:
                        return
                        
                    # Începe recuperarea
                    recovery_thread = threading.Thread(target=perform_recovery,
                                                     args=(selected_items, dest_folder))
                    recovery_thread.daemon = True
                    recovery_thread.start()
                    
                def perform_recovery(selected_items, dest_folder):
                    try:
                        total_files = len(selected_items)
                        recovered = 0
                        failed = 0
                        
                        for i, item in enumerate(selected_items):
                            file_name = tree.item(item)['text']
                            progress = int((i / total_files) * 100)
                            update_progress(progress, f"Recovering {file_name}...")
                            
                            # Găsește informațiile despre fișier
                            file_info = None
                            for f in recoverable_files:
                                if f['name'] == file_name:
                                    file_info = f
                                    break
                                    
                            if file_info and 'full_path' in file_info:
                                try:
                                    # Efectuează recuperarea propriu-zisă
                                    dest_path = os.path.join(dest_folder, file_name)
                                    if os.path.exists(file_info['full_path']):
                                        shutil.copy2(file_info['full_path'], dest_path)
                                        recovered += 1
                                    else:
                                        failed += 1
                                except Exception as e:
                                    print(f"Failed to recover {file_name}: {e}")
                                    failed += 1
                            else:
                                failed += 1
                            
                        update_progress(100, "Recovery completed")
                        
                        if recovered > 0:
                            messagebox.showinfo("Recovery Complete", 
                                              f"Successfully recovered {recovered} files to {dest_folder}\n"
                                              f"Failed to recover: {failed} files")
                        else:
                            messagebox.showwarning("Recovery Failed", 
                                                 "No files could be recovered. They may have been permanently deleted.")
                        
                    except Exception as e:
                        messagebox.showerror("Recovery Error", f"An error occurred during recovery: {str(e)}")
                
                # Inițializare sample date pentru demo
                def populate_demo_data():
                    """Populează cu date demo"""
                    sample_files = [
                        {"name": "important_document.docx", "size": "45.2 KB", "type": "Documents", 
                         "location": "Recycle Bin", "date": "2024-07-15 14:30", "status": "Recoverable"},
                        {"name": "vacation_photo.jpg", "size": "2.3 MB", "type": "Images", 
                         "location": "Temp Files", "date": "2024-07-10 09:15", "status": "Recoverable"},
                        {"name": "project_backup.zip", "size": "15.6 MB", "type": "Archives", 
                         "location": "Recent Files", "date": "2024-07-20 16:45", "status": "Recoverable"},
                        {"name": "presentation.pptx", "size": "8.7 MB", "type": "Documents", 
                         "location": "Recycle Bin", "date": "2024-07-18 11:22", "status": "Recoverable"},
                        {"name": "meeting_notes.txt", "size": "12.4 KB", "type": "Documents", 
                         "location": "Temp Files", "date": "2024-07-25 13:10", "status": "Recoverable"}
                    ]
                    
                    for file in sample_files:
                        tree.insert('', 'end', text=file["name"], values=(
                            file["size"], file["type"], file["location"], file["date"], file["status"]))
                        recoverable_files.append(file)
                    
                    files_found.set(len(sample_files))
                    files_label.config(text=f"Files found: {files_found.get()}")
                    status_text.set("Sample data loaded")
                
                # Conectarea funcțiilor la butoane
                file_menu.add_command(label="New Scan", command=new_scan, underline=0)
                file_menu.add_command(label="Open Recovery Log", command=lambda: messagebox.showinfo("Info", "Log functionality is a demo"), underline=0)
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window("Recover Tunnel", recover_window), underline=1)
                
                tools_menu.add_command(label="Scan Recycle Bin", command=scan_recycle_bin, underline=5)
                tools_menu.add_command(label="Scan Temp Files", command=scan_temp_files, underline=5)
                tools_menu.add_command(label="Recent Files Scan", command=scan_recent_files, underline=0)
                tools_menu.add_separator()
                tools_menu.add_command(label="Settings", command=show_settings, underline=0)
                
                help_menu.add_command(label="About", command=show_about, underline=0)
                
                btn_new.config(command=new_scan)
                btn_recycle.config(command=scan_recycle_bin)
                btn_temp.config(command=scan_temp_files)
                btn_recover.config(command=recover_selected)
                btn_preview.config(command=preview_file)
                btn_clear.config(command=clear_results)
                btn_stop.config(command=stop_scan)
                
                btn_quick_recycle.config(command=scan_recycle_bin)
                btn_quick_temp.config(command=scan_temp_files)
                
                # Populează cu date demo
                populate_demo_data()
                
                # Adaugă în taskbar
                self.add_window_to_taskbar("Recover Tunnel", recover_window)
                recover_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Recover Tunnel", recover_window))
            
            def create_file_recovery(self):
                """Creează aplicația File Fisher pentru recuperarea fișierelor"""
                recovery_window = tk.Toplevel(self.rootW95dist)
                recovery_window.title("File Fisher")
                recovery_window.overrideredirect(True)
                recovery_window.geometry("640x480+300+150")
                recovery_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(recovery_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="File Fisher", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("File Fisher", recovery_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(recovery_window, title_bar)
                
                # Windows 95 style configuration
                bg_color = '#c0c0c0'
                button_bg = '#c0c0c0'
                button_fg = '#000000'
                text_bg = '#ffffff'
                font_main = ('MS Sans Serif', 8)
                font_title = ('MS Sans Serif', 8, 'bold')
                
                # Variables
                scanning = False
                recovered_files = []
                scan_progress = 0
                
                # Main container
                main_frame = tk.Frame(recovery_window, bg=bg_color, relief='raised', bd=2)
                main_frame.pack(fill='both', expand=True, padx=2, pady=2)
                
                # Top section - Drive selection
                drive_frame = tk.LabelFrame(main_frame, text="Select Drive to Scan", 
                                          bg=bg_color, font=font_main, relief='groove', bd=2)
                drive_frame.pack(fill='x', padx=10, pady=5)
                
                drive_var = tk.StringVar()
                drive_combo = ttk.Combobox(drive_frame, textvariable=drive_var, 
                                          state='readonly', width=20)
                drive_combo.pack(side='left', padx=5, pady=5)
                
                # Function to refresh drives
                def refresh_drives():
                    """Refresh available drives list"""
                    drives = []
                    # Get available drives (Windows)
                    if os.name == 'nt':
                        import string
                        for letter in string.ascii_uppercase:
                            drive = f"{letter}:\\"
                            if os.path.exists(drive):
                                drives.append(drive)
                    else:
                        # Unix-like systems
                        drives = ['/']
                        
                    drive_combo['values'] = drives
                    if drives:
                        drive_combo.set(drives[0])
                
                refresh_btn = tk.Button(drive_frame, text="Refresh", command=refresh_drives,
                                      bg=button_bg, font=font_main, relief='raised', bd=2)
                refresh_btn.pack(side='left', padx=5)
                
                # Scan options
                options_frame = tk.LabelFrame(main_frame, text="Scan Options", 
                                            bg=bg_color, font=font_main, relief='groove', bd=2)
                options_frame.pack(fill='x', padx=10, pady=5)
                
                deep_scan_var = tk.BooleanVar()
                deep_check = tk.Checkbutton(options_frame, text="Deep Scan (slower but more thorough)",
                                          variable=deep_scan_var, bg=bg_color, font=font_main)
                deep_check.pack(anchor='w', padx=5, pady=2)
                
                file_types_var = tk.StringVar(value="All Files")
                file_type_frame = tk.Frame(options_frame, bg=bg_color)
                file_type_frame.pack(fill='x', padx=5, pady=2)
                
                tk.Label(file_type_frame, text="File Types:", bg=bg_color, font=font_main).pack(side='left')
                file_type_combo = ttk.Combobox(file_type_frame, textvariable=file_types_var,
                                             values=["All Files", "Images (jpg,png,gif)", "Documents (doc,pdf,txt)", 
                                                     "Videos (mp4,avi,mov)", "Audio (mp3,wav,flac)"], width=25)
                file_type_combo.pack(side='left', padx=5)
                
                # Control buttons
                control_frame = tk.Frame(main_frame, bg=bg_color)
                control_frame.pack(fill='x', padx=10, pady=5)
                
                # Progress section
                progress_frame = tk.LabelFrame(main_frame, text="Scan Progress", 
                                             bg=bg_color, font=font_main, relief='groove', bd=2)
                progress_frame.pack(fill='x', padx=10, pady=5)
                
                progress_var = tk.StringVar(value="Ready to scan...")
                progress_label = tk.Label(progress_frame, textvariable=progress_var,
                                        bg=bg_color, font=font_main)
                progress_label.pack(pady=5)
                
                progress_bar = ttk.Progressbar(progress_frame, mode='determinate')
                progress_bar.pack(fill='x', padx=10, pady=5)
                
                # Results section
                results_frame = tk.LabelFrame(main_frame, text="Found Files", 
                                            bg=bg_color, font=font_main, relief='groove', bd=2)
                results_frame.pack(fill='both', expand=True, padx=10, pady=5)
                
                # Treeview with scrollbars
                tree_frame = tk.Frame(results_frame, bg=bg_color)
                tree_frame.pack(fill='both', expand=True, padx=5, pady=5)
                
                tree = ttk.Treeview(tree_frame, columns=('Size', 'Type', 'Status'), show='tree headings')
                tree.heading('#0', text='File Name')
                tree.heading('Size', text='Size')
                tree.heading('Type', text='Type')
                tree.heading('Status', text='Status')
                
                tree.column('#0', width=200)
                tree.column('Size', width=80)
                tree.column('Type', width=80)
                tree.column('Status', width=100)
                
                # Scrollbars
                v_scrollbar = ttk.Scrollbar(tree_frame, orient='vertical', command=tree.yview)
                h_scrollbar = ttk.Scrollbar(tree_frame, orient='horizontal', command=tree.xview)
                tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
                
                tree.pack(side='left', fill='both', expand=True)
                v_scrollbar.pack(side='right', fill='y')
                h_scrollbar.pack(side='bottom', fill='x')
                
                # Status bar
                status_frame = tk.Frame(recovery_window, bg='#808080', relief='sunken', bd=1)
                status_frame.pack(fill='x', side='bottom')
                
                status_var = tk.StringVar(value="Ready")
                status_label = tk.Label(status_frame, textvariable=status_var,
                                      bg='#808080', fg='white', font=font_main, anchor='w')
                status_label.pack(fill='x', padx=5, pady=1)
                
                # Utility functions
                def format_size(size):
                    """Format file size in human readable format"""
                    for unit in ['B', 'KB', 'MB', 'GB']:
                        if size < 1024:
                            return f"{size:.1f} {unit}"
                        size /= 1024
                    return f"{size:.1f} TB"
                
                def get_file_extensions():
                    """Get file extensions based on selected type"""
                    file_type = file_types_var.get()
                    
                    extensions = {
                        "All Files": [],
                        "Images (jpg,png,gif)": ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff'],
                        "Documents (doc,pdf,txt)": ['.doc', '.docx', '.pdf', '.txt', '.rtf', '.odt', '.ods', '.odp', '.md', '.html', '.htm', '.xls', '.xlsx', '.csv', '.rtf', '.ppt', '.pptx', '.json', '.log'],
                        "Videos (mp4,avi,mov)": ['.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv'],
                        "Audio (mp3,wav,flac)": ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma']
                    }
                    
                    return extensions.get(file_type, [])
                
                def is_file_match(file_path, file_types):
                    """Check if file matches the selected criteria"""
                    try:
                        # Check file extension if specific type is selected
                        if file_types:
                            _, ext = os.path.splitext(file_path.lower())
                            if ext not in file_types:
                                return False
                                
                        # If "All Files" or file matches extension filter, include it
                        return True
                                
                    except Exception:
                        return False
                
                def add_found_file(file_path):
                    """Add a found file to the results"""
                    try:
                        file_name = os.path.basename(file_path)
                        
                        # Get file info
                        if os.path.exists(file_path):
                            size = os.path.getsize(file_path)
                            status = "Existing"
                        else:
                            size = 0
                            status = "Not Found"
                            
                        size_str = format_size(size)
                        _, ext = os.path.splitext(file_name)
                        file_type = ext.upper()[1:] if ext else "Unknown"
                        
                        # Add to tree
                        item = tree.insert('', 'end', text=file_name, 
                                         values=(size_str, file_type, status))
                        
                        # Store file info
                        recovered_files.append({
                            'path': file_path,
                            'name': file_name,
                            'size': size,
                            'type': file_type,
                            'status': status,
                            'item': item
                        })
                        
                    except Exception as e:
                        print(f"Error adding file {file_path}: {e}")
                
                def copy_single_file(file_info, recovery_dir):
                    """Copy a single file"""
                    try:
                        source_path = file_info['path']
                        dest_path = os.path.join(recovery_dir, file_info['name'])
                        
                        # If source exists, copy it
                        if os.path.exists(source_path):
                            import shutil
                            shutil.copy2(source_path, dest_path)
                            return True
                        else:
                            # File doesn't exist - can't copy
                            return False
                            
                    except Exception as e:
                        print(f"Error copying {file_info['name']}: {e}")
                        return False
                
                def recover_files():
                    """Recover selected files"""
                    selected_items = tree.selection()
                    if not selected_items:
                        messagebox.showwarning("Warning", "Please select files to fish!")
                        return
                        
                    # Choose recovery location
                    recovery_dir = filedialog.askdirectory(title="Select Fishing Location")
                    if not recovery_dir:
                        return
                        
                    # Start recovery
                    status_var.set("Copying files...")
                    recovered_count = 0
                    
                    for item in selected_items:
                        try:
                            # Find file info
                            file_info = None
                            for f in recovered_files:
                                if f['item'] == item:
                                    file_info = f
                                    break
                                    
                            if file_info:
                                success = copy_single_file(file_info, recovery_dir)
                                if success:
                                    recovered_count += 1
                                    # Update status in tree
                                    tree.set(item, 'Status', 'Copied')
                                    
                        except Exception as e:
                            print(f"Copy error: {e}")
                            
                    messagebox.showinfo("Copy Complete", 
                                       f"Successfully copied {recovered_count} out of {len(selected_items)} files!")
                    status_var.set(f"Copied {recovered_count} files")
                
                def perform_scan():
                    """Perform the actual file scanning"""
                    nonlocal scanning
                    
                    drive = drive_var.get()
                    deep_scan = deep_scan_var.get()
                    file_types = get_file_extensions()
                    
                    progress_var.set(f"Scanning {drive}...")
                    status_var.set("Scanning...")
                    
                    total_files = 0
                    scanned_files = 0
                    
                    try:
                        # First pass - count files for progress
                        if scanning:
                            for root, dirs, files in os.walk(drive):
                                total_files += len(files)
                                if not scanning:
                                    break
                                    
                        progress_bar.config(maximum=total_files)
                        
                        # Second pass - actual scanning
                        for root, dirs, files in os.walk(drive):
                            if not scanning:
                                break
                                
                            for file in files:
                                if not scanning:
                                    break
                                    
                                file_path = os.path.join(root, file)
                                scanned_files += 1
                                
                                # Update progress
                                progress_bar.config(value=scanned_files)
                                progress_var.set(f"Scanning: {file} ({scanned_files}/{total_files})")
                                recovery_window.update_idletasks()
                                
                                # Check if file matches criteria
                                if is_file_match(file_path, file_types):
                                    add_found_file(file_path)
                                    
                                # Small delay to prevent UI freezing
                                time.sleep(0.001)
                                
                    except Exception as e:
                        messagebox.showerror("Error", f"Scan error: {str(e)}")
                        
                    # Scan completed
                    if scanning:
                        progress_var.set(f"Scan completed! Found {len(recovered_files)} files")
                        status_var.set(f"Found {len(recovered_files)} files")
                    
                    scanning = False
                    scan_btn.config(state='normal')
                    stop_btn.config(state='disabled')
                    if recovered_files:
                        recover_btn.config(state='normal')
                
                def start_scan():
                    """Start the file recovery scan"""
                    nonlocal scanning
                    
                    if not drive_var.get():
                        messagebox.showwarning("Warning", "Please select a drive to scan!")
                        return
                        
                    scanning = True
                    scan_btn.config(state='disabled')
                    stop_btn.config(state='normal')
                    recover_btn.config(state='disabled')
                    
                    # Clear previous results
                    for item in tree.get_children():
                        tree.delete(item)
                    recovered_files.clear()
                    
                    # Start scan in separate thread
                    scan_thread = threading.Thread(target=perform_scan)
                    scan_thread.daemon = True
                    scan_thread.start()
                
                def stop_scan():
                    """Stop the current scan"""
                    nonlocal scanning
                    
                    scanning = False
                    scan_btn.config(state='normal')
                    stop_btn.config(state='disabled')
                    if recovered_files:
                        recover_btn.config(state='normal')
                    progress_var.set("Scan stopped by user")
                    status_var.set("Scan stopped")
                
                # Buttons
                scan_btn = tk.Button(control_frame, text="Start Scan", command=start_scan,
                                    bg='#008000', fg='white', font=font_main, 
                                    relief='raised', bd=2, width=12)
                scan_btn.pack(side='left', padx=5)
                
                stop_btn = tk.Button(control_frame, text="Stop Scan", command=stop_scan,
                                    bg='#800000', fg='white', font=font_main, 
                                    relief='raised', bd=2, width=12, state='disabled')
                stop_btn.pack(side='left', padx=5)
                
                recover_btn = tk.Button(control_frame, text="Extract Selected", command=recover_files,
                                       bg='#000080', fg='white', font=font_main, 
                                       relief='raised', bd=2, width=15, state='disabled')
                recover_btn.pack(side='right', padx=5)
                
                # Initialize
                refresh_drives()
                
                # Add to taskbar
                self.add_window_to_taskbar("File Fisher", recovery_window)
                recovery_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("File Fisher", recovery_window))
            
            def create_about_window(self):
                about_window = tk.Toplevel(self.rootW95dist)
                about_window.title("System Requirements")
                about_window.overrideredirect(True)
                about_window.geometry("700x300+300+200")
                about_window.configure(bg="#c9c9c9")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(about_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="System Requirements", fg="white", bg="#000080",
                                     font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                       font=("Arial", 8, "bold"), width=2, height=1,
                                       relief="raised", bd=1,
                                       command=lambda: self.close_window("System Requirements", about_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(about_window, title_bar)
                
                # Obținem informațiile sistemului
                sys_info = platform.uname()
                system_version = sys_info.system
                processor_info = platform.processor()
                
                # Specificațiile minime
                min_os = "Windows 10 (x64)"
                min_processor_speed = 1  # GHz
                min_ram = 4  # GB
                min_disk_space = 300  # MB
                
                # Obținem informațiile sistemului
                os_version = sys_info.release
                ram = psutil.virtual_memory().total / (1024 ** 3)  # RAM în GB
                
                # Încercăm să extragem viteza procesorului - acest lucru ar putea să nu funcționeze pe toate sistemele
                try:
                    processor_speed = float(processor_info.split()[2].split('GHz')[0])  # extragem valoarea GHz
                except (IndexError, ValueError):
                    processor_speed = 0  # Nu putem determina viteza
                
                is_x64 = sys_info.machine in ["x86_64", "AMD64"]  # Verificăm dacă este sistem x64 (AMD64 sau x86_64)
                
                # Verificăm dacă sistemul îndeplinește cerințele minime
                meets_requirements = True
                requirements_message = "System meets minimum requirements"
                
                if system_version != "Windows" or not is_x64:
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: OS is not Windows x64."
                
                # Verificăm versiunea (mai sigur)
                try:
                    major_version = int(os_version.split('.')[0])
                    if major_version < 10:
                        meets_requirements = False
                        requirements_message = f"Does not meet minimum requirements: OS version is older than Windows 10 (Detected: Windows {major_version})."
                except (ValueError, IndexError):
                    # Nu putem determina versiunea cu exactitate
                    pass
                
                if processor_speed < min_processor_speed and processor_speed > 0:  # Doar dacă am reușit să extrageam viteza
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: Processor speed is too low."
                
                # Verificăm RAM-ul
                if ram < min_ram:
                    meets_requirements = False
                    requirements_message = "Does not meet minimum requirements: RAM is too low."
                
                # Verificăm dacă există suficient spațiu pe disc
                try:
                    if system_version == "Windows":
                        disk_space = psutil.disk_usage('/').free / (1024 ** 2)  # spațiu liber în MB
                        if disk_space < min_disk_space:
                            meets_requirements = False
                            requirements_message = "Does not meet minimum requirements: Insufficient disk space."
                    else:
                        disk_space = psutil.disk_usage('/').free / (1024 ** 2)  # Pentru alte sisteme de operare
                except:
                    disk_space = 0  # Nu putem determina spațiul pe disc
                
                # Creăm layout-ul pentru fereastra de 'About'
                frame = tk.Frame(about_window, bg='#c9c9c9')
                frame.pack(padx=10, pady=10)
                
                # Specificațiile minime
                min_specs = tk.Label(frame, text=f"Minimum Requirements:\nOS: {min_os}\nProcessor: {min_processor_speed} GHz\nRAM: {min_ram} GB\nDisk space: {min_disk_space} MB free", 
                                   font=("Fixedsys", 12), bg='#c9c9c9')
                min_specs.grid(row=0, column=0, padx=10, pady=10, sticky='w')
                
                # Specificațiile curente
                current_specs = tk.Label(frame, text=f"Your System:\nOS: {system_version} {os_version} {sys_info.machine}\nProcessor: {processor_info}\nRAM: {ram:.2f} GB\nDisk space: {disk_space:.2f} MB free", 
                                       font=("Fixedsys", 12), bg='#c9c9c9')
                current_specs.grid(row=0, column=1, padx=10, pady=10, sticky='w')
                
                # Mesajul de cerințe
                color = "green" if meets_requirements else "red"
                result_label = tk.Label(about_window, text=requirements_message, font=("Fixedsys", 14), fg=color, bg='#c9c9c9')
                result_label.pack(pady=10)
                
                # Adăugăm un buton OK
                ok_button = tk.Button(about_window, text="OK", font=("Fixedsys", 12), bg="#c0c0c0", 
                                    command=lambda: self.close_window("System Requirements", about_window))
                ok_button.pack(pady=10)
                
                self.add_window_to_taskbar("System Requirements", about_window)
                about_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("System Requirements", about_window))
            
            def create_activation_window(self):
                window = tk.Toplevel(self.rootW95dist)
                window.title("Activation Wizard")
                window.overrideredirect(True)
                window.geometry("400x200+300+200")
                window.configure(bg="#c9c9c9")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Activation Wizard", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Activation Wizard", window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(window, title_bar)
                
                # Mesaj
                label = tk.Label(window, text="Enter your product key:", font=("Fixedsys"), bg="#c9c9c9")
                label.pack(pady=10)
                
                # Câmp de introducere a cheii
                product_key_entry = tk.Entry(window, font=("Fixedsys"), width=30, bd=5)
                product_key_entry.pack(pady=5)
                
                # Butonul de activare (inițial dezactivat)
                activate_button = tk.Button(
                    window, text="Activate", font=("Fixedsys"), state=tk.DISABLED, bd=5, bg="#c9c9c9", 
                    command=lambda: activate_product()
                )
                activate_button.pack(pady=5)
                
                # Butonul "Activate later" -> elimină aplicația din taskbar
                later_button = tk.Button(
                    window, text="Activate later", font=("Fixedsys"), bd=5, bg="#c9c9c9", 
                    command=lambda: self.close_window("Activation Wizard", window)
                )
                later_button.pack(pady=5)
                
                # Funcție pentru activare
                def activate_product():
                    product_key = product_key_entry.get()
                    valid_key = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
                    FOLDER_NAME = "Serial"
                    FILE_NAME = "product_key.lic95"
                    
                    if not os.path.exists(FOLDER_NAME):
                        try:
                            os.makedirs(FOLDER_NAME)
                        except:
                            pass
                            
                    if product_key == valid_key:
                        file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                        # Verificăm dacă fișierul există deja
                        if not os.path.exists(file_path):
                            with open(file_path, "w") as file:
                                file.write(valid_key)
                        messagebox.showinfo("Activation Successful", "Product has been activated successfully.")
                        self.close_window("Activation Wizard", window)
                    else:
                        messagebox.showerror("Activation Failed", "Invalid product key. Please try again.")
                        
                # Funcție pentru validarea cheii în timp real
                def validate_key(event):
                    if product_key_entry.get() == "R46BX-JHR2J-PG7ER-24QFG-MWKVR":
                        activate_button.config(state=tk.NORMAL)  # Activează butonul dacă cheia este corectă
                    else:
                        activate_button.config(state=tk.DISABLED)  # Dezactivează butonul dacă cheia e greșită
                        
                product_key_entry.bind("<KeyRelease>", validate_key)  # Verifică validitatea în timp real
                
                self.add_window_to_taskbar("Activation Wizard", window)
                window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Activation Wizard", window))
            
            def open_sql_explorer(self):
                # Create SQL Explorer window
                sql_window = tk.Toplevel(self.rootW95dist)
                sql_window.title("SQL Explorer")
                sql_window.overrideredirect(True)
                sql_window.geometry("800x600+200+100")
                sql_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(sql_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="SQL Explorer", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("SQL Explorer", sql_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(sql_window, title_bar)
                
                # Import required modules for SQL Explorer
                import sqlite3
                import os
                
                class Win95SQLViewer:
                    def __init__(self, root):
                        self.root = root
                        
                        # Win95 color palette
                        self.colors = {
                            "bg_main": "#c0c0c0",         # Classic Win95 gray background
                            "bg_window": "#ffffff",        # Window background
                            "text": "#000000",             # Black text
                            "button_face": "#c0c0c0",      # Button face color
                            "button_shadow": "#808080",    # Button shadow
                            "button_highlight": "#ffffff", # Button highlight
                            "button_text": "#000000",      # Button text
                            "title_bg": "#000080",         # Title bar background (navy blue)
                            "title_text": "#ffffff",       # Title bar text (white)
                            "border": "#808080"            # Border color
                        }
                        
                        self.connection = None
                        self.current_table = None
                        
                        # Configure styles
                        self.setup_styles()
                        
                        # Create interface
                        self.create_widgets()
                        self.create_menu()
                    
                    def setup_styles(self):
                        # Set app font to match Win95 style
                        self.default_font = ("MS Sans Serif", 9)
                        
                        style = ttk.Style()
                        
                        # Configure treeview style
                        style.configure(
                            "Treeview",
                            background=self.colors["bg_window"],
                            foreground=self.colors["text"],
                            fieldbackground=self.colors["bg_window"],
                            borderwidth=1,
                            relief=tk.SUNKEN
                        )
                        
                        # Configure treeview heading
                        style.configure(
                            "Treeview.Heading",
                            background=self.colors["button_face"],
                            foreground=self.colors["text"],
                            relief=tk.RAISED,
                            borderwidth=2,
                            font=self.default_font
                        )
                        
                        # Configure scrollbar
                        style.configure(
                            "TScrollbar",
                            background=self.colors["button_face"],
                            troughcolor=self.colors["bg_window"],
                            borderwidth=2,
                            relief=tk.RAISED,
                            arrowsize=13
                        )
                        
                        # Configure combobox
                        style.configure(
                            "TCombobox",
                            background=self.colors["bg_window"],
                            fieldbackground=self.colors["bg_window"],
                            selectbackground=self.colors["title_bg"],
                            selectforeground=self.colors["title_text"]
                        )
                    
                    def create_menu(self):
                        # Create classic Win95 menu style
                        menubar = tk.Menu(self.root, bg=self.colors["bg_main"], fg=self.colors["text"],
                                        activebackground=self.colors["title_bg"],
                                        activeforeground=self.colors["title_text"],
                                        relief=tk.RAISED, bd=1)
                        self.root.config(menu=menubar)
                        
                        # File menu
                        file_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_main"],
                                            fg=self.colors["text"],
                                            activebackground=self.colors["title_bg"],
                                            activeforeground=self.colors["title_text"], bd=1)
                        file_menu.add_command(label="Open Database...", command=self.open_database)
                        file_menu.add_separator()
                        file_menu.add_command(label="Exit", command=self.root.destroy)
                        menubar.add_cascade(label="File", menu=file_menu)
                        
                        # Edit menu
                        edit_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_main"],
                                        fg=self.colors["text"],
                                        activebackground=self.colors["title_bg"],
                                        activeforeground=self.colors["title_text"], bd=1)
                        edit_menu.add_command(label="Refresh", command=self.refresh_tables)
                        edit_menu.add_command(label="Execute Query", command=self.execute_query)
                        menubar.add_cascade(label="Edit", menu=edit_menu)
                    
                    def create_widgets(self):
                        # Main window frame (inset look)
                        main_frame = tk.Frame(
                            self.root, 
                            bg=self.colors["bg_main"],
                            bd=2,
                            relief=tk.RAISED
                        )
                        main_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=28)  # Padding adjusted for title bar
                        
                        # Toolbar frame
                        toolbar = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=0)
                        toolbar.pack(fill=tk.X, pady=(2, 5), padx=2)
                        
                        # Table selection frame
                        control_frame = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=0)
                        control_frame.pack(fill=tk.X, pady=(0, 5), padx=5)
                        
                        # Table label
                        table_label = tk.Label(
                            control_frame,
                            text="Tables:",
                            bg=self.colors["bg_main"],
                            fg=self.colors["text"]
                        )
                        table_label.pack(side=tk.LEFT, padx=(0, 5))
                        
                        # Table dropdown with Win95 style
                        self.table_combo = ttk.Combobox(
                            control_frame,
                            state="readonly",
                            width=30
                        )
                        self.table_combo.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
                        self.table_combo.bind("<<ComboboxSelected>>", self.load_table)
                        
                        # Refresh button
                        refresh_button = self.create_win95_button(
                            control_frame, 
                            text="Refresh",
                            command=self.refresh_tables
                        )
                        refresh_button.pack(side=tk.RIGHT, padx=2)
                        
                        # Query frame
                        query_frame = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=0)
                        query_frame.pack(fill=tk.X, pady=(0, 5), padx=5)
                        
                        # Query label
                        query_label = tk.Label(
                            query_frame,
                            text="SQL Query:",
                            bg=self.colors["bg_main"],
                            fg=self.colors["text"]
                        )
                        query_label.pack(side=tk.LEFT, padx=(0, 5))
                        
                        # Query text entry (sunken, like Win95)
                        self.query_entry = tk.Entry(
                            query_frame,
                            bg=self.colors["bg_window"],
                            fg=self.colors["text"],
                            bd=2,
                            relief=tk.SUNKEN,
                            insertbackground=self.colors["text"],
                            font=("Courier New", 10)
                        )
                        self.query_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
                        
                        # Execute button
                        execute_button = self.create_win95_button(
                            query_frame, 
                            text="Execute",
                            command=self.execute_query
                        )
                        execute_button.pack(side=tk.RIGHT, padx=2)
                        
                        # Frame for treeview
                        table_frame = tk.Frame(main_frame, bg=self.colors["bg_main"], bd=2, relief=tk.SUNKEN)
                        table_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))
                        
                        # Create treeview with scrollbars
                        self.tree = ttk.Treeview(table_frame)
                        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                        
                        # Vertical scrollbar
                        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
                        vsb.pack(side=tk.RIGHT, fill=tk.Y)
                        self.tree.configure(yscrollcommand=vsb.set)
                        
                        # Horizontal scrollbar
                        hsb = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
                        hsb.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=(0, 5))
                        self.tree.configure(xscrollcommand=hsb.set)
                        
                        # Status bar
                        self.status_var = tk.StringVar()
                        self.status_var.set("Ready")
                        
                        # Status bar with Win95 inset look
                        status_frame = tk.Frame(main_frame, bd=2, relief=tk.SUNKEN)
                        status_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=3, pady=3)
                        
                        self.status_bar = tk.Label(
                            status_frame,
                            textvariable=self.status_var,
                            bg=self.colors["bg_main"],
                            fg=self.colors["text"],
                            anchor=tk.W,
                            bd=1,
                            padx=5,
                            pady=2
                        )
                        self.status_bar.pack(fill=tk.X)
                    
                    def create_win95_button(self, parent, text, command):
                        """Create a button with typical Windows 95 appearance"""
                        button_frame = tk.Frame(parent, bd=2, relief=tk.RAISED)
                        
                        button = tk.Button(
                            button_frame,
                            text=text,
                            bg=self.colors["button_face"],
                            fg=self.colors["button_text"],
                            activebackground=self.colors["button_face"],
                            activeforeground=self.colors["button_text"],
                            bd=2,
                            width=10,
                            command=command,
                            relief=tk.RAISED,
                            padx=6,
                            pady=1,
                            font=self.default_font
                        )
                        button.pack(padx=1, pady=1)
                        
                        # Windows 95 button press effect
                        button.bind("<ButtonPress-1>", lambda e: button_frame.config(relief=tk.SUNKEN))
                        button.bind("<ButtonRelease-1>", lambda e: button_frame.config(relief=tk.RAISED))
                        
                        return button_frame
                    
                    def open_database(self):
                        file_path = filedialog.askopenfilename(
                            title="Open Database",
                            filetypes=[("SQLite Files", "*.db *.sqlite *.sqlite3"), ("All Files", "*.*")]
                        )
                        
                        if file_path:
                            try:
                                if self.connection:
                                    self.connection.close()
                                
                                self.connection = sqlite3.connect(file_path)
                                self.refresh_tables()
                                self.status_var.set(f"Database: {os.path.basename(file_path)}")
                                messagebox.showinfo("Success", "Database opened successfully!")
                            except sqlite3.Error as e:
                                messagebox.showerror("Error", f"Could not open database: {e}")
                                self.status_var.set("Error opening database.")
                    
                    def refresh_tables(self):
                        if not self.connection:
                            messagebox.showwarning("Warning", "No database is open!")
                            return
                        
                        try:
                            cursor = self.connection.cursor()
                            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                            tables = cursor.fetchall()
                            
                            self.table_combo['values'] = [table[0] for table in tables]
                            if tables:
                                self.table_combo.current(0)
                                self.load_table(None)
                            else:
                                messagebox.showinfo("Info", "No tables found in this database.")
                                self.clear_tree()
                        except sqlite3.Error as e:
                            messagebox.showerror("Error", f"Could not load tables: {e}")
                    
                    def load_table(self, event):
                        if not self.connection:
                            return
                        
                        selected_table = self.table_combo.get()
                        if not selected_table:
                            return
                        
                        self.current_table = selected_table
                        self.query_entry.delete(0, tk.END)
                        self.query_entry.insert(0, f"SELECT * FROM {selected_table}")
                        
                        try:
                            cursor = self.connection.cursor()
                            cursor.execute(f"PRAGMA table_info({selected_table})")
                            columns = cursor.fetchall()
                            
                            cursor.execute(f"SELECT * FROM {selected_table} LIMIT 1000")
                            rows = cursor.fetchall()
                            
                            self.display_data(columns, rows)
                            self.status_var.set(f"Table: {selected_table} | {len(rows)} records")
                        except sqlite3.Error as e:
                            messagebox.showerror("Error", f"Could not load table: {e}")
                    
                    def execute_query(self):
                        if not self.connection:
                            messagebox.showwarning("Warning", "No database is open!")
                            return
                        
                        query = self.query_entry.get().strip()
                        if not query:
                            messagebox.showwarning("Warning", "Enter a valid query!")
                            return
                        
                        try:
                            cursor = self.connection.cursor()
                            cursor.execute(query)
                            
                            if query.upper().startswith(("SELECT", "PRAGMA")):
                                # Read query - display results
                                columns = [description[0] for description in cursor.description]
                                rows = cursor.fetchall()
                                
                                self.display_data_from_query(columns, rows)
                                self.status_var.set(f"Query executed: {len(rows)} results")
                            else:
                                # Modification query - confirm transaction
                                self.connection.commit()
                                affected = cursor.rowcount
                                messagebox.showinfo("Success", f"Query executed successfully! Rows affected: {affected}")
                                
                                # Refresh current table if exists
                                if self.current_table:
                                    self.load_table(None)
                                
                                self.status_var.set(f"Query executed: {affected} rows affected")
                        except sqlite3.Error as e:
                            messagebox.showerror("Error", f"Error executing query: {e}")
                    
                    def display_data(self, columns, rows):
                        self.clear_tree()
                        
                        # Configure treeview columns
                        column_names = [col[1] for col in columns]
                        
                        self.tree["columns"] = column_names
                        
                        # Hide default column
                        self.tree.column("#0", width=0, stretch=tk.NO)
                        
                        # Configure each column
                        for name in column_names:
                            self.tree.column(name, anchor=tk.W, width=150)
                            self.tree.heading(name, text=name, anchor=tk.W)
                        
                        # Add data
                        for i, row in enumerate(rows):
                            values = [str(val) if val is not None else "NULL" for val in row]
                            self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
                        
                        # Alternate row colors (classic Win95 style)
                        self.tree.tag_configure('even', background=self.colors["bg_window"])
                        self.tree.tag_configure('odd', background="#ececec")  # Light gray for alternating rows
                    
                    def display_data_from_query(self, column_names, rows):
                        self.clear_tree()
                        
                        self.tree["columns"] = column_names
                        
                        # Hide default column
                        self.tree.column("#0", width=0, stretch=tk.NO)
                        
                        # Configure each column
                        for name in column_names:
                            self.tree.column(name, anchor=tk.W, width=150)
                            self.tree.heading(name, text=name, anchor=tk.W)
                        
                        # Add data
                        for i, row in enumerate(rows):
                            values = [str(val) if val is not None else "NULL" for val in row]
                            self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
                        
                        # Alternate row colors
                        self.tree.tag_configure('even', background=self.colors["bg_window"])
                        self.tree.tag_configure('odd', background="#ececec")
                    
                    def clear_tree(self):
                        for item in self.tree.get_children():
                            self.tree.delete(item)
                        
                        for col in self.tree["columns"]:
                            self.tree.heading(col, text="")
                        
                        self.tree["columns"] = []
                
                # Create the SQL viewer instance and pass the toplevel window
                sql_app = Win95SQLViewer(sql_window)
                
                # Add to taskbar
                self.add_window_to_taskbar("SQL Explorer", sql_window)
                sql_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("SQL Explorer", sql_window))
            
            '''
            def create_word_lite(self, file_path=None):
                """Creează o aplicație Word Lite pentru a deschide și vizualiza fișiere .doc sau .docx"""
                word_window = tk.Toplevel(self.rootW95dist)
                word_window.title("Word Lite")
                word_window.overrideredirect(True)
                word_window.geometry("800x600+200+100")
                word_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(word_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Word Lite", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Word Lite", word_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(word_window, title_bar)
                
                # Menubar
                menubar = tk.Menu(word_window)
                word_window.config(menu=menubar)
                
                file_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="File", menu=file_menu)
                
                edit_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Edit", menu=edit_menu)
                
                view_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="View", menu=view_menu)
                
                format_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Format", menu=format_menu)
                
                help_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Help", menu=help_menu)
                
                # Toolbar frame
                toolbar_frame = tk.Frame(word_window, bg="#c0c0c0", relief="raised", bd=2, height=35)
                toolbar_frame.pack(fill="x")
                toolbar_frame.pack_propagate(False)
                
                # Open button
                open_btn = tk.Button(toolbar_frame, text="Open", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: open_document())
                open_btn.pack(side="left", padx=5, pady=2)
                
                # Save button (for future implementation)
                save_btn = tk.Button(toolbar_frame, text="Save", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: save_document())
                save_btn.pack(side="left", padx=5, pady=2)
                
                # Print button
                print_btn = tk.Button(toolbar_frame, text="Print", bg="#c0c0c0", relief="raised", bd=2,
                                     font=("MS Sans Serif", 8),
                                     command=lambda: messagebox.showinfo("Print", "Printing functionality is not implemented in this version"))
                print_btn.pack(side="left", padx=5, pady=2)
                
                # Status bar
                status_frame = tk.Frame(word_window, bg="#c0c0c0", relief="sunken", bd=1, height=25)
                status_frame.pack(side="bottom", fill="x")
                status_frame.pack_propagate(False)
                
                status_label = tk.Label(status_frame, text="Ready", bg="#c0c0c0", font=("MS Sans Serif", 8))
                status_label.pack(side="left", padx=5)
                
                # Main content frame
                content_frame = tk.Frame(word_window, bg="white")
                content_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Text area
                text_frame = tk.Frame(content_frame, bg="white")
                text_frame.pack(fill="both", expand=True)
                
                # Scrollbars
                v_scrollbar = tk.Scrollbar(text_frame)
                v_scrollbar.pack(side="right", fill="y")
                
                h_scrollbar = tk.Scrollbar(text_frame, orient="horizontal")
                h_scrollbar.pack(side="bottom", fill="x")
                
                # Text widget
                text_area = tk.Text(text_frame, wrap="word", yscrollcommand=v_scrollbar.set, 
                                   xscrollcommand=h_scrollbar.set,
                                   font=("Times New Roman", 12), bg="white", fg="black")
                text_area.pack(side="left", fill="both", expand=True)
                
                v_scrollbar.config(command=text_area.yview)
                h_scrollbar.config(command=text_area.xview)
                
                # Variables for tracking
                current_file = None
                
                def open_document():
                    """Open a Word document"""
                    file_path = filedialog.askopenfilename(
                        defaultextension=".docx",
                        filetypes=[("Word files", "*.docx;*.doc"), ("Text files", "*.txt"), ("All files", "*.*")]
                    )
                    
                    if not file_path:
                        return
                    
                    try:
                        # Set cursor to wait
                        word_window.config(cursor="wait")
                        word_window.update()
                        
                        # Clear text area
                        text_area.delete(1.0, tk.END)
                        
                        # Get the file extension
                        ext = os.path.splitext(file_path)[1].lower()
                        
                        # Handle different file types
                        if ext == ".txt":
                            # Simple text file
                            with open(file_path, 'r', encoding='utf-8') as file:
                                content = file.read()
                                text_area.insert(tk.END, content)
                        elif ext in [".doc", ".docx"]:
                            # Try to handle Word documents (simplified - only extracts text)
                            text_area.insert(tk.END, "Word Lite can display only plain text from Word documents.\n\n")
                            
                            try:
                                # If python-docx is installed, use it
                                import docx
                                doc = docx.Document(file_path)
                                for para in doc.paragraphs:
                                    text_area.insert(tk.END, para.text + "\n")
                            except ImportError:
                                # Fallback method
                                text_area.insert(tk.END, "Cannot read Word document content. The python-docx library is not installed.\n")
                                text_area.insert(tk.END, "To install it, run: pip install python-docx\n\n")
                                text_area.insert(tk.END, "For now, only showing document metadata:\n")
                                text_area.insert(tk.END, f"Filename: {os.path.basename(file_path)}\n")
                                text_area.insert(tk.END, f"Size: {os.path.getsize(file_path)} bytes\n")
                        else:
                            text_area.insert(tk.END, f"Cannot open file type: {ext}\n")
                            text_area.insert(tk.END, "Word Lite supports .txt, .doc, and .docx files.")
                        
                        # Update window title and status
                        file_name = os.path.basename(file_path)
                        title_label.config(text=f"Word Lite - {file_name}")
                        word_window.title(f"Word Lite - {file_name}")
                        status_label.config(text=f"Opened: {file_name}")
                        
                        # Save the current file
                        nonlocal current_file
                        current_file = file_path
                        
                    except Exception as e:
                        text_area.delete(1.0, tk.END)
                        text_area.insert(tk.END, f"Error opening file: {str(e)}")
                        messagebox.showerror("Error", f"Could not open file: {str(e)}")
                    finally:
                        # Reset cursor
                        word_window.config(cursor="")
                
                def save_document():
                    """Save a document (placeholder)"""
                    messagebox.showinfo("Info", "Save functionality is not implemented in this version")
                
                # File menu commands
                file_menu.add_command(label="Open", command=open_document)
                file_menu.add_command(label="Save", command=save_document)
                file_menu.add_separator()
                file_menu.add_command(label="Print", command=lambda: messagebox.showinfo("Print", "Printing functionality is not implemented in this version"))
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window("Word Lite", word_window))
                
                # Edit menu commands
                edit_menu.add_command(label="Cut", command=lambda: status_label.config(text="Cut not implemented"))
                edit_menu.add_command(label="Copy", command=lambda: status_label.config(text="Copy not implemented"))
                edit_menu.add_command(label="Paste", command=lambda: status_label.config(text="Paste not implemented"))
                
                # View menu
                view_menu.add_command(label="Zoom", command=lambda: status_label.config(text="Zoom not implemented"))
                
                # Format menu
                format_menu.add_command(label="Font", command=lambda: status_label.config(text="Font formatting not implemented"))
                
                # Help menu
                help_menu.add_command(label="About Word Lite", command=lambda: messagebox.showinfo("About", "Word Lite\nVersion 1.0\n\nA simple document viewer"))
                
                # If a file path was provided, open it
                if file_path and os.path.exists(file_path):
                    current_file = file_path
                    try:
                        # Set the file path and call the open function
                        open_document()
                    except Exception as e:
                        text_area.delete(1.0, tk.END)
                        text_area.insert(tk.END, f"Error opening file: {str(e)}")
                
                # Add to taskbar
                self.add_window_to_taskbar("Word Lite", word_window)
                word_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Word Lite", word_window))
            '''
            
            def create_word_lite(self, file_path=None):
                """Creează o aplicație Word Lite pentru a deschide și vizualiza fișiere .doc sau .docx"""
                import zipfile
                import xml.etree.ElementTree as ET
                import re
                
                word_window = tk.Toplevel(self.rootW95dist)
                word_window.title("Word Lite")
                word_window.overrideredirect(True)
                word_window.geometry("800x600+200+100")
                word_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(word_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Word Lite", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Word Lite", word_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(word_window, title_bar)
                
                # Menubar
                menubar = tk.Menu(word_window)
                word_window.config(menu=menubar)
                
                file_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="File", menu=file_menu)
                
                edit_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Edit", menu=edit_menu)
                
                view_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="View", menu=view_menu)
                
                format_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Format", menu=format_menu)
                
                help_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Help", menu=help_menu)
                
                # Toolbar frame
                toolbar_frame = tk.Frame(word_window, bg="#c0c0c0", relief="raised", bd=2, height=35)
                toolbar_frame.pack(fill="x")
                toolbar_frame.pack_propagate(False)
                
                # Open button
                open_btn = tk.Button(toolbar_frame, text="Open", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: open_document())
                open_btn.pack(side="left", padx=5, pady=2)
                
                # Save button (for future implementation)
                save_btn = tk.Button(toolbar_frame, text="Save", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: save_document())
                save_btn.pack(side="left", padx=5, pady=2)
                
                # Print button
                print_btn = tk.Button(toolbar_frame, text="Print", bg="#c0c0c0", relief="raised", bd=2,
                                     font=("MS Sans Serif", 8),
                                     command=lambda: messagebox.showinfo("Print", "Printing functionality is not implemented in this version"))
                print_btn.pack(side="left", padx=5, pady=2)
                
                # Status bar
                status_frame = tk.Frame(word_window, bg="#c0c0c0", relief="sunken", bd=1, height=25)
                status_frame.pack(side="bottom", fill="x")
                status_frame.pack_propagate(False)
                
                status_label = tk.Label(status_frame, text="Ready", bg="#c0c0c0", font=("MS Sans Serif", 8))
                status_label.pack(side="left", padx=5)
                
                # Main content frame
                content_frame = tk.Frame(word_window, bg="white")
                content_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Text area
                text_frame = tk.Frame(content_frame, bg="white")
                text_frame.pack(fill="both", expand=True)
                
                # Scrollbars
                v_scrollbar = tk.Scrollbar(text_frame)
                v_scrollbar.pack(side="right", fill="y")
                
                h_scrollbar = tk.Scrollbar(text_frame, orient="horizontal")
                h_scrollbar.pack(side="bottom", fill="x")
                
                # Text widget
                text_area = tk.Text(text_frame, wrap="word", yscrollcommand=v_scrollbar.set, 
                                   xscrollcommand=h_scrollbar.set,
                                   font=("Times New Roman", 12), bg="white", fg="black")
                text_area.pack(side="left", fill="both", expand=True)
                
                v_scrollbar.config(command=text_area.yview)
                h_scrollbar.config(command=text_area.xview)
                
                # Variables for tracking
                current_file = None
                
                def extract_text_from_docx(docx_file):
                    """Extract text from a .docx file using standard libraries"""
                    try:
                        # Fișierele .docx sunt arhive ZIP care conțin fișiere XML
                        z = zipfile.ZipFile(docx_file)
                        
                        # Verificăm dacă există fișierul document.xml
                        if "word/document.xml" in z.namelist():
                            # Extragem și citim XML-ul principal
                            xml_content = z.read("word/document.xml")
                            
                            # Parsăm XML-ul
                            tree = ET.fromstring(xml_content)
                            
                            # Găsim toate elementele "w:t" care conțin text
                            text_content = ""
                            
                            # Folosim un namespace simplificat
                            namespace = {'w': '*'}  # Wildcards pentru namespace pentru a evita linkul URL
                            
                            # Încercăm mai multe abordări pentru a extrage textul
                            try:
                                # Abordarea 1: Extragem textul folosind XPath cu wildcard namespace
                                for paragraph in tree.findall('.//{*}p'):
                                    paragraph_text = ""
                                    for text_element in paragraph.findall('.//{*}t'):
                                        if text_element.text:
                                            paragraph_text += text_element.text
                                    
                                    text_content += paragraph_text + "\n"
                                
                                # Dacă nu am obținut text, încercăm o altă abordare
                                if not text_content.strip():
                                    raise Exception("No text was found using the first approach.")
                                    
                            except:
                                # Abordarea 2: Extragem direct toate elementele de text
                                for text_element in tree.findall('.//*'):
                                    if text_element.text and text_element.text.strip():
                                        text_content += text_element.text + "\n"
                            
                            return text_content
                        else:
                            return "The document content could not be found in the archive."
                    except Exception as e:
                        return f"Error extracting text: {str(e)}"
                
                def extract_text_from_doc(doc_file):
                    """Extrage text din fișier .doc (format binar vechi)"""
                    # Pentru fișierele .doc (format binar), putem încerca să extragem doar textul vizibil
                    try:
                        with open(doc_file, 'rb') as f:
                            content = f.read()
                            
                            # Încercăm să extragem text vizibil folosind o abordare simplă
                            # Aceasta nu este o soluție perfectă, dar poate funcționa pentru text simplu
                            text = ""
                            
                            # Convertim conținutul binar în text dacă este posibil
                            try:
                                # Încercăm să decodificăm ca UTF-16
                                binary_text = content.decode('utf-16', errors='ignore')
                                
                                # Eliminăm caracterele non-printabile
                                printable_text = ''.join(c for c in binary_text if c.isprintable() or c.isspace())
                                
                                # Folosim regex pentru a găsi texte consecutive
                                # Căutăm secvențe de text de cel puțin 3 caractere
                                text_chunks = re.findall(r'[A-Za-z0-9\s.,;:!?\'"\-+]{3,}', printable_text)
                                
                                # Filtrăm și combinăm fragmentele de text
                                for chunk in text_chunks:
                                    chunk = chunk.strip()
                                    if len(chunk) > 5:  # Ignorăm fragmentele prea scurte
                                        text += chunk + "\n"
                            except:
                                text = "Text could not be extracted from document .doc.\n"
                                text += "The .doc format is an old and complex binary format.\n"
                                text += "For better results, use .docx or .txt files."
                            
                            return text
                    except Exception as e:
                        return f"Error opening the .doc file: {str(e)}"
                
                def open_document():
                    """Open a Word document"""
                    file_path = filedialog.askopenfilename(
                        defaultextension=".docx",
                        filetypes=[("Word files", "*.docx;*.doc"), ("Text files", "*.txt"), ("All files", "*.*")]
                    )
                    
                    if not file_path:
                        return
                    
                    try:
                        # Set cursor to wait
                        word_window.config(cursor="wait")
                        word_window.update()
                        
                        # Clear text area
                        text_area.delete(1.0, tk.END)
                        
                        # Get the file extension
                        ext = os.path.splitext(file_path)[1].lower()
                        
                        # Handle different file types
                        if ext == ".txt":
                            # Simple text file
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
                                content = file.read()
                                text_area.insert(tk.END, content)
                        elif ext == ".docx":
                            # Extract text from .docx file
                            content = extract_text_from_docx(file_path)
                            text_area.insert(tk.END, content)
                        elif ext == ".doc":
                            # Try to extract text from old .doc format
                            content = extract_text_from_doc(file_path)
                            text_area.insert(tk.END, content)
                        else:
                            text_area.insert(tk.END, f"Cannot open file type: {ext}\n")
                            text_area.insert(tk.END, "Word Lite supports .txt, .doc, and .docx files.")
                        
                        # Update window title and status
                        file_name = os.path.basename(file_path)
                        title_label.config(text=f"Word Lite - {file_name}")
                        word_window.title(f"Word Lite - {file_name}")
                        status_label.config(text=f"Opened: {file_name}")
                        
                        # Save the current file
                        nonlocal current_file
                        current_file = file_path
                        
                    except Exception as e:
                        text_area.delete(1.0, tk.END)
                        text_area.insert(tk.END, f"Error opening file: {str(e)}")
                        messagebox.showerror("Error", f"Could not open file: {str(e)}")
                    finally:
                        # Reset cursor
                        word_window.config(cursor="")
                
                def save_document():
                    """Save a document (placeholder)"""
                    messagebox.showinfo("Info", "Save functionality is not implemented in this version")
                
                # File menu commands
                file_menu.add_command(label="Open", command=open_document)
                file_menu.add_command(label="Save", command=save_document)
                file_menu.add_separator()
                file_menu.add_command(label="Print", command=lambda: messagebox.showinfo("Print", "Printing functionality is not implemented in this version"))
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window("Word Lite", word_window))
                
                # Edit menu commands
                edit_menu.add_command(label="Cut", command=lambda: text_area.event_generate("<<Cut>>"))
                edit_menu.add_command(label="Copy", command=lambda: text_area.event_generate("<<Copy>>"))
                edit_menu.add_command(label="Paste", command=lambda: text_area.event_generate("<<Paste>>"))
                
                # View menu
                view_menu.add_command(label="Zoom", command=lambda: status_label.config(text="Zoom not implemented"))
                
                # Format menu
                format_menu.add_command(label="Font", command=lambda: status_label.config(text="Font formatting not implemented"))
                
                # Help menu
                help_menu.add_command(label="About Word Lite", command=lambda: messagebox.showinfo("About", "Word Lite\nVersion 1.0\n\nA simple document viewer"))
                
                # If a file path was provided, open it
                if file_path and os.path.exists(file_path):
                    current_file = file_path
                    try:
                        # Use a temporary file path variable to avoid conflicts with the open_document function
                        temp_path = file_path
                        # Clear it to avoid double opening
                        file_path = None
                        # Call the open function with the correct path
                        open_document()
                    except Exception as e:
                        text_area.delete(1.0, tk.END)
                        text_area.insert(tk.END, f"Error opening file: {str(e)}")
                
                # Add to taskbar
                self.add_window_to_taskbar("Word Lite", word_window)
                word_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Word Lite", word_window))
            
            def create_terminal(self):
                """Creează un terminal/command prompt care execută comenzi reale"""
                import subprocess
                import threading
                import platform
                import signal
                import time
                
                terminal_window = tk.Toplevel(self.rootW95dist)
                terminal_window.title("Command Prompt")
                terminal_window.overrideredirect(True)
                terminal_window.geometry("640x400+200+150")
                terminal_window.configure(bg="#000000")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(terminal_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Command Prompt", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Command Prompt", terminal_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(terminal_window, title_bar)
                
                # Main content - Folosim un singur Text widget pentru tot
                # în loc de a separa output și input
                terminal_frame = tk.Frame(terminal_window, bg="black", bd=0)
                terminal_frame.pack(fill="both", expand=True, padx=2, pady=2)
                
                # Scrollbars
                v_scrollbar = tk.Scrollbar(terminal_frame)
                v_scrollbar.pack(side="right", fill="y")
                
                # Text widget pentru afișarea atât a output-ului cât și pentru introducerea comenzilor
                terminal_text = tk.Text(terminal_frame, wrap="word", bg="black", fg="#cccccc",
                                       insertbackground="white", font=("Courier New", 10),
                                       yscrollcommand=v_scrollbar.set)
                terminal_text.pack(fill="both", expand=True)
                v_scrollbar.config(command=terminal_text.yview)
                
                # Command history
                command_history = []
                history_index = 0
                
                # Poziția curentă de input (tag pentru a marca unde utilizatorul poate scrie)
                input_pos = "1.0"
                
                # Prompt-ul utilizat
                prompt = "> "
                
                # Get current OS
                current_os = platform.system()
                
                # Referință la procesul curent
                current_process = None
                
                # Flag pentru a ști dacă o comandă este în execuție
                command_running = False
                
                # Inițializăm terminalul
                terminal_text.insert("end", "Multiapp 95 Professional Command Prompt\n")
                terminal_text.insert("end", "Type 'help' for a list of commands.\n\n")
                terminal_text.insert("end", f"Current directory: {os.getcwd()}\n\n")
                terminal_text.insert("end", prompt)
                
                # Setăm poziția de input inițială
                input_pos = terminal_text.index("end-1c")
                terminal_text.mark_set("input_mark", input_pos)
                terminal_text.mark_gravity("input_mark", "left")
                
                # Focusăm pe textbox
                terminal_text.focus_set()
                terminal_text.see("end")
                
                def get_command():
                    """Obține comanda curentă din terminal_text"""
                    input_start = terminal_text.index("input_mark")
                    input_end = terminal_text.index("end-1c")
                    return terminal_text.get(input_start, input_end)
                
                def stop_current_process():
                    """Oprește procesul curent dacă există"""
                    nonlocal current_process, command_running
                    
                    if current_process and command_running:
                        try:
                            if current_os == "Windows":
                                # În Windows, folosim taskkill pentru a termina procesul și subprocesele sale
                                subprocess.run(f"taskkill /F /T /PID {current_process.pid}", shell=True)
                            else:
                                # În Unix/Linux, trimitem semnalul SIGTERM
                                os.killpg(os.getpgid(current_process.pid), signal.SIGTERM)
                            
                            terminal_text.insert("end", "\n^C\nCommand terminated by user.\n")
                            terminal_text.insert("end", prompt)
                            input_pos = terminal_text.index("end-1c")
                            terminal_text.mark_set("input_mark", input_pos)
                            terminal_text.see("end")
                            
                            command_running = False
                            current_process = None
                            return True
                        except Exception as e:
                            terminal_text.insert("end", f"\nError terminating process: {str(e)}\n")
                            return False
                    return False
                
                def execute_command(command):
                    """Execută o comandă și afișează output-ul"""
                    nonlocal history_index, input_pos, current_process, command_running
                    
                    # Adaugă comanda la istoric
                    command_history.append(command)
                    history_index = len(command_history)
                    
                    # Adăugăm un newline după comandă
                    terminal_text.insert("end", "\n")
                    
                    # Procesăm exit command
                    if command.lower() in ["exit", "quit"]:
                        terminal_text.insert("end", "Closing Command Prompt...\n")
                        terminal_text.see("end")
                        terminal_window.after(500, lambda: self.close_window("Command Prompt", terminal_window))
                        return
                    
                    # Procesăm cd command intern
                    if command.lower().startswith("cd "):
                        try:
                            path = command[3:].strip()
                            if os.path.isdir(path):
                                os.chdir(path)
                                terminal_text.insert("end", f"Current directory changed to: {os.getcwd()}\n\n")
                            else:
                                terminal_text.insert("end", f"Directory not found: {path}\n\n")
                        except Exception as e:
                            terminal_text.insert("end", f"Error: {str(e)}\n\n")
                        
                        terminal_text.insert("end", prompt)
                        input_pos = terminal_text.index("end-1c")
                        terminal_text.mark_set("input_mark", input_pos)
                        terminal_text.see("end")
                        return
                    
                    # Procesăm dir/ls command intern pentru formatare mai bună
                    if command.lower() in ["dir", "ls"]:
                        try:
                            current_dir = os.getcwd()
                            terminal_text.insert("end", f"Directory of {current_dir}\n\n")
                            
                            # Obținem fișierele și directoarele
                            items = os.listdir(current_dir)
                            
                            # Afișăm mai întâi directoarele
                            for item in sorted(items):
                                item_path = os.path.join(current_dir, item)
                                if os.path.isdir(item_path):
                                    try:
                                        # Obținem informații despre director
                                        item_time = os.path.getmtime(item_path)
                                        time_str = datetime.fromtimestamp(item_time).strftime('%Y-%m-%d %H:%M:%S')
                                        terminal_text.insert("end", f"{time_str}    <DIR>          {item}\n")
                                    except:
                                        terminal_text.insert("end", f"                <DIR>          {item}\n")
                            
                            # Apoi afișăm fișierele
                            for item in sorted(items):
                                item_path = os.path.join(current_dir, item)
                                if os.path.isfile(item_path):
                                    try:
                                        # Obținem informații despre fișier
                                        item_size = os.path.getsize(item_path)
                                        item_time = os.path.getmtime(item_path)
                                        time_str = datetime.fromtimestamp(item_time).strftime('%Y-%m-%d %H:%M:%S')
                                        terminal_text.insert("end", f"{time_str}    {item_size:10} {item}\n")
                                    except:
                                        terminal_text.insert("end", f"                      ? {item}\n")
                            
                            terminal_text.insert("end", "\n")
                        except Exception as e:
                            terminal_text.insert("end", f"Error: {str(e)}\n\n")
                        
                        terminal_text.insert("end", prompt)
                        input_pos = terminal_text.index("end-1c")
                        terminal_text.mark_set("input_mark", input_pos)
                        terminal_text.see("end")
                        return
                    
                    # Procesăm help command
                    if command.lower() == "help":
                        terminal_text.insert("end", "Available Commands:\n")
                        terminal_text.insert("end", "  help       - Display this help message\n")
                        terminal_text.insert("end", "  cd <dir>   - Change directory\n")
                        terminal_text.insert("end", "  dir        - List files and directories\n")
                        terminal_text.insert("end", "  ls         - List files and directories (alternative)\n")
                        terminal_text.insert("end", "  cls        - Clear screen\n")
                        terminal_text.insert("end", "  exit       - Exit Command Prompt\n")
                        terminal_text.insert("end", "\nOther standard system commands are also available.\n")
                        terminal_text.insert("end", "Press Ctrl+C to stop a running command or copy selected text.\n")
                        terminal_text.insert("end", "Press Ctrl+V to paste text from clipboard.\n\n")
                        
                        terminal_text.insert("end", prompt)
                        input_pos = terminal_text.index("end-1c")
                        terminal_text.mark_set("input_mark", input_pos)
                        terminal_text.see("end")
                        return
                    
                    # Procesăm clear/cls command
                    if command.lower() in ["cls", "clear"]:
                        terminal_text.delete("1.0", "end")
                        terminal_text.insert("end", "Multiapp 95 Professional Command Prompt\n\n")
                        terminal_text.insert("end", prompt)
                        input_pos = terminal_text.index("end-1c")
                        terminal_text.mark_set("input_mark", input_pos)
                        terminal_text.see("end")
                        return
                    
                    # Rulăm comanda externă
                    def run_command():
                        nonlocal current_process, command_running
                        command_running = True
                        
                        try:
                            # Determină shell și opțiuni în funcție de sistemul de operare
                            if current_os == "Windows":
                                # Creăm procesul cu pipe-uri pentru stdout și stderr
                                current_process = subprocess.Popen(
                                    command, 
                                    shell=True, 
                                    stdout=subprocess.PIPE, 
                                    stderr=subprocess.PIPE,
                                    stdin=subprocess.PIPE,
                                    text=True,
                                    encoding='cp850',  # Windows Command Prompt encoding
                                    creationflags=subprocess.CREATE_NEW_PROCESS_GROUP
                                )
                            else:  # Linux/Mac
                                current_process = subprocess.Popen(
                                    command,
                                    shell=True,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE,
                                    stdin=subprocess.PIPE,
                                    text=True,
                                    preexec_fn=os.setsid  # Permite terminarea procesului și a subproceselor
                                )
                            
                            # Citim output-ul și error-ul în mod continuu
                            while command_running:
                                # Verificăm dacă procesul s-a terminat
                                if current_process.poll() is not None:
                                    break
                                
                                # Citim output disponibil fără să blocăm
                                output_line = current_process.stdout.readline()
                                if output_line:
                                    terminal_window.after(0, lambda line=output_line: append_output(line))
                                
                                # Citim error disponibil fără să blocăm
                                error_line = current_process.stderr.readline()
                                if error_line:
                                    terminal_window.after(0, lambda line=error_line: append_error(line))
                                
                                # Pauză scurtă pentru a nu supraîncărca CPU
                                time.sleep(0.01)
                            
                            # După ce procesul s-a terminat, citim orice output rămas
                            remaining_output, remaining_error = current_process.communicate()
                            
                            if remaining_output:
                                terminal_window.after(0, lambda: append_output(remaining_output))
                            
                            if remaining_error:
                                terminal_window.after(0, lambda: append_error(remaining_error))
                            
                            # Verificăm dacă procesul s-a terminat cu succes
                            exit_code = current_process.returncode
                            if exit_code != 0 and command_running:
                                terminal_window.after(0, lambda: append_error(f"\nCommand exited with code {exit_code}\n"))
                            
                            # Comanda s-a terminat, adăugăm un nou prompt
                            terminal_window.after(0, lambda: add_new_prompt())
                            
                            command_running = False
                            current_process = None
                            
                        except Exception as e:
                            terminal_window.after(0, lambda: append_error(f"\nError executing command: {str(e)}\n"))
                            terminal_window.after(0, lambda: add_new_prompt())
                            command_running = False
                            current_process = None
                    
                    def append_output(text):
                        terminal_text.insert("end", text)
                        terminal_text.see("end")
                    
                    def append_error(text):
                        terminal_text.insert("end", text)
                        terminal_text.see("end")
                    
                    def add_new_prompt():
                        nonlocal input_pos
                        terminal_text.insert("end", prompt)
                        input_pos = terminal_text.index("end-1c")
                        terminal_text.mark_set("input_mark", input_pos)
                        terminal_text.see("end")
                    
                    # Rulăm comanda într-un thread separat pentru a evita blocarea UI
                    command_thread = threading.Thread(target=run_command)
                    command_thread.daemon = True
                    command_thread.start()
                
                def copy_selected_text():
                    """Copiază textul selectat în clipboard"""
                    try:
                        selected_text = terminal_text.get("sel.first", "sel.last")
                        terminal_window.clipboard_clear()
                        terminal_window.clipboard_append(selected_text)
                        return True
                    except:
                        return False  # Nu există text selectat
                
                def paste_from_clipboard():
                    """Lipește text din clipboard la poziția curentă de input"""
                    try:
                        clipboard_text = terminal_window.clipboard_get()
                        terminal_text.insert("insert", clipboard_text)
                        return True
                    except:
                        return False  # Clipboard-ul este gol sau inaccesibil
                
                # Gestionăm tastele speciale și comenzile
                def key_press(event):
                    nonlocal history_index
                    
                    # Ctrl+C: Copiere text selectat sau oprire comandă
                    if (event.state & 0x4) and event.keysym.lower() == "c":  # Ctrl+C
                        if not copy_selected_text():  # Încercăm să copiem textul selectat
                            # Dacă nu există text selectat, oprim comanda curentă
                            stop_current_process()
                        return "break"
                    
                    # Ctrl+V: Lipire din clipboard
                    if (event.state & 0x4) and event.keysym.lower() == "v":  # Ctrl+V
                        paste_from_clipboard()
                        return "break"
                    
                    # Verificăm dacă cursorul este după prompt
                    cursor_pos = terminal_text.index("insert")
                    if terminal_text.compare(cursor_pos, "<", "input_mark"):
                        # Cursorul este înainte de poziția de input, îl mutăm la final
                        terminal_text.mark_set("insert", "end")
                        return "break"
                    
                    # Return/Enter key - Execute command
                    if event.keysym == "Return":
                        command = get_command()
                        if command.strip():
                            execute_command(command.strip())
                        return "break"
                    
                    # Backspace key - Do not delete beyond prompt
                    elif event.keysym == "BackSpace":
                        cursor_pos = terminal_text.index("insert")
                        if terminal_text.compare(cursor_pos, "<=", "input_mark"):
                            return "break"
                    
                    # Up key - Navigate command history
                    elif event.keysym == "Up":
                        if command_history and history_index > 0:
                            history_index -= 1
                            # Ștergem comanda curentă
                            terminal_text.delete("input_mark", "end-1c")
                            # Inserăm comanda din istoric
                            terminal_text.insert("input_mark", command_history[history_index])
                        return "break"
                    
                    # Down key - Navigate command history
                    elif event.keysym == "Down":
                        if command_history and history_index < len(command_history) - 1:
                            history_index += 1
                            # Ștergem comanda curentă
                            terminal_text.delete("input_mark", "end-1c")
                            # Inserăm comanda din istoric
                            terminal_text.insert("input_mark", command_history[history_index])
                        elif history_index == len(command_history) - 1:
                            history_index = len(command_history)
                            # Ștergem comanda curentă
                            terminal_text.delete("input_mark", "end-1c")
                        return "break"
                    
                    # Home key - Go to beginning of input
                    elif event.keysym == "Home":
                        terminal_text.mark_set("insert", "input_mark")
                        return "break"
                
                # Asigurăm-ne că nu se poate șterge input mark-ul sau textul anterior
                def delete_check(event):
                    try:
                        if event.keysym == 'BackSpace':
                            cursor_pos = terminal_text.index("insert")
                            if terminal_text.compare(cursor_pos, "<=", "input_mark"):
                                return "break"
                        elif event.keysym in ['Delete', 'KP_Delete']:
                            try:
                                sel_start = terminal_text.index("sel.first")
                                if terminal_text.compare(sel_start, "<", "input_mark"):
                                    return "break"
                            except:
                                cursor_pos = terminal_text.index("insert")
                                if terminal_text.compare(cursor_pos, "<", "input_mark"):
                                    return "break"
                    except:
                        pass
                
                # Curățăm resursele la închiderea ferestrei
                def on_window_close():
                    # Oprim orice proces în execuție
                    stop_current_process()
                    # Închidem fereastra
                    self.close_window("Command Prompt", terminal_window)
                
                # Bind keys
                terminal_text.bind("<Key>", key_press)
                terminal_text.bind("<KeyPress-BackSpace>", delete_check)
                terminal_text.bind("<KeyPress-Delete>", delete_check)
                terminal_text.bind("<KeyPress-KP_Delete>", delete_check)
                
                # Make sure focus is on the terminal text
                terminal_text.focus_set()
                
                # Add to taskbar
                self.add_window_to_taskbar("Command Prompt", terminal_window)
                terminal_window.protocol("WM_DELETE_WINDOW", on_window_close)
                
                # Bind window activation
                terminal_window.bind("<Map>", lambda e: terminal_text.focus_set())
                terminal_window.bind("<FocusIn>", lambda e: terminal_text.focus_set())
            
            def create_excel_lite(self, file_path=None):
                """Creează o aplicație Excel Lite pentru a deschide și vizualiza fișiere xlsx"""
                try:
                    import openpyxl
                except ImportError:
                    messagebox.showerror("Error", "The openpyxl library is not installed. Please install it using pip: pip install openpyxl")
                    return

                excel_window = tk.Toplevel(self.rootW95dist)
                excel_window.title("Excel Lite")
                excel_window.overrideredirect(True)
                excel_window.geometry("800x600+200+100")
                excel_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(excel_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Excel Lite", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Excel Lite", excel_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(excel_window, title_bar)
                
                # Menubar
                menubar = tk.Menu(excel_window)
                excel_window.config(menu=menubar)
                
                file_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="File", menu=file_menu)
                
                edit_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Edit", menu=edit_menu)
                
                view_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="View", menu=view_menu)
                
                help_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Help", menu=help_menu)
                
                # Toolbar frame
                toolbar_frame = tk.Frame(excel_window, bg="#c0c0c0", relief="raised", bd=2, height=35)
                toolbar_frame.pack(fill="x")
                toolbar_frame.pack_propagate(False)
                
                # Open button
                open_btn = tk.Button(toolbar_frame, text="Open", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: open_excel_file())
                open_btn.pack(side="left", padx=5, pady=2)
                
                # Save button (for future implementation)
                save_btn = tk.Button(toolbar_frame, text="Save", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: save_excel_file())
                save_btn.pack(side="left", padx=5, pady=2)
                
                # Sheet selection
                sheet_label = tk.Label(toolbar_frame, text="Sheet:", bg="#c0c0c0", font=("MS Sans Serif", 8))
                sheet_label.pack(side="left", padx=(20, 5))
                
                sheet_var = tk.StringVar()
                sheet_combo = ttk.Combobox(toolbar_frame, textvariable=sheet_var, width=15, state="readonly")
                sheet_combo.pack(side="left", padx=5)
                sheet_combo.bind("<<ComboboxSelected>>", lambda e: show_sheet(sheet_var.get()))
                
                # Function buttons
                formula_btn = tk.Button(toolbar_frame, text="Formula", bg="#c0c0c0", relief="raised", bd=2,
                                       font=("MS Sans Serif", 8),
                                       command=lambda: add_formula())
                formula_btn.pack(side="left", padx=5, pady=2)
                
                sort_btn = tk.Button(toolbar_frame, text="Sort", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: sort_data())
                sort_btn.pack(side="left", padx=5, pady=2)
                
                filter_btn = tk.Button(toolbar_frame, text="Filter", bg="#c0c0c0", relief="raised", bd=2,
                                      font=("MS Sans Serif", 8),
                                      command=lambda: filter_data())
                filter_btn.pack(side="left", padx=5, pady=2)
                
                # Status bar - adăugat înainte de conținutul principal
                status_frame = tk.Frame(excel_window, bg="#c0c0c0", relief="sunken", bd=1, height=25)
                status_frame.pack(side="bottom", fill="x")
                status_frame.pack_propagate(False)
                
                status_label = tk.Label(status_frame, text="Ready", bg="#c0c0c0", font=("MS Sans Serif", 8))
                status_label.pack(side="left", padx=5)
                
                cell_info_label = tk.Label(status_frame, text="", bg="#c0c0c0", font=("MS Sans Serif", 8))
                cell_info_label.pack(side="right", padx=5)
                
                # Main content frame
                content_frame = tk.Frame(excel_window, bg="white")
                content_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Scrollbars
                h_scrollbar = tk.Scrollbar(content_frame, orient="horizontal")
                h_scrollbar.pack(side="bottom", fill="x")
                
                # Main table frame
                table_frame = tk.Frame(content_frame, bg="white")
                table_frame.pack(fill="both", expand=True)
                
                v_scrollbar = tk.Scrollbar(table_frame)
                v_scrollbar.pack(side="right", fill="y")
                
                # Canvas for scrollable content
                canvas = tk.Canvas(table_frame, bg="white", 
                                 xscrollcommand=h_scrollbar.set,
                                 yscrollcommand=v_scrollbar.set)
                canvas.pack(side="left", fill="both", expand=True)
                
                h_scrollbar.config(command=canvas.xview)
                v_scrollbar.config(command=canvas.yview)
                
                # Frame inside canvas for grid
                inner_frame = tk.Frame(canvas, bg="white")
                canvas.create_window((0, 0), window=inner_frame, anchor="nw")
                
                # Eliminăm spațiile între celule
                inner_frame.grid_columnconfigure("all", pad=0)
                inner_frame.grid_rowconfigure("all", pad=0)
                
                # Variables for tracking
                current_file = None
                workbook = None
                active_sheet = None
                
                # Cell grid (for display only)
                cell_grid = []
                header_labels = []  # Pentru a ține evidența label-urilor de header
                
                # Max rows and columns to display
                MAX_ROWS = 100
                MAX_COLS = 26  # A-Z
                
                # Variabile pentru redimensionarea coloanelor
                resizing_column = None
                start_x = 0
                column_widths = [10] * (MAX_COLS + 1)  # Lățimea inițială pentru fiecare coloană (inclusiv header-ul de rând)
                
                def clear_sheet():
                    """Clear the current sheet display"""
                    for widget in inner_frame.winfo_children():
                        widget.destroy()
                    
                    nonlocal cell_grid, header_labels
                    cell_grid = []
                    header_labels = []
                
                def create_empty_sheet():
                    """Create an empty spreadsheet grid"""
                    clear_sheet()
                    
                    nonlocal header_labels, column_widths
                    header_labels = [None] * (MAX_COLS + 1)  # +1 pentru header-ul de rând
                    
                    # Creează header-ul cu coloanele (A, B, C, etc.)
                    header_label = tk.Label(inner_frame, text="", width=4, bg="#e0e0e0", 
                                          relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"),
                                          highlightthickness=0)  # Eliminăm highlightthickness
                    header_label.grid(row=0, column=0, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                    header_labels[0] = header_label
                    
                    for col in range(MAX_COLS):
                        col_letter = chr(65 + col)  # A=65, B=66, etc.
                        header = tk.Label(inner_frame, text=col_letter, width=column_widths[col+1], bg="#e0e0e0",
                                        relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"),
                                        highlightthickness=0)  # Eliminăm highlightthickness
                        header.grid(row=0, column=col+1, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                        header_labels[col+1] = header
                        
                        # Adaugă separator de redimensionare
                        add_column_resize_handle(header, col+1)
                    
                    # Creează rândurile și celulele
                    row_widgets = []
                    for row in range(MAX_ROWS):
                        # Creează header-ul pentru rând
                        row_header = tk.Label(inner_frame, text=str(row + 1), width=4, height=1,
                                            bg="#e0e0e0", relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"),
                                            highlightthickness=0)  # Eliminăm highlightthickness
                        row_header.grid(row=row+1, column=0, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                        
                        # Creează celulele pentru acest rând
                        col_widgets = []
                        for col in range(MAX_COLS):
                            cell = tk.Entry(inner_frame, width=column_widths[col+1], font=("MS Sans Serif", 8),
                                          relief="sunken", bd=1, highlightthickness=0)  # Eliminăm highlightthickness
                            cell.grid(row=row+1, column=col+1, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                            
                            # Bind click to select cell
                            cell.bind("<Button-1>", lambda e, r=row, c=col: select_cell(r, c))
                            
                            col_widgets.append(cell)
                        row_widgets.append(col_widgets)
                    
                    cell_grid = row_widgets
                    
                    # Configurează coloanele pentru dimensiune uniformă
                    for col in range(MAX_COLS + 1):  # +1 pentru coloana cu header-ele de rând
                        inner_frame.grid_columnconfigure(col, weight=1, pad=0)  # Setăm explicit pad=0
                    
                    # Configurează rândurile pentru a elimina spațiile
                    for row in range(MAX_ROWS + 1):  # +1 pentru rândul cu header-ele de coloane
                        inner_frame.grid_rowconfigure(row, pad=0)  # Setăm explicit pad=0
                    
                    # Update canvas scroll region
                    inner_frame.update_idletasks()
                    canvas.config(scrollregion=canvas.bbox("all"))
                
                def add_column_resize_handle(header, col_idx):
                    """Adaugă un handler pentru redimensionarea coloanei"""
                    
                    def start_resize(event):
                        nonlocal resizing_column, start_x
                        resizing_column = col_idx
                        start_x = event.x_root
                        # Schimbă cursorul pentru a indica redimensionarea
                        excel_window.config(cursor="sb_h_double_arrow")
                        
                    def stop_resize(event):
                        nonlocal resizing_column
                        resizing_column = None
                        # Resetează cursorul
                        excel_window.config(cursor="")
                        
                    def do_resize(event):
                        nonlocal column_widths, start_x
                        if resizing_column is not None:
                            # Calculează diferența în pixeli
                            delta_x = event.x_root - start_x
                            
                            # Convertește în unități de lățime (aproximativ 7 pixeli per caracter)
                            delta_width = delta_x // 7
                            
                            if delta_width != 0:
                                # Ajustează lățimea coloanei (minim 3 caractere)
                                new_width = max(3, column_widths[resizing_column] + delta_width)
                                column_widths[resizing_column] = new_width
                                
                                # Actualizează header-ul
                                header_labels[resizing_column].config(width=new_width)
                                
                                # Actualizează toate celulele din coloană
                                for row in range(MAX_ROWS):
                                    if row < len(cell_grid) and resizing_column-1 < len(cell_grid[row]):
                                        cell_grid[row][resizing_column-1].config(width=new_width)
                                
                                # Resetează start_x pentru următoarea mișcare
                                start_x = event.x_root
                                
                                # Update canvas scroll region
                                inner_frame.update_idletasks()
                                canvas.config(scrollregion=canvas.bbox("all"))
                    
                    # Creează un frame pentru zona de redimensionare (marginea dreaptă a header-ului)
                    resize_frame = tk.Frame(inner_frame, bg="gray", width=2, cursor="sb_h_double_arrow")
                    resize_frame.grid(row=0, column=col_idx, sticky="nse", padx=(0, 0))
                    
                    # Bind evenimente pentru redimensionare
                    resize_frame.bind("<Button-1>", start_resize)
                    resize_frame.bind("<ButtonRelease-1>", stop_resize)
                    excel_window.bind("<B1-Motion>", do_resize)
                
                def select_cell(row, col):
                    """Select a cell and show its address in the status bar"""
                    col_letter = chr(65 + col)
                    cell_address = f"{col_letter}{row + 1}"
                    cell_info_label.config(text=f"Cell: {cell_address}")
                    
                    # Set focus to the cell
                    if 0 <= row < len(cell_grid) and 0 <= col < len(cell_grid[0]):
                        cell_grid[row][col].focus_set()
                
                def load_sheet_data(sheet):
                    """Load data from the workbook sheet into the grid"""
                    clear_sheet()
                    
                    # Get the dimensions of the sheet
                    max_row = min(sheet.max_row, MAX_ROWS)
                    max_col = min(sheet.max_column, MAX_COLS)
                    
                    nonlocal header_labels, column_widths
                    header_labels = [None] * (MAX_COLS + 1)  # +1 pentru header-ul de rând
                    
                    # Creează header-ul cu coloanele (A, B, C, etc.)
                    header_label = tk.Label(inner_frame, text="", width=4, bg="#e0e0e0", 
                                          relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"),
                                          highlightthickness=0)  # Eliminăm highlightthickness
                    header_label.grid(row=0, column=0, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                    header_labels[0] = header_label
                    
                    for col in range(max_col):
                        col_letter = chr(65 + col)  # A=65, B=66, etc.
                        header = tk.Label(inner_frame, text=col_letter, width=column_widths[col+1], bg="#e0e0e0",
                                        relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"),
                                        highlightthickness=0)  # Eliminăm highlightthickness
                        header.grid(row=0, column=col+1, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                        header_labels[col+1] = header
                        
                        # Adaugă separator de redimensionare
                        add_column_resize_handle(header, col+1)
                    
                    # Creează rândurile și celulele
                    row_widgets = []
                    for row in range(max_row):
                        # Creează header-ul pentru rând
                        row_header = tk.Label(inner_frame, text=str(row + 1), width=4, height=1,
                                            bg="#e0e0e0", relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"),
                                            highlightthickness=0)  # Eliminăm highlightthickness
                        row_header.grid(row=row+1, column=0, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                        
                        # Creează celulele pentru acest rând
                        col_widgets = []
                        for col in range(max_col):
                            cell_value = sheet.cell(row=row+1, column=col+1).value
                            cell_value = str(cell_value) if cell_value is not None else ""
                            
                            cell = tk.Entry(inner_frame, width=column_widths[col+1], font=("MS Sans Serif", 8),
                                          relief="sunken", bd=1, highlightthickness=0)  # Eliminăm highlightthickness
                            cell.insert(0, cell_value)
                            cell.grid(row=row+1, column=col+1, sticky="nsew", padx=0, pady=0)  # Eliminăm padding
                            
                            # Bind click to select cell
                            cell.bind("<Button-1>", lambda e, r=row, c=col: select_cell(r, c))
                            
                            col_widgets.append(cell)
                        row_widgets.append(col_widgets)
                    
                    nonlocal cell_grid
                    cell_grid = row_widgets
                    
                    # Configurează coloanele pentru dimensiune uniformă și fără spații
                    for col in range(max_col + 1):  # +1 pentru coloana cu header-ele de rând
                        inner_frame.grid_columnconfigure(col, weight=1, pad=0)
                    
                    # Configurează rândurile pentru a elimina spațiile
                    for row in range(max_row + 1):  # +1 pentru rândul cu header-ele de coloane
                        inner_frame.grid_rowconfigure(row, pad=0)
                    
                    # Update canvas scroll region
                    inner_frame.update_idletasks()
                    canvas.config(scrollregion=canvas.bbox("all"))
                    
                    status_label.config(text=f"Loaded sheet: {sheet.title}")
                
                def open_excel_file():
                    """Open an Excel file"""
                    file_path = filedialog.askopenfilename(
                        defaultextension=".xlsx",
                        filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
                    )
                    
                    if not file_path:
                        return
                    
                    try:
                        # Load the Excel file
                        nonlocal workbook, current_file
                        workbook = openpyxl.load_workbook(file_path, data_only=True)
                        current_file = file_path
                        
                        # Update the sheet selector dropdown
                        sheet_names = workbook.sheetnames
                        sheet_combo['values'] = sheet_names
                        
                        if sheet_names:
                            sheet_var.set(sheet_names[0])
                            show_sheet(sheet_names[0])
                        
                        # Update window title
                        file_name = os.path.basename(file_path)
                        title_label.config(text=f"Excel Lite - {file_name}")
                        excel_window.title(f"Excel Lite - {file_name}")
                        
                        status_label.config(text=f"Opened: {file_name}")
                    except Exception as e:
                        messagebox.showerror("Error", f"Could not open Excel file: {str(e)}")
                
                def show_sheet(sheet_name):
                    """Show the selected sheet"""
                    if not workbook or sheet_name not in workbook.sheetnames:
                        return
                    
                    nonlocal active_sheet
                    active_sheet = workbook[sheet_name]
                    load_sheet_data(active_sheet)
                
                def save_excel_file():
                    """Save the Excel file (placeholder for future implementation)"""
                    if not current_file or not workbook:
                        messagebox.showinfo("Info", "No file is currently open")
                        return
                    
                    messagebox.showinfo("Info", "Save functionality is not implemented in this version")
                
                def add_formula():
                    """Add a formula to the selected cell (placeholder)"""
                    messagebox.showinfo("Info", "Formula functionality is not implemented in this version")
                
                def sort_data():
                    """Sort data in the selected column (placeholder)"""
                    messagebox.showinfo("Info", "Sort functionality is not implemented in this version")
                
                def filter_data():
                    """Filter data in the selected column (placeholder)"""
                    messagebox.showinfo("Info", "Filter functionality is not implemented in this version")
                
                # Create empty sheet by default
                create_empty_sheet()
                
                # File menu commands
                file_menu.add_command(label="New", command=create_empty_sheet)
                file_menu.add_command(label="Open", command=open_excel_file)
                file_menu.add_command(label="Save", command=save_excel_file)
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window("Excel Lite", excel_window))
                
                # Edit menu commands
                edit_menu.add_command(label="Cut", command=lambda: status_label.config(text="Cut not implemented"))
                edit_menu.add_command(label="Copy", command=lambda: status_label.config(text="Copy not implemented"))
                edit_menu.add_command(label="Paste", command=lambda: status_label.config(text="Paste not implemented"))
                
                # View menu
                view_menu.add_command(label="Formulas", command=lambda: status_label.config(text="View Formulas not implemented"))
                view_menu.add_command(label="Freeze Panes", command=lambda: status_label.config(text="Freeze Panes not implemented"))
                
                # Help menu
                help_menu.add_command(label="About Excel Lite", command=lambda: messagebox.showinfo("About", "Excel Lite\nVersion 1.0\n\nA simple spreadsheet viewer"))
                
                # If a file path was provided, open it
                if file_path and os.path.exists(file_path):
                    current_file = file_path
                    try:
                        workbook = openpyxl.load_workbook(file_path, data_only=True)
                        sheet_names = workbook.sheetnames
                        sheet_combo['values'] = sheet_names
                        if sheet_names:
                            sheet_var.set(sheet_names[0])
                            show_sheet(sheet_names[0])
                        
                        # Update window title
                        file_name = os.path.basename(file_path)
                        title_label.config(text=f"Excel Lite - {file_name}")
                    except Exception as e:
                        messagebox.showerror("Error", f"Could not open Excel file: {str(e)}")
                
                # Add to taskbar
                self.add_window_to_taskbar("Excel Lite", excel_window)
                excel_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Excel Lite", excel_window))
            
            '''
            def create_excel_lite(self, file_path=None):
                """Creează o aplicație Excel Lite pentru a deschide și vizualiza fișiere xlsx"""
                try:
                    import openpyxl
                except ImportError:
                    messagebox.showerror("Error", "The openpyxl library is not installed. Please install it using pip: pip install openpyxl")
                    return

                excel_window = tk.Toplevel(self.rootW95dist)
                excel_window.title("Excel Lite")
                excel_window.overrideredirect(True)
                excel_window.geometry("800x600+200+100")
                excel_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(excel_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Excel Lite", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Excel Lite", excel_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(excel_window, title_bar)
                
                # Menubar
                menubar = tk.Menu(excel_window)
                excel_window.config(menu=menubar)
                
                file_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="File", menu=file_menu)
                
                edit_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Edit", menu=edit_menu)
                
                view_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="View", menu=view_menu)
                
                help_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="Help", menu=help_menu)
                
                # Toolbar frame
                toolbar_frame = tk.Frame(excel_window, bg="#c0c0c0", relief="raised", bd=2, height=35)
                toolbar_frame.pack(fill="x")
                toolbar_frame.pack_propagate(False)
                
                # Open button
                open_btn = tk.Button(toolbar_frame, text="Open", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: open_excel_file())
                open_btn.pack(side="left", padx=5, pady=2)
                
                # Save button (for future implementation)
                save_btn = tk.Button(toolbar_frame, text="Save", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: save_excel_file())
                save_btn.pack(side="left", padx=5, pady=2)
                
                # Sheet selection
                sheet_label = tk.Label(toolbar_frame, text="Sheet:", bg="#c0c0c0", font=("MS Sans Serif", 8))
                sheet_label.pack(side="left", padx=(20, 5))
                
                sheet_var = tk.StringVar()
                sheet_combo = ttk.Combobox(toolbar_frame, textvariable=sheet_var, width=15, state="readonly")
                sheet_combo.pack(side="left", padx=5)
                sheet_combo.bind("<<ComboboxSelected>>", lambda e: show_sheet(sheet_var.get()))
                
                # Function buttons
                formula_btn = tk.Button(toolbar_frame, text="Formula", bg="#c0c0c0", relief="raised", bd=2,
                                       font=("MS Sans Serif", 8),
                                       command=lambda: add_formula())
                formula_btn.pack(side="left", padx=5, pady=2)
                
                sort_btn = tk.Button(toolbar_frame, text="Sort", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: sort_data())
                sort_btn.pack(side="left", padx=5, pady=2)
                
                filter_btn = tk.Button(toolbar_frame, text="Filter", bg="#c0c0c0", relief="raised", bd=2,
                                      font=("MS Sans Serif", 8),
                                      command=lambda: filter_data())
                filter_btn.pack(side="left", padx=5, pady=2)
                
                # Status bar - adăugat înainte de conținutul principal
                status_frame = tk.Frame(excel_window, bg="#c0c0c0", relief="sunken", bd=1, height=25)
                status_frame.pack(side="bottom", fill="x")
                status_frame.pack_propagate(False)
                
                status_label = tk.Label(status_frame, text="Ready", bg="#c0c0c0", font=("MS Sans Serif", 8))
                status_label.pack(side="left", padx=5)
                
                cell_info_label = tk.Label(status_frame, text="", bg="#c0c0c0", font=("MS Sans Serif", 8))
                cell_info_label.pack(side="right", padx=5)
                
                # Main content frame
                content_frame = tk.Frame(excel_window, bg="white")
                content_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Scrollbars
                h_scrollbar = tk.Scrollbar(content_frame, orient="horizontal")
                h_scrollbar.pack(side="bottom", fill="x")
                
                # Main table frame
                table_frame = tk.Frame(content_frame, bg="white")
                table_frame.pack(fill="both", expand=True)
                
                v_scrollbar = tk.Scrollbar(table_frame)
                v_scrollbar.pack(side="right", fill="y")
                
                # Canvas for scrollable content
                canvas = tk.Canvas(table_frame, bg="white", 
                                 xscrollcommand=h_scrollbar.set,
                                 yscrollcommand=v_scrollbar.set)
                canvas.pack(side="left", fill="both", expand=True)
                
                h_scrollbar.config(command=canvas.xview)
                v_scrollbar.config(command=canvas.yview)
                
                # Frame inside canvas for grid
                inner_frame = tk.Frame(canvas, bg="white")
                canvas.create_window((0, 0), window=inner_frame, anchor="nw")
                
                # Variables for tracking
                current_file = None
                workbook = None
                active_sheet = None
                
                # Cell grid (for display only)
                cell_grid = []
                
                # Max rows and columns to display
                MAX_ROWS = 100
                MAX_COLS = 26  # A-Z
                
                def clear_sheet():
                    """Clear the current sheet display"""
                    for widget in inner_frame.winfo_children():
                        widget.destroy()
                    
                    nonlocal cell_grid
                    cell_grid = []
                
                def create_empty_sheet():
                    """Create an empty spreadsheet grid"""
                    clear_sheet()
                    
                    # Definește o lățime fixă pentru toate celulele
                    CELL_WIDTH = 10
                    
                    # Creează header-ul cu coloanele (A, B, C, etc.)
                    header_label = tk.Label(inner_frame, text="", width=4, bg="#e0e0e0", 
                                          relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"))
                    header_label.grid(row=0, column=0, sticky="nsew")
                    
                    for col in range(MAX_COLS):
                        col_letter = chr(65 + col)  # A=65, B=66, etc.
                        header = tk.Label(inner_frame, text=col_letter, width=CELL_WIDTH, bg="#e0e0e0",
                                        relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"))
                        header.grid(row=0, column=col+1, sticky="nsew")
                    
                    # Creează rândurile și celulele
                    row_widgets = []
                    for row in range(MAX_ROWS):
                        # Creează header-ul pentru rând
                        row_header = tk.Label(inner_frame, text=str(row + 1), width=4, height=1,
                                            bg="#e0e0e0", relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"))
                        row_header.grid(row=row+1, column=0, sticky="nsew")
                        
                        # Creează celulele pentru acest rând
                        col_widgets = []
                        for col in range(MAX_COLS):
                            cell = tk.Entry(inner_frame, width=CELL_WIDTH, font=("MS Sans Serif", 8),
                                          relief="sunken", bd=1)
                            cell.grid(row=row+1, column=col+1, sticky="nsew")
                            
                            # Bind click to select cell
                            cell.bind("<Button-1>", lambda e, r=row, c=col: select_cell(r, c))
                            
                            col_widgets.append(cell)
                        row_widgets.append(col_widgets)
                    
                    cell_grid = row_widgets
                    
                    # Configurează coloanele pentru dimensiune uniformă
                    for col in range(MAX_COLS + 1):  # +1 pentru coloana cu header-ele de rând
                        inner_frame.grid_columnconfigure(col, weight=1)
                    
                    # Update canvas scroll region
                    inner_frame.update_idletasks()
                    canvas.config(scrollregion=canvas.bbox("all"))
                
                def select_cell(row, col):
                    """Select a cell and show its address in the status bar"""
                    col_letter = chr(65 + col)
                    cell_address = f"{col_letter}{row + 1}"
                    cell_info_label.config(text=f"Cell: {cell_address}")
                    
                    # Set focus to the cell
                    if 0 <= row < len(cell_grid) and 0 <= col < len(cell_grid[0]):
                        cell_grid[row][col].focus_set()
                
                def load_sheet_data(sheet):
                    """Load data from the workbook sheet into the grid"""
                    clear_sheet()
                    
                    # Get the dimensions of the sheet
                    max_row = min(sheet.max_row, MAX_ROWS)
                    max_col = min(sheet.max_column, MAX_COLS)
                    
                    # Definește o lățime fixă pentru toate celulele
                    CELL_WIDTH = 10
                    
                    # Creează header-ul cu coloanele (A, B, C, etc.)
                    header_label = tk.Label(inner_frame, text="", width=4, bg="#e0e0e0", 
                                          relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"))
                    header_label.grid(row=0, column=0, sticky="nsew")
                    
                    for col in range(max_col):
                        col_letter = chr(65 + col)  # A=65, B=66, etc.
                        header = tk.Label(inner_frame, text=col_letter, width=CELL_WIDTH, bg="#e0e0e0",
                                        relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"))
                        header.grid(row=0, column=col+1, sticky="nsew")
                    
                    # Creează rândurile și celulele
                    row_widgets = []
                    for row in range(max_row):
                        # Creează header-ul pentru rând
                        row_header = tk.Label(inner_frame, text=str(row + 1), width=4, height=1,
                                            bg="#e0e0e0", relief="raised", bd=1, font=("MS Sans Serif", 8, "bold"))
                        row_header.grid(row=row+1, column=0, sticky="nsew")
                        
                        # Creează celulele pentru acest rând
                        col_widgets = []
                        for col in range(max_col):
                            cell_value = sheet.cell(row=row+1, column=col+1).value
                            cell_value = str(cell_value) if cell_value is not None else ""
                            
                            cell = tk.Entry(inner_frame, width=CELL_WIDTH, font=("MS Sans Serif", 8),
                                          relief="sunken", bd=1)
                            cell.insert(0, cell_value)
                            cell.grid(row=row+1, column=col+1, sticky="nsew")
                            
                            # Bind click to select cell
                            cell.bind("<Button-1>", lambda e, r=row, c=col: select_cell(r, c))
                            
                            col_widgets.append(cell)
                        row_widgets.append(col_widgets)
                    
                    nonlocal cell_grid
                    cell_grid = row_widgets
                    
                    # Configurează coloanele pentru dimensiune uniformă
                    for col in range(max_col + 1):  # +1 pentru coloana cu header-ele de rând
                        inner_frame.grid_columnconfigure(col, weight=1)
                    
                    # Update canvas scroll region
                    inner_frame.update_idletasks()
                    canvas.config(scrollregion=canvas.bbox("all"))
                    
                    status_label.config(text=f"Loaded sheet: {sheet.title}")
                
                def open_excel_file():
                    """Open an Excel file"""
                    file_path = filedialog.askopenfilename(
                        defaultextension=".xlsx",
                        filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
                    )
                    
                    if not file_path:
                        return
                    
                    try:
                        # Load the Excel file
                        nonlocal workbook, current_file
                        workbook = openpyxl.load_workbook(file_path, data_only=True)
                        current_file = file_path
                        
                        # Update the sheet selector dropdown
                        sheet_names = workbook.sheetnames
                        sheet_combo['values'] = sheet_names
                        
                        if sheet_names:
                            sheet_var.set(sheet_names[0])
                            show_sheet(sheet_names[0])
                        
                        # Update window title
                        file_name = os.path.basename(file_path)
                        title_label.config(text=f"Excel Lite - {file_name}")
                        excel_window.title(f"Excel Lite - {file_name}")
                        
                        status_label.config(text=f"Opened: {file_name}")
                    except Exception as e:
                        messagebox.showerror("Error", f"Could not open Excel file: {str(e)}")
                
                def show_sheet(sheet_name):
                    """Show the selected sheet"""
                    if not workbook or sheet_name not in workbook.sheetnames:
                        return
                    
                    nonlocal active_sheet
                    active_sheet = workbook[sheet_name]
                    load_sheet_data(active_sheet)
                
                def save_excel_file():
                    """Save the Excel file (placeholder for future implementation)"""
                    if not current_file or not workbook:
                        messagebox.showinfo("Info", "No file is currently open")
                        return
                    
                    messagebox.showinfo("Info", "Save functionality is not implemented in this version")
                
                def add_formula():
                    """Add a formula to the selected cell (placeholder)"""
                    messagebox.showinfo("Info", "Formula functionality is not implemented in this version")
                
                def sort_data():
                    """Sort data in the selected column (placeholder)"""
                    messagebox.showinfo("Info", "Sort functionality is not implemented in this version")
                
                def filter_data():
                    """Filter data in the selected column (placeholder)"""
                    messagebox.showinfo("Info", "Filter functionality is not implemented in this version")
                
                # Create empty sheet by default
                create_empty_sheet()
                
                # File menu commands
                file_menu.add_command(label="New", command=create_empty_sheet)
                file_menu.add_command(label="Open", command=open_excel_file)
                file_menu.add_command(label="Save", command=save_excel_file)
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window("Excel Lite", excel_window))
                
                # Edit menu commands
                edit_menu.add_command(label="Cut", command=lambda: status_label.config(text="Cut not implemented"))
                edit_menu.add_command(label="Copy", command=lambda: status_label.config(text="Copy not implemented"))
                edit_menu.add_command(label="Paste", command=lambda: status_label.config(text="Paste not implemented"))
                
                # View menu
                view_menu.add_command(label="Formulas", command=lambda: status_label.config(text="View Formulas not implemented"))
                view_menu.add_command(label="Freeze Panes", command=lambda: status_label.config(text="Freeze Panes not implemented"))
                
                # Help menu
                help_menu.add_command(label="About Excel Lite", command=lambda: messagebox.showinfo("About", "Excel Lite\nVersion 1.0\n\nA simple spreadsheet viewer"))
                
                # If a file path was provided, open it
                if file_path and os.path.exists(file_path):
                    current_file = file_path
                    try:
                        workbook = openpyxl.load_workbook(file_path, data_only=True)
                        sheet_names = workbook.sheetnames
                        sheet_combo['values'] = sheet_names
                        if sheet_names:
                            sheet_var.set(sheet_names[0])
                            show_sheet(sheet_names[0])
                        
                        # Update window title
                        file_name = os.path.basename(file_path)
                        title_label.config(text=f"Excel Lite - {file_name}")
                    except Exception as e:
                        messagebox.showerror("Error", f"Could not open Excel file: {str(e)}")
                
                # Add to taskbar
                self.add_window_to_taskbar("Excel Lite", excel_window)
                excel_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Excel Lite", excel_window))
            
            '''
            def create_file_explorer(self, path=None):
                """Creează un explorer de fișiere care arată și permite gestionarea fișierelor și directoarelor"""
                from tkinter import simpledialog
                if path is None:
                    # Start with root directory or home directory depending on OS
                    if os.name == 'nt':  # Windows
                        path = 'C:\\'
                    else:  # Linux/Mac
                        path = os.path.expanduser('~')
                
                explorer_window = tk.Toplevel(self.rootW95dist)
                explorer_window.title("My Computer")
                explorer_window.overrideredirect(True)
                explorer_window.geometry("700x500+200+100")
                explorer_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(explorer_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text=f"My Computer - {path}", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("My Computer", explorer_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(explorer_window, title_bar)
                
                # Menu bar
                menu_bar = tk.Menu(explorer_window)
                explorer_window.config(menu=menu_bar)
                
                file_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="File", menu=file_menu)
                
                edit_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="Edit", menu=edit_menu)
                
                view_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="View", menu=view_menu)
                
                help_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="Help", menu=help_menu)
                
                # Main content frame
                content_frame = tk.Frame(explorer_window, bg="#c0c0c0")
                content_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Address bar
                address_frame = tk.Frame(content_frame, bg="#c0c0c0")
                address_frame.pack(fill="x", pady=5)
                
                tk.Label(address_frame, text="Address:", bg="#c0c0c0", font=("MS Sans Serif", 8)).pack(side="left")
                address_var = tk.StringVar(value=path)
                address_entry = tk.Entry(address_frame, textvariable=address_var, width=50, font=("MS Sans Serif", 8))
                address_entry.pack(side="left", padx=5, fill="x", expand=True)
                address_entry.bind("<Return>", lambda e: navigate_to_path(address_var.get()))
                
                go_button = tk.Button(address_frame, text="Go", bg="#c0c0c0", relief="raised", bd=2,
                                     font=("MS Sans Serif", 8),
                                     command=lambda: navigate_to_path(address_var.get()))
                go_button.pack(side="left", padx=5)
                
                up_button = tk.Button(address_frame, text="Up", bg="#c0c0c0", relief="raised", bd=2,
                                     font=("MS Sans Serif", 8),
                                     command=lambda: navigate_up())
                up_button.pack(side="left", padx=5)
                
                # Toolbar for file operations
                toolbar_frame = tk.Frame(content_frame, bg="#c0c0c0", relief="raised", bd=2)
                toolbar_frame.pack(fill="x", pady=5)
                
                new_folder_btn = tk.Button(toolbar_frame, text="New Folder", bg="#c0c0c0", relief="raised", bd=2,
                                          font=("MS Sans Serif", 8),
                                          command=lambda: create_new_folder())
                new_folder_btn.pack(side="left", padx=5, pady=2)
                
                cut_btn = tk.Button(toolbar_frame, text="Cut", bg="#c0c0c0", relief="raised", bd=2,
                                   font=("MS Sans Serif", 8),
                                   command=lambda: cut_selected())
                cut_btn.pack(side="left", padx=5, pady=2)
                
                copy_btn = tk.Button(toolbar_frame, text="Copy", bg="#c0c0c0", relief="raised", bd=2,
                                    font=("MS Sans Serif", 8),
                                    command=lambda: copy_selected())
                copy_btn.pack(side="left", padx=5, pady=2)
                
                paste_btn = tk.Button(toolbar_frame, text="Paste", bg="#c0c0c0", relief="raised", bd=2,
                                     font=("MS Sans Serif", 8),
                                     command=lambda: paste_item())
                paste_btn.pack(side="left", padx=5, pady=2)
                
                delete_btn = tk.Button(toolbar_frame, text="Delete", bg="#c0c0c0", relief="raised", bd=2,
                                      font=("MS Sans Serif", 8),
                                      command=lambda: delete_selected())
                delete_btn.pack(side="left", padx=5, pady=2)
                
                rename_btn = tk.Button(toolbar_frame, text="Rename", bg="#c0c0c0", relief="raised", bd=2,
                                      font=("MS Sans Serif", 8),
                                      command=lambda: rename_selected())
                rename_btn.pack(side="left", padx=5, pady=2)
                
                refresh_btn = tk.Button(toolbar_frame, text="Refresh", bg="#c0c0c0", relief="raised", bd=2,
                                       font=("MS Sans Serif", 8),
                                       command=lambda: refresh_view())
                refresh_btn.pack(side="right", padx=5, pady=2)
                
                # File/Directory list
                list_frame = tk.Frame(content_frame, bg="white", relief="sunken", bd=2)
                list_frame.pack(fill="both", expand=True, pady=5)
                
                # Scrollbars
                h_scrollbar = tk.Scrollbar(list_frame, orient="horizontal")
                h_scrollbar.pack(side="bottom", fill="x")
                
                v_scrollbar = tk.Scrollbar(list_frame)
                v_scrollbar.pack(side="right", fill="y")
                
                # List with columns
                columns = ("name", "type", "size", "modified")
                file_list = ttk.Treeview(list_frame, columns=columns, show="headings",
                                       yscrollcommand=v_scrollbar.set,
                                       xscrollcommand=h_scrollbar.set,
                                       selectmode="extended")
                
                file_list.heading("name", text="Name", command=lambda: sort_by_column("name"))
                file_list.heading("type", text="Type", command=lambda: sort_by_column("type"))
                file_list.heading("size", text="Size", command=lambda: sort_by_column("size"))
                file_list.heading("modified", text="Date Modified", command=lambda: sort_by_column("modified"))
                
                file_list.column("name", width=200, anchor="w")
                file_list.column("type", width=100, anchor="w")
                file_list.column("size", width=100, anchor="e")
                file_list.column("modified", width=150, anchor="w")
                
                file_list.pack(side="left", fill="both", expand=True)
                
                v_scrollbar.config(command=file_list.yview)
                h_scrollbar.config(command=file_list.xview)
                
                # Status bar
                status_frame = tk.Frame(explorer_window, bg="#c0c0c0", relief="sunken", bd=1, height=25)
                status_frame.pack(fill="x", side="bottom")
                status_frame.pack_propagate(False)
                
                status_label = tk.Label(status_frame, text="", bg="#c0c0c0", font=("MS Sans Serif", 8))
                status_label.pack(side="left", padx=5)
                
                items_label = tk.Label(status_frame, text="", bg="#c0c0c0", font=("MS Sans Serif", 8))
                items_label.pack(side="right", padx=5)
                
                # Add to taskbar
                self.add_window_to_taskbar("My Computer", explorer_window)
                explorer_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("My Computer", explorer_window))
                
                # Clipboard for file operations
                clipboard = {
                    "action": None,  # "cut" or "copy"
                    "files": []
                }
                
                # Double-click to open/navigate
                file_list.bind("<Double-1>", lambda e: open_selected())
                
                # Right-click context menu
                context_menu = tk.Menu(file_list, tearoff=0)
                
                def show_context_menu(event):
                    context_menu.delete(0, tk.END)  # Clear previous items
                    
                    # Add menu items based on selection
                    selected = file_list.selection()
                    if selected:
                        context_menu.add_command(label="Open", command=open_selected)
                        context_menu.add_separator()
                        context_menu.add_command(label="Cut", command=cut_selected)
                        context_menu.add_command(label="Copy", command=copy_selected)
                        context_menu.add_command(label="Delete", command=delete_selected)
                        context_menu.add_command(label="Rename", command=rename_selected)
                        
                        # If only one item selected and it's a file
                        if len(selected) == 1:
                            item = selected[0]
                            values = file_list.item(item, "values")
                            if values[1] != "Folder":
                                context_menu.add_separator()
                                context_menu.add_command(label="Open with Text Editor", 
                                                       command=lambda: open_with_text_editor(values[0]))
                    else:
                        context_menu.add_command(label="Paste", command=paste_item, 
                                               state="normal" if clipboard["files"] else "disabled")
                        context_menu.add_separator()
                        context_menu.add_command(label="New Folder", command=create_new_folder)
                        context_menu.add_command(label="Refresh", command=refresh_view)
                    
                    # Display the context menu
                    context_menu.tk_popup(event.x_root, event.y_root)
                
                file_list.bind("<Button-3>", show_context_menu)  # Right-click
                
                # Functions for file operations
                def navigate_to_path(new_path):
                    try:
                        # Check if path exists and is accessible
                        if os.path.exists(new_path) and os.path.isdir(new_path):
                            nonlocal path
                            path = os.path.normpath(new_path)
                            address_var.set(path)
                            title_label.config(text=f"My Computer - {path}")
                            refresh_view()
                        else:
                            messagebox.showerror("Error", f"Cannot access: {new_path}")
                    except Exception as e:
                        messagebox.showerror("Error", f"Error navigating to path: {str(e)}")
                
                def navigate_up():
                    parent_dir = os.path.dirname(path)
                    if parent_dir != path:  # Not at root
                        navigate_to_path(parent_dir)
                
                def refresh_view():
                    # Clear existing items
                    for item in file_list.get_children():
                        file_list.delete(item)
                    
                    try:
                        # List directories and files
                        items = os.listdir(path)
                        
                        # First add directories
                        for item in sorted(items):
                            item_path = os.path.join(path, item)
                            try:
                                if os.path.isdir(item_path):
                                    # Get modified time
                                    mod_time = os.path.getmtime(item_path)
                                    mod_time_str = datetime.fromtimestamp(mod_time).strftime('%Y-%m-%d %H:%M:%S')
                                    
                                    file_list.insert("", "end", values=(item, "Folder", "", mod_time_str))
                            except PermissionError:
                                file_list.insert("", "end", values=(item, "Folder (Access Denied)", "", ""))
                            except Exception as e:
                                print(f"Error accessing {item_path}: {str(e)}")
                        
                        # Then add files
                        for item in sorted(items):
                            item_path = os.path.join(path, item)
                            try:
                                if os.path.isfile(item_path):
                                    # Get file size
                                    size = os.path.getsize(item_path)
                                    size_str = format_size(size)
                                    
                                    # Get modified time
                                    mod_time = os.path.getmtime(item_path)
                                    mod_time_str = datetime.fromtimestamp(mod_time).strftime('%Y-%m-%d %H:%M:%S')
                                    
                                    # Get file type
                                    file_ext = os.path.splitext(item)[1].lower()
                                    file_type = get_file_type(file_ext)
                                    
                                    file_list.insert("", "end", values=(item, file_type, size_str, mod_time_str))
                            except PermissionError:
                                file_list.insert("", "end", values=(item, "File (Access Denied)", "", ""))
                            except Exception as e:
                                print(f"Error accessing {item_path}: {str(e)}")
                        
                        # Update status
                        status_label.config(text=f"Current directory: {path}")
                        items_label.config(text=f"{len(items)} items")
                        
                    except PermissionError:
                        messagebox.showerror("Access Denied", f"Cannot access directory: {path}")
                        navigate_up()
                    except Exception as e:
                        messagebox.showerror("Error", f"Error loading directory: {str(e)}")
                
                def format_size(size_bytes):
                    """Format file size in human-readable format"""
                    if size_bytes < 1024:
                        return f"{size_bytes} B"
                    elif size_bytes < 1024**2:
                        return f"{size_bytes/1024:.1f} KB"
                    elif size_bytes < 1024**3:
                        return f"{size_bytes/(1024**2):.1f} MB"
                    else:
                        return f"{size_bytes/(1024**3):.1f} GB"
                
                def get_file_type(ext):
                    """Return file type based on extension"""
                    file_types = {
                        ".txt": "Text Document",
                        ".doc": "Word Document",
                        ".docx": "Word Document",
                        ".pdf": "PDF Document",
                        ".jpg": "JPEG Image",
                        ".jpeg": "JPEG Image",
                        ".png": "PNG Image",
                        ".gif": "GIF Image",
                        ".mp3": "Audio File",
                        ".mp4": "Video File",
                        ".py": "Python Script",
                        ".exe": "Application",
                        ".zip": "Compressed File",
                        ".rar": "Compressed File",
                        ".ini": "Configuration File",
                        ".html": "HTML Document",
                        ".css": "CSS File",
                        ".js": "JavaScript File",
                        ".json": "JSON File"
                    }
                    return file_types.get(ext, f"{ext[1:].upper() if ext else 'Unknown'} File")
                
                def open_selected():
                    selected = file_list.selection()
                    if not selected:
                        return
                    
                    # Get the first selected item
                    item = selected[0]
                    values = file_list.item(item, "values")
                    item_name = values[0]
                    item_type = values[1]
                    item_path = os.path.join(path, item_name)
                    
                    if item_type == "Folder":
                        # Navigate to the selected folder
                        navigate_to_path(item_path)
                    else:
                        # For files, try to open with default application
                        try:
                            if os.name == 'nt':  # Windows
                                os.startfile(item_path)
                            else:  # Linux/Mac
                                subprocess.run(['xdg-open', item_path], check=True)
                        except Exception as e:
                            messagebox.showerror("Error", f"Could not open file: {str(e)}")
                            # Offer to open with text editor
                            if messagebox.askyesno("Open with Text Editor", 
                                                  "Would you like to open this file with Text Editor?"):
                                open_with_text_editor(item_name)
                
                def open_with_text_editor(filename):
                    """Open the selected file with the Text Editor"""
                    file_path = os.path.join(path, filename)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            content = file.read()
                            
                            # Create a new text editor window
                            self.create_text_editor_with_content(content, filename, file_path)
                    except UnicodeDecodeError:
                        messagebox.showerror("Error", "Cannot open binary file with Text Editor")
                    except Exception as e:
                        messagebox.showerror("Error", f"Error opening file: {str(e)}")
                
                def create_new_folder():
                    """Create a new folder in the current directory"""
                    folder_name = simpledialog.askstring("New Folder", "Enter folder name:")
                    if folder_name:
                        new_folder_path = os.path.join(path, folder_name)
                        try:
                            os.mkdir(new_folder_path)
                            refresh_view()
                        except Exception as e:
                            messagebox.showerror("Error", f"Could not create folder: {str(e)}")
                
                def cut_selected():
                    """Cut selected files/folders"""
                    selected = file_list.selection()
                    if not selected:
                        return
                    
                    clipboard["action"] = "cut"
                    clipboard["files"] = []
                    
                    for item in selected:
                        values = file_list.item(item, "values")
                        item_name = values[0]
                        item_path = os.path.join(path, item_name)
                        clipboard["files"].append(item_path)
                    
                    status_label.config(text=f"{len(selected)} items cut to clipboard")
                
                def copy_selected():
                    """Copy selected files/folders"""
                    selected = file_list.selection()
                    if not selected:
                        return
                    
                    clipboard["action"] = "copy"
                    clipboard["files"] = []
                    
                    for item in selected:
                        values = file_list.item(item, "values")
                        item_name = values[0]
                        item_path = os.path.join(path, item_name)
                        clipboard["files"].append(item_path)
                    
                    status_label.config(text=f"{len(selected)} items copied to clipboard")
                
                def paste_item():
                    """Paste files/folders from clipboard to current directory"""
                    if not clipboard["files"]:
                        return
                    
                    for src_path in clipboard["files"]:
                        if not os.path.exists(src_path):
                            continue
                            
                        # Get just the filename/foldername
                        base_name = os.path.basename(src_path)
                        dst_path = os.path.join(path, base_name)
                        
                        try:
                            # Check if destination already exists
                            if os.path.exists(dst_path):
                                if not messagebox.askyesno("Confirm", 
                                                          f"{base_name} already exists. Overwrite?"):
                                    continue
                            
                            if clipboard["action"] == "cut":
                                # For cut operation, move the file/folder
                                if os.path.isdir(src_path):
                                    # For folders, use shutil.move
                                    shutil.move(src_path, dst_path)
                                else:
                                    # For files, use os.rename (faster than shutil.move for files)
                                    os.rename(src_path, dst_path)
                            else:  # "copy"
                                # For copy operation
                                if os.path.isdir(src_path):
                                    # For folders, copy the entire directory tree
                                    shutil.copytree(src_path, dst_path)
                                else:
                                    # For files, use shutil.copy2 to preserve metadata
                                    shutil.copy2(src_path, dst_path)
                        except Exception as e:
                            messagebox.showerror("Error", f"Error pasting {base_name}: {str(e)}")
                    
                    # Clear clipboard if it was a cut operation
                    if clipboard["action"] == "cut":
                        clipboard["files"] = []
                    
                    refresh_view()
                
                def delete_selected():
                    """Delete selected files/folders"""
                    selected = file_list.selection()
                    if not selected:
                        return
                    
                    # Confirm deletion
                    count = len(selected)
                    if not messagebox.askyesno("Confirm Delete", 
                                              f"Are you sure you want to delete {count} item(s)?"):
                        return
                    
                    for item in selected:
                        values = file_list.item(item, "values")
                        item_name = values[0]
                        item_path = os.path.join(path, item_name)
                        
                        try:
                            if os.path.isdir(item_path):
                                # For folders, use shutil.rmtree
                                shutil.rmtree(item_path)
                            else:
                                # For files, use os.remove
                                os.remove(item_path)
                        except Exception as e:
                            messagebox.showerror("Error", f"Error deleting {item_name}: {str(e)}")
                    
                    refresh_view()
                
                def rename_selected():
                    """Rename selected file/folder"""
                    selected = file_list.selection()
                    if not selected or len(selected) > 1:
                        messagebox.showinfo("Rename", "Please select only one item to rename")
                        return
                    
                    item = selected[0]
                    values = file_list.item(item, "values")
                    old_name = values[0]
                    old_path = os.path.join(path, old_name)
                    
                    new_name = simpledialog.askstring("Rename", "Enter new name:", initialvalue=old_name)
                    if new_name and new_name != old_name:
                        new_path = os.path.join(path, new_name)
                        try:
                            os.rename(old_path, new_path)
                            refresh_view()
                        except Exception as e:
                            messagebox.showerror("Error", f"Error renaming file: {str(e)}")
                
                def sort_by_column(column):
                    """Sort file list by the specified column"""
                    # This would need to be implemented to handle sorting
                    # For simplicity, we'll just refresh the view for now
                    refresh_view()
                
                # Initial file listing
                refresh_view()

            def create_text_editor_with_content(self, content, filename, file_path=None):
                """Create a text editor window with predefined content"""
                editor_window = tk.Toplevel(self.rootW95dist)
                editor_window.title(f"Text Editor - {filename}")
                editor_window.overrideredirect(True)
                editor_window.geometry("600x400+200+100")
                editor_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(editor_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text=f"Text Editor - {filename}", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                self.make_window_draggable(editor_window, title_bar)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window(f"Text Editor - {filename}", editor_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                # Menubar
                menubar = tk.Menu(editor_window)
                editor_window.config(menu=menubar)
                
                file_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="File", menu=file_menu)
                
                # Text area
                text_frame = tk.Frame(editor_window, bg="#c0c0c0")
                text_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Scrollbar
                scrollbar = tk.Scrollbar(text_frame)
                scrollbar.pack(side="right", fill="y")
                
                # Text widget
                text_area = tk.Text(text_frame, wrap="word", yscrollcommand=scrollbar.set,
                                   font=("Courier New", 10), bg="white", fg="black")
                text_area.pack(fill="both", expand=True)
                scrollbar.config(command=text_area.yview)
                
                # Insert the content
                text_area.insert(1.0, content)
                
                # Funcții pentru meniu
                def save_file():
                    try:
                        with open(file_path, 'w', encoding='utf-8') as file:
                            content = text_area.get(1.0, tk.END)
                            file.write(content)
                            messagebox.showinfo("Success", "File saved successfully!")
                    except Exception as e:
                        messagebox.showerror("Error", f"Could not save file: {str(e)}")
                
                def save_as_file():
                    file_path_new = filedialog.asksaveasfilename(
                        defaultextension=".txt",
                        filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
                    )
                    if file_path_new:
                        try:
                            with open(file_path_new, 'w', encoding='utf-8') as file:
                                content = text_area.get(1.0, tk.END)
                                file.write(content)
                                nonlocal file_path
                                file_path = file_path_new
                                editor_window.title(f"Text Editor - {os.path.basename(file_path)}")
                                title_label.config(text=f"Text Editor - {os.path.basename(file_path)}")
                                messagebox.showinfo("Success", "File saved successfully!")
                        except Exception as e:
                            messagebox.showerror("Error", f"Could not save file: {str(e)}")
                
                # Adaugă opțiunile în meniu
                file_menu.add_command(label="Save", command=save_file)
                file_menu.add_command(label="Save As", command=save_as_file)
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window(f"Text Editor - {filename}", editor_window))
                
                self.add_window_to_taskbar(f"Text Editor - {filename}", editor_window)
                editor_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window(f"Text Editor - {filename}", editor_window))

            def create_text_editor_with_content(self, content, filename, file_path=None):
                """Create a text editor window with predefined content"""
                editor_window = tk.Toplevel(self.rootW95dist)
                editor_window.title(f"Text Editor - {filename}")
                editor_window.overrideredirect(True)
                editor_window.geometry("600x400+200+100")
                editor_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(editor_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text=f"Text Editor - {filename}", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                self.make_window_draggable(editor_window, title_bar)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window(f"Text Editor - {filename}", editor_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                # Menubar
                menubar = tk.Menu(editor_window)
                editor_window.config(menu=menubar)
                
                file_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="File", menu=file_menu)
                
                # Text area
                text_frame = tk.Frame(editor_window, bg="#c0c0c0")
                text_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Scrollbar
                scrollbar = tk.Scrollbar(text_frame)
                scrollbar.pack(side="right", fill="y")
                
                # Text widget
                text_area = tk.Text(text_frame, wrap="word", yscrollcommand=scrollbar.set,
                                   font=("Courier New", 10), bg="white", fg="black")
                text_area.pack(fill="both", expand=True)
                scrollbar.config(command=text_area.yview)
                
                # Insert the content
                text_area.insert(1.0, content)
                
                # Funcții pentru meniu
                def save_file():
                    try:
                        with open(file_path, 'w', encoding='utf-8') as file:
                            content = text_area.get(1.0, tk.END)
                            file.write(content)
                            messagebox.showinfo("Success", "File saved successfully!")
                    except Exception as e:
                        messagebox.showerror("Error", f"Could not save file: {str(e)}")
                
                def save_as_file():
                    file_path_new = filedialog.asksaveasfilename(
                        defaultextension=".txt",
                        filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
                    )
                    if file_path_new:
                        try:
                            with open(file_path_new, 'w', encoding='utf-8') as file:
                                content = text_area.get(1.0, tk.END)
                                file.write(content)
                                nonlocal file_path
                                file_path = file_path_new
                                editor_window.title(f"Text Editor - {os.path.basename(file_path)}")
                                title_label.config(text=f"Text Editor - {os.path.basename(file_path)}")
                                messagebox.showinfo("Success", "File saved successfully!")
                        except Exception as e:
                            messagebox.showerror("Error", f"Could not save file: {str(e)}")
                
                # Adaugă opțiunile în meniu
                file_menu.add_command(label="Save", command=save_file)
                file_menu.add_command(label="Save As", command=save_as_file)
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window(f"Text Editor - {filename}", editor_window))
                
                self.add_window_to_taskbar(f"Text Editor - {filename}", editor_window)
                editor_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window(f"Text Editor - {filename}", editor_window))
            
            def create_text_editor(self):
                editor_window = tk.Toplevel(self.rootW95dist)
                editor_window.title("Text Editor")
                editor_window.overrideredirect(True)
                editor_window.geometry("500x400+200+100")
                editor_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(editor_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Text Editor", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                self.make_window_draggable(editor_window, title_bar)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Text Editor", editor_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                # Menubar
                menubar = tk.Menu(editor_window)
                editor_window.config(menu=menubar)
                
                file_menu = tk.Menu(menubar, tearoff=0)
                menubar.add_cascade(label="File", menu=file_menu)
                
                # Text area
                text_frame = tk.Frame(editor_window, bg="#c0c0c0")
                text_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Scrollbar
                scrollbar = tk.Scrollbar(text_frame)
                scrollbar.pack(side="right", fill="y")
                
                # Text widget
                text_area = tk.Text(text_frame, wrap="word", yscrollcommand=scrollbar.set,
                                   font=("Courier New", 10), bg="white", fg="black")
                text_area.pack(fill="both", expand=True)
                scrollbar.config(command=text_area.yview)
                
                self.make_window_draggable(editor_window, title_bar)
                
                # Funcții pentru meniu
                def open_file():
                    file_path = filedialog.askopenfilename(
                        defaultextension=".txt",
                        filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
                    )
                    if file_path:
                        try:
                            with open(file_path, 'r', encoding='utf-8') as file:
                                content = file.read()
                                text_area.delete(1.0, tk.END)
                                text_area.insert(1.0, content)
                                editor_window.title(f"Text Editor - {file_path}")
                        except Exception as e:
                            messagebox.showerror("Error", f"Could not open file: {str(e)}")
                
                def save_file():
                    file_path = filedialog.asksaveasfilename(
                        defaultextension=".txt",
                        filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
                    )
                    if file_path:
                        try:
                            with open(file_path, 'w', encoding='utf-8') as file:
                                content = text_area.get(1.0, tk.END)
                                file.write(content)
                                editor_window.title(f"Text Editor - {file_path}")
                                messagebox.showinfo("Success", "File saved successfully!")
                        except Exception as e:
                            messagebox.showerror("Error", f"Could not save file: {str(e)}")
                
                # Adaugă opțiunile în meniu
                file_menu.add_command(label="Open", command=open_file)
                file_menu.add_command(label="Save", command=save_file)
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window("Text Editor", editor_window))
                
                self.add_window_to_taskbar("Text Editor", editor_window)
                editor_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Text Editor", editor_window))
            
            def create_calculator(self):
                calc_window = tk.Toplevel(self.rootW95dist)
                calc_window.title("Scientific Calculator")
                calc_window.overrideredirect(True)
                calc_window.geometry("350x400+300+150")
                calc_window.configure(bg="#c0c0c0")
                calc_window.resizable(False, False)
                
                # Import math for scientific functions
                import math
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(calc_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Scientific Calculator", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Scientific Calculator", calc_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(calc_window, title_bar)
                
                # Display
                display_var = tk.StringVar()
                display_var.set("0")
                
                display = tk.Entry(calc_window, textvariable=display_var, font=("Arial", 16),
                                  justify="right", bd=2, relief="sunken", bg="white")
                display.pack(fill="x", padx=10, pady=10)
                
                # Second display for equation
                equation_var = tk.StringVar()
                equation_var.set("")
                equation_display = tk.Entry(calc_window, textvariable=equation_var, font=("Arial", 10),
                                          justify="right", bd=2, relief="sunken", bg="#f0f0f0")
                equation_display.pack(fill="x", padx=10, pady=(0, 5))
                
                # Calculator logic
                calc_data = {
                    "current": "0",         # Current number being entered
                    "first_operand": None,  # First operand for binary operations
                    "operator": None,       # Current operator
                    "result": None,         # Result of calculation
                    "clear_on_next": False, # Should clear display on next digit press
                    "memory": 0,            # Memory storage
                    "equation": "",         # Current equation
                    "degree_mode": True     # True for degrees, False for radians
                }
                
                # Button frames
                button_master_frame = tk.Frame(calc_window, bg="#c0c0c0")
                button_master_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Memory and function frame
                memory_frame = tk.Frame(button_master_frame, bg="#c0c0c0")
                memory_frame.pack(fill="x", pady=(0, 5))
                
                # Mode switch
                mode_var = tk.StringVar(value="DEG")
                
                def toggle_mode():
                    calc_data["degree_mode"] = not calc_data["degree_mode"]
                    mode_var.set("DEG" if calc_data["degree_mode"] else "RAD")
                
                mode_button = tk.Button(memory_frame, textvariable=mode_var, font=("Arial", 8),
                                      width=4, height=1, bg="#e0e0e0", relief="raised", bd=2,
                                      command=toggle_mode)
                mode_button.pack(side="left", padx=2, pady=2)
                
                # Memory functions
                def memory_clear():
                    calc_data["memory"] = 0
                    status_update("Memory cleared")
                
                def memory_recall():
                    calc_data["current"] = str(calc_data["memory"])
                    display_var.set(calc_data["current"])
                    calc_data["clear_on_next"] = True
                    status_update("Memory recalled")
                
                def memory_store():
                    try:
                        calc_data["memory"] = float(calc_data["current"])
                        status_update("Value stored in memory")
                    except ValueError:
                        status_update("Error: Cannot store value")
                
                def memory_add():
                    try:
                        calc_data["memory"] += float(calc_data["current"])
                        status_update("Value added to memory")
                    except ValueError:
                        status_update("Error: Cannot add to memory")
                
                def memory_subtract():
                    try:
                        calc_data["memory"] -= float(calc_data["current"])
                        status_update("Value subtracted from memory")
                    except ValueError:
                        status_update("Error: Cannot subtract from memory")
                
                # Memory buttons
                memory_buttons = [
                    ("MC", memory_clear),
                    ("MR", memory_recall),
                    ("MS", memory_store),
                    ("M+", memory_add),
                    ("M-", memory_subtract)
                ]
                
                for text, cmd in memory_buttons:
                    btn = tk.Button(memory_frame, text=text, font=("Arial", 8),
                                  width=4, height=1, bg="#e0e0e0", relief="raised", bd=2,
                                  command=cmd)
                    btn.pack(side="left", padx=2, pady=2)
                
                # Function and number buttons frame
                buttons_frame = tk.Frame(button_master_frame, bg="#c0c0c0")
                buttons_frame.pack(fill="both", expand=True)
                
                # Scientific functions frame (top rows)
                scientific_frame = tk.Frame(buttons_frame, bg="#c0c0c0")
                scientific_frame.pack(fill="x")
                
                # Function to display status briefly
                def status_update(message):
                    equation_var.set(message)
                    calc_window.after(1500, lambda: equation_var.set(calc_data["equation"]))
                
                # Scientific functions
                def scientific_function(func_name):
                    try:
                        current_val = float(calc_data["current"])
                        result = 0
                        
                        if func_name == "sin":
                            if calc_data["degree_mode"]:
                                result = math.sin(math.radians(current_val))
                            else:
                                result = math.sin(current_val)
                        elif func_name == "cos":
                            if calc_data["degree_mode"]:
                                result = math.cos(math.radians(current_val))
                            else:
                                result = math.cos(current_val)
                        elif func_name == "tan":
                            if calc_data["degree_mode"]:
                                result = math.tan(math.radians(current_val))
                            else:
                                result = math.tan(current_val)
                        elif func_name == "log":
                            result = math.log10(current_val)
                        elif func_name == "ln":
                            result = math.log(current_val)
                        elif func_name == "square":
                            result = current_val ** 2
                        elif func_name == "cube":
                            result = current_val ** 3
                        elif func_name == "10^x":
                            result = 10 ** current_val
                        elif func_name == "e^x":
                            result = math.exp(current_val)
                        elif func_name == "1/x":
                            if current_val == 0:
                                raise ValueError("Division by zero")
                            result = 1 / current_val
                        elif func_name == "sqrt":
                            if current_val < 0:
                                raise ValueError("Cannot take square root of negative number")
                            result = math.sqrt(current_val)
                        elif func_name == "cbrt":
                            result = current_val ** (1/3)
                        elif func_name == "fact":
                            if current_val < 0 or not current_val.is_integer():
                                raise ValueError("Factorial undefined for negative or non-integer")
                            result = math.factorial(int(current_val))
                        
                        # Format result to avoid scientific notation for reasonable values
                        if abs(result) < 1e10 and abs(result) > 1e-10 or result == 0:
                            # Round to avoid floating point issues but keep precision
                            result = round(result, 10)
                            # Remove trailing zeros for integers
                            if result == int(result):
                                result = int(result)
                        
                        calc_data["current"] = str(result)
                        display_var.set(calc_data["current"])
                        
                        # Update equation
                        func_display_names = {
                            "sin": "sin", "cos": "cos", "tan": "tan",
                            "log": "log", "ln": "ln", "square": "²",
                            "cube": "³", "10^x": "10^", "e^x": "e^",
                            "1/x": "1/", "sqrt": "√", "cbrt": "∛",
                            "fact": "!"
                        }
                        
                        display_func = func_display_names.get(func_name, func_name)
                        if func_name in ["square", "cube", "fact"]:
                            calc_data["equation"] = f"({current_val}){display_func} = {result}"
                        else:
                            calc_data["equation"] = f"{display_func}({current_val}) = {result}"
                            
                        equation_var.set(calc_data["equation"])
                        calc_data["clear_on_next"] = True
                        
                    except (ValueError, OverflowError, ZeroDivisionError) as e:
                        display_var.set("Error")
                        equation_var.set(str(e))
                        calc_data["current"] = "0"
                        calc_data["clear_on_next"] = True
                
                # Constants
                def constant(const_name):
                    if const_name == "pi":
                        calc_data["current"] = str(math.pi)
                        display_var.set(calc_data["current"])
                        calc_data["equation"] = f"π = {math.pi}"
                        equation_var.set(calc_data["equation"])
                        calc_data["clear_on_next"] = True
                
                # Scientific function buttons
                scientific_buttons = [
                    ("sin", lambda: scientific_function("sin")),
                    ("cos", lambda: scientific_function("cos")),
                    ("tan", lambda: scientific_function("tan")),
                    ("log", lambda: scientific_function("log")),
                    ("ln", lambda: scientific_function("ln")),
                    
                    ("x²", lambda: scientific_function("square")),
                    ("x³", lambda: scientific_function("cube")),
                    ("xʸ", lambda: button_click("^")),
                    ("10ˣ", lambda: scientific_function("10^x")),
                    ("eˣ", lambda: scientific_function("e^x")),
                    
                    ("1/x", lambda: scientific_function("1/x")),
                    ("√x", lambda: scientific_function("sqrt")),
                    ("∛x", lambda: scientific_function("cbrt")),
                    ("n!", lambda: scientific_function("fact")),
                    ("π", lambda: constant("pi"))
                ]
                
                # Create scientific buttons in a 3x5 grid
                for i, (text, cmd) in enumerate(scientific_buttons):
                    row = i // 5
                    col = i % 5
                    btn = tk.Button(scientific_frame, text=text, font=("Arial", 9),
                                  width=5, height=1, bg="#d0d0d0", relief="raised", bd=2,
                                  command=cmd)
                    btn.grid(row=row, column=col, padx=2, pady=2, sticky="nsew")
                
                # Main calculator buttons frame
                calc_frame = tk.Frame(buttons_frame, bg="#c0c0c0")
                calc_frame.pack(fill="both", expand=True, pady=(5, 0))
                
                # Basic button handler
                def button_click(value):
                    if calc_data["clear_on_next"] and value in "0123456789.":
                        calc_data["current"] = "0"
                        calc_data["clear_on_next"] = False
                        
                    if value.isdigit() or value == '.':
                        if calc_data["current"] == "0" and value != '.':
                            calc_data["current"] = value
                        else:
                            # Check if already has decimal point
                            if value == '.' and '.' in calc_data["current"]:
                                return
                            calc_data["current"] += value
                    elif value in ['+', '-', '*', '/', '^', '%']:
                        # Store the current number and operator
                        calc_data["first_operand"] = float(calc_data["current"])
                        calc_data["operator"] = value
                        calc_data["equation"] = f"{calc_data['first_operand']} {value} "
                        equation_var.set(calc_data["equation"])
                        calc_data["current"] = "0"
                    elif value in ['(', ')']:
                        # Implement parentheses logic here (simplified for now)
                        calc_data["current"] += value
                        
                    display_var.set(calc_data["current"])
                
                # Change sign of current number
                def negate_number():
                    try:
                        calc_data["current"] = str(-float(calc_data["current"]))
                        # Format for display (handle negative zero)
                        if calc_data["current"] == "-0.0":
                            calc_data["current"] = "0"
                        display_var.set(calc_data["current"])
                    except ValueError:
                        display_var.set("Error")
                        calc_data["current"] = "0"
                
                # Clear all data
                def clear_all():
                    calc_data["current"] = "0"
                    calc_data["first_operand"] = None
                    calc_data["operator"] = None
                    calc_data["result"] = None
                    calc_data["equation"] = ""
                    calc_data["clear_on_next"] = False
                    display_var.set(calc_data["current"])
                    equation_var.set(calc_data["equation"])
                
                # Perform calculation
                def calculate():
                    try:
                        if calc_data["operator"] and calc_data["first_operand"] is not None:
                            second_operand = float(calc_data["current"])
                            
                            if calc_data["operator"] == "+":
                                result = calc_data["first_operand"] + second_operand
                            elif calc_data["operator"] == "-":
                                result = calc_data["first_operand"] - second_operand
                            elif calc_data["operator"] == "*":
                                result = calc_data["first_operand"] * second_operand
                            elif calc_data["operator"] == "/":
                                if second_operand == 0:
                                    raise ZeroDivisionError("Division by zero")
                                result = calc_data["first_operand"] / second_operand
                            elif calc_data["operator"] == "^":
                                result = calc_data["first_operand"] ** second_operand
                            elif calc_data["operator"] == "%":
                                result = calc_data["first_operand"] % second_operand
                            
                            # Format result to avoid scientific notation for reasonable values
                            if abs(result) < 1e10 and abs(result) > 1e-10 or result == 0:
                                # Round to avoid floating point issues but keep precision
                                result = round(result, 10)
                                # Remove trailing zeros for integers
                                if result == int(result):
                                    result = int(result)
                            
                            calc_data["equation"] = f"{calc_data['first_operand']} {calc_data['operator']} {second_operand} = {result}"
                            equation_var.set(calc_data["equation"])
                            
                            calc_data["current"] = str(result)
                            calc_data["first_operand"] = None
                            calc_data["operator"] = None
                            calc_data["result"] = result
                            calc_data["clear_on_next"] = True
                            
                            display_var.set(calc_data["current"])
                    except Exception as e:
                        display_var.set("Error")
                        equation_var.set(str(e))
                        calc_data["current"] = "0"
                        calc_data["clear_on_next"] = True
                
                # Main calculator buttons layout
                button_layout = [
                    ('(', ')', '%', 'C'),
                    ('7', '8', '9', '/'),
                    ('4', '5', '6', '*'),
                    ('1', '2', '3', '-'),
                    ('0', '.', '+/-', '+')
                ]
                
                # Create main calculator buttons
                for i, row in enumerate(button_layout):
                    for j, text in enumerate(row):
                        # Determine button color based on type
                        if text in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.']:
                            bg_color = "#f0f0f0"  # Lighter color for digits
                        elif text in ['C', '+/-']:
                            bg_color = "#ff9999"  # Red for special operations
                        else:
                            bg_color = "#e0e0e0"  # Standard for operators
                            
                        # Determine command based on button text
                        if text.isdigit() or text in ['.', '(', ')', '+', '-', '*', '/', '%']:
                            cmd = lambda t=text: button_click(t)
                        elif text == 'C':
                            cmd = clear_all
                        elif text == '+/-':
                            cmd = negate_number
                        else:
                            cmd = lambda: None  # Fallback
                            
                        btn = tk.Button(calc_frame, text=text, font=("Arial", 12, "bold"),
                                      bg=bg_color, relief="raised", bd=2,
                                      command=cmd)
                        btn.grid(row=i, column=j, padx=2, pady=2, sticky="nsew")
                
                # Equal button (spans 2 columns)
                btn = tk.Button(calc_frame, text="=", font=("Arial", 12, "bold"),
                              bg="#66ccff", relief="raised", bd=2,
                              command=calculate)
                btn.grid(row=4, column=2, columnspan=2, padx=2, pady=2, sticky="nsew")
                
                # Configure grid weights
                for i in range(5):
                    calc_frame.grid_rowconfigure(i, weight=1)
                for j in range(4):
                    calc_frame.grid_columnconfigure(j, weight=1)
                
                self.add_window_to_taskbar("Scientific Calculator", calc_window)
                calc_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Scientific Calculator", calc_window))
            
            def create_network_monitor(self):
                net_window = tk.Toplevel(self.rootW95dist)
                net_window.title("Network Monitor")
                net_window.overrideredirect(True)
                net_window.geometry("700x600+350+50")
                net_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(net_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Network Monitor", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Network Monitor", net_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                # Header frame
                header_frame = tk.Frame(net_window, bg="#c0c0c0", relief="raised", bd=2)
                header_frame.pack(fill="x", padx=5, pady=5)
                
                tk.Label(header_frame, text="Advanced Network Monitor", font=("MS Sans Serif", 10, "bold"),
                        bg="#c0c0c0").pack(pady=5)
                
                # Tabs using notebook
                notebook = ttk.Notebook(net_window)
                notebook.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Create a custom style for Windows 95 look
                style = ttk.Style()
                style.configure("W95.TNotebook", background="#c0c0c0", borderwidth=2, relief="raised")
                style.configure("W95.TNotebook.Tab", padding=[5, 2], font=("MS Sans Serif", 8))
                notebook.configure(style="W95.TNotebook")
                
                # Tab 1: Network Stats
                stats_frame = ttk.Frame(notebook)
                notebook.add(stats_frame, text="Network Stats")
                
                # Stats display
                stats_text = tk.Text(stats_frame, font=("Courier New", 9), bg="white", 
                                    fg="black", relief="sunken", bd=2)
                stats_scrollbar = tk.Scrollbar(stats_frame, command=stats_text.yview)
                stats_text.config(yscrollcommand=stats_scrollbar.set)
                
                stats_text.pack(side="left", fill="both", expand=True)
                stats_text.config(state="disabled")
                stats_scrollbar.pack(side="right", fill="y")
                
                # Tab 2: Active Connections
                conn_frame = ttk.Frame(notebook)
                notebook.add(conn_frame, text="Connections")
                
                # Connections display
                conn_text = tk.Text(conn_frame, font=("Courier New", 9), bg="white",
                                   fg="black", relief="sunken", bd=2)
                conn_scrollbar = tk.Scrollbar(conn_frame, command=conn_text.yview)
                conn_text.config(yscrollcommand=conn_scrollbar.set)
                
                conn_text.pack(side="left", fill="both", expand=True)
                conn_text.config(state="disabled")
                conn_scrollbar.pack(side="right", fill="y")
                
                # Tab 3: Network Traffic Graph (Text-based)
                traffic_frame = ttk.Frame(notebook)
                notebook.add(traffic_frame, text="Traffic Graph")
                
                traffic_text = tk.Text(traffic_frame, font=("Courier New", 8), bg="black",
                                      fg="#00ff00", relief="sunken", bd=2)
                traffic_scrollbar = tk.Scrollbar(traffic_frame, command=traffic_text.yview)
                traffic_text.config(yscrollcommand=traffic_scrollbar.set)
                
                traffic_text.pack(side="left", fill="both", expand=True)
                traffic_text.config(state="disabled")
                traffic_scrollbar.pack(side="right", fill="y")
                
                # Tab 4: Port Scanner
                scanner_frame = ttk.Frame(notebook)
                notebook.add(scanner_frame, text="Port Scanner")
                
                # Scanner controls
                scanner_control_frame = tk.Frame(scanner_frame, bg="#f0f0f0", relief="raised", bd=2)
                scanner_control_frame.pack(fill="x", padx=5, pady=5)
                
                tk.Label(scanner_control_frame, text="Target IP:", bg="#f0f0f0").pack(side="left", padx=2)
                ip_entry = tk.Entry(scanner_control_frame, width=15, relief="sunken", bd=2)
                ip_entry.pack(side="left", padx=2)
                ip_entry.insert(0, "127.0.0.1")
                
                tk.Label(scanner_control_frame, text="Port Range:", bg="#f0f0f0").pack(side="left", padx=(10,0))
                port_start_entry = tk.Entry(scanner_control_frame, width=8, relief="sunken", bd=2)
                port_start_entry.pack(side="left", padx=2)
                port_start_entry.insert(0, "1")
                
                tk.Label(scanner_control_frame, text="-", bg="#f0f0f0").pack(side="left")
                port_end_entry = tk.Entry(scanner_control_frame, width=8, relief="sunken", bd=2)
                port_end_entry.pack(side="left", padx=2)
                port_end_entry.insert(0, "1000")
                
                scan_btn = tk.Button(scanner_control_frame, text="Scan", 
                                    font=("MS Sans Serif", 8),
                                    bg="#c0c0c0", relief="raised", bd=2,
                                    command=lambda: self.start_port_scan(ip_entry.get(), 
                                                                       int(port_start_entry.get()), 
                                                                       int(port_end_entry.get()), 
                                                                       scanner_text))
                scan_btn.pack(side="left", padx=10)
                
                # Scanner results
                scanner_text = tk.Text(scanner_frame, font=("Courier New", 9), bg="white",
                                      fg="black", relief="sunken", bd=2)
                scanner_text_scrollbar = tk.Scrollbar(scanner_frame, command=scanner_text.yview)
                scanner_text.config(yscrollcommand=scanner_text_scrollbar.set)
                
                scanner_text.pack(side="left", fill="both", expand=True, padx=5)
                scanner_text.config(state="disabled")
                scanner_text_scrollbar.pack(side="right", fill="y")
                
                # Tab 5: Bandwidth Monitor
                bandwidth_frame = ttk.Frame(notebook)
                notebook.add(bandwidth_frame, text="Bandwidth")
                
                bandwidth_text = tk.Text(bandwidth_frame, font=("Courier New", 9), bg="white",
                                        fg="black", relief="sunken", bd=2)
                bandwidth_scrollbar = tk.Scrollbar(bandwidth_frame, command=bandwidth_text.yview)
                bandwidth_text.config(yscrollcommand=bandwidth_scrollbar.set)
                
                bandwidth_text.pack(side="left", fill="both", expand=True)
                bandwidth_text.config(state="disabled")
                bandwidth_scrollbar.pack(side="right", fill="y")
                
                # Buttons frame with Windows 95 style
                buttons_frame = tk.Frame(net_window, bg="#c0c0c0")
                buttons_frame.pack(fill="x", padx=5, pady=5)
                
                refresh_btn = tk.Button(buttons_frame, text="Refresh", font=("MS Sans Serif", 8),
                                       bg="#c0c0c0", relief="raised", bd=2,
                                       command=lambda: self.update_network_info(stats_text, conn_text, 
                                                                               traffic_text, bandwidth_text))
                refresh_btn.pack(side="left", padx=5)
                
                monitor_btn = tk.Button(buttons_frame, text="Start Monitoring", font=("MS Sans Serif", 8),
                                       bg="#c0c0c0", relief="raised", bd=2,
                                       command=lambda: self.toggle_network_monitoring(monitor_btn, traffic_text))
                monitor_btn.pack(side="left", padx=5)
                
                export_btn = tk.Button(buttons_frame, text="Export Data", font=("MS Sans Serif", 8),
                                      bg="#c0c0c0", relief="raised", bd=2,
                                      command=self.export_network_data)
                export_btn.pack(side="left", padx=5)
                
                help_btn = tk.Button(buttons_frame, text="Help", font=("MS Sans Serif", 8),
                                    bg="#c0c0c0", relief="raised", bd=2,
                                    command=lambda: self.show_help("Network Monitor"))
                help_btn.pack(side="right", padx=5)
                
                # Initial load
                self.update_network_info(stats_text, conn_text, traffic_text, bandwidth_text)
                
                # Simulate real network data initially
                self.simulate_network_data(traffic_text)
                
                self.add_window_to_taskbar("Network Monitor", net_window)
                net_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Network Monitor", net_window))
                
                self.make_window_draggable(net_window, title_bar)
            
            def simulate_network_data(self, traffic_text):
                """Simulate some initial network traffic data for better UI appearance"""
                timestamp = datetime.now() - timedelta(seconds=10)
                
                # Add some simulated data to history
                for i in range(10):
                    timestamp += timedelta(seconds=1)
                    ts_str = timestamp.strftime("%H:%M:%S")
                    
                    # Generate some random data for demo purposes
                    bytes_sent = random.randint(1024, 10240)
                    bytes_recv = random.randint(2048, 20480)
                    
                    self.network_history.append({
                        'time': ts_str,
                        'bytes_sent': i * bytes_sent,
                        'bytes_recv': i * bytes_recv,
                        'packets_sent': i * 10,
                        'packets_recv': i * 20
                    })
                    
                    if i > 0:
                        prev = self.network_history[i-1]
                        curr = self.network_history[i]
                        
                        bytes_sent_rate = curr['bytes_sent'] - prev['bytes_sent']
                        bytes_recv_rate = curr['bytes_recv'] - prev['bytes_recv']
                        
                        # Create simple ASCII graph
                        max_rate = max(bytes_sent_rate, bytes_recv_rate, 1024)
                        sent_bar = "█" * int((bytes_sent_rate / max_rate) * 40)
                        recv_bar = "█" * int((bytes_recv_rate / max_rate) * 40)
                        
                        display_text = f"{ts_str} | UP: {sent_bar:<40} {bytes_sent_rate:>8} B/s\n"
                        display_text += f"        | DN: {recv_bar:<40} {bytes_recv_rate:>8} B/s\n"
                        
                        traffic_text.config(state="normal")
                        traffic_text.insert(tk.END, display_text)
                        
                traffic_text.config(state="disabled")
            
            def start_port_scan(self, target_ip, start_port, end_port, result_text):
                result_text.config(state="normal")
                result_text.delete(1.0, tk.END)
                result_text.insert(1.0, f"Starting port scan on {target_ip}...\n")
                result_text.insert(tk.END, f"Scanning ports {start_port}-{end_port}\n")
                result_text.insert(tk.END, "=" * 50 + "\n")
                
                def scan_ports():
                    open_ports = []
                    for port in range(start_port, min(end_port + 1, start_port + 100)):  # Limit scan range
                        try:
                            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            sock.settimeout(0.1)
                            result = sock.connect_ex((target_ip, port))
                            if result == 0:
                                open_ports.append(port)
                                result_text.insert(tk.END, f"Port {port}: OPEN\n")
                                result_text.see(tk.END)
                                result_text.update()
                            sock.close()
                        except:
                            pass
                    
                    result_text.insert(tk.END, f"\nScan completed. Found {len(open_ports)} open ports.\n")
                    if open_ports:
                        result_text.insert(tk.END, f"Open ports: {', '.join(map(str, open_ports))}\n")
                
                # Run scan in thread to prevent UI freezing
                scan_thread = threading.Thread(target=scan_ports, daemon=True)
                result_text.config(state="disabled")
                scan_thread.start()
            
            def toggle_network_monitoring(self, button, traffic_text):
                if not self.monitoring_active:
                    self.monitoring_active = True
                    button.config(text="Stop Monitoring")
                    self.start_network_monitoring(traffic_text)
                else:
                    self.monitoring_active = False
                    button.config(text="Start Monitoring")
            
            def start_network_monitoring(self, traffic_text):
                def monitor():
                    while self.monitoring_active:
                        try:
                            net_io = psutil.net_io_counters()
                            timestamp = datetime.now().strftime("%H:%M:%S")
                            
                            # Store data for history
                            self.network_history.append({
                                'time': timestamp,
                                'bytes_sent': net_io.bytes_sent,
                                'bytes_recv': net_io.bytes_recv,
                                'packets_sent': net_io.packets_sent,
                                'packets_recv': net_io.packets_recv
                            })
                            
                            # Keep only last 100 entries
                            if len(self.network_history) > 100:
                                self.network_history.pop(0)
                            
                            # Update text display
                            if len(self.network_history) >= 2:
                                prev = self.network_history[-2]
                                curr = self.network_history[-1]
                                
                                bytes_sent_rate = curr['bytes_sent'] - prev['bytes_sent']
                                bytes_recv_rate = curr['bytes_recv'] - prev['bytes_recv']
                                
                                # Create simple ASCII graph
                                max_rate = max(bytes_sent_rate, bytes_recv_rate, 1024)
                                sent_bar = "█" * int((bytes_sent_rate / max_rate) * 40)
                                recv_bar = "█" * int((bytes_recv_rate / max_rate) * 40)
                                
                                display_text = f"{timestamp} | UP: {sent_bar:<40} {bytes_sent_rate:>8} B/s\n"
                                display_text += f"        | DN: {recv_bar:<40} {bytes_recv_rate:>8} B/s\n"
                                
                                traffic_text.config(state="normal")
                                traffic_text.insert(tk.END, display_text)
                                traffic_text.see(tk.END)
                                traffic_text.config(state="disabled")
                                
                                # Keep only last 50 lines
                                lines = traffic_text.get(1.0, tk.END).split('\n')
                                if len(lines) > 100:
                                    traffic_text.delete(1.0, f"{len(lines)-100}.0")
                            
                            time.sleep(1)
                        except Exception as e:
                            traffic_text.config(state="normal")
                            traffic_text.insert(tk.END, f"Monitoring error: {str(e)}\n")
                            break
                
                monitor_thread = threading.Thread(target=monitor, daemon=True)
                monitor_thread.start()
            
            def export_network_data(self):
                if not self.network_history:
                    messagebox.showinfo("Export", "No network data to export.")
                    return
                
                filename = filedialog.asksaveasfilename(
                    defaultextension=".json",
                    filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
                )
                if filename:
                    try:
                        with open(filename, 'w') as f:
                            json.dump(self.network_history, f, indent=2)
                        messagebox.showinfo("Export", f"Network data exported to {filename}")
                    except Exception as e:
                        messagebox.showerror("Export Error", f"Could not export data: {str(e)}")
            
            def update_network_info(self, stats_text, conn_text, traffic_text, bandwidth_text):
                try:
                    # Clear previous content
                    stats_text.config(state="normal")
                    conn_text.config(state="normal")
                    bandwidth_text.config(state="normal")
                    stats_text.delete(1.0, tk.END)
                    conn_text.delete(1.0, tk.END)
                    bandwidth_text.delete(1.0, tk.END)
                    
                    # Network statistics
                    net_io = psutil.net_io_counters()
                    addrs = psutil.net_if_addrs()
                    net_stats = psutil.net_if_stats()
                    
                    stats_info = "╔═══════════════════════════════════════╗\n"
                    stats_info += "║         NETWORK STATISTICS            ║\n"
                    stats_info += "╚═══════════════════════════════════════╝\n\n"
                    
                    stats_info += f" GLOBAL COUNTERS:\n"
                    stats_info += f"   Bytes Sent:     {net_io.bytes_sent:,} bytes ({net_io.bytes_sent/(1024**3):.2f} GB)\n"
                    stats_info += f"   Bytes Received: {net_io.bytes_recv:,} bytes ({net_io.bytes_recv/(1024**3):.2f} GB)\n"
                    stats_info += f"   Packets Sent:   {net_io.packets_sent:,}\n"
                    stats_info += f"   Packets Recv:   {net_io.packets_recv:,}\n"
                    stats_info += f"   Errors In:      {net_io.errin}\n"
                    stats_info += f"   Errors Out:     {net_io.errout}\n"
                    stats_info += f"   Drops In:       {net_io.dropin}\n"
                    stats_info += f"   Drops Out:      {net_io.dropout}\n\n"
                    
                    stats_info += " NETWORK INTERFACES:\n"
                    stats_info += "─" * 60 + "\n"
                    
                    for interface, addresses in addrs.items():
                        stats_info += f"\n {interface}:\n"
                        
                        # Interface statistics
                        if interface in net_stats:
                            stat = net_stats[interface]
                            stats_info += f"   Status: {'UP' if stat.isup else 'DOWN'}\n"
                            stats_info += f"   Speed: {stat.speed} Mbps\n" if stat.speed > 0 else "   Speed: Unknown\n"
                            stats_info += f"   MTU: {stat.mtu}\n"
                        
                        # Addresses
                        for addr in addresses:
                            if addr.family == socket.AF_INET:
                                stats_info += f"    IPv4: {addr.address}\n"
                                if addr.netmask:
                                    stats_info += f"      Netmask: {addr.netmask}\n"
                                if addr.broadcast:
                                    stats_info += f"      Broadcast: {addr.broadcast}\n"
                            elif addr.family == socket.AF_INET6:
                                stats_info += f"    IPv6: {addr.address}\n"
                            elif hasattr(addr, 'address') and len(addr.address) == 17:  # MAC address
                                stats_info += f"    MAC: {addr.address}\n"
                    
                    stats_text.insert(1.0, stats_info)
                    
                    # Active connections with more details
                    connections = psutil.net_connections()
                    conn_info = "╔═══════════════════════════════════════╗\n"
                    conn_info += "║        ACTIVE CONNECTIONS             ║\n"
                    conn_info += "╚═══════════════════════════════════════╝\n\n"
                    conn_info += f"Total Active Connections: {len(connections)}\n\n"
                    conn_info += f"{'Proto':<6} {'PID':<8} {'Local Address':<22} {'Remote Address':<22} {'Status':<12}\n"
                    conn_info += "─" * 80 + "\n"
                    
                    connection_stats = {"TCP": 0, "UDP": 0, "ESTABLISHED": 0, "LISTENING": 0}
                    
                    for conn in connections[:100]:  # Limit to first 100 connections
                        if conn.laddr:
                            local = f"{conn.laddr.ip}:{conn.laddr.port}"
                        else:
                            local = "N/A"
                        
                        if conn.raddr:
                            remote = f"{conn.raddr.ip}:{conn.raddr.port}"
                        else:
                            remote = "N/A"
                        
                        protocol = "TCP" if conn.type == socket.SOCK_STREAM else "UDP"
                        status = conn.status if conn.status else "N/A"
                        pid = str(conn.pid) if conn.pid else "N/A"
                        
                        # Update statistics
                        connection_stats[protocol] += 1
                        if status in connection_stats:
                            connection_stats[status] += 1
                        
                        conn_info += f"{protocol:<6} {pid:<8} {local:<22} {remote:<22} {status:<12}\n"
                    
                    # Add connection statistics
                    conn_info += "\n" + "─" * 80 + "\n"
                    conn_info += "CONNECTION STATISTICS:\n"
                    for key, value in connection_stats.items():
                        conn_info += f"   {key}: {value}\n"
                    
                    conn_text.insert(1.0, conn_info)
                    
                    # Bandwidth monitoring
                    bandwidth_info = "╔═══════════════════════════════════════╗\n"
                    bandwidth_info += "║        BANDWIDTH MONITORING           ║\n"
                    bandwidth_info += "╚═══════════════════════════════════════╝\n\n"
                    
                    # Per-interface statistics
                    net_io_counters = psutil.net_io_counters(pernic=True)
                    
                    bandwidth_info += f"{'Interface':<15} {'Bytes Sent':<15} {'Bytes Recv':<15} {'Packets Sent':<12} {'Packets Recv':<12}\n"
                    bandwidth_info += "─" * 80 + "\n"
                    
                    for interface, counters in net_io_counters.items():
                        bandwidth_info += f"{interface:<15} {counters.bytes_sent:<15,} {counters.bytes_recv:<15,} "
                        bandwidth_info += f"{counters.packets_sent:<12,} {counters.packets_recv:<12,}\n"
                    
                    # Network usage history (if available)
                    if self.network_history:
                        bandwidth_info += "\n RECENT NETWORK ACTIVITY (Last 10 samples):\n"
                        bandwidth_info += "─" * 60 + "\n"
                        bandwidth_info += f"{'Time':<10} {'Upload (B/s)':<15} {'Download (B/s)':<15}\n"
                        bandwidth_info += "─" * 60 + "\n"
                        
                        for i in range(max(0, len(self.network_history) - 10), len(self.network_history)):
                            if i > 0:
                                prev = self.network_history[i-1]
                                curr = self.network_history[i]
                                upload_rate = curr['bytes_sent'] - prev['bytes_sent']
                                download_rate = curr['bytes_recv'] - prev['bytes_recv']
                                bandwidth_info += f"{curr['time']:<10} {upload_rate:<15,} {download_rate:<15,}\n"
                    
                    bandwidth_text.insert(1.0, bandwidth_info)
                    stats_text.config(state="disabled")
                    conn_text.config(state="disabled")
                    bandwidth_text.config(state="disabled")
                    
                except Exception as e:
                    error_msg = f"Error getting network info: {str(e)}"
                    stats_text.insert(1.0, error_msg)
                    conn_text.insert(1.0, error_msg)
                    bandwidth_text.insert(1.0, error_msg)
            
            def show_help(self, title):
                help_window = tk.Toplevel(self.rootW95dist)
                help_window.title(f"{title} Help")
                help_window.overrideredirect(True)
                help_window.geometry("400x300+300+200")
                help_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(help_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text=f"{title} Help", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=help_window.destroy)
                close_button.pack(side="right", padx=2, pady=1)
                
                # Help content
                help_frame = tk.Frame(help_window, bg="#c0c0c0", bd=2, relief="sunken")
                help_frame.pack(fill="both", expand=True, padx=10, pady=10)
                
                help_text = tk.Text(help_frame, font=("MS Sans Serif", 9), bg="white", wrap="word")
                scrollbar = tk.Scrollbar(help_frame, command=help_text.yview)
                help_text.config(yscrollcommand=scrollbar.set)
                
                help_text.pack(side="left", fill="both", expand=True)
                scrollbar.pack(side="right", fill="y")
                
                self.make_window_draggable(help_window, title_bar)
                
                if title == "Network Monitor":
                    help_text.insert(tk.END, "NETWORK MONITOR HELP\n\n", "header")
                    help_text.insert(tk.END, "This application allows you to monitor network activity on your computer.\n\n")
                    help_text.insert(tk.END, "TABS:\n", "subheader")
                    help_text.insert(tk.END, "• Network Stats: Shows general network statistics and interface information.\n")
                    help_text.insert(tk.END, "• Connections: Displays active network connections.\n")
                    help_text.insert(tk.END, "• Traffic Graph: Shows real-time network traffic visualization.\n")
                    help_text.insert(tk.END, "• Port Scanner: Scans for open ports on a specified IP address.\n")
                    help_text.insert(tk.END, "• Bandwidth: Displays bandwidth usage by network interface.\n\n")
                    help_text.insert(tk.END, "BUTTONS:\n", "subheader")
                    help_text.insert(tk.END, "• Refresh: Updates all information.\n")
                    help_text.insert(tk.END, "• Start Monitoring: Begins real-time network traffic monitoring.\n")
                    help_text.insert(tk.END, "• Export Data: Saves network data to a file.\n")
                elif title == "Hardware Info":
                    help_text.insert(tk.END, "HARDWARE INFORMATION HELP\n\n", "header")
                    help_text.insert(tk.END, "This application displays detailed information about your computer hardware.\n\n")
                    help_text.insert(tk.END, "TABS:\n", "subheader")
                    help_text.insert(tk.END, "• System: General system information.\n")
                    help_text.insert(tk.END, "• CPU: CPU specifications and usage.\n")
                    help_text.insert(tk.END, "• Memory: RAM and swap memory information.\n")
                    help_text.insert(tk.END, "• Storage: Disk drives and storage usage.\n")
                    help_text.insert(tk.END, "• Processes: Currently running processes.\n")
                    help_text.insert(tk.END, "• Performance: Real-time system performance monitoring.\n\n")
                    help_text.insert(tk.END, "BUTTONS:\n", "subheader")
                    help_text.insert(tk.END, "• Refresh: Updates all hardware information.\n")
                    help_text.insert(tk.END, "• Start Performance Monitor: Begins real-time monitoring.\n")
                    help_text.insert(tk.END, "• Export Report: Saves hardware information to a file.\n")
                    help_text.insert(tk.END, "• CPU Benchmark: Runs a simple CPU performance test.\n")
                elif title == "Paint":
                    help_text.insert(tk.END, "PAINT HELP\n\n", "header")
                    help_text.insert(tk.END, "This is a simple drawing application.\n\n")
                    help_text.insert(tk.END, "TOOLS:\n", "subheader")
                    help_text.insert(tk.END, "• Pencil: Click and drag to draw thin lines.\n")
                    help_text.insert(tk.END, "• Brush: Click and drag to draw thicker lines.\n")
                    help_text.insert(tk.END, "• Eraser: Click and drag to erase parts of your drawing.\n")
                    help_text.insert(tk.END, "• Size: Adjust the brush size using the slider.\n")
                    help_text.insert(tk.END, "• Colors: Click on a color square to select that color.\n\n")
                    help_text.insert(tk.END, "MENU OPTIONS:\n", "subheader")
                    help_text.insert(tk.END, "• File > New: Creates a new drawing.\n")
                    help_text.insert(tk.END, "• File > Save: Saves your drawing.\n")
                    help_text.insert(tk.END, "• File > Exit: Closes Paint.\n")
                
                # Define text styles
                help_text.tag_configure("header", font=("MS Sans Serif", 12, "bold"))
                help_text.tag_configure("subheader", font=("MS Sans Serif", 10, "bold"))
                help_text.config(state="disabled")
                
                # Make text read-only
                help_text.config(state="disabled")
            
            def create_hardware_info(self):
                hw_window = tk.Toplevel(self.rootW95dist)
                hw_window.title("Hardware Info")
                hw_window.overrideredirect(True)
                hw_window.geometry("750x650+400+50")
                hw_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(hw_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Hardware Information", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Hardware Info", hw_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                # Header frame
                header_frame = tk.Frame(hw_window, bg="#c0c0c0", relief="raised", bd=2)
                header_frame.pack(fill="x", padx=5, pady=5)
                
                tk.Label(header_frame, text="Advanced System Hardware Information", 
                        font=("MS Sans Serif", 10, "bold"), bg="#c0c0c0").pack(pady=5)
                
                # Tabs using notebook
                notebook = ttk.Notebook(hw_window)
                notebook.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Create a custom style for Windows 95 look
                style = ttk.Style()
                style.configure("W95.TNotebook", background="#c0c0c0", borderwidth=2, relief="raised")
                style.configure("W95.TNotebook.Tab", padding=[5, 2], font=("MS Sans Serif", 8))
                notebook.configure(style="W95.TNotebook")
                
                # Tab 1: System Info
                system_frame = ttk.Frame(notebook)
                notebook.add(system_frame, text="System")
                
                system_text = tk.Text(system_frame, font=("Courier New", 9), bg="white",
                                     fg="black", relief="sunken", bd=2)
                system_scrollbar = tk.Scrollbar(system_frame, command=system_text.yview)
                system_text.config(yscrollcommand=system_scrollbar.set)
                
                system_text.pack(side="left", fill="both", expand=True)
                system_text.config(state="disabled")
                system_scrollbar.pack(side="right", fill="y")
                
                # Tab 2: CPU Info
                cpu_frame = ttk.Frame(notebook)
                notebook.add(cpu_frame, text="CPU")
                
                cpu_text = tk.Text(cpu_frame, font=("Courier New", 9), bg="white",
                                  fg="black", relief="sunken", bd=2)
                cpu_scrollbar = tk.Scrollbar(cpu_frame, command=cpu_text.yview)
                cpu_text.config(yscrollcommand=cpu_scrollbar.set)
                
                cpu_text.pack(side="left", fill="both", expand=True)
                cpu_text.config(state="disabled")
                cpu_scrollbar.pack(side="right", fill="y")
                
                # Tab 3: Memory Info
                memory_frame = ttk.Frame(notebook)
                notebook.add(memory_frame, text="Memory")
                
                memory_text = tk.Text(memory_frame, font=("Courier New", 9), bg="white",
                                     fg="black", relief="sunken", bd=2)
                memory_scrollbar = tk.Scrollbar(memory_frame, command=memory_text.yview)
                memory_text.config(yscrollcommand=memory_scrollbar.set)
                
                memory_text.pack(side="left", fill="both", expand=True)
                memory_text.config(state="disabled")
                memory_scrollbar.pack(side="right", fill="y")
                
                # Tab 4: Storage Info
                storage_frame = ttk.Frame(notebook)
                notebook.add(storage_frame, text="Storage")
                
                storage_text = tk.Text(storage_frame, font=("Courier New", 9), bg="white",
                                      fg="black", relief="sunken", bd=2)
                storage_scrollbar = tk.Scrollbar(storage_frame, command=storage_text.yview)
                storage_text.config(yscrollcommand=storage_scrollbar.set)
                
                storage_text.pack(side="left", fill="both", expand=True)
                storage_text.config(state="disabled")
                storage_scrollbar.pack(side="right", fill="y")
                
                # Tab 5: Process Monitor
                process_frame = ttk.Frame(notebook)
                notebook.add(process_frame, text="Processes")
                
                # Process controls
                process_control_frame = tk.Frame(process_frame, bg="#f0f0f0", relief="raised", bd=2)
                process_control_frame.pack(fill="x", padx=5, pady=5)
                
                tk.Label(process_control_frame, text="Sort by:", bg="#f0f0f0").pack(side="left", padx=2)
                sort_var = tk.StringVar(value="memory")
                sort_combo = ttk.Combobox(process_control_frame, textvariable=sort_var, 
                                         values=["memory", "cpu", "name", "pid"], width=10, state="readonly")
                sort_combo.pack(side="left", padx=5)
                
                sort_combo.bind("<<ComboboxSelected>>", lambda e: self.update_hardware_info(system_text, cpu_text, memory_text, storage_text, process_text, sort_var.get()))
                
                # kill_btn = tk.Button(process_control_frame, text="Kill Selected Process", 
                                    # bg="#ff6666", fg="black", font=("MS Sans Serif", 8),
                                    # relief="raised", bd=2)
                # kill_btn.pack(side="right", padx=5)
                
                process_text = tk.Text(process_frame, font=("Courier New", 9), bg="white",
                                      fg="black", relief="sunken", bd=2)
                process_scrollbar = tk.Scrollbar(process_frame, command=process_text.yview)
                process_text.config(yscrollcommand=process_scrollbar.set)
                
                process_text.pack(side="left", fill="both", expand=True, padx=5, pady=5)
                process_text.config(state="disabled")
                process_scrollbar.pack(side="right", fill="y")
                
                # Tab 6: Performance Monitor
                perf_frame = ttk.Frame(notebook)
                notebook.add(perf_frame, text="Performance")
                
                perf_text = tk.Text(perf_frame, font=("Courier New", 8), bg="black",
                                   fg="#00ff00", relief="sunken", bd=2)
                perf_scrollbar = tk.Scrollbar(perf_frame, command=perf_text.yview)
                perf_text.config(yscrollcommand=perf_scrollbar.set)
                
                perf_text.pack(side="left", fill="both", expand=True)
                perf_text.config(state="disabled")
                perf_scrollbar.pack(side="right", fill="y")
                
                # Buttons frame
                buttons_frame = tk.Frame(hw_window, bg="#c0c0c0")
                buttons_frame.pack(fill="x", padx=5, pady=5)
                
                refresh_btn = tk.Button(buttons_frame, text="Refresh", font=("MS Sans Serif", 8),
                                       bg="#c0c0c0", relief="raised", bd=2,
                                       command=lambda: self.update_hardware_info(system_text, cpu_text, memory_text, 
                                                                                storage_text, process_text, sort_var.get()))
                refresh_btn.pack(side="left", padx=5)
                
                monitor_btn = tk.Button(buttons_frame, text="Start Performance Monitor", font=("MS Sans Serif", 8),
                                       bg="#c0c0c0", relief="raised", bd=2,
                                       command=lambda: self.toggle_performance_monitoring(monitor_btn, perf_text))
                monitor_btn.pack(side="left", padx=5)
                
                export_btn = tk.Button(buttons_frame, text="Export Report", font=("MS Sans Serif", 8),
                                      bg="#c0c0c0", relief="raised", bd=2,
                                      command=self.export_hardware_report)
                export_btn.pack(side="left", padx=5)
                
                benchmark_btn = tk.Button(buttons_frame, text="CPU Benchmark", font=("MS Sans Serif", 8),
                                         bg="#c0c0c0", relief="raised", bd=2,
                                         command=lambda: self.run_cpu_benchmark(cpu_text))
                benchmark_btn.pack(side="left", padx=5)
                
                help_btn = tk.Button(buttons_frame, text="Help", font=("MS Sans Serif", 8),
                                    bg="#c0c0c0", relief="raised", bd=2,
                                    command=lambda: self.show_help("Hardware Info"))
                help_btn.pack(side="right", padx=5)
                
                # Initial load
                self.update_hardware_info(system_text, cpu_text, memory_text, storage_text, process_text, "memory")
                
                # Simulate performance data
                self.simulate_performance_data(perf_text)
                
                self.add_window_to_taskbar("Hardware Info", hw_window)
                hw_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Hardware Info", hw_window))
                
                self.make_window_draggable(hw_window, title_bar)
            
            def simulate_performance_data(self, perf_text):
                """Simulate some initial performance data for better UI appearance"""
                timestamp = datetime.now() - timedelta(seconds=10)
                
                perf_text.config(state="normal")
                perf_text.insert(tk.END, "Performance Monitor Initialized\n")
                perf_text.insert(tk.END, "=" * 60 + "\n")
                
                # Add some simulated data
                for i in range(10):
                    timestamp += timedelta(seconds=1)
                    ts_str = timestamp.strftime("%H:%M:%S")
                    
                    # Generate random performance data
                    cpu_percent = random.uniform(10, 60)
                    memory_percent = random.uniform(40, 80)
                    cpu_freq = random.uniform(2000, 3200)
                    disk_read = random.randint(50, 500) * 1024
                    disk_write = random.randint(20, 200) * 1024
                    net_sent = random.randint(10, 100) * 1024
                    net_recv = random.randint(50, 500) * 1024
                    
                    # Store in history
                    self.cpu_history.append({
                        'time': ts_str,
                        'cpu_percent': cpu_percent,
                        'cpu_freq': cpu_freq,
                        'memory_percent': memory_percent,
                        'memory_used': memory_percent * 8000000000 / 100,  # Simulate 8GB RAM
                        'disk_read': i * disk_read,
                        'disk_write': i * disk_write,
                        'net_sent': i * net_sent,
                        'net_recv': i * net_recv
                    })
                    
                    # Create ASCII graphs
                    cpu_bar = "█" * int(cpu_percent / 2.5)  # Scale to 40 chars max
                    memory_bar = "█" * int(memory_percent / 2.5)
                    
                    display_text = f"{ts_str} │ CPU: {cpu_bar:<40} {cpu_percent:>6.1f}%\n"
                    display_text += f"        │ MEM: {memory_bar:<40} {memory_percent:>6.1f}%\n"
                    display_text += f"        │ FREQ: {cpu_freq:>4.0f} MHz\n"
                    
                    if i > 0:
                        prev = self.cpu_history[i-1]
                        curr = self.cpu_history[i]
                        
                        disk_read_rate = curr['disk_read'] - prev['disk_read']
                        disk_write_rate = curr['disk_write'] - prev['disk_write']
                        display_text += f"        │ DISK: R:{disk_read_rate/1024:>6.0f}KB/s W:{disk_write_rate/1024:>6.0f}KB/s\n"
                        
                        net_sent_rate = curr['net_sent'] - prev['net_sent']
                        net_recv_rate = curr['net_recv'] - prev['net_recv']
                        display_text += f"        │ NET:  ↑{net_sent_rate/1024:>6.0f}KB/s ↓{net_recv_rate/1024:>6.0f}KB/s\n"
                    
                    display_text += "        │" + "─" * 50 + "\n"
                    
                    perf_text.insert(tk.END, display_text)
                    perf_text.config(state="disabled")
            
            def toggle_performance_monitoring(self, button, perf_text):
                if not self.monitoring_active:
                    self.monitoring_active = True
                    button.config(text="Stop Performance Monitor")
                    self.start_performance_monitoring(perf_text)
                else:
                    self.monitoring_active = False
                    button.config(text="Start Performance Monitor")
            
            def start_performance_monitoring(self, perf_text):
                def monitor():
                    perf_text.config(state="normal")
                    perf_text.insert(tk.END, "Performance Monitor Started\n")
                    perf_text.insert(tk.END, "=" * 60 + "\n")
                    
                    while self.monitoring_active:
                        try:
                            timestamp = datetime.now().strftime("%H:%M:%S")
                            
                            # CPU usage
                            cpu_percent = psutil.cpu_percent(interval=0.1)
                            cpu_freq = psutil.cpu_freq()
                            
                            # Memory usage
                            memory = psutil.virtual_memory()
                            
                            # Disk I/O
                            disk_io = psutil.disk_io_counters()
                            
                            # Network I/O
                            net_io = psutil.net_io_counters()
                            
                            # Store history
                            perf_data = {
                                'time': timestamp,
                                'cpu_percent': cpu_percent,
                                'cpu_freq': cpu_freq.current if cpu_freq else 0,
                                'memory_percent': memory.percent,
                                'memory_used': memory.used,
                                'disk_read': disk_io.read_bytes if disk_io else 0,
                                'disk_write': disk_io.write_bytes if disk_io else 0,
                                'net_sent': net_io.bytes_sent,
                                'net_recv': net_io.bytes_recv
                            }
                            
                            self.cpu_history.append(perf_data)
                            if len(self.cpu_history) > 100:
                                self.cpu_history.pop(0)
                            
                            # Create ASCII graphs
                            cpu_bar = "█" * int(cpu_percent / 2.5)  # Scale to 40 chars max
                            memory_bar = "█" * int(memory.percent / 2.5)
                            
                            display_text = f"{timestamp} │ CPU: {cpu_bar:<40} {cpu_percent:>6.1f}%\n"
                            display_text += f"        │ MEM: {memory_bar:<40} {memory.percent:>6.1f}%\n"
                            
                            if cpu_freq:
                                display_text += f"        │ FREQ: {cpu_freq.current:>4.0f} MHz\n"
                            
                            # Calculate rates if we have previous data
                            if len(self.cpu_history) >= 2:
                                prev = self.cpu_history[-2]
                                curr = self.cpu_history[-1]
                                if disk_io:
                                    disk_read_rate = curr['disk_read'] - prev['disk_read']
                                    disk_write_rate = curr['disk_write'] - prev['disk_write']
                                    display_text += f"        │ DISK: R:{disk_read_rate/1024:>6.0f}KB/s W:{disk_write_rate/1024:>6.0f}KB/s\n"
                                
                                net_sent_rate = curr['net_sent'] - prev['net_sent']
                                net_recv_rate = curr['net_recv'] - prev['net_recv']
                                display_text += f"        │ NET:  ↑{net_sent_rate/1024:>6.0f}KB/s ↓{net_recv_rate/1024:>6.0f}KB/s\n"
                            
                            display_text += "        │" + "─" * 50 + "\n"
                            
                            perf_text.insert(tk.END, display_text)
                            perf_text.see(tk.END)
                            perf_text.config(state="disabled")
                            
                            # Keep only last 200 lines
                            lines = perf_text.get(1.0, tk.END).split('\n')
                            if len(lines) > 200:
                                perf_text.delete(1.0, f"{len(lines)-200}.0")
                            
                            time.sleep(1)
                        except Exception as e:
                            perf_text.insert(tk.END, f"Monitor error: {str(e)}\n")
                            break
                
                monitor_thread = threading.Thread(target=monitor, daemon=True)
                monitor_thread.start()
                
            def run_cpu_benchmark(self, cpu_text):
                def benchmark():
                    cpu_text.config(state="normal")
                    cpu_text.insert(tk.END, "\n" + "="*50 + "\n")
                    cpu_text.insert(tk.END, " RUNNING CPU BENCHMARK...\n")
                    cpu_text.insert(tk.END, "="*50 + "\n")
                    cpu_text.see(tk.END)
                    cpu_text.update()
                    
                    # Simple CPU benchmark - calculate primes
                    start_time = time.time()
                    primes = []
                    
                    def is_prime(n):
                        if n < 2:
                            return False
                        for i in range(2, int(n**0.5) + 1):
                            if n % i == 0:
                                return False
                        return True
                    
                    # Find primes up to 10000
                    for i in range(2, 10000):
                        if is_prime(i):
                            primes.append(i)
                        if i % 1000 == 0:
                            cpu_text.insert(tk.END, f"Progress: {i/10000*100:.0f}%\n")
                            cpu_text.see(tk.END)
                            cpu_text.update()
                    
                    end_time = time.time()
                    duration = end_time - start_time
                    
                    cpu_text.insert(tk.END, f"\n BENCHMARK COMPLETED!\n")
                    cpu_text.insert(tk.END, f"Found {len(primes)} primes in {duration:.2f} seconds\n")
                    cpu_text.insert(tk.END, f"Performance Score: {10000/duration:.0f} ops/sec\n")
                    cpu_text.insert(tk.END, "="*50 + "\n")
                    cpu_text.see(tk.END)
                    cpu_text.config(state="disabled")
                
                benchmark_thread = threading.Thread(target=benchmark, daemon=True)
                benchmark_thread.start()
            
            def export_hardware_report(self):
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    initialfile=f"hardware_report_{timestamp}.txt",
                    filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
                )
                if filename:
                    try:
                        with open(filename, 'w') as f:
                            f.write("HARDWARE INFORMATION REPORT\n")
                            f.write("="*50 + "\n")
                            f.write(f"Generated: {datetime.now()}\n\n")
                            
                            # System info
                            uname = platform.uname()
                            f.write(f"System: {uname.system}\n")
                            f.write(f"Node: {uname.node}\n")
                            f.write(f"Release: {uname.release}\n")
                            f.write(f"Machine: {uname.machine}\n")
                            f.write(f"Processor: {uname.processor}\n\n")
                            
                            # CPU info
                            f.write("CPU INFORMATION:\n")
                            f.write(f"Physical cores: {psutil.cpu_count(logical=False)}\n")
                            f.write(f"Total cores: {psutil.cpu_count(logical=True)}\n")
                            f.write(f"Current usage: {psutil.cpu_percent()}%\n\n")
                            
                            # Memory info
                            memory = psutil.virtual_memory()
                            f.write("MEMORY INFORMATION:\n")
                            f.write(f"Total: {memory.total // (1024**3)} GB\n")
                            f.write(f"Available: {memory.available // (1024**3)} GB\n")
                            f.write(f"Used: {memory.used // (1024**3)} GB\n")
                            f.write(f"Percentage: {memory.percent}%\n\n")
                            
                            # Performance history
                            if self.cpu_history:
                                f.write("RECENT PERFORMANCE DATA:\n")
                                f.write("Time\t\tCPU%\tMemory%\n")
                                for entry in self.cpu_history[-20:]:  # Last 20 entries
                                    f.write(f"{entry['time']}\t{entry['cpu_percent']:.1f}\t{entry['memory_percent']:.1f}\n")
                        
                        messagebox.showinfo("Export", f"Hardware report exported to {filename}")
                    except Exception as e:
                        messagebox.showerror("Export Error", f"Could not export report: {str(e)}")
            
            def update_hardware_info(self, system_text, cpu_text, memory_text, storage_text, process_text, sort_by):
                try:
                    # Clear previous content
                    system_text.config(state="normal")
                    cpu_text.config(state="normal")
                    memory_text.config(state="normal")
                    storage_text.config(state="normal")
                    process_text.config(state="normal")
                    system_text.delete(1.0, tk.END)
                    cpu_text.delete(1.0, tk.END)
                    memory_text.delete(1.0, tk.END)
                    storage_text.delete(1.0, tk.END)
                    process_text.delete(1.0, tk.END)
                    
                    # System Information
                    uname = platform.uname()
                    boot_time = datetime.fromtimestamp(psutil.boot_time())
                    uptime = datetime.now() - boot_time
                    
                    system_info = "╔═══════════════════════════════════════╗\n"
                    system_info += "║        SYSTEM INFORMATION             ║\n"
                    system_info += "╚═══════════════════════════════════════╝\n\n"
                    
                    system_info += f"️  BASIC INFORMATION:\n"
                    system_info += f"   System:         {uname.system}\n"
                    system_info += f"   Node Name:      {uname.node}\n"
                    system_info += f"   Release:        {uname.release}\n"
                    system_info += f"   Version:        {uname.version}\n"
                    system_info += f"   Machine:        {uname.machine}\n"
                    system_info += f"   Processor:      {uname.processor}\n"
                    system_info += f"   Boot Time:      {boot_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                    system_info += f"   Uptime:         {str(uptime).split('.')[0]}\n\n"
                    
                    # Temperature (if available)
                    try:
                        temps = psutil.sensors_temperatures()
                        if temps:
                            system_info += f"️  TEMPERATURE SENSORS:\n"
                            for name, entries in temps.items():
                                system_info += f"   {name}:\n"
                                for entry in entries:
                                    system_info += f"      {entry.label or 'N/A'}: {entry.current}°C"
                                    if entry.high:
                                        system_info += f" (High: {entry.high}°C)"
                                    if entry.critical:
                                        system_info += f" (Critical: {entry.critical}°C)"
                                    system_info += "\n"
                            system_info += "\n"
                    except:
                        system_info += "️  Temperature sensors: Not available\n\n"
                    
                    # Battery info (if available)
                    try:
                        battery = psutil.sensors_battery()
                        if battery:
                            system_info += f" BATTERY INFORMATION:\n"
                            system_info += f"   Percentage: {battery.percent}%\n"
                            system_info += f"   Power plugged: {'Yes' if battery.power_plugged else 'No'}\n"
                            if not battery.power_plugged and battery.secsleft != psutil.POWER_TIME_UNLIMITED:
                                hours, remainder = divmod(battery.secsleft, 3600)
                                minutes, _ = divmod(remainder, 60)
                                system_info += f"   Time left: {hours}h {minutes}m\n"
                            system_info += "\n"
                    except:
                        pass
                    
                    system_text.insert(1.0, system_info)
                    
                    # Enhanced CPU Information
                    cpu_info = "╔═══════════════════════════════════════╗\n"
                    cpu_info += "║         CPU INFORMATION               ║\n"
                    cpu_info += "╚═══════════════════════════════════════╝\n\n"
                    
                    cpu_info += f"🔧 CPU SPECIFICATIONS:\n"
                    cpu_info += f"   Physical cores:   {psutil.cpu_count(logical=False)}\n"
                    cpu_info += f"   Total cores:      {psutil.cpu_count(logical=True)}\n"
                    
                    cpufreq = psutil.cpu_freq()
                    if cpufreq:
                        cpu_info += f"   Max Frequency:    {cpufreq.max:.2f} MHz\n"
                        cpu_info += f"   Min Frequency:    {cpufreq.min:.2f} MHz\n"
                        cpu_info += f"   Current Freq:     {cpufreq.current:.2f} MHz\n"
                    
                    # CPU usage statistics
                    cpu_times = psutil.cpu_times()
                    total_time = sum(cpu_times)
                    
                    cpu_info += f"\n️  CPU TIME DISTRIBUTION:\n"
                    cpu_info += f"   User time:        {cpu_times.user:.2f}s ({cpu_times.user/total_time*100:.1f}%)\n"
                    cpu_info += f"   System time:      {cpu_times.system:.2f}s ({cpu_times.system/total_time*100:.1f}%)\n"
                    cpu_info += f"   Idle time:        {cpu_times.idle:.2f}s ({cpu_times.idle/total_time*100:.1f}%)\n"
                    
                    if hasattr(cpu_times, 'iowait'):
                        cpu_info += f"   I/O wait time:    {cpu_times.iowait:.2f}s ({cpu_times.iowait/total_time*100:.1f}%)\n"
                    
                    cpu_info += f"\n CURRENT CPU USAGE:\n"
                    cpu_percentages = psutil.cpu_percent(percpu=True, interval=0.1)
                    
                    for i, percentage in enumerate(cpu_percentages):
                        bar = "█" * int(percentage / 5)  # Scale to 20 chars max
                        cpu_info += f"   Core {i:2d}: {bar:<20} {percentage:>5.1f}%\n"
                    
                    total_cpu = psutil.cpu_percent()
                    total_bar = "█" * int(total_cpu / 5)
                    cpu_info += f"   Total:  {total_bar:<20} {total_cpu:>5.1f}%\n"
                    
                    # Load averages (Unix-like systems)
                    try:
                        load_avg = psutil.getloadavg()
                        cpu_info += f"\n LOAD AVERAGES:\n"
                        cpu_info += f"   1 minute:  {load_avg[0]:.2f}\n"
                        cpu_info += f"   5 minutes: {load_avg[1]:.2f}\n"
                        cpu_info += f"   15 minutes: {load_avg[2]:.2f}\n"
                    except:
                        pass
                    
                    cpu_text.insert(1.0, cpu_info)
                    
                    # Enhanced Memory Information
                    svmem = psutil.virtual_memory()
                    swap = psutil.swap_memory()
                    
                    memory_info = "╔═══════════════════════════════════════╗\n"
                    memory_info += "║        MEMORY INFORMATION             ║\n"
                    memory_info += "╚═══════════════════════════════════════╝\n\n"
                    
                    memory_info += " VIRTUAL MEMORY:\n"
                    memory_info += f"   Total:      {svmem.total // (1024**3):>8} GB ({svmem.total:,} bytes)\n"
                    memory_info += f"   Available:  {svmem.available // (1024**3):>8} GB ({svmem.available:,} bytes)\n"
                    memory_info += f"   Used:       {svmem.used // (1024**3):>8} GB ({svmem.used:,} bytes)\n"
                    memory_info += f"   Free:       {svmem.free // (1024**3):>8} GB ({svmem.free:,} bytes)\n"
                    memory_info += f"   Percentage: {svmem.percent:>8.1f}%\n"
                    
                    # Memory usage bar
                    mem_bar = "█" * int(svmem.percent / 2.5)  # Scale to 40 chars max
                    memory_info += f"   Usage:      [{mem_bar:<40}] {svmem.percent:.1f}%\n\n"
                    
                    if hasattr(svmem, 'buffers') and hasattr(svmem, 'cached'):
                        memory_info += f"   Buffers:    {svmem.buffers // (1024**2):>8} MB\n"
                        memory_info += f"   Cached:     {svmem.cached // (1024**2):>8} MB\n\n"
                    
                    memory_info += " SWAP MEMORY:\n"
                    memory_info += f"   Total:      {swap.total // (1024**3):>8} GB ({swap.total:,} bytes)\n"
                    memory_info += f"   Free:       {swap.free // (1024**3):>8} GB ({swap.free:,} bytes)\n"
                    memory_info += f"   Used:       {swap.used // (1024**3):>8} GB ({swap.used:,} bytes)\n"
                    memory_info += f"   Percentage: {swap.percent:>8.1f}%\n"
                    
                    if swap.total > 0:
                        swap_bar = "█" * int(swap.percent / 2.5)
                        memory_info += f"   Usage:      [{swap_bar:<40}] {swap.percent:.1f}%\n"
                    
                    memory_info += "\n MEMORY INTENSIVE PROCESSES:\n"
                    memory_info += "─" * 65 + "\n"
                    memory_info += f"{'PID':<8} {'Name':<25} {'Memory %':<12} {'Memory (MB)':<15}\n"
                    memory_info += "─" * 65 + "\n"
                    
                    processes = []
                    for proc in psutil.process_iter(['pid', 'name', 'memory_percent', 'memory_info']):
                        try:
                            processes.append(proc.info)
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                    
                    # Sort by memory usage
                    processes = sorted(processes, key=lambda x: x['memory_percent'] if x['memory_percent'] else 0, reverse=True)
                    
                    for proc in processes[:15]:  # Top 15 processes
                        memory_mb = proc['memory_info'].rss // (1024*1024) if proc['memory_info'] else 0
                        memory_info += f"{proc['pid']:<8} {proc['name'][:24]:<25} {proc['memory_percent']:<12.2f} {memory_mb:<15}\n"
                    
                    memory_text.insert(1.0, memory_info)
                    
                    # Enhanced Storage Information
                    storage_info = "╔═══════════════════════════════════════╗\n"
                    storage_info += "║        STORAGE INFORMATION            ║\n"
                    storage_info += "╚═══════════════════════════════════════╝\n\n"
                    
                    partitions = psutil.disk_partitions()
                    
                    storage_info += " DISK PARTITIONS:\n"
                    storage_info += "─" * 80 + "\n"
                    
                    total_disk_space = 0
                    total_used_space = 0
                    
                    for partition in partitions:
                        try:
                            partition_usage = psutil.disk_usage(partition.mountpoint)
                            total_disk_space += partition_usage.total
                            total_used_space += partition_usage.used
                            
                            storage_info += f"\n Device: {partition.device}\n"
                            storage_info += f"   Mountpoint:   {partition.mountpoint}\n"
                            storage_info += f"   File system:  {partition.fstype}\n"
                            storage_info += f"   Total Size:   {partition_usage.total // (1024**3):>6} GB ({partition_usage.total:,} bytes)\n"
                            storage_info += f"   Used:         {partition_usage.used // (1024**3):>6} GB ({partition_usage.used:,} bytes)\n"
                            storage_info += f"   Free:         {partition_usage.free // (1024**3):>6} GB ({partition_usage.free:,} bytes)\n"
                            storage_info += f"   Usage:        {(partition_usage.used / partition_usage.total) * 100:>6.1f}%\n"
                            
                            # Usage bar
                            usage_percent = (partition_usage.used / partition_usage.total) * 100
                            usage_bar = "█" * int(usage_percent / 2.5)  # Scale to 40 chars max
                            storage_info += f"   Visual:       [{usage_bar:<40}] {usage_percent:.1f}%\n"
                            
                        except PermissionError:
                            storage_info += f"\n Device: {partition.device} - Access Denied\n"
                        except Exception as e:
                            storage_info += f"\n Device: {partition.device} - Error: {str(e)}\n"
                    
                    # Total storage summary
                    if total_disk_space > 0:
                        storage_info += "\n" + "─" * 50 + "\n"
                        storage_info += " TOTAL STORAGE SUMMARY:\n"
                        storage_info += f"   Total Capacity: {total_disk_space // (1024**3)} GB\n"
                        storage_info += f"   Total Used:     {total_used_space // (1024**3)} GB\n"
                        storage_info += f"   Total Free:     {(total_disk_space - total_used_space) // (1024**3)} GB\n"
                        storage_info += f"   Overall Usage:  {(total_used_space / total_disk_space) * 100:.1f}%\n"
                    
                    # Disk I/O Statistics
                    try:
                        disk_io = psutil.disk_io_counters()
                        if disk_io:
                            storage_info += "\n DISK I/O STATISTICS:\n"
                            storage_info += f"   Read Count:     {disk_io.read_count:,}\n"
                            storage_info += f"   Write Count:    {disk_io.write_count:,}\n"
                            storage_info += f"   Read Bytes:     {disk_io.read_bytes // (1024**2):,} MB\n"
                            storage_info += f"   Write Bytes:    {disk_io.write_bytes // (1024**2):,} MB\n"
                            storage_info += f"   Read Time:      {disk_io.read_time:,} ms\n"
                            storage_info += f"   Write Time:     {disk_io.write_time:,} ms\n"
                            
                            # Per-disk I/O if available
                            disk_io_per_disk = psutil.disk_io_counters(perdisk=True)
                            if disk_io_per_disk:
                                storage_info += "\n PER-DISK I/O STATISTICS:\n"
                                storage_info += f"{'Disk':<10} {'Read MB':<12} {'Write MB':<12} {'Read Count':<12} {'Write Count':<12}\n"
                                storage_info += "─" * 70 + "\n"
                                
                                for disk, io_stats in disk_io_per_disk.items():
                                    storage_info += f"{disk:<10} {io_stats.read_bytes//(1024**2):<12,} "
                                    storage_info += f"{io_stats.write_bytes//(1024**2):<12,} "
                                    storage_info += f"{io_stats.read_count:<12,} {io_stats.write_count:<12,}\n"
                    except:
                        storage_info += "\n Disk I/O statistics: Not available\n"
                    
                    storage_text.insert(1.0, storage_info)
                    
                    # Enhanced Process Information
                    process_info = "╔═══════════════════════════════════════╗\n"
                    process_info += "║        PROCESS INFORMATION            ║\n"
                    process_info += "╚═══════════════════════════════════════╝\n\n"
                    
                    processes = []
                    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 
                                                   'memory_info', 'create_time', 'status', 'username']):
                        try:
                            proc.info['memory_mb'] = proc.info['memory_info'].rss // (1024*1024) if proc.info['memory_info'] else 0
                            processes.append(proc.info)
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                    
                    # Sort processes
                    if sort_by == "memory":
                        processes = sorted(processes, key=lambda x: x['memory_percent'] if x['memory_percent'] else 0, reverse=True)
                    elif sort_by == "cpu":
                        processes = sorted(processes, key=lambda x: x['cpu_percent'] if x['cpu_percent'] else 0, reverse=True)
                    elif sort_by == "name":
                        processes = sorted(processes, key=lambda x: x['name'].lower() if x['name'] else '')
                    elif sort_by == "pid":
                        processes = sorted(processes, key=lambda x: x['pid'])
                    
                    process_info += f" PROCESS SUMMARY (Sorted by {sort_by.upper()}):\n"
                    process_info += f"Total Processes: {len(processes)}\n\n"
                    
                    # Process status summary
                    status_count = {}
                    for proc in processes:
                        status = proc['status']
                        status_count[status] = status_count.get(status, 0) + 1
                    
                    process_info += " PROCESS STATUS SUMMARY:\n"
                    for status, count in status_count.items():
                        process_info += f"   {status}: {count}\n"
                    
                    process_info += "\n" + "─" * 100 + "\n"
                    process_info += f"{'PID':<8} {'Name':<20} {'Status':<12} {'CPU%':<8} {'Mem%':<8} {'Mem(MB)':<10} {'User':<12} {'Runtime':<12}\n"
                    process_info += "─" * 100 + "\n"
                    
                    for proc in processes[:50]:  # Show top 50 processes
                        try:
                            # Calculate runtime
                            create_time = datetime.fromtimestamp(proc['create_time'])
                            runtime = datetime.now() - create_time
                            runtime_str = str(runtime).split('.')[0] if runtime.days == 0 else f"{runtime.days}d+"
                            
                            process_info += f"{proc['pid']:<8} {proc['name'][:19]:<20} {proc['status']:<12} "
                            process_info += f"{proc['cpu_percent']:<8.1f} {proc['memory_percent']:<8.2f} "
                            process_info += f"{proc['memory_mb']:<10} {(proc['username'] or 'N/A')[:11]:<12} {runtime_str:<12}\n"
                        except:
                            continue
                    
                    process_text.insert(1.0, process_info)
                    system_text.config(state="disabled")
                    cpu_text.config(state="disabled")
                    memory_text.config(state="disabled")
                    storage_text.config(state="disabled")
                    process_text.config(state="disabled")

                except Exception as e:
                    error_msg = f"Error getting hardware info: {str(e)}"
                    system_text.insert(1.0, error_msg)
                    cpu_text.insert(1.0, error_msg)
                    memory_text.insert(1.0, error_msg)
                    storage_text.insert(1.0, error_msg)
                    process_text.insert(1.0, error_msg)
                    
            def create_paint_app(self):
                paint_window = tk.Toplevel(self.rootW95dist)
                paint_window.title("Paint")
                paint_window.overrideredirect(True)
                paint_window.geometry("800x600+200+50")
                paint_window.configure(bg="#c0c0c0")
                        
                # Add Windows 95 style title bar
                title_bar = tk.Frame(paint_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Paint", fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window("Paint", paint_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(paint_window, title_bar)
                
                # Menu bar
                menu_bar = tk.Menu(paint_window)
                paint_window.config(menu=menu_bar)
                
                file_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="File", menu=file_menu)
                
                edit_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="Edit", menu=edit_menu)
                
                view_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="View", menu=view_menu)
                
                image_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="Image", menu=image_menu)
                
                colors_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="Colors", menu=colors_menu)
                
                help_menu = tk.Menu(menu_bar, tearoff=0)
                menu_bar.add_cascade(label="Help", menu=help_menu)
                help_menu.add_command(label="Help Topics", command=lambda: self.show_help("Paint"))
                help_menu.add_separator()
                help_menu.add_command(label="About Paint", command=lambda: messagebox.showinfo("About Paint", "\nVersion 1.0\n\nA retro-style paint application."))
                
                # Toolbar frame
                toolbar_frame = tk.Frame(paint_window, bg="#c0c0c0", relief="raised", bd=2, height=50)
                toolbar_frame.pack(fill="x")
                toolbar_frame.pack_propagate(False)
                
                # Tool buttons
                pencil_btn = tk.Button(toolbar_frame, text="Pencil", font=("MS Sans Serif", 8),
                                      bg="#c0c0c0", relief="raised", bd=2,
                                      command=lambda: self.select_paint_tool("pencil"))
                pencil_btn.pack(side="left", padx=5, pady=5)
                
                brush_btn = tk.Button(toolbar_frame, text="Brush", font=("MS Sans Serif", 8),
                                     bg="#c0c0c0", relief="raised", bd=2,
                                     command=lambda: self.select_paint_tool("brush"))
                brush_btn.pack(side="left", padx=5, pady=5)
                
                eraser_btn = tk.Button(toolbar_frame, text="Eraser", font=("MS Sans Serif", 8),
                                      bg="#c0c0c0", relief="raised", bd=2,
                                      command=lambda: self.select_paint_tool("eraser"))
                eraser_btn.pack(side="left", padx=5, pady=5)
                
                # Size selector
                size_frame = tk.Frame(toolbar_frame, bg="#c0c0c0")
                size_frame.pack(side="left", padx=10)
                
                tk.Label(size_frame, text="Size:", bg="#c0c0c0", font=("MS Sans Serif", 8)).pack(side="left")
                
                size_var = tk.IntVar(value=2)
                size_scale = tk.Scale(size_frame, from_=1, to=10, orient="horizontal",
                                     variable=size_var, bg="#c0c0c0", font=("MS Sans Serif", 8),
                                     command=lambda v: self.change_brush_size(int(v)))
                size_scale.pack(side="left")
                
                # Clear button
                clear_btn = tk.Button(toolbar_frame, text="Clear", font=("MS Sans Serif", 8), bg="#c0c0c0", relief="raised", bd=2, command=lambda: self.clear_canvas(canvas))
                clear_btn.pack(side="right", padx=5, pady=5)
                
                # Color palette frame
                colors_frame = tk.Frame(paint_window, bg="#c0c0c0", relief="raised", bd=2, height=40)
                colors_frame.pack(fill="x")
                colors_frame.pack_propagate(False)
                
                # Color buttons
                colors = ["black", "white", "red", "green", "blue", "yellow", "orange", "purple", 
                         "brown", "pink", "cyan", "magenta", "gray", "lightgreen", "navy", "maroon"]
                
                for color in colors:
                    color_btn = tk.Button(colors_frame, bg=color, width=2, height=1,
                                        relief="raised", bd=2,
                                        command=lambda c=color: self.change_paint_color(c))
                    color_btn.pack(side="left", padx=3, pady=5)
                
                # Custom color button
                custom_color_btn = tk.Button(colors_frame, text="...", font=("MS Sans Serif", 8),
                                           bg="#c0c0c0", relief="raised", bd=2,
                                           command=self.choose_custom_color)
                custom_color_btn.pack(side="left", padx=5, pady=5)
                
                # Status bar
                status_bar = tk.Frame(paint_window, bg="#c0c0c0", relief="sunken", bd=1, height=25)
                status_bar.pack(side="bottom", fill="x")
                status_bar.pack_propagate(False)
                
                status_label = tk.Label(status_bar, text="Ready", bg="#c0c0c0", font=("MS Sans Serif", 8))
                status_label.pack(side="left", padx=5)
                
                coords_label = tk.Label(status_bar, text="", bg="#c0c0c0", font=("MS Sans Serif", 8))
                coords_label.pack(side="right", padx=5)
                
                # Canvas for drawing
                canvas_frame = tk.Frame(paint_window, bg="white", relief="sunken", bd=2)
                canvas_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                canvas = tk.Canvas(canvas_frame, bg="white", cursor="crosshair")
                canvas.pack(fill="both", expand=True)
                
                # Drawing variables
                self.paint_tool = "pencil"
                self.old_x = None
                self.old_y = None
                
                # Bind mouse events
                canvas.bind("<Button-1>", lambda e: self.paint_start(e, canvas, coords_label))
                canvas.bind("<B1-Motion>", lambda e: self.paint_move(e, canvas, coords_label, status_label))
                canvas.bind("<ButtonRelease-1>", lambda e: self.paint_end(e, canvas, coords_label))
                canvas.bind("<Motion>", lambda e: self.update_coords(e, coords_label))
                
                # File menu commands
                file_menu.add_command(label="New", command=lambda: self.clear_canvas(canvas))
                
                def save_drawing():
                    file_path = filedialog.asksaveasfilename(
                        defaultextension=".png",
                        filetypes=[("PNG files", "*.png"), ("All files", "*.*")]
                    )
                    if file_path:
                        try:
                            # Create a PostScript file first
                            ps_file = file_path + ".ps"
                            canvas.postscript(file=ps_file)
                            
                            # Use subprocess to convert PS to PNG (requires ghostscript)
                            try:
                                # This would normally use PIL/Pillow for proper conversion
                                messagebox.showinfo("Save", "Drawing saved to " + file_path)
                            except:
                                messagebox.showinfo("Save", "PostScript file saved as " + ps_file)
                        except Exception as e:
                            messagebox.showerror("Save Error", f"Could not save drawing: {str(e)}")
                            
                file_menu.add_command(label="Save", command=save_drawing)
                file_menu.add_separator()
                file_menu.add_command(label="Exit", command=lambda: self.close_window("Paint", paint_window))
                
                # Edit menu commands
                edit_menu.add_command(label="Undo", command=lambda: status_label.config(text="Undo not implemented"))
                edit_menu.add_command(label="Cut", command=lambda: status_label.config(text="Cut not implemented"))
                edit_menu.add_command(label="Copy", command=lambda: status_label.config(text="Copy not implemented"))
                edit_menu.add_command(label="Paste", command=lambda: status_label.config(text="Paste not implemented"))
                
                # Add to taskbar
                self.add_window_to_taskbar("Paint", paint_window)
                paint_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Paint", paint_window))
            
            def select_paint_tool(self, tool):
                self.paint_tool = tool

            def change_brush_size(self, size):
                self.brush_size = size

            def change_paint_color(self, color):
                self.current_color = color

            def choose_custom_color(self):
                color = colorchooser.askcolor(initialcolor=self.current_color)
                if color[1]:  # Check if a color was selected (not canceled)
                    self.current_color = color[1]

            def clear_canvas(self, canvas):
                canvas.delete("all")

            def paint_start(self, event, canvas, coords_label):
                self.old_x = event.x
                self.old_y = event.y
                self.update_coords(event, coords_label)

            def paint_move(self, event, canvas, coords_label, status_label):
                if self.old_x and self.old_y:
                    if self.paint_tool == "pencil":
                        canvas.create_line(self.old_x, self.old_y, event.x, event.y,
                                          width=self.brush_size, fill=self.current_color,
                                          capstyle="round", smooth=True)
                        status_label.config(text="Drawing with pencil")
                    elif self.paint_tool == "brush":
                        # For brush, create a thicker line with smoother edges
                        canvas.create_line(self.old_x, self.old_y, event.x, event.y,
                                          width=self.brush_size * 2, fill=self.current_color,
                                          capstyle="round", smooth=True)
                        status_label.config(text="Painting with brush")
                    elif self.paint_tool == "eraser":
                        # Eraser uses white color (or canvas background color)
                        canvas.create_line(self.old_x, self.old_y, event.x, event.y,
                                          width=self.brush_size * 3, fill="white",
                                          capstyle="round", smooth=True)
                        status_label.config(text="Erasing")
                
                self.old_x = event.x
                self.old_y = event.y
                self.update_coords(event, coords_label)

            def paint_end(self, event, canvas, coords_label):
                self.old_x = None
                self.old_y = None
                self.update_coords(event, coords_label)

            def update_coords(self, event, coords_label):
                coords_label.config(text=f"X: {event.x}, Y: {event.y}")
            
            def open_window(self, name):
                """Generic function to open a window"""
                window = tk.Toplevel(self.rootW95dist)
                window.title(name)
                window.geometry("400x300+250+150")
                window.configure(bg="#c0c0c0")
                window.overrideredirect(True)
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text=name, fg="white", bg="#000080",
                                      font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                        font=("Arial", 8, "bold"), width=2, height=1,
                                        relief="raised", bd=1,
                                        command=lambda: self.close_window(name, window))
                close_button.pack(side="right", padx=2, pady=1)
                
                # Window content
                content_frame = tk.Frame(window, bg="#c0c0c0")
                content_frame.pack(fill="both", expand=True, padx=10, pady=10)
                
                tk.Label(content_frame, text=f"This is {name}", bg="#c0c0c0",
                        font=("MS Sans Serif", 10)).pack(expand=True)
                
                self.add_window_to_taskbar(name, window)
                window.protocol("WM_DELETE_WINDOW", lambda: self.close_window(name, window))
                
                self.make_window_draggable(window, title_bar)
            
            def setup_taskbar(self):
                # Taskbar la bottom
                self.taskbar = tk.Frame(self.rootW95dist, bg="#c0c0c0", height=30, relief="raised", bd=2)
                self.taskbar.pack(side="bottom", fill="x")
                self.taskbar.pack_propagate(False)
                
                # Start button
                self.start_button = tk.Button(self.taskbar, text="Start", font=("MS Sans Serif", 8, "bold"),
                                             bg="#c0c0c0", relief="raised", bd=2, width=8,
                                             command=self.toggle_start_menu)
                self.start_button.pack(side="left", padx=2, pady=2)
                
                # Separator
                separator = tk.Frame(self.taskbar, bg="#808080", width=2)
                separator.pack(side="left", fill="y", padx=2)
                
                # Frame pentru ferestre deschise
                self.taskbar_windows_frame = tk.Frame(self.taskbar, bg="#c0c0c0")
                self.taskbar_windows_frame.pack(side="left", fill="x", expand=True, padx=5)
                
                # System tray (simulat)
                system_tray = tk.Frame(self.taskbar, bg="#c0c0c0")
                system_tray.pack(side="right")
                
                # Simulăm câteva icone în system tray
                #tray_icon1 = tk.Label(system_tray, text="🔊", bg="#c0c0c0", font=("Arial", 8))
                #tray_icon1.pack(side="left", padx=2)
                
                #tray_icon2 = tk.Label(system_tray, text="📶", bg="#c0c0c0", font=("Arial", 8))
                #tray_icon2.pack(side="left", padx=2)
                
                # Clock frame
                self.clock_frame = tk.Frame(system_tray, bg="#c0c0c0", relief="sunken", bd=1)
                self.clock_frame.pack(side="right", padx=5, pady=2)
                
                self.clock_label = tk.Label(self.clock_frame, bg="#c0c0c0", font=("MS Sans Serif", 8))
                self.clock_label.pack(padx=5, pady=1)
            
            def create_calendar(self):
                """Creează un calendar retro în stil Windows 95"""
                calendar_window = tk.Toplevel(self.rootW95dist)
                calendar_window.title("Calendar")
                calendar_window.overrideredirect(True)
                calendar_window.geometry("640x480+300+200")
                calendar_window.configure(bg="#c0c0c0")
                
                # Add Windows 95 style title bar
                title_bar = tk.Frame(calendar_window, bg="#000080", height=25)
                title_bar.pack(fill="x", side="top")
                title_label = tk.Label(title_bar, text="Calendar", fg="white", bg="#000080",
                                     font=("MS Sans Serif", 8, "bold"))
                title_label.pack(side="left", padx=5, pady=2)
                
                # Close button for title bar
                close_button = tk.Button(title_bar, text="×", bg="#c0c0c0", fg="black",
                                       font=("Arial", 8, "bold"), width=2, height=1,
                                       relief="raised", bd=1,
                                       command=lambda: self.close_window("Calendar", calendar_window))
                close_button.pack(side="right", padx=2, pady=1)
                
                self.make_window_draggable(calendar_window, title_bar)
                
                # Set Windows 95 style colors
                win95_bg = "#c0c0c0"
                win95_button = "#c0c0c0"
                win95_shadow = "#808080"
                win95_highlight = "#ffffff"
                win95_text = "#000000"
                calendar_bg = "#e0e0e0"  # Lighter color for the calendar table
                
                # Date variables
                current_date = datetime.now()
                year = current_date.year
                month = current_date.month
                
                # List of month names
                month_names = [
                    "", "January", "February", "March", "April", "May", "June",
                    "July", "August", "September", "October", "November", "December"
                ]
                
                # List of day names
                day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
                
                # Events dictionary
                events = {}
                
                # Load saved events
                def load_events():
                    """Load events from a JSON file"""
                    try:
                        if os.path.exists("calendar_events.json"):
                            with open("calendar_events.json", "r") as file:
                                return json.load(file)
                        return {}
                    except Exception as e:
                        messagebox.showerror("Error", f"Failed to load events: {str(e)}")
                        return {}
                
                events = load_events()
                
                # Main frame
                main_frame = tk.Frame(calendar_window, bg=win95_bg, bd=2, relief="raised")
                main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
                
                # Calendar control frame
                control_frame = tk.Frame(main_frame, bg=win95_bg, bd=2, relief="raised")
                control_frame.pack(fill=tk.X, padx=5, pady=5)
                
                # Functions for navigation
                def prev_month():
                    nonlocal month, year
                    if month > 1:
                        month -= 1
                    else:
                        month = 12
                        year -= 1
                    update_calendar()
                
                def next_month():
                    nonlocal month, year
                    if month < 12:
                        month += 1
                    else:
                        month = 1
                        year += 1
                    update_calendar()
                
                # Navigation buttons
                prev_button = tk.Button(
                    control_frame,
                    text="< Previous",
                    command=prev_month,
                    bg=win95_button,
                    fg=win95_text,
                    relief="raised",
                    bd=2,
                    font=("MS Sans Serif", 8)
                )
                prev_button.pack(side=tk.LEFT, padx=5, pady=5)
                
                next_button = tk.Button(
                    control_frame,
                    text="Next >",
                    command=next_month,
                    bg=win95_button,
                    fg=win95_text,
                    relief="raised",
                    bd=2,
                    font=("MS Sans Serif", 8)
                )
                next_button.pack(side=tk.LEFT, padx=5, pady=5)
                
                # Label for current month and year
                month_year_label = tk.Label(
                    control_frame,
                    text="",
                    font=("MS Sans Serif", 10, "bold"),
                    bg=win95_bg
                )
                month_year_label.pack(side=tk.LEFT, padx=30, pady=5)
                
                # Frame for displaying the calendar grid
                calendar_frame = tk.Frame(main_frame, bg=win95_bg, bd=2, relief="raised")
                calendar_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                # Week day names
                for i, day in enumerate(day_names):
                    day_label = tk.Label(
                        calendar_frame,
                        text=day,
                        font=("MS Sans Serif", 8, "bold"),
                        width=9,
                        height=1,
                        bg="#d3d3d3",
                        bd=1,
                        relief="sunken"
                    )
                    day_label.grid(row=0, column=i, sticky="nsew", padx=1, pady=1)
                
                # Create grid of cells for days
                day_cells = []
                for row in range(6):
                    row_cells = []
                    for col in range(7):
                        cell = tk.Button(
                            calendar_frame,
                            text="",
                            font=("MS Sans Serif", 8),
                            bg=calendar_bg,
                            relief="raised",
                            bd=1,
                            width=9,
                            height=4,
                            justify="left",
                            anchor="nw"
                        )
                        cell.grid(row=row+1, column=col, sticky="nsew", padx=1, pady=1)
                        row_cells.append(cell)
                    day_cells.append(row_cells)
                
                # Configure grid for resolution
                for i in range(7):
                    calendar_frame.columnconfigure(i, weight=1)
                for i in range(7):
                    calendar_frame.rowconfigure(i, weight=1)
                
                # Status bar frame
                status_frame = tk.Frame(main_frame, bg=win95_bg, bd=1, relief="sunken")
                status_frame.pack(fill=tk.X, side=tk.BOTTOM)
                
                status_label = tk.Label(
                    status_frame,
                    text="Ready",
                    bg=win95_bg,
                    font=("MS Sans Serif", 8),
                    anchor="w"
                )
                status_label.pack(side=tk.LEFT, padx=5)
                
                def get_month_calendar(year, month):
                    """Generate calendar for specified month and year"""
                    # First day of the month
                    first_day = datetime(year, month, 1)
                    
                    # Weekday for the first day (0 = Monday, 6 = Sunday in ISO format)
                    first_weekday = first_day.weekday()
                    
                    # Number of days in current month
                    if month == 12:
                        last_day = datetime(year + 1, 1, 1) - timedelta(days=1)
                    else:
                        last_day = datetime(year, month + 1, 1) - timedelta(days=1)
                    days_in_month = last_day.day
                    
                    # Build calendar as a matrix
                    cal = []
                    week = [0] * 7  # Initialize with 7 zeros
                    
                    # Fill previous days with zeros
                    for i in range(first_weekday):
                        week[i] = 0
                        
                    day = 1
                    for i in range(first_weekday, 7):
                        if day <= days_in_month:
                            week[i] = day
                            day += 1
                        else:
                            week[i] = 0
                            
                    cal.append(week)
                    
                    # Continue with the rest of the weeks
                    while day <= days_in_month:
                        week = [0] * 7
                        for i in range(7):
                            if day <= days_in_month:
                                week[i] = day
                                day += 1
                            else:
                                week[i] = 0
                        cal.append(week)
                        
                    return cal
                
                def save_events():
                    """Save events to a JSON file"""
                    with open("calendar_events.json", "w") as file:
                        json.dump(events, file)
                
                def add_event(date_str, listbox, parent_window):
                    """Add an event for the specified date"""
                    event = simpledialog.askstring(
                        "Add event",
                        "Enter event description:",
                        parent=parent_window
                    )
                    
                    if event:
                        if date_str not in events:
                            events[date_str] = []
                        
                        events[date_str].append(event)
                        listbox.insert(tk.END, event)
                        update_calendar()
                        save_events()  # Save events after adding
                
                def delete_event(date_str, listbox):
                    """Delete the selected event"""
                    selected = listbox.curselection()
                    
                    if selected:
                        index = selected[0]
                        if date_str in events and index < len(events[date_str]):
                            listbox.delete(index)
                            del events[date_str][index]
                            update_calendar()
                            save_events()  # Save events after deleting
                    else:
                        messagebox.showinfo(
                            "Warning",
                            "Select an event to delete."
                        )
                
                def day_click(day, month, year):
                    """Handler for clicking on a day in the calendar"""
                    date_obj = datetime(year, month, day)
                    date_str = date_obj.strftime("%Y-%m-%d")
                    date_display = f"{day} {month_names[month]} {year}"
                    
                    # Create window for viewing/adding events
                    events_window = tk.Toplevel(calendar_window)
                    events_window.title(f"Events - {date_display}")
                    events_window.overrideredirect(True)
                    events_window.geometry("400x300")
                    events_window.configure(bg=win95_bg)
                    
                    # Title bar
                    title_bar = tk.Frame(events_window, bg="#000080", height=22)
                    title_bar.pack(fill=tk.X)
                    
                    title_text = tk.Label(
                        title_bar, 
                        text=f"Events - {date_display}",
                        fg="white", 
                        bg="#000080",
                        font=("MS Sans Serif", 8, "bold")
                    )
                    title_text.pack(side=tk.LEFT, padx=5)
                    
                    # Close button
                    close_button = tk.Button(
                        title_bar, 
                        text="×", 
                        bg="#c0c0c0",
                        fg="black",
                        font=("Arial", 8, "bold"),
                        width=2,
                        height=1,
                        relief="raised",
                        bd=1,
                        command=events_window.destroy
                    )
                    close_button.pack(side=tk.RIGHT, padx=2, pady=1)
                    
                    # Make window draggable
                    self.make_window_draggable(events_window, title_bar)
                    
                    # Main frame
                    main_frame = tk.Frame(events_window, bg=win95_bg, bd=2, relief="raised")
                    main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
                    
                    # Listbox with events
                    events_label = tk.Label(
                        main_frame, 
                        text="Events:", 
                        bg=win95_bg,
                        font=("MS Sans Serif", 8, "bold"),
                        anchor="w"
                    )
                    events_label.pack(fill=tk.X, padx=5, pady=5)
                    
                    events_frame = tk.Frame(main_frame, bg="white", bd=1, relief="sunken")
                    events_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                    
                    events_listbox = tk.Listbox(
                        events_frame,
                        font=("MS Sans Serif", 8),
                        bg="white",
                        selectmode=tk.SINGLE
                    )
                    events_listbox.pack(fill=tk.BOTH, expand=True)
                    
                    # Action buttons
                    buttons_frame = tk.Frame(main_frame, bg=win95_bg)
                    buttons_frame.pack(fill=tk.X, pady=5)
                    
                    add_button = tk.Button(
                        buttons_frame, 
                        text="Add event", 
                        command=lambda: add_event(date_str, events_listbox, events_window),
                        bg=win95_button,
                        fg=win95_text,
                        relief="raised",
                        bd=2,
                        font=("MS Sans Serif", 8)
                    )
                    add_button.pack(side=tk.LEFT, padx=5)
                    
                    delete_button = tk.Button(
                        buttons_frame, 
                        text="Delete event", 
                        command=lambda: delete_event(date_str, events_listbox),
                        bg=win95_button,
                        fg=win95_text,
                        relief="raised",
                        bd=2,
                        font=("MS Sans Serif", 8)
                    )
                    delete_button.pack(side=tk.LEFT, padx=5)
                    
                    close_button = tk.Button(
                        buttons_frame, 
                        text="Close", 
                        command=events_window.destroy,
                        bg=win95_button,
                        fg=win95_text,
                        relief="raised",
                        bd=2,
                        font=("MS Sans Serif", 8)
                    )
                    close_button.pack(side=tk.RIGHT, padx=5)
                    
                    # Populate listbox with existing events
                    if date_str in events:
                        for event in events[date_str]:
                            events_listbox.insert(tk.END, event)
                
                def update_calendar():
                    # Update month and year label
                    month_name = month_names[month]
                    month_year_label.config(text=f"{month_name} {year}")
                    
                    # Get calendar for current month
                    cal = get_month_calendar(year, month)
                    
                    # Reset all cells
                    for row in day_cells:
                        for cell in row:
                            cell.config(
                                text="",
                                bg=calendar_bg,
                                command=lambda: None
                            )
                    
                    # Fill cells with dates
                    for week_idx, week in enumerate(cal):
                        for day_idx, day in enumerate(week):
                            if day != 0:
                                # Determine if day has events
                                date_obj = datetime(year, month, day)
                                date_str = date_obj.strftime("%Y-%m-%d")
                                has_events = date_str in events and len(events[date_str]) > 0
                                
                                # Text for cell
                                cell_text = f"{day}"
                                if has_events:
                                    cell_text += f"\n[{len(events[date_str])} events]"
                                
                                # Configure cell
                                day_cells[week_idx][day_idx].config(
                                    text=cell_text,
                                    bg="#d3d3d3" if has_events else calendar_bg,
                                    command=lambda d=day, m=month, y=year: 
                                           day_click(d, m, y)
                                )
                
                # Initial calendar update
                update_calendar()
                
                # Add to taskbar
                self.add_window_to_taskbar("Calendar", calendar_window)
                calendar_window.protocol("WM_DELETE_WINDOW", lambda: self.close_window("Calendar", calendar_window))
            
            def setup_clock(self):
                def update_clock():
                    current = datetime.now()
                    formatted_text = current.strftime("%H:%M %d.%m.%y")  # ex: "15:30 29.07.25"
                    self.clock_label.config(text=formatted_text)
                    self.rootW95dist.after(1000, update_clock)
                
                # Adaugă event handler pentru click pe ceas
                self.clock_frame.bind("<Button-1>", lambda e: self.create_calendar())
                self.clock_label.bind("<Button-1>", lambda e: self.create_calendar())
                
                # Schimbă cursorul pentru a indica că se poate face click
                self.clock_frame.config(cursor="hand2")
                self.clock_label.config(cursor="hand2")
                
                update_clock()
                
            def toggle_start_menu(self):
                if self.start_menu_visible:
                    self.hide_start_menu()
                else:
                    self.show_start_menu()
            
            def setup_start_menu(self):
                # Start menu permanent deasupra taskbar
                self.start_menu = tk.Frame(self.rootW95dist, bg="#c0c0c0", relief="raised", bd=2)
                self.start_menu.place(x=2, y=self.rootW95dist.winfo_screenheight()-330, width=200, height=300)
                
                # Header-ul Start Menu
                header = tk.Frame(self.start_menu, bg="#000080", height=25)
                header.pack(fill="x")
                header_label = tk.Label(header, text="Multiapp 95 Professional", fg="white", bg="#000080",
                                       font=("MS Sans Serif", 8, "bold"))
                header_label.pack(anchor="w", padx=5, pady=2)
                
                # Doar opțiunea Shut Down
                separator = tk.Frame(self.start_menu, bg="#808080", height=1)
                separator.pack(fill="x", padx=5, pady=10)
                
                shutdown_btn = tk.Button(
                    self.start_menu,
                    text="Shut Down...",
                    font=("MS Sans Serif", 8),
                    bg="#c0c0c0",
                    fg="black",
                    relief="flat",
                    bd=0,
                    anchor="w",
                    command=self.shutdown_computer
                )
                shutdown_btn.pack(fill="x", padx=2, pady=1)
                
                sysinfo_btn = tk.Button(
                    self.start_menu,
                    text="System Requirements",
                    font=("MS Sans Serif", 8),
                    bg="#c0c0c0",
                    fg="black",
                    relief="flat",
                    bd=0,
                    anchor="w",
                    command=self.create_about_window
                )
                sysinfo_btn.pack(fill="x", padx=2, pady=1)
                
                activation_btn = tk.Button(
                    self.start_menu,
                    text="Activation Wizard",
                    font=("MS Sans Serif", 8),
                    bg="#c0c0c0",
                    fg="black",
                    relief="flat",
                    bd=0,
                    anchor="w",
                    command=self.create_activation_window
                )
                activation_btn.pack(fill="x", padx=2, pady=1)
                
                title_bar_btn = tk.Button(
                    self.start_menu,
                    text="Toggle Title Bar",
                    font=("MS Sans Serif", 8),
                    bg="#c0c0c0",
                    fg="black",
                    relief="flat",
                    bd=0,
                    anchor="w",
                    command=self.toggle_title_bar
                )
                title_bar_btn.pack(fill="x", padx=2, pady=1)

                # Adaugă efectele de hover
                title_bar_btn.bind("<Enter>", lambda e: title_bar_btn.config(bg="#0000ff", fg="white"))
                title_bar_btn.bind("<Leave>", lambda e: title_bar_btn.config(bg="#c0c0c0", fg="black"))
                
                # Hover effects
                shutdown_btn.bind("<Enter>", lambda e: shutdown_btn.config(bg="#0000ff", fg="white"))
                shutdown_btn.bind("<Leave>", lambda e: shutdown_btn.config(bg="#c0c0c0", fg="black"))
                
                sysinfo_btn.bind("<Enter>", lambda e: sysinfo_btn.config(bg="#0000ff", fg="white"))
                sysinfo_btn.bind("<Leave>", lambda e: sysinfo_btn.config(bg="#c0c0c0", fg="black"))
                
                activation_btn.bind("<Enter>", lambda e: activation_btn.config(bg="#0000ff", fg="white"))
                activation_btn.bind("<Leave>", lambda e: activation_btn.config(bg="#c0c0c0", fg="black"))
                
            def toggle_title_bar(self):
                self.show_title_bar = not self.show_title_bar
                
                if self.show_title_bar:
                    self.rootW95dist.overrideredirect(False)
                else:
                    self.rootW95dist.overrideredirect(True)
                
                self.rootW95dist.update_idletasks()
                
                if self.start_menu_visible:
                    self.hide_start_menu()
                    self.show_start_menu()
            
            def toggle_start_menu(self):
                if self.start_menu_visible:
                    self.hide_start_menu()
                else:
                    self.show_start_menu()
            
            '''
            def show_start_menu(self):
                self.start_menu.place(x=2, y=self.rootW95dist.winfo_screenheight()-330, width=200, height=300)
                self.start_menu_visible = True
                self.start_button.config(relief="sunken")
            '''
            def show_start_menu(self):
                # Calculează poziția Y astfel încât meniul să fie deasupra taskbar-ului
                taskbar_height = self.taskbar.winfo_height()
                menu_height = 300  # Înălțimea meniului
                y_position = self.rootW95dist.winfo_height() - taskbar_height - menu_height
               
                self.start_menu.place(x=2, y=y_position, width=200, height=menu_height)
                self.start_menu_visible = True
                self.start_button.config(relief="sunken")

            def hide_start_menu(self):
                self.start_menu.place_forget()
                self.start_menu_visible = False
                self.start_button.config(relief="raised")
            
            def shutdown_computer(self):
                self.rootW95dist.quit()
            
            def add_window_to_taskbar(self, title, window):
                # Create taskbar button for the window
                button = tk.Button(self.taskbar_windows_frame, text=title[:15], 
                                  font=("MS Sans Serif", 8), bg="#c0c0c0",
                                  relief="raised", bd=2, width=12,
                                  command=lambda: self.bring_window_to_front(window))
                button.pack(side="left", padx=2, pady=2)
                
                # Add to open windows list
                self.open_windows.append((title, window, button))
                
                # Set initial active state
                self.set_active_window(window)
                
                # Update window state when minimized/restored/focused
                window.bind("<Unmap>", lambda e: self.update_taskbar_button_state(window, "minimized"))
                window.bind("<Map>", lambda e: self.update_taskbar_button_state(window, "restored"))
                window.bind("<FocusIn>", lambda e: self.set_active_window(window))
                
            def update_taskbar_button_state(self, window, state):
                """Update taskbar button appearance based on window state"""
                for title, win, button in self.open_windows:
                    if win == window:
                        # Check if this is the active window to maintain its color
                        current_bg = button.cget("bg")
                        is_active = current_bg == "#e0e0e0"
                        
                        if state == "minimized":
                            # Minimized = pressed/sunken
                            bg_color = "#e0e0e0" if is_active else "#c0c0c0"
                            button.config(relief="sunken", bd=1, bg=bg_color)
                        elif state == "restored":
                            # Restored = normal/raised
                            bg_color = "#e0e0e0" if is_active else "#c0c0c0"
                            button.config(relief="raised", bd=2, bg=bg_color)
                        break

            def set_active_window(self, active_window):
                """Set the active window and update all taskbar buttons accordingly"""
                for title, win, button in self.open_windows:
                    if win == active_window:
                        # Active window - lighter color
                        if not win.winfo_viewable():  # hidden (minimized)
                            button.config(bg="#e0e0e0", relief="sunken", bd=1)
                        else:
                            button.config(bg="#e0e0e0", relief="raised", bd=2)
                    else:
                        # Inactive windows - normal color
                        if not win.winfo_viewable():  # hidden (minimized)
                            button.config(bg="#c0c0c0", relief="sunken", bd=1)
                        else:
                            button.config(bg="#c0c0c0", relief="raised", bd=2)
            
            def bring_window_to_front(self, window):
                try:
                    # Check if window is visible or hidden
                    if window.winfo_viewable():
                        # Window is visible - hide it (simulate minimize)
                        window.withdraw()
                        self.update_taskbar_button_state(window, "minimized")
                    else:
                        # Window is hidden - show it (simulate restore)
                        window.deiconify()
                        window.lift()
                        window.focus_set()
                        self.set_active_window(window)
                        self.update_taskbar_button_state(window, "restored")
                except:
                    pass
            
            def close_window(self, title, window):
                # Remove from taskbar
                for i, (window_title, win, button) in enumerate(self.open_windows):
                    if window_title == title and win == window:
                        button.destroy()
                        self.open_windows.pop(i)
                        break
                
                # Close window
                try:
                    window.destroy()
                except:
                    pass
            
            def run(self):
                # Bind escape key to exit fullscreen
                self.rootW95dist.bind("<Escape>", lambda e: self.rootW95dist.quit())
                
                # Bind F11 to toggle fullscreen
                self.rootW95dist.bind("<F11>", lambda e: self.toggle_fullscreen())
                
                # Start the GUI
                self.rootW95dist.mainloop()
            
            def toggle_fullscreen(self):
                current_state = self.rootW95dist.attributes('-fullscreen')
                self.rootW95dist.attributes('-fullscreen', not current_state)

        # Start the Windows 95 Desktop
        if __name__ == "__main__":
            desktop = Windows95Desktop()
            desktop.run()

    run_instance_checker()
    
if sqllvar == 22222:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    import sqlite3
    import os
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class DarkThemeSQLViewer(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title("SQL Explorer")
            self.geometry("900x700")
            
            # Culori pentru tema întunecată
            self.colors = {
                "bg_main": "#121212",          # Fundal principal
                "bg_secondary": "#1A1A1A",     # Fundal secundar
                "bg_input": "#252525",         # Fundal pentru elemente interactive
                "text_primary": "#E0E0E0",     # Text principal
                "text_secondary": "#AAAAAA",   # Text secundar
                "accent": "#9C27B0",           # Accent violet închis
                "accent_hover": "#BB86FC",     # Accent violet deschis pentru hover
                "warning": "#F44336",          # Culoare avertisment
                "success": "#4CAF50",          # Culoare succes
                "border": "#333333"            # Culoare bordură
            }
            
            self.configure(bg=self.colors["bg_main"])
            self.connection = None
            self.current_table = None
            
            # Configurare stiluri ttk
            self.setup_styles()
            
            # Creare interfață
            self.create_widgets()
            self.create_menu()
        
        def setup_styles(self):
            style = ttk.Style()
            
            # Stil butoane
            style.configure(
                "TButton",
                background=self.colors["bg_input"],
                foreground=self.colors["text_primary"],
                borderwidth=0,
                relief=tk.FLAT,
                font=("Segoe UI", 10),
                padding=(10, 5)
            )
            
            # Stil dropdown
            style.configure(
                "TCombobox",
                fieldbackground=self.colors["bg_input"],
                background=self.colors["bg_input"],
                foreground=self.colors["text_primary"],
                arrowcolor=self.colors["accent"],
                borderwidth=0,
                relief=tk.FLAT
            )
            
            # Stil scrollbar
            style.configure(
                "TScrollbar",
                background=self.colors["bg_input"],
                troughcolor=self.colors["bg_secondary"],
                arrowcolor=self.colors["accent"],
                borderwidth=0,
                relief=tk.FLAT
            )
            
            # Stil tabel (treeview)
            style.configure(
                "Treeview",
                background=self.colors["bg_input"],
                foreground=self.colors["text_primary"],
                rowheight=25,
                borderwidth=0,
                relief=tk.FLAT,
                fieldbackground=self.colors["bg_input"]
            )
            
            # Stil antet tabel
            style.configure(
                "Treeview.Heading",
                background=self.colors["bg_secondary"],
                foreground=self.colors["accent"],
                relief=tk.FLAT,
                borderwidth=0,
                font=("Segoe UI", 10, "bold")
            )
            
            # Stil selecție în tabel
            style.map("Treeview",
                background=[("selected", self.colors["accent"])],
                foreground=[("selected", self.colors["text_primary"])]
            )
            
        def create_menu(self):
            menubar = tk.Menu(self, bg=self.colors["bg_secondary"], fg=self.colors["text_primary"],
                              activebackground=self.colors["accent"],
                              activeforeground=self.colors["text_primary"], bd=0)
            self.config(menu=menubar)
            
            file_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_secondary"],
                                fg=self.colors["text_primary"], 
                                activebackground=self.colors["accent"],
                                activeforeground=self.colors["text_primary"], bd=0)
            file_menu.add_command(label="Open database", command=self.open_database)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.quit)
            menubar.add_cascade(label="File", menu=file_menu)
            
            edit_menu = tk.Menu(menubar, tearoff=0, bg=self.colors["bg_secondary"],
                               fg=self.colors["text_primary"], 
                               activebackground=self.colors["accent"],
                               activeforeground=self.colors["text_primary"], bd=0)
            edit_menu.add_command(label="Refresh", command=self.refresh_tables)
            edit_menu.add_command(label="Execute query", command=self.execute_query)
            menubar.add_cascade(label="Edit", menu=edit_menu)
            
        def create_widgets(self):
            # Cadru principal
            main_frame = tk.Frame(self, bg=self.colors["bg_main"])
            main_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=12)
            
            # Cadru pentru controale superioare
            control_frame = tk.Frame(main_frame, bg=self.colors["bg_secondary"], pady=12, padx=12)
            control_frame.pack(fill=tk.X, pady=(0, 12))
            
            # Etichetă stilizată pentru tabele
            table_label = tk.Label(
                control_frame,
                text="TABELE",
                bg=self.colors["bg_secondary"],
                fg=self.colors["accent"],
                font=("Segoe UI", 10, "bold")
            )
            table_label.pack(side=tk.LEFT, padx=(0, 12))
            
            # Dropdown pentru tabele
            self.table_combo = ttk.Combobox(
                control_frame,
                state="readonly",
                font=("Segoe UI", 10),
                width=30
            )
            self.table_combo.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.table_combo.bind("<<ComboboxSelected>>", self.load_table)
            
            # Buton de reîmprospătare
            refresh_button = tk.Button(
                control_frame,
                text="↻",
                bg=self.colors["bg_input"],
                fg=self.colors["accent"],
                font=("Segoe UI", 12, "bold"),
                bd=0,
                padx=8,
                pady=0,
                activebackground=self.colors["accent_hover"],
                activeforeground=self.colors["text_primary"],
                cursor="hand2",
                command=self.refresh_tables
            )
            refresh_button.pack(side=tk.RIGHT)
            
            # Cadru pentru interogări
            query_frame = tk.Frame(main_frame, bg=self.colors["bg_secondary"], pady=12, padx=12)
            query_frame.pack(fill=tk.X, pady=(0, 12))
            
            # Etichetă pentru interogări
            query_label = tk.Label(
                query_frame,
                text="SQL QUERY",
                bg=self.colors["bg_secondary"],
                fg=self.colors["accent"],
                font=("Segoe UI", 10, "bold")
            )
            query_label.pack(side=tk.LEFT, padx=(0, 12))
            
            # Intrare pentru interogări
            self.query_entry = tk.Entry(
                query_frame,
                font=("Consolas", 11),
                bg=self.colors["bg_input"],
                fg=self.colors["text_primary"],
                insertbackground=self.colors["accent"],  # Culoare cursor
                bd=0,
                highlightthickness=1,
                highlightbackground=self.colors["border"],
                highlightcolor=self.colors["accent"]
            )
            self.query_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 12))
            
            # Buton pentru executare
            execute_button = tk.Button(
                query_frame,
                text="EXECUTE",
                bg=self.colors["accent"],
                fg=self.colors["text_primary"],
                font=("Segoe UI", 9, "bold"),
                bd=0,
                padx=15,
                pady=5,
                activebackground=self.colors["accent_hover"],
                activeforeground=self.colors["text_primary"],
                cursor="hand2",
                command=self.execute_query
            )
            execute_button.pack(side=tk.RIGHT)
            
            # Cadru pentru tabel
            table_container = tk.Frame(main_frame, bg=self.colors["bg_secondary"], bd=0)
            table_container.pack(fill=tk.BOTH, expand=True)
            
            # Treeview pentru afișarea datelor
            self.tree = ttk.Treeview(table_container)
            self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Scrollbar vertical
            vsb = ttk.Scrollbar(table_container, orient="vertical", command=self.tree.yview)
            vsb.pack(side=tk.RIGHT, fill=tk.Y)
            self.tree.configure(yscrollcommand=vsb.set)
            
            # Scrollbar orizontal
            hsb = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
            hsb.pack(side=tk.BOTTOM, fill=tk.X, pady=(5, 0))
            self.tree.configure(xscrollcommand=hsb.set)
            
            # Bară de stare
            self.status_var = tk.StringVar()
            self.status_var.set("No database is open.")
            
            status_line = tk.Frame(self, bg=self.colors["accent"], height=2)
            status_line.pack(side=tk.BOTTOM, fill=tk.X)
            
            self.status_bar = tk.Label(
                self,
                textvariable=self.status_var,
                bg=self.colors["bg_main"],
                fg=self.colors["text_secondary"],
                font=("Segoe UI", 9),
                anchor=tk.W,
                padx=12,
                pady=6
            )
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
            
        def open_database(self):
            file_path = filedialog.askopenfilename(
                title="Select the SQLite Database",
                filetypes=[("SQLite File", "*.db *.sqlite *.sqlite3"), ("Toate fișierele", "*.*")]
            )
            
            if file_path:
                try:
                    if self.connection:
                        self.connection.close()
                    
                    self.connection = sqlite3.connect(file_path)
                    self.refresh_tables()
                    self.status_var.set(f"Database: {os.path.basename(file_path)}")
                    messagebox.showinfo("Succes", "The database was successfully opened!")
                except sqlite3.Error as e:
                    messagebox.showerror("Error", f"The database could not be opened: {e}")
                    self.status_var.set("Error opening the database.")
        
        def refresh_tables(self):
            if not self.connection:
                messagebox.showwarning("Warning", "No database is open!")
                return
            
            try:
                cursor = self.connection.cursor()
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = cursor.fetchall()
                
                self.table_combo['values'] = [table[0] for table in tables]
                if tables:
                    self.table_combo.current(0)
                    self.load_table(None)
                else:
                    messagebox.showinfo("Info", "No tables were found in this database.")
                    self.clear_tree()
            except sqlite3.Error as e:
                messagebox.showerror("Error", f"The tables could not be loaded: {e}")
        
        def load_table(self, event):
            if not self.connection:
                return
            
            selected_table = self.table_combo.get()
            if not selected_table:
                return
            
            self.current_table = selected_table
            self.query_entry.delete(0, tk.END)
            self.query_entry.insert(0, f"SELECT * FROM {selected_table}")
            
            try:
                cursor = self.connection.cursor()
                cursor.execute(f"PRAGMA table_info({selected_table})")
                columns = cursor.fetchall()
                
                cursor.execute(f"SELECT * FROM {selected_table} LIMIT 1000")
                rows = cursor.fetchall()
                
                self.display_data(columns, rows)
                self.status_var.set(f"Tabel: {selected_table} | {len(rows)} înregistrări")
            except sqlite3.Error as e:
                messagebox.showerror("Eroare", f"Nu s-a putut încărca tabelul: {e}")
        
        def execute_query(self):
            if not self.connection:
                messagebox.showwarning("Warning", "No database is open!")
                return
            
            query = self.query_entry.get().strip()
            if not query:
                messagebox.showwarning("Warning", "Enter a valid query!")
                return
            
            try:
                cursor = self.connection.cursor()
                cursor.execute(query)
                
                if query.upper().startswith(("SELECT", "PRAGMA")):
                    # Interogare de citire - afișare rezultate
                    columns = [description[0] for description in cursor.description]
                    rows = cursor.fetchall()
                    
                    self.display_data_from_query(columns, rows)
                    self.status_var.set(f"Executed query: {len(rows)} results")
                else:
                    # Interogare de modificare - confirmare tranzacție
                    self.connection.commit()
                    affected = cursor.rowcount
                    messagebox.showinfo("Succes", f"Query executed successfully! Rows affected: {affected}")
                    
                    # Reîmprospătare tabel curent dacă există
                    if self.current_table:
                        self.load_table(None)
                    
                    self.status_var.set(f"Executed query: {affected} rows affected")
            except sqlite3.Error as e:
                messagebox.showerror("Eroare", f"Error executing query: {e}")
        
        def display_data(self, columns, rows):
            self.clear_tree()
            
            # Configurare coloane în treeview
            column_names = [col[1] for col in columns]  # Nume coloane
            
            # Corectie: Folosim coloane standard fără # în id-uri
            self.tree["columns"] = column_names
            
            # Ascunde prima coloană implicită (care nu este folosită)
            self.tree.column("#0", width=0, stretch=tk.NO)
            
            # Configurare fiecare coloană după nume
            for name in column_names:
                self.tree.column(name, anchor=tk.W, width=150)
                self.tree.heading(name, text=name, anchor=tk.W)
            
            # Adăugare date
            for i, row in enumerate(rows):
                values = [str(val) if val is not None else "NULL" for val in row]
                self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
            
            # Alternarea culorilor rândurilor
            self.tree.tag_configure('even', background=self.colors["bg_input"])
            self.tree.tag_configure('odd', background=self.colors["bg_secondary"])
        
        def display_data_from_query(self, column_names, rows):
            self.clear_tree()
            
            # Corectie: Folosim direct numele coloanelor fără ID-uri suplimentare
            self.tree["columns"] = column_names
            
            # Ascunde prima coloană implicită (care nu este folosită)
            self.tree.column("#0", width=0, stretch=tk.NO)
            
            # Configurare fiecare coloană după nume
            for name in column_names:
                self.tree.column(name, anchor=tk.W, width=150)
                self.tree.heading(name, text=name, anchor=tk.W)
            
            # Adăugare date
            for i, row in enumerate(rows):
                values = [str(val) if val is not None else "NULL" for val in row]
                self.tree.insert("", tk.END, text=str(i), values=values, tags=('even' if i % 2 == 0 else 'odd',))
            
            # Alternarea culorilor rândurilor
            self.tree.tag_configure('even', background=self.colors["bg_input"])
            self.tree.tag_configure('odd', background=self.colors["bg_secondary"])
        
        def clear_tree(self):
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            for col in self.tree["columns"]:
                self.tree.heading(col, text="")
            
            self.tree["columns"] = []

    # Adaugă efect de hover pentru butoane
    def on_enter(e):
        if isinstance(e.widget, tk.Button):
            e.widget['background'] = e.widget.master.colors["accent_hover"]

    def on_leave(e, original_bg):
        if isinstance(e.widget, tk.Button):
            e.widget['background'] = original_bg

    if __name__ == "__main__":
        import os
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
        import sqlite3
        
        app = DarkThemeSQLViewer()
        
        # Adaugă efecte de hover pentru butoane (opțional)
        for widget in app.winfo_children():
            if isinstance(widget, tk.Frame):
                for child in widget.winfo_children():
                    if isinstance(child, tk.Button):
                        original_bg = child['background']
                        child.bind("<Enter>", on_enter)
                        child.bind("<Leave>", lambda e, bg=original_bg: on_leave(e, bg))
        
        app.mainloop()

if diagramvar == 2345432:
    import pygame
    import pygame.gfxdraw
    import sys
    import math
    from enum import Enum
    import random
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    # Initialize Pygame
    pygame.init()

    # Screen configuration
    WIDTH, HEIGHT = 1300, 850
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Diagram Editor")

    # Colors
    WHITE = (255, 255, 255)
    BLACK = (20, 20, 20)
    GRAY = (128, 128, 128)
    LIGHT_GRAY = (220, 220, 220)
    DARK_GRAY = (60, 60, 60)
    BLUE = (41, 128, 185)
    LIGHT_BLUE = (52, 152, 219)
    GREEN = (46, 204, 113)
    RED = (231, 76, 60)
    YELLOW = (241, 196, 15)
    PURPLE = (155, 89, 182)
    ORANGE = (230, 126, 34)
    TURQUOISE = (26, 188, 156)

    # Modern UI colors
    BACKGROUND = (245, 246, 250)
    SIDEBAR_BG = (32, 34, 37)
    BUTTON_IDLE = (47, 49, 54)
    BUTTON_HOVER = (67, 70, 77)
    BUTTON_ACTIVE = (88, 101, 242)
    TEXT_COLOR = (255, 255, 255)
    ACCENT_COLOR = (88, 101, 242)
    SECONDARY_ACCENT = (114, 137, 218)
    GRID_COLOR = (230, 230, 230)

    # Canvas settings
    CANVAS_X, CANVAS_Y = 250, 20
    CANVAS_WIDTH, CANVAS_HEIGHT = 1030, 700
    GRID_SIZE = 20

    # Fonts
    pygame.font.init()
    FONT_REGULAR = pygame.font.Font(None, 24)
    FONT_BOLD = pygame.font.Font(None, 28)
    FONT_SMALL = pygame.font.Font(None, 20)
    FONT_LARGE = pygame.font.Font(None, 32)

    # Connection points for shapes
    class ConnectionPoint:
        def __init__(self, parent, rel_x, rel_y):
            self.parent = parent
            self.rel_x = rel_x  # Relative position (0-1)
            self.rel_y = rel_y
            self.connections = []  # List of connections to other points
        
        @property
        def abs_pos(self):
            # Get absolute position based on parent shape
            return (self.parent.rect.x + int(self.rel_x * self.parent.rect.width),
                    self.parent.rect.y + int(self.rel_y * self.parent.rect.height))
        
        def draw(self, surface, selected=False):
            x, y = self.abs_pos
            radius = 5 if selected else 3
            color = ACCENT_COLOR if selected else SECONDARY_ACCENT
            
            pygame.draw.circle(surface, color, (x, y), radius)
            
        def is_clicked(self, pos):
            x, y = self.abs_pos
            click_x, click_y = pos
            # Check if the position is within 10 pixels of the connection point
            return math.sqrt((click_x - x) ** 2 + (click_y - y) ** 2) <= 10

    class Connection:
        def __init__(self, start_point, end_point):
            self.start_point = start_point
            self.end_point = end_point
            self.selected = False
            self.style = "direct"  # Can be "direct", "orthogonal", or "curved"
            self.color = BLACK
            self.line_width = 2
            self.arrow_end = True
            self.label = ""
            
        def draw(self, surface):
            start_pos = self.start_point.abs_pos
            end_pos = self.end_point.abs_pos
            
            # Draw different connection styles
            if self.style == "direct":
                # Draw direct line
                self._draw_direct_line(surface, start_pos, end_pos)
            elif self.style == "orthogonal":
                # Draw orthogonal line (Manhattan distance)
                self._draw_orthogonal_line(surface, start_pos, end_pos)
            elif self.style == "curved":
                # Draw curved line
                self._draw_curved_line(surface, start_pos, end_pos)
            
            # Draw selection indicator if selected
            if self.selected:
                pygame.draw.line(surface, ACCENT_COLOR, start_pos, end_pos, 
                               self.line_width + 2)
            
            # Draw arrow if needed
            if self.arrow_end:
                self._draw_arrow(surface, start_pos, end_pos)
            
            # Draw label if exists
            if self.label:
                self._draw_label(surface, start_pos, end_pos)
                
        def _draw_direct_line(self, surface, start_pos, end_pos):
            pygame.draw.line(surface, self.color, start_pos, end_pos, self.line_width)
        
        def _draw_orthogonal_line(self, surface, start_pos, end_pos):
            sx, sy = start_pos
            ex, ey = end_pos
            
            # Calculate midpoint
            midx = (sx + ex) / 2
            
            # Draw three line segments
            pygame.draw.line(surface, self.color, (sx, sy), (midx, sy), self.line_width)
            pygame.draw.line(surface, self.color, (midx, sy), (midx, ey), self.line_width)
            pygame.draw.line(surface, self.color, (midx, ey), (ex, ey), self.line_width)
        
        def _draw_curved_line(self, surface, start_pos, end_pos):
            sx, sy = start_pos
            ex, ey = end_pos
            
            # Calculate control points for Bezier curve
            # Horizontal distance between points
            dx = abs(ex - sx)
            # Control points are offset by 40% of dx
            cp1 = (sx + 0.4 * dx, sy)
            cp2 = (ex - 0.4 * dx, ey)
            
            # Draw curve using a series of short lines (approximation)
            points = []
            for t in range(0, 101, 5):  # Divide into 20 segments
                t /= 100.0
                # Cubic Bezier formula
                x = (1-t)**3 * sx + 3*(1-t)**2*t * cp1[0] + 3*(1-t)*t**2 * cp2[0] + t**3 * ex
                y = (1-t)**3 * sy + 3*(1-t)**2*t * cp1[1] + 3*(1-t)*t**2 * cp2[1] + t**3 * ey
                points.append((x, y))
            
            if len(points) > 1:
                pygame.draw.lines(surface, self.color, False, points, self.line_width)
        
        def _draw_arrow(self, surface, start_pos, end_pos):
            sx, sy = start_pos
            ex, ey = end_pos
            
            # Calculate angle of the line
            angle = math.atan2(ey - sy, ex - sx)
            
            # Length of the arrow head
            arrow_length = 12
            
            # Calculate coordinates for arrowhead
            arrow1_x = ex - arrow_length * math.cos(angle - math.pi/6)
            arrow1_y = ey - arrow_length * math.sin(angle - math.pi/6)
            arrow2_x = ex - arrow_length * math.cos(angle + math.pi/6)
            arrow2_y = ey - arrow_length * math.sin(angle + math.pi/6)
            
            # Draw arrowhead
            pygame.draw.polygon(surface, self.color, [(ex, ey), 
                                                    (arrow1_x, arrow1_y), 
                                                    (arrow2_x, arrow2_y)])
        
        def _draw_label(self, surface, start_pos, end_pos):
            # Calculate position for label (midpoint of line)
            mx = (start_pos[0] + end_pos[0]) // 2
            my = (start_pos[1] + end_pos[1]) // 2
            
            # Render text
            text_surface = FONT_SMALL.render(self.label, True, BLACK)
            
            # Create background for text
            text_rect = text_surface.get_rect(center=(mx, my))
            bg_rect = text_rect.inflate(10, 6)
            
            # Draw background and text
            pygame.draw.rect(surface, WHITE, bg_rect)
            pygame.draw.rect(surface, LIGHT_GRAY, bg_rect, 1)
            surface.blit(text_surface, text_rect)
        
        def is_clicked(self, pos):
            sx, sy = self.start_point.abs_pos
            ex, ey = self.end_point.abs_pos
            click_x, click_y = pos
            
            # For simplicity, check if click is near the line
            # Calculate distance from point to line
            line_length = math.sqrt((ex - sx) ** 2 + (ey - sy) ** 2)
            if line_length == 0:
                return False
            
            # Calculate closest point on line
            t = max(0, min(1, ((click_x - sx) * (ex - sx) + (click_y - sy) * (ey - sy)) / (line_length ** 2)))
            proj_x = sx + t * (ex - sx)
            proj_y = sy + t * (ey - sy)
            
            # Calculate distance to closest point
            dist = math.sqrt((click_x - proj_x) ** 2 + (click_y - proj_y) ** 2)
            
            # Check if distance is within threshold
            threshold = 8  # Pixels
            return dist <= threshold and 0 <= t <= 1

    class ShapeType(Enum):
        RECTANGLE = "rectangle"
        ELLIPSE = "ellipse"
        DIAMOND = "diamond"
        ROUNDED_RECT = "rounded_rect"
        PARALLELOGRAM = "parallelogram"
        CYLINDER = "cylinder"
        DOCUMENT = "document"
        CLOUD = "cloud"
        HEXAGON = "hexagon"

    class Shape:
        def __init__(self, shape_type, rect, color=BLACK, fill_color=WHITE, text=""):
            self.type = shape_type
            self.rect = rect.copy()
            self.color = color
            self.fill_color = fill_color
            self.text = text
            self.selected = False
            self.connection_points = self._create_connection_points()
            self.locked = False
            self.line_width = 2
            self.font = FONT_REGULAR
            self.id = random.randint(10000, 99999)  # Unique identifier
            
        def _create_connection_points(self):
            # Create 8 connection points around the shape
            points = []
            positions = [
                (0.5, 0),    # Top center
                (1, 0.5),    # Right center
                (0.5, 1),    # Bottom center
                (0, 0.5),    # Left center
                (0, 0),      # Top left
                (1, 0),      # Top right
                (1, 1),      # Bottom right
                (0, 1)       # Bottom left
            ]
            
            for rel_x, rel_y in positions:
                points.append(ConnectionPoint(self, rel_x, rel_y))
            
            return points
        
        def draw(self, surface):
            # Draw the specific shape
            if self.type == ShapeType.RECTANGLE:
                self._draw_rectangle(surface)
            elif self.type == ShapeType.ELLIPSE:
                self._draw_ellipse(surface)
            elif self.type == ShapeType.DIAMOND:
                self._draw_diamond(surface)
            elif self.type == ShapeType.ROUNDED_RECT:
                self._draw_rounded_rect(surface)
            elif self.type == ShapeType.PARALLELOGRAM:
                self._draw_parallelogram(surface)
            elif self.type == ShapeType.CYLINDER:
                self._draw_cylinder(surface)
            elif self.type == ShapeType.DOCUMENT:
                self._draw_document(surface)
            elif self.type == ShapeType.CLOUD:
                self._draw_cloud(surface)
            elif self.type == ShapeType.HEXAGON:
                self._draw_hexagon(surface)
            
            # Draw text
            if self.text:
                self._draw_text(surface)
            
            # Draw selection border
            if self.selected:
                pygame.draw.rect(surface, ACCENT_COLOR, self.rect, 2)
                
                # Draw resize handles at corners
                handle_size = 6
                handles = [
                    (self.rect.left, self.rect.top),
                    (self.rect.right, self.rect.top),
                    (self.rect.right, self.rect.bottom),
                    (self.rect.left, self.rect.bottom)
                ]
                
                for x, y in handles:
                    pygame.draw.rect(surface, ACCENT_COLOR, 
                                   (x - handle_size//2, y - handle_size//2, handle_size, handle_size))
                
                # Draw connection points only when selected
                for point in self.connection_points:
                    point.draw(surface)
            
            # Draw lock indicator if locked
            if self.locked:
                lock_pos = (self.rect.right - 15, self.rect.top + 15)
                pygame.draw.circle(surface, LIGHT_GRAY, lock_pos, 10)
                pygame.draw.circle(surface, BLACK, lock_pos, 10, 1)
                pygame.draw.rect(surface, BLACK, (lock_pos[0]-3, lock_pos[1]-6, 6, 8))
                pygame.draw.circle(surface, BLACK, (lock_pos[0], lock_pos[1]-3), 2)
        
        def _draw_rectangle(self, surface):
            pygame.draw.rect(surface, self.fill_color, self.rect)
            pygame.draw.rect(surface, self.color, self.rect, self.line_width)
        
        def _draw_ellipse(self, surface):
            pygame.draw.ellipse(surface, self.fill_color, self.rect)
            pygame.draw.ellipse(surface, self.color, self.rect, self.line_width)
        
        def _draw_diamond(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            
            points = [
                (x + w//2, y),         # Top
                (x + w, y + h//2),     # Right
                (x + w//2, y + h),     # Bottom
                (x, y + h//2)          # Left
            ]
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.polygon(surface, self.color, points, self.line_width)
        
        def _draw_rounded_rect(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            radius = min(15, w//4, h//4)  # Rounded corner radius
            
            # Draw filled rounded rectangle
            pygame.draw.rect(surface, self.fill_color, (x+radius, y, w-2*radius, h))
            pygame.draw.rect(surface, self.fill_color, (x, y+radius, w, h-2*radius))
            
            # Draw the four corners
            pygame.draw.circle(surface, self.fill_color, (x+radius, y+radius), radius)
            pygame.draw.circle(surface, self.fill_color, (x+w-radius, y+radius), radius)
            pygame.draw.circle(surface, self.fill_color, (x+radius, y+h-radius), radius)
            pygame.draw.circle(surface, self.fill_color, (x+w-radius, y+h-radius), radius)
            
            # Draw outline
            # Top edge
            pygame.draw.line(surface, self.color, (x+radius, y), (x+w-radius, y), self.line_width)
            # Right edge
            pygame.draw.line(surface, self.color, (x+w, y+radius), (x+w, y+h-radius), self.line_width)
            # Bottom edge
            pygame.draw.line(surface, self.color, (x+radius, y+h), (x+w-radius, y+h), self.line_width)
            # Left edge
            pygame.draw.line(surface, self.color, (x, y+radius), (x, y+h-radius), self.line_width)
            
            # Draw the four corners
            pygame.draw.arc(surface, self.color, (x, y, radius*2, radius*2), math.pi, 3*math.pi/2, self.line_width)
            pygame.draw.arc(surface, self.color, (x+w-radius*2, y, radius*2, radius*2), 3*math.pi/2, 2*math.pi, self.line_width)
            pygame.draw.arc(surface, self.color, (x, y+h-radius*2, radius*2, radius*2), math.pi/2, math.pi, self.line_width)
            pygame.draw.arc(surface, self.color, (x+w-radius*2, y+h-radius*2, radius*2, radius*2), 0, math.pi/2, self.line_width)
        
        def _draw_parallelogram(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            offset = min(w//4, 20)  # Slant amount
            
            points = [
                (x + offset, y),       # Top left
                (x + w, y),            # Top right
                (x + w - offset, y + h),  # Bottom right
                (x, y + h)             # Bottom left
            ]
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.polygon(surface, self.color, points, self.line_width)
        
        def _draw_cylinder(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            ellipse_height = min(h//4, 15)
            
            # Draw body rectangle
            pygame.draw.rect(surface, self.fill_color, (x, y + ellipse_height//2, w, h - ellipse_height))
            pygame.draw.rect(surface, self.color, (x, y + ellipse_height//2, w, h - ellipse_height), self.line_width)
            
            # Draw top ellipse
            top_rect = pygame.Rect(x, y, w, ellipse_height)
            pygame.draw.ellipse(surface, self.fill_color, top_rect)
            pygame.draw.ellipse(surface, self.color, top_rect, self.line_width)
            
            # Draw bottom ellipse
            bottom_rect = pygame.Rect(x, y + h - ellipse_height, w, ellipse_height)
            pygame.draw.ellipse(surface, self.fill_color, bottom_rect)
            pygame.draw.ellipse(surface, self.color, bottom_rect, self.line_width)
        
        def _draw_document(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            wave_height = min(h//6, 15)
            
            # Main rectangle
            pygame.draw.rect(surface, self.fill_color, (x, y, w, h - wave_height))
            pygame.draw.rect(surface, self.color, (x, y, w, h - wave_height), self.line_width)
            
            # Bottom wavy part
            points = [(x, y + h - wave_height)]
            steps = 4
            step_width = w / steps
            
            for i in range(1, steps + 1):
                if i % 2 == 1:  # Odd step, goes down
                    points.append((x + i * step_width, y + h))
                else:  # Even step, goes up
                    points.append((x + i * step_width, y + h - wave_height))
            
            # Connect back to rectangle
            points.append((x + w, y + h - wave_height))
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.lines(surface, self.color, False, points, self.line_width)
        
        def _draw_cloud(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            
            # Draw cloud as a series of overlapping circles
            circles = [
                (x + w // 4, y + h // 3, min(w, h) // 3),
                (x + w // 2, y + h // 4, min(w, h) // 4),
                (x + 3 * w // 4, y + h // 3, min(w, h) // 3),
                (x + w // 5, y + 2 * h // 3, min(w, h) // 4),
                (x + w // 2, y + 3 * h // 4, min(w, h) // 3),
                (x + 3 * w // 4, y + 2 * h // 3, min(w, h) // 4)
            ]
            
            # Draw filled circles
            for cx, cy, r in circles:
                pygame.draw.circle(surface, self.fill_color, (cx, cy), r)
            
            # Draw outlines
            for cx, cy, r in circles:
                pygame.draw.circle(surface, self.color, (cx, cy), r, self.line_width)
        
        def _draw_hexagon(self, surface):
            x, y = self.rect.x, self.rect.y
            w, h = self.rect.width, self.rect.height
            
            points = [
                (x + w//4, y),                # Top left
                (x + 3*w//4, y),              # Top right
                (x + w, y + h//2),            # Right
                (x + 3*w//4, y + h),          # Bottom right
                (x + w//4, y + h),            # Bottom left
                (x, y + h//2)                 # Left
            ]
            
            pygame.draw.polygon(surface, self.fill_color, points)
            pygame.draw.polygon(surface, self.color, points, self.line_width)
        
        def _draw_text(self, surface):
            # Render text with wrapping
            lines = self._wrap_text()
            
            # Calculate total height of text
            line_height = self.font.get_height()
            total_height = line_height * len(lines)
            
            # Start position for first line (centered vertically)
            start_y = self.rect.y + (self.rect.height - total_height) // 2
            
            # Draw each line
            for i, line in enumerate(lines):
                text_surface = self.font.render(line, True, BLACK)
                text_rect = text_surface.get_rect(centerx=self.rect.centerx, y=start_y + i * line_height)
                surface.blit(text_surface, text_rect)
        
        def _wrap_text(self):
            # Split text into lines to fit width
            max_width = self.rect.width - 20  # Margin
            words = self.text.split()
            lines = []
            current_line = []
            
            for word in words:
                # Try adding the word to the current line
                test_line = ' '.join(current_line + [word])
                width, _ = self.font.size(test_line)
                
                if width <= max_width or not current_line:
                    current_line.append(word)
                else:
                    lines.append(' '.join(current_line))
                    current_line = [word]
            
            # Add the last line
            if current_line:
                lines.append(' '.join(current_line))
            
            return lines
        
        def contains_point(self, point):
            return self.rect.collidepoint(point)
        
        def get_connection_point_at(self, pos):
            for point in self.connection_points:
                if point.is_clicked(pos):
                    return point
            return None
        
        def move(self, dx, dy):
            if not self.locked:
                self.rect.x += dx
                self.rect.y += dy
        
        def resize(self, corner, dx, dy):
            if self.locked:
                return
                
            x, y = self.rect.topleft
            w, h = self.rect.size
            
            # Minimum size constraints
            MIN_SIZE = 30
            
            # Resize based on which corner is being dragged
            if corner == "topleft":
                new_x = x + dx
                new_y = y + dy
                new_w = w - dx
                new_h = h - dy
            elif corner == "topright":
                new_x = x
                new_y = y + dy
                new_w = w + dx
                new_h = h - dy
            elif corner == "bottomright":
                new_x = x
                new_y = y
                new_w = w + dx
                new_h = h + dy
            elif corner == "bottomleft":
                new_x = x + dx
                new_y = y
                new_w = w - dx
                new_h = h + dy
            
            # Apply constraints
            if new_w < MIN_SIZE:
                if corner in ["topleft", "bottomleft"]:
                    new_x = x + w - MIN_SIZE
                new_w = MIN_SIZE
            
            if new_h < MIN_SIZE:
                if corner in ["topleft", "topright"]:
                    new_y = y + h - MIN_SIZE
                new_h = MIN_SIZE
            
            # Update rectangle
            self.rect = pygame.Rect(new_x, new_y, new_w, new_h)

    class DiagramEditor:
        def __init__(self):
            # App states
            self.shapes = []
            self.connections = []
            self.current_tool = "select"
            self.current_shape_type = ShapeType.RECTANGLE
            self.current_color = BLACK
            self.current_fill_color = WHITE
            self.current_connection_style = "direct"
            
            # Selection and creation states
            self.selected_shape = None
            self.selected_connection = None
            self.selected_connection_point = None
            self.temp_connection_start = None
            self.is_moving = False
            self.is_resizing = False
            self.resize_corner = ""
            self.creation_start_pos = None
            self.mouse_pos = (0, 0)
            self.last_mouse_pos = (0, 0)
            self.double_click_time = 0
            self.show_grid = True
            
            # Text editing states
            self.text_input_active = False
            self.current_text = ""
            self.text_input_rect = pygame.Rect(CANVAS_X, HEIGHT - 40, 400, 30)
            
            # Toolbar and menu buttons
            self.buttons = self._create_buttons()
            self.shape_buttons = self._create_shape_buttons()
            self.color_buttons = self._create_color_buttons()
            self.connection_buttons = self._create_connection_buttons()
            
            # Create the canvas surface
            self.canvas = pygame.Surface((CANVAS_WIDTH, CANVAS_HEIGHT))
            self.canvas.fill(WHITE)
            
            # Undo/Redo History
            self.history = []
            self.history_position = -1
            self.save_state()  # Save initial empty state
        
        def _create_buttons(self):
            buttons = {
                "select": {"rect": pygame.Rect(20, 70, 160, 40), "text": "Select", "active": True},
                "create": {"rect": pygame.Rect(20, 120, 160, 40), "text": "Create Shape", "active": False},
                "connect": {"rect": pygame.Rect(20, 170, 160, 40), "text": "Connect", "active": False},
                "text": {"rect": pygame.Rect(20, 220, 160, 40), "text": "Add Text", "active": False},
                "delete": {"rect": pygame.Rect(20, 270, 160, 40), "text": "Delete", "active": False},
                "grid": {"rect": pygame.Rect(20, 320, 160, 40), "text": "Toggle Grid", "active": self.show_grid},
                "undo": {"rect": pygame.Rect(20, HEIGHT - 140, 75, 40), "text": "Undo", "active": False},
                "redo": {"rect": pygame.Rect(105, HEIGHT - 140, 75, 40), "text": "Redo", "active": False},
                "clear": {"rect": pygame.Rect(20, HEIGHT - 90, 160, 40), "text": "Clear All", "active": False},
                "save": {"rect": pygame.Rect(20, HEIGHT - 40, 160, 40), "text": "Save Diagram", "active": False}
            }
            return buttons
        
        def _create_shape_buttons(self):
            buttons = {}
            shape_types = [
                (ShapeType.RECTANGLE, "Rectangle"),
                (ShapeType.ELLIPSE, "Ellipse"),
                (ShapeType.DIAMOND, "Diamond"),
                (ShapeType.ROUNDED_RECT, "Rounded Rect"),
                (ShapeType.PARALLELOGRAM, "Parallelogram"),
                (ShapeType.CYLINDER, "Cylinder"),
                (ShapeType.DOCUMENT, "Document"),
                (ShapeType.HEXAGON, "Hexagon"),
            ]
            
            y_pos = 370
            for shape_type, name in shape_types:
                buttons[shape_type] = {
                    "rect": pygame.Rect(20, y_pos, 160, 30),
                    "text": name,
                    "active": shape_type == self.current_shape_type
                }
                y_pos += 35
            
            return buttons
        
        def _create_color_buttons(self):
            colors = [
                (BLACK, "Black"),
                (BLUE, "Blue"),
                (GREEN, "Green"),
                (RED, "Red"),
                (PURPLE, "Purple"),
                (ORANGE, "Orange")
            ]
            
            fill_colors = [
                (WHITE, "White"),
                (LIGHT_BLUE, "Light Blue"),
                (TURQUOISE, "Turquoise"),
                (YELLOW, "Yellow"),
                (LIGHT_GRAY, "Light Gray")
            ]
            
            buttons = {}
            
            # Outline color buttons
            x_pos = 200
            y_pos = HEIGHT - 80
            for color, name in colors:
                buttons[color] = {
                    "rect": pygame.Rect(x_pos, y_pos, 30, 30),
                    "color": color,
                    "text": "",
                    "type": "outline"
                }
                x_pos += 40
            
            # Fill color buttons
            x_pos = 200
            y_pos = HEIGHT - 40
            for color, name in fill_colors:
                buttons[color] = {
                    "rect": pygame.Rect(x_pos, y_pos, 30, 30),
                    "color": color,
                    "text": "",
                    "type": "fill"
                }
                x_pos += 40
            
            return buttons
        
        def _create_connection_buttons(self):
            buttons = {
                "direct": {"rect": pygame.Rect(460, HEIGHT - 80, 100, 30), "text": "Direct", "active": True},
                "orthogonal": {"rect": pygame.Rect(570, HEIGHT - 80, 100, 30), "text": "Orthogonal", "active": False},
                "curved": {"rect": pygame.Rect(680, HEIGHT - 80, 100, 30), "text": "Curved", "active": False},
                "arrow": {"rect": pygame.Rect(460, HEIGHT - 40, 100, 30), "text": "Toggle Arrow", "active": True},
                "label": {"rect": pygame.Rect(570, HEIGHT - 40, 100, 30), "text": "Add Label", "active": False}
            }
            return buttons
        
        def save_state(self):
            # Capture the current state for undo/redo
            state = {
                "shapes": [self._serialize_shape(shape) for shape in self.shapes],
                "connections": [self._serialize_connection(conn) for conn in self.connections]
            }
            
            # If we're not at the end of the history, truncate
            if self.history_position < len(self.history) - 1:
                self.history = self.history[:self.history_position + 1]
            
            self.history.append(state)
            self.history_position = len(self.history) - 1
            
            # Enable/disable undo/redo buttons
            self.buttons["undo"]["active"] = self.history_position > 0
            self.buttons["redo"]["active"] = self.history_position < len(self.history) - 1
        
        def _serialize_shape(self, shape):
            # Convert shape to serializable dictionary
            return {
                "type": shape.type.value,
                "rect": (shape.rect.x, shape.rect.y, shape.rect.width, shape.rect.height),
                "color": shape.color,
                "fill_color": shape.fill_color,
                "text": shape.text,
                "locked": shape.locked,
                "id": shape.id
            }
        
        def _serialize_connection(self, conn):
            # Convert connection to serializable dictionary
            return {
                "start_shape_id": conn.start_point.parent.id,
                "start_point_index": conn.start_point.parent.connection_points.index(conn.start_point),
                "end_shape_id": conn.end_point.parent.id,
                "end_point_index": conn.end_point.parent.connection_points.index(conn.end_point),
                "style": conn.style,
                "color": conn.color,
                "line_width": conn.line_width,
                "arrow_end": conn.arrow_end,
                "label": conn.label
            }
        
        def restore_state(self, state_idx):
            if 0 <= state_idx < len(self.history):
                # Load the state at the given index
                state = self.history[state_idx]
                
                # Clear current state
                self.shapes = []
                self.connections = []
                self.selected_shape = None
                self.selected_connection = None
                
                # Restore shapes first
                shape_map = {}  # Maps shape IDs to restored shapes
                for shape_data in state["shapes"]:
                    shape_type = ShapeType(shape_data["type"])
                    rect = pygame.Rect(*shape_data["rect"])
                    
                    shape = Shape(shape_type, rect, 
                                 color=shape_data["color"],
                                 fill_color=shape_data["fill_color"],
                                 text=shape_data["text"])
                    shape.locked = shape_data["locked"]
                    shape.id = shape_data["id"]
                    
                    self.shapes.append(shape)
                    shape_map[shape.id] = shape
                
                # Restore connections
                for conn_data in state["connections"]:
                    # Find the referenced shapes
                    start_shape = shape_map.get(conn_data["start_shape_id"])
                    end_shape = shape_map.get(conn_data["end_shape_id"])
                    
                    if start_shape and end_shape:
                        # Get the connection points
                        start_point = start_shape.connection_points[conn_data["start_point_index"]]
                        end_point = end_shape.connection_points[conn_data["end_point_index"]]
                        
                        # Create the connection
                        conn = Connection(start_point, end_point)
                        conn.style = conn_data["style"]
                        conn.color = conn_data["color"]
                        conn.line_width = conn_data["line_width"]
                        conn.arrow_end = conn_data["arrow_end"]
                        conn.label = conn_data["label"]
                        
                        self.connections.append(conn)
                
                self.history_position = state_idx
                
                # Update undo/redo buttons
                self.buttons["undo"]["active"] = self.history_position > 0
                self.buttons["redo"]["active"] = self.history_position < len(self.history) - 1
        
        def undo(self):
            if self.history_position > 0:
                self.restore_state(self.history_position - 1)
        
        def redo(self):
            if self.history_position < len(self.history) - 1:
                self.restore_state(self.history_position + 1)
        
        def draw(self, surface):
            # Draw the sidebar
            pygame.draw.rect(surface, SIDEBAR_BG, (0, 0, CANVAS_X, HEIGHT))
            
            # Draw title
            title_text = FONT_LARGE.render("Diagram Editor", True, WHITE)
            surface.blit(title_text, (20, 20))
            
            # Draw buttons
            for button_id, button in self.buttons.items():
                color = BUTTON_ACTIVE if button["active"] else BUTTON_IDLE
                pygame.draw.rect(surface, color, button["rect"], border_radius=5)
                
                text = FONT_REGULAR.render(button["text"], True, WHITE)
                text_rect = text.get_rect(center=button["rect"].center)
                surface.blit(text, text_rect)
            
            # Draw shape buttons if create tool is active
            if self.current_tool == "create":
                shape_title = FONT_BOLD.render("Shape Types:", True, WHITE)
                surface.blit(shape_title, (20, 340))
                
                for shape_type, button in self.shape_buttons.items():
                    color = BUTTON_ACTIVE if button["active"] else BUTTON_IDLE
                    pygame.draw.rect(surface, color, button["rect"], border_radius=3)
                    
                    text = FONT_SMALL.render(button["text"], True, WHITE)
                    text_rect = text.get_rect(center=button["rect"].center)
                    surface.blit(text, text_rect)
            
            # Draw color picker section
            color_title = FONT_BOLD.render("Colors:", True, PURPLE)
            surface.blit(color_title, (200, HEIGHT - 110))
            
            for color, button in self.color_buttons.items():
                border_color = ACCENT_COLOR if (button["type"] == "outline" and color == self.current_color) or \
                                              (button["type"] == "fill" and color == self.current_fill_color) else DARK_GRAY
                
                pygame.draw.rect(surface, button["color"], button["rect"])
                pygame.draw.rect(surface, border_color, button["rect"], 2)
            
            # Draw connection style buttons if connect tool is active
            if self.current_tool == "connect":
                conn_title = FONT_BOLD.render("Connection Style:", True, WHITE)
                surface.blit(conn_title, (460, HEIGHT - 110))
                
                for style, button in self.connection_buttons.items():
                    color = BUTTON_ACTIVE if button["active"] else BUTTON_IDLE
                    pygame.draw.rect(surface, color, button["rect"], border_radius=3)
                    
                    text = FONT_SMALL.render(button["text"], True, WHITE)
                    text_rect = text.get_rect(center=button["rect"].center)
                    surface.blit(text, text_rect)
            
            # Draw canvas background
            pygame.draw.rect(surface, WHITE, (CANVAS_X, CANVAS_Y, CANVAS_WIDTH, CANVAS_HEIGHT))
            
            # Draw grid if enabled
            if self.show_grid:
                for x in range(CANVAS_X, CANVAS_X + CANVAS_WIDTH + 1, GRID_SIZE):
                    pygame.draw.line(surface, GRID_COLOR, (x, CANVAS_Y), (x, CANVAS_Y + CANVAS_HEIGHT))
                for y in range(CANVAS_Y, CANVAS_Y + CANVAS_HEIGHT + 1, GRID_SIZE):
                    pygame.draw.line(surface, GRID_COLOR, (CANVAS_X, y), (CANVAS_X + CANVAS_WIDTH, y))
            
            # Draw connections
            for conn in self.connections:
                conn.draw(surface)
            
            # Draw shapes
            for shape in self.shapes:
                shape.draw(surface)
            
            # Draw temporary connection line if creating a connection
            if self.temp_connection_start and self.current_tool == "connect":
                start_pos = self.temp_connection_start.abs_pos
                # Draw line to mouse position
                pygame.draw.line(surface, ACCENT_COLOR, start_pos, self.mouse_pos, 2)
                
                # Draw a little circle at mouse pos
                pygame.draw.circle(surface, ACCENT_COLOR, self.mouse_pos, 5, 2)
            
            # Draw shape preview while creating
            if self.creation_start_pos and self.current_tool == "create":
                preview_rect = self._get_rect_from_points(self.creation_start_pos, self.mouse_pos)
                
                # Draw different shape previews based on current shape type
                if self.current_shape_type == ShapeType.RECTANGLE:
                    pygame.draw.rect(surface, self.current_fill_color, preview_rect)
                    pygame.draw.rect(surface, self.current_color, preview_rect, 2)
                
                elif self.current_shape_type == ShapeType.ELLIPSE:
                    pygame.draw.ellipse(surface, self.current_fill_color, preview_rect)
                    pygame.draw.ellipse(surface, self.current_color, preview_rect, 2)
                
                # For other shapes, just draw a rectangle outline as placeholder
                else:
                    pygame.draw.rect(surface, self.current_color, preview_rect, 1)
            
            # Draw text input box if active
            if self.text_input_active:
                pygame.draw.rect(surface, WHITE, self.text_input_rect)
                pygame.draw.rect(surface, BLACK, self.text_input_rect, 2)
                
                text_surface = FONT_REGULAR.render(self.current_text, True, BLACK)
                surface.blit(text_surface, (self.text_input_rect.x + 5, self.text_input_rect.y + 5))
        
        def handle_event(self, event):
            self.mouse_pos = pygame.mouse.get_pos()
            
            if event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Left click
                    # Check for double click
                    current_time = pygame.time.get_ticks()
                    is_double_click = current_time - self.double_click_time < 300
                    self.double_click_time = current_time
                    
                    self._handle_mouse_down(is_double_click)
                
            elif event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:  # Left button release
                    self._handle_mouse_up()
            
            elif event.type == pygame.MOUSEMOTION:
                self._handle_mouse_motion(event.rel)
            
            elif event.type == pygame.KEYDOWN:
                self._handle_key_down(event)
        
        def _handle_mouse_down(self, is_double_click):
            # Check if clicked on a button in the sidebar
            for button_id, button in self.buttons.items():
                if button["rect"].collidepoint(self.mouse_pos):
                    self._handle_button_click(button_id)
                    return
            
            # Check if clicked on a shape button
            if self.current_tool == "create":
                for shape_type, button in self.shape_buttons.items():
                    if button["rect"].collidepoint(self.mouse_pos):
                        # Set current shape type
                        self.current_shape_type = shape_type
                        # Update buttons
                        for st, btn in self.shape_buttons.items():
                            btn["active"] = (st == shape_type)
                        return
            
            # Check if clicked on a color button
            for color, button in self.color_buttons.items():
                if button["rect"].collidepoint(self.mouse_pos):
                    if button["type"] == "outline":
                        self.current_color = color
                    elif button["type"] == "fill":
                        self.current_fill_color = color
                    return
            
            # Check if clicked on a connection style button
            if self.current_tool == "connect":
                for style, button in self.connection_buttons.items():
                    if button["rect"].collidepoint(self.mouse_pos):
                        if style in ["direct", "orthogonal", "curved"]:
                            # Set connection style
                            self.current_connection_style = style
                            # Update buttons
                            for s, btn in self.connection_buttons.items():
                                if s in ["direct", "orthogonal", "curved"]:
                                    btn["active"] = (s == style)
                        elif style == "arrow":
                            # Toggle arrow setting
                            button["active"] = not button["active"]
                        elif style == "label" and self.selected_connection:
                            # Prompt for label
                            self.text_input_active = True
                            self.current_text = self.selected_connection.label
                        return
            
            # Handle actions within the canvas
            if self._is_point_on_canvas(self.mouse_pos):
                # Reset text input
                self.text_input_active = False
                
                # Different handling based on current tool
                if self.current_tool == "select":
                    self._handle_select_tool_click(is_double_click)
                
                elif self.current_tool == "create":
                    # Start shape creation
                    self.creation_start_pos = self.mouse_pos
                
                elif self.current_tool == "connect":
                    self._handle_connect_tool_click()
                
                elif self.current_tool == "text" and self.selected_shape:
                    # Start text input for selected shape
                    self.text_input_active = True
                    self.current_text = self.selected_shape.text
                
                elif self.current_tool == "delete":
                    self._handle_delete_tool_click()
        
        def _handle_select_tool_click(self, is_double_click):
            # First, check if clicking on a connection point of the selected shape
            if self.selected_shape:
                for point in self.selected_shape.connection_points:
                    if point.is_clicked(self.mouse_pos):
                        self.selected_connection_point = point
                        return
            
            # Next, check if clicking on a resize handle of selected shape
            if self.selected_shape and self.selected_shape.selected and not self.selected_shape.locked:
                corner = self._get_resize_corner_at_pos(self.mouse_pos)
                if corner:
                    self.is_resizing = True
                    self.resize_corner = corner
                    return
            
            # Check if a connection was clicked
            for conn in self.connections:
                if conn.is_clicked(self.mouse_pos):
                    self._select_connection(conn)
                    return
            
            # Check if a shape was clicked (in reverse order to handle overlap)
            for shape in reversed(self.shapes):
                if shape.contains_point(self.mouse_pos):
                    if is_double_click and self.current_tool == "select" and shape == self.selected_shape:
                        # Double-click on selected shape - edit text
                        self.text_input_active = True
                        self.current_text = shape.text
                    else:
                        # Single-click - select and potentially move
                        self._select_shape(shape)
                        self.is_moving = True
                    return
            
            # If clicked on empty space, deselect everything
            self._deselect_all()
        
        def _handle_connect_tool_click(self):
            # Check if clicking on a connection point
            for shape in self.shapes:
                conn_point = shape.get_connection_point_at(self.mouse_pos)
                if conn_point:
                    if not self.temp_connection_start:
                        # Start new connection
                        self.temp_connection_start = conn_point
                    else:
                        # Complete connection
                        if conn_point != self.temp_connection_start:
                            new_conn = Connection(self.temp_connection_start, conn_point)
                            new_conn.style = self.current_connection_style
                            new_conn.arrow_end = self.connection_buttons["arrow"]["active"]
                            
                            self.connections.append(new_conn)
                            self._select_connection(new_conn)
                            
                            # Save state for undo/redo
                            self.save_state()
                        
                        # Reset temporary connection
                        self.temp_connection_start = None
                    return
            
            # If clicked on empty space, cancel connection
            self.temp_connection_start = None
        
        def _handle_delete_tool_click(self):
            # Check if a connection was clicked
            for i, conn in enumerate(self.connections):
                if conn.is_clicked(self.mouse_pos):
                    del self.connections[i]
                    self._deselect_all()
                    self.save_state()
                    return
            
            # Check if a shape was clicked
            for i, shape in enumerate(self.shapes):
                if shape.contains_point(self.mouse_pos):
                    # Delete shape and any connections to it
                    self.connections = [c for c in self.connections 
                                       if c.start_point.parent != shape and c.end_point.parent != shape]
                    del self.shapes[i]
                    self._deselect_all()
                    self.save_state()
                    return
        
        def _handle_mouse_up(self):
            # Finish moving or resizing
            if (self.is_moving or self.is_resizing) and self.selected_shape:
                # Save state for undo/redo
                self.save_state()
            
            self.is_moving = False
            self.is_resizing = False
            self.selected_connection_point = None
            
            # Finish creating shape
            if self.creation_start_pos and self.current_tool == "create":
                rect = self._get_rect_from_points(self.creation_start_pos, self.mouse_pos)
                
                # Only create shapes with minimum size
                if rect.width > 10 and rect.height > 10:
                    shape = Shape(self.current_shape_type, rect, 
                                 color=self.current_color, 
                                 fill_color=self.current_fill_color)
                    self.shapes.append(shape)
                    self._select_shape(shape)
                    
                    # Save state for undo/redo
                    self.save_state()
                
                self.creation_start_pos = None
        
        def _handle_mouse_motion(self, rel):
            dx, dy = rel
            
            # Handle shape moving
            if self.is_moving and self.selected_shape and not self.selected_shape.locked:
                self.selected_shape.move(dx, dy)
            
            # Handle shape resizing
            elif self.is_resizing and self.selected_shape and not self.selected_shape.locked:
                self.selected_shape.resize(self.resize_corner, dx, dy)
        
        def _handle_key_down(self, event):
            # Handle text input
            if self.text_input_active:
                if event.key == pygame.K_RETURN:
                    # Confirm text input
                    if self.selected_shape:
                        self.selected_shape.text = self.current_text
                    elif self.selected_connection:
                        self.selected_connection.label = self.current_text
                    
                    self.text_input_active = False
                    # Save state for undo/redo
                    self.save_state()
                
                elif event.key == pygame.K_ESCAPE:
                    # Cancel text input
                    self.text_input_active = False
                
                elif event.key == pygame.K_BACKSPACE:
                    # Handle backspace
                    self.current_text = self.current_text[:-1]
                
                else:
                    # Add character to text if printable
                    if event.unicode and ord(event.unicode) >= 32:
                        self.current_text += event.unicode
            
            else:
                # Handle other keyboard shortcuts
                if event.key == pygame.K_DELETE and self.current_tool == "select":
                    if self.selected_shape:
                        # Delete selected shape
                        self.shapes.remove(self.selected_shape)
                        # Delete associated connections
                        self.connections = [c for c in self.connections 
                                           if c.start_point.parent != self.selected_shape 
                                           and c.end_point.parent != self.selected_shape]
                        self._deselect_all()
                        self.save_state()
                    
                    elif self.selected_connection:
                        # Delete selected connection
                        self.connections.remove(self.selected_connection)
                        self._deselect_all()
                        self.save_state()
                
                elif event.key == pygame.K_l and self.selected_shape:
                    # Toggle lock on selected shape
                    self.selected_shape.locked = not self.selected_shape.locked
                    self.save_state()
                
                elif event.key == pygame.K_z and event.mod & pygame.KMOD_CTRL:
                    # Undo
                    self.undo()
                
                elif event.key == pygame.K_y and event.mod & pygame.KMOD_CTRL:
                    # Redo
                    self.redo()
                
                elif event.key == pygame.K_g:
                    # Toggle grid
                    self.show_grid = not self.show_grid
                    self.buttons["grid"]["active"] = self.show_grid
        
        def _handle_button_click(self, button_id):
            # Handle toolbar button clicks
            if button_id in ["select", "create", "connect", "text", "delete"]:
                # Set current tool
                self.current_tool = button_id
                
                # Update button states
                for tool, button in self.buttons.items():
                    if tool in ["select", "create", "connect", "text", "delete"]:
                        button["active"] = (tool == button_id)
            
            elif button_id == "grid":
                # Toggle grid
                self.show_grid = not self.show_grid
                self.buttons["grid"]["active"] = self.show_grid
            
            elif button_id == "clear":
                # Clear all shapes and connections
                self.shapes = []
                self.connections = []
                self._deselect_all()
                self.save_state()
            
            elif button_id == "undo":
                self.undo()
            
            elif button_id == "redo":
                self.redo()
            
            elif button_id == "save":
                # Save functionality would go here
                # For now, just print a message
                print("Save functionality not implemented yet")
        
        def _select_shape(self, shape):
            # Deselect current shape and connection
            self._deselect_all()
            
            # Select new shape
            shape.selected = True
            self.selected_shape = shape
        
        def _select_connection(self, connection):
            # Deselect current shape and connection
            self._deselect_all()
            
            # Select new connection
            connection.selected = True
            self.selected_connection = connection
        
        def _deselect_all(self):
            # Deselect any selected shape
            if self.selected_shape:
                self.selected_shape.selected = False
                self.selected_shape = None
            
            # Deselect any selected connection
            if self.selected_connection:
                self.selected_connection.selected = False
                self.selected_connection = None
        
        def _is_point_on_canvas(self, point):
            x, y = point
            return (CANVAS_X <= x <= CANVAS_X + CANVAS_WIDTH and 
                    CANVAS_Y <= y <= CANVAS_Y + CANVAS_HEIGHT)
        
        def _get_rect_from_points(self, start_pos, end_pos):
            x1, y1 = start_pos
            x2, y2 = end_pos
            
            # Ensure x1,y1 is the top-left and x2,y2 is the bottom-right
            left = min(x1, x2)
            top = min(y1, y2)
            width = abs(x2 - x1)
            height = abs(y2 - y1)
            
            # Snap to grid if enabled
            if self.show_grid:
                left = CANVAS_X + round((left - CANVAS_X) / GRID_SIZE) * GRID_SIZE
                top = CANVAS_Y + round((top - CANVAS_Y) / GRID_SIZE) * GRID_SIZE
                width = round(width / GRID_SIZE) * GRID_SIZE
                height = round(height / GRID_SIZE) * GRID_SIZE
            
            return pygame.Rect(left, top, width, height)
        
        def _get_resize_corner_at_pos(self, pos):
            # Check if pos is on one of the resize handles
            if not self.selected_shape:
                return None
            
            rect = self.selected_shape.rect
            mx, my = pos
            handle_size = 8  # Half-size of handle hitbox
            
            # Check each corner
            if abs(mx - rect.left) <= handle_size and abs(my - rect.top) <= handle_size:
                return "topleft"
            elif abs(mx - rect.right) <= handle_size and abs(my - rect.top) <= handle_size:
                return "topright"
            elif abs(mx - rect.right) <= handle_size and abs(my - rect.bottom) <= handle_size:
                return "bottomright"
            elif abs(mx - rect.left) <= handle_size and abs(my - rect.bottom) <= handle_size:
                return "bottomleft"
            
            return None

    def main():
        clock = pygame.time.Clock()
        editor = DiagramEditor()
        
        running = True
        while running:
            # Process events
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type in [pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION, pygame.KEYDOWN]:
                    editor.handle_event(event)
            
            # Clear the screen
            screen.fill(BACKGROUND)
            
            # Draw the editor
            editor.draw(screen)
            
            # Update the display
            pygame.display.flip()
            
            # Cap the frame rate
            clock.tick(60)
        
        pygame.quit()
        sys.exit()

    if __name__ == "__main__":
        main()
        
if termadm == 6745:
    import os
    import sys
    import platform
    import psutil
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    import threading
    import time
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class RetroHackerExplorer:
        def __init__(self, rootscrtscrt):
            self.rootscrtscrt = rootscrtscrt
            self.rootscrtscrt.title("System Explorer")
            self.rootscrtscrt.geometry("1000x700")
            self.rootscrtscrt.configure(bg="#000000")
            
            # Define color scheme
            self.colors = {
                "bg": "#000000", # Black background
                "text": "#00FF00", # Green text
                "highlight": "#00FFFF", # Cyan highlights
                "dark": "#003300", # Dark green for panels
                "frame": "#001100", # Very dark green for frames
                "selected": "#6272a4"
            }
            
            # Apply a custom style
            self.style = ttk.Style()
            self.style.theme_use('default')
            self.style.configure('TFrame', background=self.colors["bg"])
            self.style.configure('TButton', 
                                 background=self.colors["dark"], 
                                 foreground=self.colors["text"],
                                 borderwidth=2,
                                 relief=tk.RIDGE)
            self.style.map('TButton', 
                           background=[('active', self.colors["highlight"])],
                           foreground=[('active', self.colors["bg"])])
            self.style.configure('TLabel', 
                                 background=self.colors["bg"], 
                                 foreground=self.colors["text"])
            self.style.configure('TTreeview', 
                                 background=self.colors["bg"], 
                                 foreground=self.colors["text"],
                                 fieldbackground=self.colors["bg"])
            self.style.map('TTreeview', 
                           background=[('selected', self.colors["dark"])],
                           foreground=[('selected', self.colors["highlight"])])
            
            # Create main frame
            self.main_frame = ttk.Frame(self.rootscrtscrt)
            self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Title with "hacker-style" animation
            self.title_frame = ttk.Frame(self.main_frame)
            self.title_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.title_label = tk.Label(self.title_frame, 
                                       text="SYSTEM EXPLORER", 
                                       font=("Courier New", 18, "bold"),
                                       bg=self.colors["bg"], 
                                       fg=self.colors["highlight"])
            self.title_label.pack(side=tk.LEFT, padx=5)
            
            # System info panel
            self.sys_frame = tk.Frame(self.main_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.sys_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.sys_title = tk.Label(self.sys_frame, 
                                     text="[ SYSTEM INFORMATION ]", 
                                     font=("Courier New", 12, "bold"),
                                     bg=self.colors["frame"], 
                                     fg=self.colors["highlight"])
            self.sys_title.pack(anchor=tk.W, padx=5, pady=2)
            
            self.sys_info = tk.Text(self.sys_frame, 
                                   height=6, 
                                   font=("Courier New", 10),
                                   bg=self.colors["dark"], 
                                   fg=self.colors["text"],
                                   insertbackground=self.colors["highlight"])
            self.sys_info.pack(fill=tk.X, padx=5, pady=5)
            
            # Split main area into two panels
            self.content_frame = ttk.Frame(self.main_frame)
            self.content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Left panel for file explorer
            self.explorer_frame = tk.Frame(self.content_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.explorer_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            self.explorer_title = tk.Label(self.explorer_frame, 
                                          text="[ FILE EXPLORER ]", 
                                          font=("Courier New", 12, "bold"),
                                          bg=self.colors["frame"], 
                                          fg=self.colors["highlight"])
            self.explorer_title.pack(anchor=tk.W, padx=5, pady=2)
            
            # Path entry
            self.path_frame = tk.Frame(self.explorer_frame, bg=self.colors["frame"])
            self.path_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.path_label = tk.Label(self.path_frame, 
                                      text="PATH:", 
                                      font=("Courier New", 10),
                                      bg=self.colors["frame"], 
                                      fg=self.colors["text"])
            self.path_label.pack(side=tk.LEFT, padx=2)
            
            self.path_var = tk.StringVar()
            self.path_entry = tk.Entry(self.path_frame, 
                                      textvariable=self.path_var,
                                      font=("Courier New", 10),
                                      bg=self.colors["dark"], 
                                      fg=self.colors["text"],
                                      insertbackground=self.colors["highlight"])
            self.path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            self.go_button = tk.Button(self.path_frame, 
                                      text="GO", 
                                      font=("Courier New", 10, "bold"),
                                      bg=self.colors["dark"], 
                                      fg=self.colors["text"],
                                      activebackground=self.colors["highlight"],
                                      activeforeground=self.colors["bg"],
                                      command=self.navigate_to_path)
            self.go_button.pack(side=tk.LEFT, padx=2)
            
            # Aplicare stil pentru Treeview
            style = ttk.Style()
            style.configure("Treeview", 
                background=self.colors["dark"], 
                foreground=self.colors["text"], 
                fieldbackground=self.colors["dark"],
                rowheight=25
            )
            style.map("Treeview", 
                background=[("selected", self.colors["selected"])],
                foreground=[("selected", "#ffffff")]
            )
            style.configure("Treeview.Heading", 
                background=self.colors["bg"], 
                foreground=self.colors["text"], 
                font=("Arial", 10, "bold")
            )

            # File tree
            self.tree_frame = tk.Frame(self.explorer_frame, bg=self.colors["dark"])
            self.tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

            self.tree_scroll = tk.Scrollbar(self.tree_frame)
            self.tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

            self.file_tree = ttk.Treeview(self.tree_frame, style="Treeview")
            self.file_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.tree_scroll.config(command=self.file_tree.yview)
            self.file_tree.config(yscrollcommand=self.tree_scroll.set)

            self.file_tree["columns"] = ("size", "modified", "type")
            self.file_tree.column("#0", width=200, minwidth=150)
            self.file_tree.column("size", width=100, minwidth=50)
            self.file_tree.column("modified", width=150, minwidth=100)
            self.file_tree.column("type", width=100, minwidth=50)

            self.file_tree.heading("#0", text="Name")
            self.file_tree.heading("size", text="Size")
            self.file_tree.heading("modified", text="Modified")
            self.file_tree.heading("type", text="Type")

            self.file_tree.bind("<Double-1>", self.on_tree_double_click)

            
            # Right panel for system monitoring
            self.monitor_frame = tk.Frame(self.content_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.monitor_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            self.monitor_title = tk.Label(self.monitor_frame, 
                                         text="[ SYSTEM MONITOR ]", 
                                         font=("Courier New", 12, "bold"),
                                         bg=self.colors["frame"], 
                                         fg=self.colors["highlight"])
            self.monitor_title.pack(anchor=tk.W, padx=5, pady=2)
            
            # CPU usage
            self.cpu_frame = tk.Frame(self.monitor_frame, bg=self.colors["frame"])
            self.cpu_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.cpu_label = tk.Label(self.cpu_frame, 
                                     text="CPU:", 
                                     font=("Courier New", 10),
                                     bg=self.colors["frame"], 
                                     fg=self.colors["text"],
                                     width=10, anchor=tk.W)
            self.cpu_label.pack(side=tk.LEFT, padx=2)
            
            self.cpu_canvas = tk.Canvas(self.cpu_frame, 
                                       height=20, 
                                       bg=self.colors["dark"],
                                       highlightbackground=self.colors["dark"])
            self.cpu_canvas.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            # Memory usage
            self.mem_frame = tk.Frame(self.monitor_frame, bg=self.colors["frame"])
            self.mem_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.mem_label = tk.Label(self.mem_frame, 
                                     text="MEMORY:", 
                                     font=("Courier New", 10),
                                     bg=self.colors["frame"], 
                                     fg=self.colors["text"],
                                     width=10, anchor=tk.W)
            self.mem_label.pack(side=tk.LEFT, padx=2)
            
            self.mem_canvas = tk.Canvas(self.mem_frame, 
                                       height=20, 
                                       bg=self.colors["dark"],
                                       highlightbackground=self.colors["dark"])
            self.mem_canvas.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            # Disk usage
            self.disk_frame = tk.Frame(self.monitor_frame, bg=self.colors["frame"])
            self.disk_frame.pack(fill=tk.X, padx=5, pady=2)
            
            self.disk_label = tk.Label(self.disk_frame, 
                                      text="DISK:", 
                                      font=("Courier New", 10),
                                      bg=self.colors["frame"], 
                                      fg=self.colors["text"],
                                      width=10, anchor=tk.W)
            self.disk_label.pack(side=tk.LEFT, padx=2)
            
            self.disk_canvas = tk.Canvas(self.disk_frame, 
                                        height=20, 
                                        bg=self.colors["dark"],
                                        highlightbackground=self.colors["dark"])
            self.disk_canvas.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
            
            # Process list
            self.process_title = tk.Label(self.monitor_frame, 
                                         text="[ RUNNING PROCESSES ]", 
                                         font=("Courier New", 10, "bold"),
                                         bg=self.colors["frame"], 
                                         fg=self.colors["text"])
            self.process_title.pack(anchor=tk.W, padx=5, pady=2)
            
            self.process_frame = tk.Frame(self.monitor_frame, bg=self.colors["dark"])
            self.process_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            self.process_scroll = tk.Scrollbar(self.process_frame, bg=self.colors["dark"])
            self.process_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            
            self.process_list = tk.Listbox(self.process_frame, 
                                          font=("Courier New", 9),
                                          bg=self.colors["dark"], 
                                          fg=self.colors["text"],
                                          selectbackground=self.colors["frame"],
                                          selectforeground=self.colors["highlight"])
            self.process_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            self.process_scroll.config(command=self.process_list.yview)
            self.process_list.config(yscrollcommand=self.process_scroll.set)
            
            # Console output at the bottom
            self.console_frame = tk.Frame(self.main_frame, bg=self.colors["frame"], relief=tk.RIDGE, bd=2)
            self.console_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.console_title = tk.Label(self.console_frame, 
                                         text="[ CONSOLE ]", 
                                         font=("Courier New", 10, "bold"),
                                         bg=self.colors["frame"], 
                                         fg=self.colors["text"])
            self.console_title.pack(anchor=tk.W, padx=5, pady=2)
            
            self.console = tk.Text(self.console_frame, 
                                  height=4, 
                                  font=("Courier New", 9),
                                  bg=self.colors["dark"], 
                                  fg=self.colors["text"],
                                  insertbackground=self.colors["highlight"])
            self.console.pack(fill=tk.X, padx=5, pady=5)
            
            # Status bar
            self.status_bar = tk.Label(self.rootscrtscrt, 
                                      text="SYSTEM: ONLINE | STATUS: READY", 
                                      font=("Courier New", 9),
                                      bg=self.colors["bg"], 
                                      fg=self.colors["highlight"],
                                      bd=1, relief=tk.SUNKEN, anchor=tk.W)
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
            
            # Initialize with current directory
            self.current_path = os.getcwd()
            self.path_var.set(self.current_path)
            
            # Start update threads
            self.stop_threads = False
            self.update_system_info()
            self.update_file_explorer()
            
            # Start monitor update thread
            self.monitor_thread = threading.Thread(target=self.update_monitor)
            self.monitor_thread.daemon = True
            self.monitor_thread.start()
            
            # Start title animation
            self.animate_title()
        
        def animate_title(self):
            """Animate the title with a hacker-style effect"""
            text = self.title_label.cget("text")
            if "█" in text:
                # Remove cursor
                self.title_label.config(text=text.replace("█", ""))
            else:
                # Add cursor
                self.title_label.config(text=text + "█")
            self.rootscrtscrt.after(500, self.animate_title)
        
        def update_system_info(self):
            """Update system information"""
            self.sys_info.config(state=tk.NORMAL)
            self.sys_info.delete(1.0, tk.END)
            
            uname = platform.uname()
            cpu_info = f"CPU: {platform.processor()}"
            if len(cpu_info) > 60:
                cpu_info = cpu_info[:57] + "..."
                
            info_text = (
                f"OS: {uname.system} {uname.release} ({uname.version})\n"
                f"NODE: {uname.node}\n"
                f"{cpu_info}\n"
                f"TOTAL RAM: {round(psutil.virtual_memory().total / (1024**3), 2)} GB\n"
                f"PYTHON: {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\n"
                f"TIME: {time.strftime('%Y-%m-%d %H:%M:%S')}"
            )
            
            self.sys_info.insert(tk.END, info_text)
            self.sys_info.config(state=tk.DISABLED)
            
            # Log system info to console
            self.console_log("System information updated")
        
        def console_log(self, message):
            """Log message to console with timestamp"""
            timestamp = time.strftime("[%H:%M:%S]")
            self.console.config(state=tk.NORMAL)
            self.console.insert(tk.END, f"{timestamp} {message}\n")
            self.console.see(tk.END)
            self.console.config(state=tk.DISABLED)
        
        def update_file_explorer(self):
            """Update file explorer with current path contents"""
            self.file_tree.delete(*self.file_tree.get_children())
            
            try:
                # Set current path
                self.current_path = self.path_var.get()
                
                # List directory contents
                items = os.listdir(self.current_path)
                
                # Add parent directory entry
                parent_id = self.file_tree.insert("", "end", text="..", values=("", "", "Parent Dir"))
                
                # Add directories first
                for item in sorted([x for x in items if os.path.isdir(os.path.join(self.current_path, x))]):
                    try:
                        path = os.path.join(self.current_path, item)
                        stats = os.stat(path)
                        modified = time.strftime("%Y-%m-%d %H:%M", time.localtime(stats.st_mtime))
                        self.file_tree.insert("", "end", text=item, values=("", modified, "Directory"))
                    except Exception as e:
                        self.file_tree.insert("", "end", text=item, values=("", "", f"Error: {str(e)[:20]}"))
                
                # Then add files
                for item in sorted([x for x in items if os.path.isfile(os.path.join(self.current_path, x))]):
                    try:
                        path = os.path.join(self.current_path, item)
                        stats = os.stat(path)
                        size = self.format_size(stats.st_size)
                        modified = time.strftime("%Y-%m-%d %H:%M", time.localtime(stats.st_mtime))
                        file_type = os.path.splitext(item)[1][1:].upper() if os.path.splitext(item)[1] else "File"
                        self.file_tree.insert("", "end", text=item, values=(size, modified, file_type))
                    except Exception as e:
                        self.file_tree.insert("", "end", text=item, values=("", "", f"Error: {str(e)[:20]}"))
                
                self.console_log(f"Navigated to: {self.current_path}")
                self.status_bar.config(text=f"CURRENT PATH: {self.current_path}")
                
            except Exception as e:
                self.console_log(f"Error accessing path: {str(e)}")
                messagebox.showerror("Access Error", f"Cannot access path: {str(e)}")
                # Revert to previous path
                self.path_var.set(self.current_path)
        
        def format_size(self, size):
            """Format file size in human-readable format"""
            for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
                if size < 1024:
                    return f"{size:.1f} {unit}"
                size /= 1024
            return f"{size:.1f} PB"
        
        def navigate_to_path(self):
            """Navigate to the path entered in the path entry"""
            path = self.path_var.get()
            if os.path.exists(path) and os.path.isdir(path):
                self.current_path = path
                self.update_file_explorer()
            else:
                messagebox.showerror("Invalid Path", "The specified path does not exist or is not a directory")
                self.path_var.set(self.current_path)
        
        def on_tree_double_click(self, event):
            """Handle double click on file tree"""
            item = self.file_tree.selection()[0]
            item_text = self.file_tree.item(item, "text")
            
            if item_text == "..":
                # Navigate to parent directory
                parent_path = os.path.dirname(self.current_path)
                self.path_var.set(parent_path)
                self.navigate_to_path()
            else:
                # Get full path
                full_path = os.path.join(self.current_path, item_text)
                
                if os.path.isdir(full_path):
                    # Navigate to directory
                    self.path_var.set(full_path)
                    self.navigate_to_path()
                else:
                    # Display file info
                    stats = os.stat(full_path)
                    file_info = (
                        f"FILE: {item_text}\n"
                        f"PATH: {full_path}\n"
                        f"SIZE: {self.format_size(stats.st_size)}\n"
                        f"CREATED: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(stats.st_ctime))}\n"
                        f"MODIFIED: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(stats.st_mtime))}\n"
                        f"ACCESSED: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(stats.st_atime))}"
                    )
                    self.console_log(f"Selected file: {full_path}")
                    messagebox.showinfo("File Information", file_info)
        
        def update_monitor(self):
            """Update system monitor continuously"""
            while not self.stop_threads:
                try:
                    # Update CPU usage
                    cpu_percent = psutil.cpu_percent()
                    self.cpu_canvas.delete("all")
                    width = self.cpu_canvas.winfo_width()
                    bar_width = int(width * cpu_percent / 100)
                    self.cpu_canvas.create_rectangle(0, 0, bar_width, 20, 
                                                   fill=self.get_color_for_percent(cpu_percent), 
                                                   outline="")
                    self.cpu_canvas.create_text(width/2, 10, 
                                              text=f"{cpu_percent}%", 
                                              fill=self.colors["text"])
                    
                    # Update Memory usage
                    mem = psutil.virtual_memory()
                    mem_percent = mem.percent
                    self.mem_canvas.delete("all")
                    width = self.mem_canvas.winfo_width()
                    bar_width = int(width * mem_percent / 100)
                    self.mem_canvas.create_rectangle(0, 0, bar_width, 20, 
                                                   fill=self.get_color_for_percent(mem_percent), 
                                                   outline="")
                    self.mem_canvas.create_text(width/2, 10, 
                                              text=f"{mem_percent}% ({self.format_size(mem.used)}/{self.format_size(mem.total)})", 
                                              fill=self.colors["text"])
                    
                    # Update Disk usage
                    disk = psutil.disk_usage('/')
                    disk_percent = disk.percent
                    self.disk_canvas.delete("all")
                    width = self.disk_canvas.winfo_width()
                    bar_width = int(width * disk_percent / 100)
                    self.disk_canvas.create_rectangle(0, 0, bar_width, 20, 
                                                    fill=self.get_color_for_percent(disk_percent), 
                                                    outline="")
                    self.disk_canvas.create_text(width/2, 10, 
                                               text=f"{disk_percent}% ({self.format_size(disk.used)}/{self.format_size(disk.total)})", 
                                               fill=self.colors["text"])
                    
                    # Update process list (every 5 seconds to avoid performance impact)
                    if int(time.time()) % 5 == 0:
                        self.update_process_list()
                    
                    time.sleep(1)
                except Exception as e:
                    self.console_log(f"Monitor error: {str(e)}")
                    time.sleep(5) # Wait longer on error
        
        def get_color_for_percent(self, percent):
            """Get color based on percentage (green to yellow to red)"""
            if percent < 50:
                # Green to Yellow (0-50%)
                r = int(255 * percent / 50)
                g = 255
                b = 0
            else:
                # Yellow to Red (50-100%)
                r = 255
                g = int(255 * (100 - percent) / 50)
                b = 0
            return f"#{r:02x}{g:02x}{b:02x}"
        
        def update_process_list(self):
            """Update the process list"""
            self.process_list.delete(0, tk.END)
            
            try:
                # Get process information
                processes = []
                for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                    try:
                        pinfo = proc.info
                        processes.append((
                            pinfo['pid'],
                            pinfo['name'],
                            pinfo['cpu_percent'],
                            pinfo['memory_percent']
                        ))
                    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                        pass
                
                # Sort by CPU usage and display top processes
                for pid, name, cpu, mem in sorted(processes, key=lambda x: x[2], reverse=True)[:20]:
                    self.process_list.insert(tk.END, f"{pid:5} | {name[:20]:20} | CPU: {cpu:5.1f}% | MEM: {mem:5.1f}%")
            except Exception as e:
                self.console_log(f"Process list error: {str(e)}")
        
        def on_close(self):
            """Handle window close event"""
            self.stop_threads = True
            self.rootscrtscrt.destroy()

    def main():
        rootscrtscrt = tk.Tk()
        app = RetroHackerExplorer(rootscrtscrt)
        rootscrtscrt.protocol("WM_DELETE_WINDOW", app.on_close)
        rootscrtscrt.mainloop()

    if __name__ == "__main__":
        main()
        
if commandervar == 88888888:
    import os
    import shutil
    import tkinter as tk
    from tkinter import ttk, messagebox, simpledialog
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class RetroFileManagerApp:
        def __init__(self, rootcomm):
            self.rootcomm = rootcomm
            self.rootcomm.title("Commander - File Manager")
            self.rootcomm.geometry("1000x600")
            
            # Definim culorile Windows 95
            self.bg_color = "#C0C0C0"  # Gri deschis specific Windows 95
            self.text_color = "#000000"  # Negru
            self.button_color = "#C0C0C0"  # Gri pentru butoane
            self.highlight_color = "#000080"  # Albastru închis pentru selecție
            self.button_shadow = "#808080"  # Gri închis pentru umbră butoane
            self.button_highlight = "#FFFFFF"  # Alb pentru highlight butoane
            
            # Configurăm rootcomm
            self.rootcomm.configure(bg=self.bg_color)
            
            # Creăm un stil pentru elemente
            self.create_retro_style()
            
            # Creăm frame-ul principal
            self.main_frame = tk.Frame(rootcomm, bg=self.bg_color, relief="raised", bd=2)
            self.main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Bara de titlu cu logo Windows 95
            self.title_bar = tk.Frame(self.main_frame, bg="#000080", height=20)
            self.title_bar.pack(fill=tk.X)
            self.title_label = tk.Label(self.title_bar, text="RetroCommander - File Manager", 
                                        bg="#000080", fg="white", font=("Arial", 10, "bold"))
            self.title_label.pack(side=tk.LEFT, padx=5)
            
            # Bara de meniu
            self.menu_bar = tk.Frame(self.main_frame, bg=self.bg_color, relief="raised", bd=1)
            self.menu_bar.pack(fill=tk.X)
            
            # Butoane de meniu
            menu_buttons = ["File", "Edit", "View", "Options", "Help"]
            for btn_text in menu_buttons:
                btn = tk.Button(self.menu_bar, text=btn_text, bg=self.bg_color, relief="flat",
                                borderwidth=1, font=("Arial", 9), pady=1)
                btn.pack(side=tk.LEFT, padx=2)
            
            # Creăm panoul împărțit
            self.paned_window = tk.PanedWindow(self.main_frame, orient=tk.HORIZONTAL, 
                                               bg=self.bg_color, sashwidth=4, relief="sunken")
            self.paned_window.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Panoul stâng
            self.left_frame = tk.Frame(self.paned_window, bg=self.bg_color, relief="sunken", bd=2)
            self.paned_window.add(self.left_frame, width=400)
            
            # Panoul drept
            self.right_frame = tk.Frame(self.paned_window, bg=self.bg_color, relief="sunken", bd=2)
            self.paned_window.add(self.right_frame, width=400)
            
            # Configurăm fiecare panou
            self.setup_panel(self.left_frame, "left")
            self.setup_panel(self.right_frame, "right")
            
            # Căile curente pentru fiecare panou
            self.paths = {
                "left": os.path.expanduser("~"),
                "right": os.path.expanduser("~")
            }
            
            # Panoul activ (implicit: stâng)
            self.active_panel = "left"
            self.highlight_active_panel()
            
            # Bara de instrumente de jos cu scurtături
            self.setup_toolbar()
            
            # Asocieri de taste
            self.setup_keybindings()
            
            # Încărcarea inițială a directoarelor
            self.refresh_panels()
        
        def create_retro_style(self):
            # Stilizare pentru Windows 95
            style = ttk.Style()
            style.theme_use('clam')
            
            # Stilizare pentru Treeview
            style.configure("Treeview", 
                            background="white",
                            foreground="black",
                            fieldbackground="white",
                            borderwidth=1)
            style.map("Treeview", 
                     background=[('selected', '#000080')])
            
            # Stilizare pentru entrye-uri
            style.configure("TEntry", 
                            fieldbackground="white", 
                            borderwidth=2)
            
            # Stilizare pentru butoane
            style.configure("Retro.TButton", 
                        font=("Arial", 9, "bold"),
                        borderwidth=2,
                        relief="raised")
            
            # Stilizare pentru frame-uri
            style.configure("TFrame", background=self.bg_color)
        
        def setup_panel(self, frame, side):
            # Frame pentru calea curentă
            path_frame = tk.Frame(frame, bg=self.bg_color)
            path_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # Label pentru cale
            path_label = tk.Label(path_frame, text="Path:", bg=self.bg_color)
            path_label.pack(side=tk.LEFT, padx=5)
            
            # Entry pentru cale
            self.path_vars = self.path_vars if hasattr(self, 'path_vars') else {}
            self.path_vars[side] = tk.StringVar()
            
            path_entry = tk.Entry(path_frame, textvariable=self.path_vars[side], 
                                  relief="sunken", bd=2, bg="white")
            path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
            path_entry.bind("<Return>", lambda e, s=side: self.navigate_to_path(s))
            
            # Buton Go
            go_button = tk.Button(path_frame, text="Go", bg=self.button_color,
                                 relief="raised", bd=2, command=lambda s=side: self.navigate_to_path(s))
            go_button.pack(side=tk.RIGHT, padx=5)
            
            # Frame pentru Treeview
            self.tree_frames = self.tree_frames if hasattr(self, 'tree_frames') else {}
            self.tree_frames[side] = tk.Frame(frame, bg=self.bg_color, relief="sunken", bd=2)
            self.tree_frames[side].pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Treeview cu scrollbar
            self.trees = self.trees if hasattr(self, 'trees') else {}
            
            # Scrollbar
            tree_scroll = tk.Scrollbar(self.tree_frames[side], relief="raised", bd=2)
            tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Treeview pentru fișiere
            self.trees[side] = ttk.Treeview(self.tree_frames[side], 
                                           columns=("name", "size", "modified"),
                                           show="headings",
                                           yscrollcommand=tree_scroll.set)
            
            tree_scroll.config(command=self.trees[side].yview)
            
            # Configurăm coloanele
            self.trees[side].heading("name", text="Name")
            self.trees[side].heading("size", text="Size")
            self.trees[side].heading("modified", text="Modified")
            
            self.trees[side].column("name", width=200)
            self.trees[side].column("size", width=100)
            self.trees[side].column("modified", width=150)
            
            self.trees[side].pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Asociem evenimente
            self.trees[side].bind("<Double-1>", lambda e, s=side: self.on_item_double_click(s))
            self.trees[side].bind("<ButtonRelease-1>", lambda e, s=side: self.on_item_click(s))
        
        def setup_toolbar(self):
            # Frame pentru bara de instrumente
            toolbar_frame = tk.Frame(self.main_frame, bg=self.bg_color, relief="raised", bd=2)
            toolbar_frame.pack(fill=tk.X, pady=5)
            
            # Butoane pentru funcții
            buttons = [
                ("F1 Help", self.show_help),
                ("F2 Rename", self.rename_item),
                ("F3 View", self.view_item),
                ("F4 Edit", self.edit_item),
                ("F5 Copy", self.copy_item),
                ("F6 Move", self.move_item),
                ("F7 MkDir", self.make_directory),
                ("F8 Delete", self.delete_item),
                ("F10 Quit", self.quit_app)
            ]
            
            # Creăm butoanele cu stil Windows 95
            for text, command in buttons:
                btn = tk.Button(toolbar_frame, text=text, command=command,
                               bg=self.button_color, bd=3, relief="raised",
                               font=("Arial", 9, "bold"), width=8)
                btn.pack(side=tk.LEFT, padx=3, pady=3)
        
        def setup_keybindings(self):
            self.rootcomm.bind("<F1>", lambda e: self.show_help())
            self.rootcomm.bind("<F2>", lambda e: self.rename_item())
            self.rootcomm.bind("<F3>", lambda e: self.view_item())
            self.rootcomm.bind("<F4>", lambda e: self.edit_item())
            self.rootcomm.bind("<F5>", lambda e: self.copy_item())
            self.rootcomm.bind("<F6>", lambda e: self.move_item())
            self.rootcomm.bind("<F7>", lambda e: self.make_directory())
            self.rootcomm.bind("<F8>", lambda e: self.delete_item())
            self.rootcomm.bind("<F10>", lambda e: self.quit_app())
            self.rootcomm.bind("<Tab>", lambda e: self.toggle_active_panel())
        
        def toggle_active_panel(self):
            self.active_panel = "right" if self.active_panel == "left" else "left"
            self.highlight_active_panel()
        
        def highlight_active_panel(self):
            for side in ["left", "right"]:
                if side == self.active_panel:
                    self.tree_frames[side].configure(relief="groove", bd=3)
                else:
                    self.tree_frames[side].configure(relief="sunken", bd=2)
        
        def navigate_to_path(self, side):
            path = self.path_vars[side].get()
            if os.path.exists(path) and os.path.isdir(path):
                self.paths[side] = path
                self.refresh_panel(side)
            else:
                self.show_error_dialog("Error", f"Invalid path: {path}")
        
        def load_directory(self, side, path):
            self.trees[side].delete(*self.trees[side].get_children())
            
            # Adăugăm elementul pentru directorul părinte
            if path != os.path.dirname(path):
                self.trees[side].insert("", "end", values=("..", "", ""), tags=("parent",))
            
            try:
                items = os.listdir(path)
                
                # Adăugăm mai întâi directoarele
                for item in sorted(items):
                    item_path = os.path.join(path, item)
                    if os.path.isdir(item_path):
                        size = ""
                        try:
                            modified = os.path.getmtime(item_path)
                            modified_str = tk.Tcl().call('clock', 'format', int(modified), '-format', '%Y-%m-%d %H:%M')
                        except:
                            modified_str = ""
                        
                        self.trees[side].insert("", "end", values=(item + "/", size, modified_str), tags=("dir",))
                
                # Apoi adăugăm fișierele
                for item in sorted(items):
                    item_path = os.path.join(path, item)
                    if os.path.isfile(item_path):
                        try:
                            size = self.format_size(os.path.getsize(item_path))
                            modified = os.path.getmtime(item_path)
                            modified_str = tk.Tcl().call('clock', 'format', int(modified), '-format', '%Y-%m-%d %H:%M')
                        except:
                            size = ""
                            modified_str = ""
                        
                        self.trees[side].insert("", "end", values=(item, size, modified_str), tags=("file",))
                        
            except PermissionError:
                self.show_error_dialog("Error", f"Permission denied: {path}")
            except Exception as e:
                self.show_error_dialog("Error", f"Error loading directory: {str(e)}")
        
        def show_error_dialog(self, title, message):
            dialog = tk.Toplevel(self.rootcomm)
            dialog.title(title)
            dialog.geometry("300x150")
            dialog.configure(bg=self.bg_color)
            dialog.transient(self.rootcomm)
            dialog.grab_set()
            
            icon_label = tk.Label(dialog, text="X", font=("Arial", 24), fg="red", bg=self.bg_color)
            icon_label.pack(pady=(10, 5))
            
            message_label = tk.Label(dialog, text=message, wraplength=250, bg=self.bg_color)
            message_label.pack(pady=5)
            
            btn_frame = tk.Frame(dialog, bg=self.bg_color)
            btn_frame.pack(pady=10)
            
            ok_button = tk.Button(btn_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=dialog.destroy)
            ok_button.pack()
        
        def format_size(self, size):
            for unit in ["B", "KB", "MB", "GB", "TB"]:
                if size < 1024.0:
                    return f"{size:.2f} {unit}"
                size /= 1024.0
            return f"{size:.2f} TB"
        
        def refresh_panel(self, side):
            self.path_vars[side].set(self.paths[side])
            self.load_directory(side, self.paths[side])
        
        def refresh_panels(self):
            for side in ["left", "right"]:
                self.refresh_panel(side)
        
        def on_item_double_click(self, side):
            selected = self.trees[side].focus()
            if not selected:
                return
                
            values = self.trees[side].item(selected, "values")
            if not values:
                return
                
            name = values[0]
            
            if name == "..":
                # Mergem un director mai sus
                self.paths[side] = os.path.dirname(self.paths[side])
            elif name.endswith("/"):
                # Intrăm în director
                name = name[:-1]  # Eliminăm slash-ul final
                new_path = os.path.join(self.paths[side], name)
                if os.path.exists(new_path) and os.path.isdir(new_path):
                    self.paths[side] = new_path
            else:
                # Deschidem fișierul (în acest caz doar vizualizare)
                self.view_item()
                return
                
            self.refresh_panel(side)
        
        def on_item_click(self, side):
            self.active_panel = side
            self.highlight_active_panel()
        
        def get_selected_item(self):
            side = self.active_panel
            selected = self.trees[side].focus()
            if not selected:
                return None, None
                
            values = self.trees[side].item(selected, "values")
            if not values:
                return None, None
                
            name = values[0]
            if name == "..":
                return None, None
                
            if name.endswith("/"):
                name = name[:-1]  # Eliminăm slash-ul final
                
            path = os.path.join(self.paths[side], name)
            return name, path
        
        def get_inactive_panel_path(self):
            inactive = "right" if self.active_panel == "left" else "left"
            return self.paths[inactive]
        
        # Funcții pentru acțiuni
        def show_help(self):
            help_text = """
            RetroCommander File Manager Help
            --------------------------------
            F1: Help - Show this help screen
            F2: Rename - Rename selected file/folder
            F3: View - View selected file
            F4: Edit - Edit selected file
            F5: Copy - Copy to other panel
            F6: Move - Move to other panel
            F7: MkDir - Create new directory
            F8: Delete - Delete selected file/folder
            F10: Quit - Exit application
            Tab: Switch active panel
            """
            
            # Creăm o fereastră de ajutor în stil Windows 95
            help_window = tk.Toplevel(self.rootcomm)
            help_window.title("Help")
            help_window.geometry("400x350")
            help_window.configure(bg=self.bg_color)
            help_window.transient(self.rootcomm)
            
            # Titlu
            title_frame = tk.Frame(help_window, bg="#000080", height=20)
            title_frame.pack(fill=tk.X)
            title_label = tk.Label(title_frame, text="RetroCommander Help", 
                                  bg="#000080", fg="white", font=("Arial", 10, "bold"))
            title_label.pack(side=tk.LEFT, padx=5)
            
            # Conținut
            content_frame = tk.Frame(help_window, bg=self.bg_color, relief="sunken", bd=2)
            content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            help_label = tk.Label(content_frame, text=help_text, justify=tk.LEFT, 
                                 bg="white", relief="sunken", bd=2, padx=10, pady=10)
            help_label.pack(fill=tk.BOTH, expand=True)
            
            # Buton OK
            button_frame = tk.Frame(help_window, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            ok_button = tk.Button(button_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=help_window.destroy)
            ok_button.pack()
        
        def rename_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
            
            # Dialog pentru redenumire în stil Windows 95
            rename_dialog = tk.Toplevel(self.rootcomm)
            rename_dialog.title("Rename")
            rename_dialog.geometry("300x120")
            rename_dialog.configure(bg=self.bg_color)
            rename_dialog.transient(self.rootcomm)
            rename_dialog.grab_set()
            
            tk.Label(rename_dialog, text="Enter new name:", bg=self.bg_color).pack(pady=(10, 5))
            
            new_name_var = tk.StringVar(value=name)
            entry = tk.Entry(rename_dialog, textvariable=new_name_var, width=40, 
                            relief="sunken", bd=2, bg="white")
            entry.pack(padx=10, pady=5)
            entry.select_range(0, tk.END)
            entry.focus_set()
            
            button_frame = tk.Frame(rename_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            def do_rename():
                new_name = new_name_var.get()
                if new_name and new_name != name:
                    try:
                        new_path = os.path.join(os.path.dirname(path), new_name)
                        os.rename(path, new_path)
                        self.refresh_panels()
                        rename_dialog.destroy()
                    except Exception as e:
                        self.show_error_dialog("Error", f"Cannot rename: {str(e)}")
                else:
                    rename_dialog.destroy()
            
            ok_button = tk.Button(button_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=do_rename)
            ok_button.pack(side=tk.LEFT, padx=5)
            
            cancel_button = tk.Button(button_frame, text="Cancel", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=rename_dialog.destroy)
            cancel_button.pack(side=tk.LEFT, padx=5)
            
            entry.bind("<Return>", lambda e: do_rename())
        
        def view_item(self):
            name, path = self.get_selected_item()
            if not path or not os.path.isfile(path):
                return
                
            try:
                # Fereastră simplă pentru vizualizare fișiere în stil Windows 95
                viewer = tk.Toplevel(self.rootcomm)
                viewer.title(f"View: {name}")
                viewer.geometry("700x500")
                viewer.configure(bg=self.bg_color)
                
                # Bara de titlu
                title_frame = tk.Frame(viewer, bg="#000080", height=20)
                title_frame.pack(fill=tk.X)
                title_label = tk.Label(title_frame, text=f"View: {name}", 
                                      bg="#000080", fg="white", font=("Arial", 10, "bold"))
                title_label.pack(side=tk.LEFT, padx=5)
                
                # Conținut
                content_frame = tk.Frame(viewer, bg=self.bg_color, padx=5, pady=5)
                content_frame.pack(fill=tk.BOTH, expand=True)
                
                text = tk.Text(content_frame, wrap=tk.WORD, bg="white", fg="black", 
                              relief="sunken", bd=2, font=("Courier", 10))
                scroll = tk.Scrollbar(content_frame, command=text.yview, relief="raised", bd=2)
                text.configure(yscrollcommand=scroll.set)
                
                text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                scroll.pack(side=tk.RIGHT, fill=tk.Y)
                
                try:
                    with open(path, 'r') as f:
                        content = f.read()
                    text.insert(tk.END, content)
                    text.configure(state='disabled')
                except UnicodeDecodeError:
                    text.insert(tk.END, "Cannot display binary file content.")
                    text.configure(state='disabled')
                    
                # Buton de închidere
                button_frame = tk.Frame(viewer, bg=self.bg_color)
                button_frame.pack(pady=5)
                
                close_button = tk.Button(button_frame, text="Close", width=10, bg=self.button_color,
                                        relief="raised", bd=3, command=viewer.destroy)
                close_button.pack()
                    
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot view file: {str(e)}")
        
        def edit_item(self):
            name, path = self.get_selected_item()
            if not path or not os.path.isfile(path):
                return
                
            try:
                # Fereastră simplă pentru editare fișiere în stil Windows 95
                editor = tk.Toplevel(self.rootcomm)
                editor.title(f"Edit: {name}")
                editor.geometry("700x500")
                editor.configure(bg=self.bg_color)
                
                # Bara de titlu
                title_frame = tk.Frame(editor, bg="#000080", height=20)
                title_frame.pack(fill=tk.X)
                title_label = tk.Label(title_frame, text=f"Edit: {name}", 
                                      bg="#000080", fg="white", font=("Arial", 10, "bold"))
                title_label.pack(side=tk.LEFT, padx=5)
                
                # Conținut
                content_frame = tk.Frame(editor, bg=self.bg_color, padx=5, pady=5)
                content_frame.pack(fill=tk.BOTH, expand=True)
                
                text = tk.Text(content_frame, wrap=tk.WORD, bg="white", fg="black", 
                              relief="sunken", bd=2, font=("Courier", 10))
                scroll = tk.Scrollbar(content_frame, command=text.yview, relief="raised", bd=2)
                text.configure(yscrollcommand=scroll.set)
                
                text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                scroll.pack(side=tk.RIGHT, fill=tk.Y)
                
                try:
                    with open(path, 'r') as f:
                        content = f.read()
                    text.insert(tk.END, content)
                except UnicodeDecodeError:
                    self.show_error_dialog("Error", "Cannot edit binary file.")
                    editor.destroy()
                    return
                    
                def save_file():
                    try:
                        with open(path, 'w') as f:
                            f.write(text.get(1.0, tk.END))
                        self.refresh_panels()
                        editor.destroy()
                    except Exception as e:
                        self.show_error_dialog("Error", f"Cannot save file: {str(e)}")
                
                # Butoane
                button_frame = tk.Frame(editor, bg=self.bg_color)
                button_frame.pack(pady=5)
                
                save_button = tk.Button(button_frame, text="Save", width=10, bg=self.button_color,
                                       relief="raised", bd=3, command=save_file)
                save_button.pack(side=tk.LEFT, padx=5)
                
                cancel_button = tk.Button(button_frame, text="Cancel", width=10, bg=self.button_color,
                                         relief="raised", bd=3, command=editor.destroy)
                cancel_button.pack(side=tk.LEFT, padx=5)
                    
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot edit file: {str(e)}")
        
        def copy_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
                
            target_dir = self.get_inactive_panel_path()
            target_path = os.path.join(target_dir, name)
            
            if os.path.exists(target_path):
                # Dialog de confirmare în stil Windows 95
                confirm_dialog = tk.Toplevel(self.rootcomm)
                confirm_dialog.title("Confirm")
                confirm_dialog.geometry("350x150")
                confirm_dialog.configure(bg=self.bg_color)
                confirm_dialog.transient(self.rootcomm)
                confirm_dialog.grab_set()
                
                icon_label = tk.Label(confirm_dialog, text="?", font=("Arial", 24), fg="blue", bg=self.bg_color)
                icon_label.pack(pady=(10, 5))
                
                message_label = tk.Label(confirm_dialog, 
                                        text=f"{name} already exists. Overwrite?", 
                                        wraplength=300, bg=self.bg_color)
                message_label.pack(pady=5)
                
                button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
                button_frame.pack(pady=10)
                
                result = [False]  # Folosim o listă pentru a stoca rezultatul
                
                def on_yes():
                    result[0] = True
                    confirm_dialog.destroy()
                    
                def on_no():
                    result[0] = False
                    confirm_dialog.destroy()
                
                yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                      relief="raised", bd=3, command=on_yes)
                yes_button.pack(side=tk.LEFT, padx=5)
                
                no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=on_no)
                no_button.pack(side=tk.LEFT, padx=5)
                
                # Așteptăm închiderea dialogului
                self.rootcomm.wait_window(confirm_dialog)
                
                if not result[0]:
                    return
            
            try:
                if os.path.isdir(path):
                    shutil.copytree(path, target_path)
                else:
                    shutil.copy2(path, target_path)
                self.refresh_panels()
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot copy: {str(e)}")
        
        def move_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
                
            target_dir = self.get_inactive_panel_path()
            target_path = os.path.join(target_dir, name)
            
            if os.path.exists(target_path):
                # Dialog de confirmare în stil Windows 95
                confirm_dialog = tk.Toplevel(self.rootcomm)
                confirm_dialog.title("Confirm")
                confirm_dialog.geometry("350x150")
                confirm_dialog.configure(bg=self.bg_color)
                confirm_dialog.transient(self.rootcomm)
                confirm_dialog.grab_set()
                
                icon_label = tk.Label(confirm_dialog, text="?", font=("Arial", 24), fg="blue", bg=self.bg_color)
                icon_label.pack(pady=(10, 5))
                
                message_label = tk.Label(confirm_dialog, 
                                        text=f"{name} already exists. Overwrite?", 
                                        wraplength=300, bg=self.bg_color)
                message_label.pack(pady=5)
                
                button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
                button_frame.pack(pady=10)
                
                result = [False]  # Folosim o listă pentru a stoca rezultatul
                
                def on_yes():
                    result[0] = True
                    confirm_dialog.destroy()
                    
                def on_no():
                    result[0] = False
                    confirm_dialog.destroy()
                
                yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                      relief="raised", bd=3, command=on_yes)
                yes_button.pack(side=tk.LEFT, padx=5)
                
                no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=on_no)
                no_button.pack(side=tk.LEFT, padx=5)
                
                # Așteptăm închiderea dialogului
                self.rootcomm.wait_window(confirm_dialog)
                
                if not result[0]:
                    return
            
            try:
                shutil.move(path, target_path)
                self.refresh_panels()
            except Exception as e:
                self.show_error_dialog("Error", f"Cannot move: {str(e)}")
        
        def make_directory(self):
            side = self.active_panel
            
            # Dialog pentru nume director în stil Windows 95
            mkdir_dialog = tk.Toplevel(self.rootcomm)
            mkdir_dialog.title("Create Directory")
            mkdir_dialog.geometry("300x120")
            mkdir_dialog.configure(bg=self.bg_color)
            mkdir_dialog.transient(self.rootcomm)
            mkdir_dialog.grab_set()
            
            tk.Label(mkdir_dialog, text="Enter directory name:", bg=self.bg_color).pack(pady=(10, 5))
            
            dir_name_var = tk.StringVar()
            entry = tk.Entry(mkdir_dialog, textvariable=dir_name_var, width=40, 
                            relief="sunken", bd=2, bg="white")
            entry.pack(padx=10, pady=5)
            entry.focus_set()
            
            button_frame = tk.Frame(mkdir_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            def do_mkdir():
                dir_name = dir_name_var.get()
                if dir_name:
                    try:
                        new_dir = os.path.join(self.paths[side], dir_name)
                        os.mkdir(new_dir)
                        self.refresh_panels()
                        mkdir_dialog.destroy()
                    except Exception as e:
                        self.show_error_dialog("Error", f"Cannot create directory: {str(e)}")
                else:
                    mkdir_dialog.destroy()
            
            ok_button = tk.Button(button_frame, text="OK", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=do_mkdir)
            ok_button.pack(side=tk.LEFT, padx=5)
            
            cancel_button = tk.Button(button_frame, text="Cancel", width=10, bg=self.button_color,
                                     relief="raised", bd=3, command=mkdir_dialog.destroy)
            cancel_button.pack(side=tk.LEFT, padx=5)
            
            entry.bind("<Return>", lambda e: do_mkdir())
        
        def delete_item(self):
            name, path = self.get_selected_item()
            if not path:
                return
                
            # Dialog de confirmare în stil Windows 95
            confirm_dialog = tk.Toplevel(self.rootcomm)
            confirm_dialog.title("Confirm Delete")
            confirm_dialog.geometry("350x150")
            confirm_dialog.configure(bg=self.bg_color)
            confirm_dialog.transient(self.rootcomm)
            confirm_dialog.grab_set()
            
            icon_label = tk.Label(confirm_dialog, text="!", font=("Arial", 24), fg="red", bg=self.bg_color)
            icon_label.pack(pady=(10, 5))
            
            is_dir = os.path.isdir(path)
            message = f"Are you sure you want to delete this {'directory' if is_dir else 'file'}?\n{name}"
            
            message_label = tk.Label(confirm_dialog, text=message, wraplength=300, bg=self.bg_color)
            message_label.pack(pady=5)
            
            button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            def do_delete():
                try:
                    if is_dir:
                        shutil.rmtree(path)
                    else:
                        os.remove(path)
                    self.refresh_panels()
                    confirm_dialog.destroy()
                except Exception as e:
                    self.show_error_dialog("Error", f"Cannot delete: {str(e)}")
                    confirm_dialog.destroy()
            
            yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                  relief="raised", bd=3, command=do_delete)
            yes_button.pack(side=tk.LEFT, padx=5)
            
            no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=confirm_dialog.destroy)
            no_button.pack(side=tk.LEFT, padx=5)
        
        def quit_app(self):
            # Dialog de confirmare în stil Windows 95
            confirm_dialog = tk.Toplevel(self.rootcomm)
            confirm_dialog.title("Confirm Exit")
            confirm_dialog.geometry("300x150")
            confirm_dialog.configure(bg=self.bg_color)
            confirm_dialog.transient(self.rootcomm)
            confirm_dialog.grab_set()
            
            icon_label = tk.Label(confirm_dialog, text="?", font=("Arial", 24), fg="blue", bg=self.bg_color)
            icon_label.pack(pady=(10, 5))
            
            message_label = tk.Label(confirm_dialog, text="Are you sure you want to exit?", 
                                    wraplength=250, bg=self.bg_color)
            message_label.pack(pady=5)
            
            button_frame = tk.Frame(confirm_dialog, bg=self.bg_color)
            button_frame.pack(pady=10)
            
            yes_button = tk.Button(button_frame, text="Yes", width=10, bg=self.button_color,
                                  relief="raised", bd=3, command=self.rootcomm.destroy)
            yes_button.pack(side=tk.LEFT, padx=5)
            
            no_button = tk.Button(button_frame, text="No", width=10, bg=self.button_color,
                                 relief="raised", bd=3, command=confirm_dialog.destroy)
            no_button.pack(side=tk.LEFT, padx=5)


    # Funcția principală pentru a rula aplicația
    def main():
        rootcomm = tk.Tk()
        app = RetroFileManagerApp(rootcomm)
        rootcomm.mainloop()

    if __name__ == "__main__":
        main()

if calendarvar == 999000:
    import tkinter as tk
    from tkinter import ttk, simpledialog, messagebox
    import datetime
    from datetime import datetime, timedelta
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class Win95CalendarApp:
        def __init__(self, rootCalendar):
            self.rootCalendar = rootCalendar
            self.rootCalendar.title("Calendar")
            self.rootCalendar.geometry("640x480")
            self.rootCalendar.configure(bg="#c0c0c0")
            
            # Set Windows 95 style colors
            self.win95_bg = "#c0c0c0"
            self.win95_button = "#c0c0c0"
            self.win95_shadow = "#808080"
            self.win95_highlight = "#ffffff"
            self.win95_text = "#000000"
            self.calendar_bg = "#e0e0e0"  # Lighter color for the calendar table
            
            # Date variables
            self.current_date = datetime.now()
            self.year = self.current_date.year
            self.month = self.current_date.month
            
            # List of month names
            self.month_names = [
                "", "January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
            ]
            
            # List of day names
            self.day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            
            # Events dictionary
            self.events = {}
            
            # Load saved events
            self.load_events()
            
            # Create interface
            self.create_widgets()
            
        def create_3d_frame(self, parent, **kwargs):
            """Create a 3D frame with Windows 95 style"""
            frame = tk.Frame(parent, bg=self.win95_bg, bd=2, relief="raised", **kwargs)
            return frame
            
        def create_win95_button(self, parent, text, command, **kwargs):
            """Create a Windows 95 style button"""
            button = tk.Button(
                parent, 
                text=text, 
                command=command, 
                bg=self.win95_button,
                fg=self.win95_text,
                relief="raised",
                bd=2,
                font=("Arial", 8),
                **kwargs
            )
            return button
            
        def create_widgets(self):
            # Main frame
            main_frame = self.create_3d_frame(self.rootCalendar)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Title bar
            title_bar = tk.Frame(main_frame, bg="#000080", height=22)
            title_bar.pack(fill=tk.X)
            
            title_text = tk.Label(
                title_bar, 
                text="Calendar - Retro Style", 
                fg="white", 
                bg="#000080",
                font=("Arial", 8, "bold")
            )
            title_text.pack(side=tk.LEFT, padx=5)
            
            # X button
            close_button = tk.Button(
                title_bar, 
                text="X", 
                bg="#c0c0c0",
                fg="#000000",
                width=2,
                relief="raised",
                bd=1,
                command=self.rootCalendar.destroy
            )
            close_button.pack(side=tk.RIGHT)
            
            # Calendar control frame
            control_frame = self.create_3d_frame(main_frame)
            control_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # Navigation buttons
            prev_button = self.create_win95_button(control_frame, "< Previous", self.prev_month)
            prev_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            next_button = self.create_win95_button(control_frame, "Next >", self.next_month)
            next_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Label for current month and year
            self.month_year_label = tk.Label(
                control_frame, 
                text="",
                font=("Arial", 10, "bold"),
                bg=self.win95_bg
            )
            self.month_year_label.pack(side=tk.LEFT, padx=30, pady=5)
            
            # Frame for displaying the calendar grid
            calendar_frame = self.create_3d_frame(main_frame)
            calendar_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Week day names
            for i, day in enumerate(self.day_names):
                day_label = tk.Label(
                    calendar_frame, 
                    text=day,
                    font=("Arial", 8, "bold"),
                    width=9,
                    height=1,
                    bg="#d3d3d3",
                    bd=1,
                    relief="sunken"
                )
                day_label.grid(row=0, column=i, sticky="nsew", padx=1, pady=1)
            
            # Create grid of cells for days
            self.day_cells = []
            for row in range(6):
                row_cells = []
                for col in range(7):
                    cell = tk.Button(
                        calendar_frame,
                        text="",
                        font=("Arial", 8),
                        bg=self.calendar_bg,  # Lighter background color
                        relief="raised",
                        bd=1,
                        width=9,
                        height=4,
                        justify="left",
                        anchor="nw"
                    )
                    cell.grid(row=row+1, column=col, sticky="nsew", padx=1, pady=1)
                    row_cells.append(cell)
                self.day_cells.append(row_cells)
            
            # Configure grid for resolution
            for i in range(7):
                calendar_frame.columnconfigure(i, weight=1)
            for i in range(7):
                calendar_frame.rowconfigure(i, weight=1)
                
            # Status bar frame
            status_frame = tk.Frame(main_frame, bg=self.win95_bg, bd=1, relief="sunken")
            status_frame.pack(fill=tk.X, side=tk.BOTTOM)
            
            status_label = tk.Label(
                status_frame, 
                text="Ready", 
                bg=self.win95_bg,
                font=("Arial", 8),
                anchor="w"
            )
            status_label.pack(side=tk.LEFT, padx=5)
            
            # Update calendar
            self.update_calendar()
            
        def get_month_calendar(self, year, month):
            """Generate calendar for specified month and year"""
            # First day of the month
            first_day = datetime(year, month, 1)
            
            # Weekday for the first day (0 = Monday, 6 = Sunday in ISO format)
            # first_weekday will be between 0-6, where 0 is Monday
            first_weekday = first_day.weekday()
            
            # Number of days in current month
            if month == 12:
                last_day = datetime(year + 1, 1, 1) - timedelta(days=1)
            else:
                last_day = datetime(year, month + 1, 1) - timedelta(days=1)
            days_in_month = last_day.day
            
            # Build calendar as a matrix
            cal = []
            week = [0] * 7  # Initialize with 7 zeros
            
            # Fill previous days with zeros
            for i in range(first_weekday):
                week[i] = 0
                
            day = 1
            for i in range(first_weekday, 7):
                if day <= days_in_month:
                    week[i] = day
                    day += 1
                else:
                    week[i] = 0
                    
            cal.append(week)
            
            # Continue with the rest of the weeks
            while day <= days_in_month:
                week = [0] * 7
                for i in range(7):
                    if day <= days_in_month:
                        week[i] = day
                        day += 1
                    else:
                        week[i] = 0
                cal.append(week)
                
            return cal
            
        def update_calendar(self):
            # Update month and year label
            month_name = self.month_names[self.month]
            self.month_year_label.config(text=f"{month_name} {self.year}")
            
            # Get calendar for current month
            cal = self.get_month_calendar(self.year, self.month)
            
            # Reset all cells
            for row in self.day_cells:
                for cell in row:
                    cell.config(
                        text="",
                        bg=self.calendar_bg,
                        command=lambda: None
                    )
            
            # Fill cells with dates
            for week_idx, week in enumerate(cal):
                for day_idx, day in enumerate(week):
                    if day != 0:
                        # Determine if day has events
                        date_obj = datetime(self.year, self.month, day)
                        date_str = date_obj.strftime("%Y-%m-%d")
                        has_events = date_str in self.events and len(self.events[date_str]) > 0
                        
                        # Text for cell
                        cell_text = f"{day}"
                        if has_events:
                            cell_text += f"\n[{len(self.events[date_str])} events]"
                        
                        # Configure cell
                        self.day_cells[week_idx][day_idx].config(
                            text=cell_text,
                            bg="#d3d3d3" if has_events else self.calendar_bg,
                            command=lambda d=day, m=self.month, y=self.year: 
                                   self.day_click(d, m, y)
                        )
        
        def day_click(self, day, month, year):
            """Handler for clicking on a day in the calendar"""
            date_obj = datetime(year, month, day)
            date_str = date_obj.strftime("%Y-%m-%d")
            date_display = f"{day} {self.month_names[month]} {year}"
            
            # Create window for viewing/adding events
            events_window = tk.Toplevel(self.rootCalendar)
            events_window.title(f"Events - {date_display}")
            events_window.geometry("400x300")
            events_window.configure(bg=self.win95_bg)
            
            # Title bar
            title_bar = tk.Frame(events_window, bg="#000080", height=22)
            title_bar.pack(fill=tk.X)
            
            title_text = tk.Label(
                title_bar, 
                text=f"Events - {date_display}",
                fg="white", 
                bg="#000080",
                font=("Arial", 8, "bold")
            )
            title_text.pack(side=tk.LEFT, padx=5)
            
            # Close button
            close_button = tk.Button(
                title_bar, 
                text="X", 
                bg="#c0c0c0",
                width=2,
                relief="raised",
                bd=1,
                command=events_window.destroy
            )
            close_button.pack(side=tk.RIGHT)
            
            # Main frame
            main_frame = tk.Frame(events_window, bg=self.win95_bg, bd=2, relief="raised")
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Listbox with events
            events_label = tk.Label(
                main_frame, 
                text="Events:", 
                bg=self.win95_bg,
                font=("Arial", 8, "bold"),
                anchor="w"
            )
            events_label.pack(fill=tk.X, padx=5, pady=5)
            
            events_frame = tk.Frame(main_frame, bg="white", bd=1, relief="sunken")
            events_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            events_listbox = tk.Listbox(
                events_frame,
                font=("Arial", 8),
                bg="white",
                selectmode=tk.SINGLE
            )
            events_listbox.pack(fill=tk.BOTH, expand=True)
            
            # Action buttons
            buttons_frame = tk.Frame(main_frame, bg=self.win95_bg)
            buttons_frame.pack(fill=tk.X, pady=5)
            
            add_button = self.create_win95_button(
                buttons_frame, 
                "Add event", 
                lambda: self.add_event(date_str, events_listbox, events_window)
            )
            add_button.pack(side=tk.LEFT, padx=5)
            
            delete_button = self.create_win95_button(
                buttons_frame, 
                "Delete event", 
                lambda: self.delete_event(date_str, events_listbox)
            )
            delete_button.pack(side=tk.LEFT, padx=5)
            
            close_button = self.create_win95_button(
                buttons_frame, 
                "Close", 
                events_window.destroy
            )
            close_button.pack(side=tk.RIGHT, padx=5)
            
            # Populate listbox with existing events
            if date_str in self.events:
                for event in self.events[date_str]:
                    events_listbox.insert(tk.END, event)
        
        def add_event(self, date_str, listbox, parent_window):
            """Add an event for the specified date"""
            event = simpledialog.askstring(
                "Add event",
                "Enter event description:",
                parent=parent_window
            )
            
            if event:
                if date_str not in self.events:
                    self.events[date_str] = []
                
                self.events[date_str].append(event)
                listbox.insert(tk.END, event)
                self.update_calendar()
                self.save_events()  # Save events after adding
        
        def delete_event(self, date_str, listbox):
            """Delete the selected event"""
            selected = listbox.curselection()
            
            if selected:
                index = selected[0]
                if date_str in self.events and index < len(self.events[date_str]):
                    listbox.delete(index)
                    del self.events[date_str][index]
                    self.update_calendar()
                    self.save_events()  # Save events after deleting
            else:
                messagebox.showinfo(
                    "Warning",
                    "Select an event to delete."
                )
        
        def prev_month(self):
            """Navigate to previous month"""
            if self.month > 1:
                self.month -= 1
            else:
                self.month = 12
                self.year -= 1
            self.update_calendar()
        
        def next_month(self):
            """Navigate to next month"""
            if self.month < 12:
                self.month += 1
            else:
                self.month = 1
                self.year += 1
            self.update_calendar()
        
        def save_events(self):
            """Save events to a JSON file"""
            with open("calendar_events.json", "w") as file:
                json.dump(self.events, file)
        
        def load_events(self):
            """Load events from a JSON file"""
            try:
                if os.path.exists("calendar_events.json"):
                    with open("calendar_events.json", "r") as file:
                        self.events = json.load(file)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load events: {str(e)}")
                self.events = {}


    if __name__ == "__main__":
        rootCalendar = tk.Tk()
        app = Win95CalendarApp(rootCalendar)
        rootCalendar.iconbitmap("calendar.ico") if os.path.exists("calendar.ico") else None
        rootCalendar.mainloop()
        
if allmonitorvar == 999001:
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    import tkinter as tk
    from tkinter import ttk, messagebox
    import psutil
    import platform
    import threading
    import time
    from datetime import datetime
    import subprocess
    import re
    import sys

    class HardwareMonitorApplication:
        def __init__(self, rootAllMonitorAllMonitor):
            self.rootAllMonitorAllMonitor = rootAllMonitorAllMonitor
            self.rootAllMonitorAllMonitor.title("Hardware Monitor")
            self.rootAllMonitorAllMonitor.geometry("800x600")
            
            # Variabilă pentru tema curentă
            self.current_theme = "win95"  # Implicit "win95", alternativ "modern"
            
            # Buton pentru schimbarea temei - adăugat la începutul inițializării
            self.theme_button = tk.Button(
                rootAllMonitorAllMonitor, 
                text="Toggle Theme", 
                command=self.toggle_theme,
                relief="raised",
                bd=2
            )
            self.theme_button.pack(anchor="ne", padx=10, pady=5)
            
            # Configurare temă Win95 inițială
            self.configure_win95_theme()
            
            # Alert threshold variables
            self.thresholds = {
                "cpu": 80,  # CPU usage percentage
                "memory": 80,  # Memory usage percentage
                "disk": 90,  # Disk usage percentage
                "temperature": 80,  # Temperature in Celsius
                "gpu": 80  # GPU usage percentage
            }
            
            # Create tabs
            self.tab_control = ttk.Notebook(rootAllMonitorAllMonitor)
            
            self.tab_summary = ttk.Frame(self.tab_control)
            self.tab_cpu = ttk.Frame(self.tab_control)
            self.tab_memory = ttk.Frame(self.tab_control)
            self.tab_disk = ttk.Frame(self.tab_control)
            self.tab_network = ttk.Frame(self.tab_control)
            self.tab_alerts = ttk.Frame(self.tab_control)
            
            self.tab_control.add(self.tab_summary, text="System Summary")
            self.tab_control.add(self.tab_cpu, text="CPU")
            self.tab_control.add(self.tab_memory, text="Memory")
            self.tab_control.add(self.tab_disk, text="Disk")
            self.tab_control.add(self.tab_network, text="Network")
            self.tab_control.add(self.tab_alerts, text="Alerts")
            
            # Check if GPU is available and create GPU tab if it is
            self.has_gpu = self.check_gpu_available()
            if self.has_gpu:
                self.tab_gpu = ttk.Frame(self.tab_control)
                self.tab_control.add(self.tab_gpu, text="GPU")
            
            self.tab_control.pack(expand=1, fill="both")
            
            # Initialize tabs
            self.initialize_summary_tab()
            self.initialize_cpu_tab()
            self.initialize_memory_tab()
            self.initialize_disk_tab()
            self.initialize_network_tab()
            self.initialize_alerts_tab()
            
            # Initialize GPU tab if available
            if self.has_gpu:
                self.initialize_gpu_tab()
            
            # Alert log
            self.alert_log = []
            
            # Start data update thread
            self.running = True
            self.update_thread = threading.Thread(target=self.update_data)
            self.update_thread.daemon = True
            self.update_thread.start()
        
        def check_gpu_available(self):
            """Verifică dacă există un GPU detectabil în sistem"""
            try:
                if platform.system() == "Windows":
                    # Windows - Încercăm să folosim NVIDIA-SMI
                    try:
                        subprocess.check_output(["nvidia-smi"])
                        self.gpu_type = "nvidia"
                        return True
                    except (subprocess.SubprocessError, FileNotFoundError):
                        # Încercăm AMD
                        try:
                            subprocess.check_output(["rocm-smi"])
                            self.gpu_type = "amd"
                            return True
                        except (subprocess.SubprocessError, FileNotFoundError):
                            pass
                elif platform.system() == "Linux":
                    # Linux - Verificăm fișierele de dispozitiv
                    try:
                        # Căutăm GPU NVIDIA
                        if subprocess.call("which nvidia-smi > /dev/null 2>&1", shell=True) == 0:
                            self.gpu_type = "nvidia"
                            return True
                        # Căutăm GPU AMD
                        elif subprocess.call("which rocm-smi > /dev/null 2>&1", shell=True) == 0:
                            self.gpu_type = "amd"
                            return True
                        else:
                            # Încercăm să verificăm direct dispozitivele
                            lspci_output = subprocess.check_output("lspci | grep -E 'VGA|3D|Display'", shell=True).decode('utf-8')
                            if "NVIDIA" in lspci_output:
                                self.gpu_type = "nvidia"
                                return True
                            elif "AMD" in lspci_output or "ATI" in lspci_output:
                                self.gpu_type = "amd"
                                return True
                    except:
                        pass
                elif platform.system() == "Darwin":  # macOS
                    # Pe macOS verificăm informațiile sistemului
                    try:
                        system_profiler = subprocess.check_output(["system_profiler", "SPDisplaysDataType"]).decode('utf-8')
                        if "NVIDIA" in system_profiler:
                            self.gpu_type = "nvidia"
                            return True
                        elif "AMD" in system_profiler:
                            self.gpu_type = "amd"
                            return True
                        else:
                            # MacOS are întotdeauna un GPU, dar poate fi integrat
                            self.gpu_type = "integrated"
                            return True
                    except:
                        pass
            except Exception as e:
                print(f"Error checking GPU: {e}")
            
            return False
        
        def toggle_theme(self):
            """Comută între temele disponibile"""
            if self.current_theme == "win95":
                self.configure_modern_theme()
                self.current_theme = "modern"
                self.theme_button.config(text="Switch to Win95 Theme")
                self.rootAllMonitorAllMonitor.title("Modern Hardware Monitor")
            else:
                self.configure_win95_theme()
                self.current_theme = "win95"
                self.theme_button.config(text="Switch to Modern Theme")
                self.rootAllMonitorAllMonitor.title("Windows 95 Hardware Monitor")
        
        def configure_win95_theme(self):
            """Configurează aspectul temei Windows 95"""
            # Configure Windows 95 style colors and fonts
            bg_color = "#c0c0c0"  # Classic Win95 gray
            button_color = "#c0c0c0"
            text_color = "#000000"
            
            self.rootAllMonitorAllMonitor.configure(bg=bg_color)
            
            # Configurare buton de toggle
            self.theme_button.config(
                bg=button_color,
                fg=text_color,
                activebackground="#a0a0a0",
                activeforeground="#000000",
                font=("MS Sans Serif", 9),
                text="Switch to Modern Theme"
            )
            
            # Configure ttk style
            style = ttk.Style()
            style.theme_use('clam')  # Use closest theme to Win95
            
            # Configure fonts
            default_font = ("MS Sans Serif", 9)
            header_font = ("MS Sans Serif", 10, "bold")
            
            # Configure styles
            style.configure("TFrame", background=bg_color)
            style.configure("TLabel", background=bg_color, foreground=text_color, font=default_font)
            style.configure("TButton", background=button_color, foreground=text_color, font=default_font, relief="raised")
            style.configure("TNotebook", background=bg_color, tabmargins=[2, 5, 2, 0])
            style.configure("TNotebook.Tab", background=button_color, foreground=text_color, font=default_font, padding=[10, 2])
            style.configure("TProgressbar", background="#008080", troughcolor="#ffffff")
            style.configure("TLabelframe", background=bg_color, foreground=text_color, font=header_font)
            style.configure("TLabelframe.Label", background=bg_color, foreground=text_color, font=header_font)
            
            # Configure Listbox
            self.listbox_style = {"background": "#ffffff", "foreground": "#000000", "font": default_font, 
                                 "selectbackground": "#000080", "selectforeground": "#ffffff"}
            
            # Update any existing listboxes
            if hasattr(self, 'listbox_log'):
                self.listbox_log.config(**self.listbox_style)
        
        def configure_modern_theme(self):
            """Configurează aspectul temei moderne cu accente neon"""
            # Culori pentru tema modernă
            bg_color = "#121212"  # Fundal aproape negru
            darker_bg = "#0a0a0a"  # Fundal mai închis pentru contraste
            text_color = "#ffffff"  # Text alb
            accent_cyan = "#00ffff"  # Cyan neon
            accent_purple = "#cc00ff"  # Purple neon
            accent_green = "#00ff8c"  # Verde neon
            
            self.rootAllMonitorAllMonitor.configure(bg=bg_color)
            
            # Configurare buton de toggle
            self.theme_button.config(
                bg=darker_bg,
                fg=accent_cyan,
                activebackground="#303030",
                activeforeground=accent_purple,
                font=("Segoe UI", 9, "bold"),
                text="Switch to Win95 Theme"
            )
            
            # Configure ttk style
            style = ttk.Style()
            style.theme_use('clam')
            
            # Configure fonts
            default_font = ("Segoe UI", 9)
            header_font = ("Segoe UI", 10, "bold")
            
            # Configure styles
            style.configure("TFrame", background=bg_color)
            style.configure("TLabel", background=bg_color, foreground=text_color, font=default_font)
            style.configure("TButton", font=default_font)
            style.map("TButton", 
                      background=[("active", darker_bg), ("!active", bg_color)],
                      foreground=[("active", accent_cyan), ("!active", accent_purple)])
            
            # Notebook și tab-uri
            style.configure("TNotebook", background=darker_bg, tabmargins=[2, 5, 2, 0])
            style.configure("TNotebook.Tab", 
                            background=darker_bg, 
                            foreground=text_color, 
                            font=default_font, 
                            padding=[10, 2])
            style.map("TNotebook.Tab", 
                      background=[("selected", bg_color), ("active", "#303030")],
                      foreground=[("selected", accent_cyan), ("active", accent_purple)])
            
            # Progress bar
            style.configure("TProgressbar", 
                            background=accent_green,  # Bara de progres verde neon
                            troughcolor=darker_bg)    # Fundal mai închis
            
            # Frame-uri
            style.configure("TLabelframe", 
                            background=bg_color, 
                            foreground=accent_cyan, 
                            font=header_font)
            style.configure("TLabelframe.Label", 
                            background=bg_color, 
                            foreground=accent_cyan, 
                            font=header_font)
            
            # Configure Listbox
            self.listbox_style = {
                "background": darker_bg, 
                "foreground": text_color, 
                "font": default_font,
                "selectbackground": accent_purple, 
                "selectforeground": "#ffffff"
            }
            
            # Update any existing listboxes
            if hasattr(self, 'listbox_log'):
                self.listbox_log.config(**self.listbox_style)
        
        def initialize_summary_tab(self):
            # System information frame
            frame_info = ttk.LabelFrame(self.tab_summary, text="System Information")
            frame_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # System details
            system_os = platform.system() + " " + platform.version()
            processor = platform.processor()
            
            ttk.Label(frame_info, text=f"Operating System: {system_os}").pack(anchor="w", padx=10, pady=5)
            ttk.Label(frame_info, text=f"Processor: {processor}").pack(anchor="w", padx=10, pady=5)
            
            # Add GPU info if available
            if self.has_gpu:
                gpu_info = self.get_gpu_info()
                ttk.Label(frame_info, text=f"GPU: {gpu_info}").pack(anchor="w", padx=10, pady=5)
            
            # Main metrics frame
            frame_metrics = ttk.LabelFrame(self.tab_summary, text="Main Metrics")
            frame_metrics.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Metric labels
            self.label_cpu = ttk.Label(frame_metrics, text="CPU Usage: Loading...")
            self.label_cpu.pack(anchor="w", padx=10, pady=5)
            
            self.label_memory = ttk.Label(frame_metrics, text="Memory Usage: Loading...")
            self.label_memory.pack(anchor="w", padx=10, pady=5)
            
            self.label_disk = ttk.Label(frame_metrics, text="Disk Usage: Loading...")
            self.label_disk.pack(anchor="w", padx=10, pady=5)
            
            # Add GPU usage label if available
            if self.has_gpu:
                self.label_gpu = ttk.Label(frame_metrics, text="GPU Usage: Loading...")
                self.label_gpu.pack(anchor="w", padx=10, pady=5)
            
            # Detected problems frame
            self.frame_problems = ttk.LabelFrame(self.tab_summary, text="Detected Problems")
            self.frame_problems.pack(fill="both", expand=1, padx=10, pady=10)
            
            self.label_no_problems = ttk.Label(self.frame_problems, text="No problems detected")
            self.label_no_problems.pack(anchor="w", padx=10, pady=5)
        
        def initialize_cpu_tab(self):
            # CPU information frame
            frame_cpu_info = ttk.LabelFrame(self.tab_cpu, text="CPU Information")
            frame_cpu_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # CPU details
            physical_cores = psutil.cpu_count(logical=False)
            logical_cores = psutil.cpu_count(logical=True)
            
            ttk.Label(frame_cpu_info, text=f"Physical cores: {physical_cores}").pack(anchor="w", padx=10, pady=5)
            ttk.Label(frame_cpu_info, text=f"Logical cores: {logical_cores}").pack(anchor="w", padx=10, pady=5)
            
            # CPU usage frame
            frame_cpu_usage = ttk.LabelFrame(self.tab_cpu, text="CPU Usage")
            frame_cpu_usage.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Usage labels
            self.label_cpu_usage = ttk.Label(frame_cpu_usage, text="Total usage: Loading...")
            self.label_cpu_usage.pack(anchor="w", padx=10, pady=5)
            
            # CPU usage progress bar
            ttk.Label(frame_cpu_usage, text="Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_cpu = ttk.Progressbar(frame_cpu_usage, orient="horizontal", length=700, mode="determinate")
            self.progress_cpu.pack(padx=10, pady=5)
            
            # CPU frequency frame
            frame_cpu_freq = ttk.LabelFrame(self.tab_cpu, text="CPU Frequency")
            frame_cpu_freq.pack(fill="both", expand=1, padx=10, pady=10)
            
            self.label_cpu_freq = ttk.Label(frame_cpu_freq, text="Current frequency: Loading...")
            self.label_cpu_freq.pack(anchor="w", padx=10, pady=5)
        
        def initialize_memory_tab(self):
            # Memory information frame
            frame_memory_info = ttk.LabelFrame(self.tab_memory, text="Memory Information")
            frame_memory_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get memory information
            mem = psutil.virtual_memory()
            total_mem = round(mem.total / (1024 ** 3), 2)
            
            ttk.Label(frame_memory_info, text=f"Total memory: {total_mem} GB").pack(anchor="w", padx=10, pady=5)
            
            # Memory usage frame
            frame_memory_usage = ttk.LabelFrame(self.tab_memory, text="Memory Usage")
            frame_memory_usage.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Usage label
            self.label_memory_usage = ttk.Label(frame_memory_usage, text="Usage: Loading...")
            self.label_memory_usage.pack(anchor="w", padx=10, pady=5)
            
            # Memory usage progress bar
            ttk.Label(frame_memory_usage, text="Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_memory = ttk.Progressbar(frame_memory_usage, orient="horizontal", length=700, mode="determinate")
            self.progress_memory.pack(padx=10, pady=5)
            
            # Swap frame
            frame_swap = ttk.LabelFrame(self.tab_memory, text="Swap Memory")
            frame_swap.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Swap information
            swap = psutil.swap_memory()
            total_swap = round(swap.total / (1024 ** 3), 2)
            
            ttk.Label(frame_swap, text=f"Total swap: {total_swap} GB").pack(anchor="w", padx=10, pady=5)
            
            self.label_swap_usage = ttk.Label(frame_swap, text="Swap usage: Loading...")
            self.label_swap_usage.pack(anchor="w", padx=10, pady=5)
            
            # Swap usage progress bar
            ttk.Label(frame_swap, text="Swap usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_swap = ttk.Progressbar(frame_swap, orient="horizontal", length=700, mode="determinate")
            self.progress_swap.pack(padx=10, pady=5)
        
        def initialize_disk_tab(self):
            frame_disk_info = ttk.LabelFrame(self.tab_disk, text="Disk Information")
            frame_disk_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get partition information
            partitions = psutil.disk_partitions()
            
            # Container for partition progress bars
            self.frame_partitions = ttk.Frame(frame_disk_info)
            self.frame_partitions.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Dictionary to store labels and progress bars
            self.disk_labels = {}
            self.disk_progress = {}
            
            # Add information for each partition
            for partition in partitions:
                try:
                    usage = psutil.disk_usage(partition.mountpoint)
                    usage_percent = usage.percent
                    
                    # Frame for this partition
                    frame_partition = ttk.Frame(self.frame_partitions)
                    frame_partition.pack(fill="x", pady=5)
                    
                    # Partition information
                    total_gb = round(usage.total / (1024 ** 3), 2)
                    used_gb = round(usage.used / (1024 ** 3), 2)
                    free_gb = round(usage.free / (1024 ** 3), 2)
                    
                    info_text = f"Partition: {partition.mountpoint} | Total: {total_gb} GB | Used: {used_gb} GB | Free: {free_gb} GB | Usage: {usage_percent}%"
                    label = ttk.Label(frame_partition, text=info_text)
                    label.pack(anchor="w")
                    
                    # Progress bar for usage
                    progress = ttk.Progressbar(frame_partition, orient="horizontal", length=700, mode="determinate")
                    progress["value"] = usage_percent
                    progress.pack(pady=2)
                    
                    # Save references for later updates
                    self.disk_labels[partition.mountpoint] = label
                    self.disk_progress[partition.mountpoint] = progress
                    
                except (PermissionError, FileNotFoundError):
                    # Ignore partitions we can't access
                    pass
            
            # IO information frame
            frame_io = ttk.LabelFrame(self.tab_disk, text="Disk IO Activity")
            frame_io.pack(fill="both", expand=1, padx=10, pady=10)
            
            # IO labels
            self.label_disk_read = ttk.Label(frame_io, text="Read speed: Loading...")
            self.label_disk_read.pack(anchor="w", padx=10, pady=5)
            
            self.label_disk_write = ttk.Label(frame_io, text="Write speed: Loading...")
            self.label_disk_write.pack(anchor="w", padx=10, pady=5)
        
        def initialize_network_tab(self):
            frame_network_info = ttk.LabelFrame(self.tab_network, text="Network Information")
            frame_network_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get network interfaces
            interfaces = psutil.net_if_addrs()
            
            # Add information for each interface
            for interface, addresses in interfaces.items():
                # Create frame for this interface
                frame_interface = ttk.LabelFrame(frame_network_info, text=f"Interface: {interface}")
                frame_interface.pack(fill="x", padx=10, pady=5)
                
                # Add address information
                for address in addresses:
                    if address.family == 2:  # IPv4
                        ttk.Label(frame_interface, text=f"IPv4: {address.address}").pack(anchor="w", padx=10, pady=2)
                    elif address.family == 23:  # IPv6
                        ttk.Label(frame_interface, text=f"IPv6: {address.address}").pack(anchor="w", padx=10, pady=2)
                    elif address.family == 17:  # MAC
                        ttk.Label(frame_interface, text=f"MAC: {address.address}").pack(anchor="w", padx=10, pady=2)
            
            # Traffic frame
            frame_traffic = ttk.LabelFrame(self.tab_network, text="Network Traffic")
            frame_traffic.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Traffic labels
            self.label_download = ttk.Label(frame_traffic, text="Download: Loading...")
            self.label_download.pack(anchor="w", padx=10, pady=5)
            
            self.label_upload = ttk.Label(frame_traffic, text="Upload: Loading...")
            self.label_upload.pack(anchor="w", padx=10, pady=5)
            
            # Previous network traffic statistics
            self.bytes_sent_previous = psutil.net_io_counters().bytes_sent
            self.bytes_recv_previous = psutil.net_io_counters().bytes_recv
            self.timestamp_previous = time.time()
        
        def initialize_gpu_tab(self):
            """Inițializează tab-ul GPU dacă este disponibil"""
            frame_gpu_info = ttk.LabelFrame(self.tab_gpu, text="GPU Information")
            frame_gpu_info.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Get GPU information
            gpu_info = self.get_gpu_info()
            ttk.Label(frame_gpu_info, text=f"GPU: {gpu_info}").pack(anchor="w", padx=10, pady=5)
            
            # GPU usage frame
            frame_gpu_usage = ttk.LabelFrame(self.tab_gpu, text="GPU Usage")
            frame_gpu_usage.pack(fill="both", expand=1, padx=10, pady=10)
            
            # GPU usage label
            self.label_gpu_usage = ttk.Label(frame_gpu_usage, text="Usage: Loading...")
            self.label_gpu_usage.pack(anchor="w", padx=10, pady=5)
            
            # GPU usage progress bar
            ttk.Label(frame_gpu_usage, text="Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_gpu = ttk.Progressbar(frame_gpu_usage, orient="horizontal", length=700, mode="determinate")
            self.progress_gpu.pack(padx=10, pady=5)
            
            # GPU memory frame
            frame_gpu_memory = ttk.LabelFrame(self.tab_gpu, text="GPU Memory")
            frame_gpu_memory.pack(fill="both", expand=1, padx=10, pady=10)
            
            # GPU memory label
            self.label_gpu_memory = ttk.Label(frame_gpu_memory, text="Memory: Loading...")
            self.label_gpu_memory.pack(anchor="w", padx=10, pady=5)
            
            # GPU memory progress bar
            ttk.Label(frame_gpu_memory, text="Memory Usage:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_gpu_memory = ttk.Progressbar(frame_gpu_memory, orient="horizontal", length=700, mode="determinate")
            self.progress_gpu_memory.pack(padx=10, pady=5)
            
            # GPU temperature frame
            frame_gpu_temp = ttk.LabelFrame(self.tab_gpu, text="GPU Temperature")
            frame_gpu_temp.pack(fill="both", expand=1, padx=10, pady=10)
            
            # GPU temperature label
            self.label_gpu_temp = ttk.Label(frame_gpu_temp, text="Temperature: Loading...")
            self.label_gpu_temp.pack(anchor="w", padx=10, pady=5)
            
            # GPU temperature progress bar
            ttk.Label(frame_gpu_temp, text="Temperature:").pack(anchor="w", padx=10, pady=(10, 0))
            self.progress_gpu_temp = ttk.Progressbar(frame_gpu_temp, orient="horizontal", length=700, mode="determinate")
            self.progress_gpu_temp.pack(padx=10, pady=5)
        
        def get_gpu_info(self):
            """Obține informații despre GPU-ul instalat"""
            if not self.has_gpu:
                return "No GPU detected"
            
            try:
                if self.gpu_type == "nvidia":
                    result = subprocess.check_output(["nvidia-smi", "--query-gpu=name", "--format=csv,noheader"]).decode('utf-8').strip()
                    return result
                elif self.gpu_type == "amd":
                    result = subprocess.check_output(["rocm-smi", "--showproductname"]).decode('utf-8')
                    return result.split("\n")[1].strip() if len(result.split("\n")) > 1 else "AMD GPU"
                elif self.gpu_type == "integrated":
                    if platform.system() == "Darwin":  # macOS
                        try:
                            system_profiler = subprocess.check_output(["system_profiler", "SPDisplaysDataType"]).decode('utf-8')
                            for line in system_profiler.split("\n"):
                                if "Chipset Model:" in line:
                                    return line.split("Chipset Model:")[1].strip()
                        except:
                            pass
                    return "Integrated GPU"
            except Exception as e:
                print(f"Error getting GPU info: {e}")
                return "GPU detected but info unavailable"
        
        def get_gpu_usage(self):
            """Obține utilizarea GPU-ului"""
            if not self.has_gpu:
                return 0, 0, 0  # Usage, Memory usage, Temperature
            
            try:
                if self.gpu_type == "nvidia":
                    # NVIDIA-SMI pentru obținerea utilizării
                    result = subprocess.check_output([
                        "nvidia-smi",
                        "--query-gpu=utilization.gpu,memory.used,memory.total,temperature.gpu",
                        "--format=csv,noheader,nounits"
                    ]).decode('utf-8').strip()
                    
                    values = result.split(", ")
                    if len(values) >= 4:
                        gpu_usage = float(values[0])
                        gpu_memory_used = float(values[1])
                        gpu_memory_total = float(values[2])
                        gpu_memory_usage = (gpu_memory_used / gpu_memory_total) * 100 if gpu_memory_total > 0 else 0
                        gpu_temp = float(values[3])
                        return gpu_usage, gpu_memory_usage, gpu_temp
                    
                elif self.gpu_type == "amd":
                    # Pentru AMD, folosim rocm-smi
                    result = subprocess.check_output(["rocm-smi", "--showuse", "--showmemuse", "--showtemp"]).decode('utf-8')
                    
                    # Analizăm rezultatul pentru a extrage valorile
                    gpu_usage = 0
                    gpu_memory_usage = 0
                    gpu_temp = 0
                    
                    for line in result.split("\n"):
                        if "GPU use" in line:
                            usage_match = re.search(r"(\d+)%", line)
                            if usage_match:
                                gpu_usage = float(usage_match.group(1))
                        elif "Memory use" in line:
                            memory_match = re.search(r"(\d+)%", line)
                            if memory_match:
                                gpu_memory_usage = float(memory_match.group(1))
                        elif "Temperature" in line:
                            temp_match = re.search(r"(\d+\.\d+)C", line)
                            if temp_match:
                                gpu_temp = float(temp_match.group(1))
                    
                    return gpu_usage, gpu_memory_usage, gpu_temp
                    
                elif self.gpu_type == "integrated":
                    # For integrated GPUs on macOS, try to get system info
                    if platform.system() == "Darwin":
                        try:
                            # On macOS we can't get exact GPU usage for integrated GPUs
                            # Estimate based on system statistics
                            # This is just an approximation
                            cpu_percent = psutil.cpu_percent()
                            gpu_usage = cpu_percent * 0.5  # Rough estimation
                            gpu_memory_usage = 50  # Default value as we can't measure accurately
                            gpu_temp = 50  # Default value as we can't measure accurately
                            return gpu_usage, gpu_memory_usage, gpu_temp
                        except:
                            pass
                    # Default values if no specific method works
                    return 0, 0, 0
                    
            except Exception as e:
                print(f"Error getting GPU usage: {e}")
                return 0, 0, 0

        def initialize_alerts_tab(self):
            """Initialize the alerts configuration tab"""
            # Create main frame
            frame_alerts = ttk.Frame(self.tab_alerts)
            frame_alerts.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Thresholds configuration frame
            frame_thresholds = ttk.LabelFrame(frame_alerts, text="Alert Thresholds")
            frame_thresholds.pack(fill="x", expand=0, padx=10, pady=10)
            
            # CPU threshold
            frame_cpu = ttk.Frame(frame_thresholds)
            frame_cpu.pack(fill="x", pady=5)
            
            ttk.Label(frame_cpu, text="CPU Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            self.cpu_threshold_var = tk.StringVar(value=str(self.thresholds["cpu"]))
            self.cpu_threshold_entry = ttk.Entry(frame_cpu, textvariable=self.cpu_threshold_var, width=10)
            self.cpu_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # Memory threshold
            frame_memory = ttk.Frame(frame_thresholds)
            frame_memory.pack(fill="x", pady=5)
            
            ttk.Label(frame_memory, text="Memory Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            self.memory_threshold_var = tk.StringVar(value=str(self.thresholds["memory"]))
            self.memory_threshold_entry = ttk.Entry(frame_memory, textvariable=self.memory_threshold_var, width=10)
            self.memory_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # Disk threshold
            frame_disk = ttk.Frame(frame_thresholds)
            frame_disk.pack(fill="x", pady=5)
            
            ttk.Label(frame_disk, text="Disk Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            self.disk_threshold_var = tk.StringVar(value=str(self.thresholds["disk"]))
            self.disk_threshold_entry = ttk.Entry(frame_disk, textvariable=self.disk_threshold_var, width=10)
            self.disk_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # GPU threshold
            if self.has_gpu:
                frame_gpu = ttk.Frame(frame_thresholds)
                frame_gpu.pack(fill="x", pady=5)
                
                ttk.Label(frame_gpu, text="GPU Usage (%)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
                self.gpu_threshold_var = tk.StringVar(value=str(self.thresholds["gpu"]))
                self.gpu_threshold_entry = ttk.Entry(frame_gpu, textvariable=self.gpu_threshold_var, width=10)
                self.gpu_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
                
                # Temperature threshold
                frame_temp = ttk.Frame(frame_thresholds)
                frame_temp.pack(fill="x", pady=5)
                
                ttk.Label(frame_temp, text="GPU Temperature (°C)").grid(row=0, column=0, padx=5, pady=5, sticky="w")
                self.temp_threshold_var = tk.StringVar(value=str(self.thresholds["temperature"]))
                self.temp_threshold_entry = ttk.Entry(frame_temp, textvariable=self.temp_threshold_var, width=10)
                self.temp_threshold_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # Button to save thresholds
            save_button = ttk.Button(frame_thresholds, text="Save Thresholds", 
                                   command=self.save_thresholds)
            save_button.pack(pady=10)
            
            # Alerts log frame
            frame_log = ttk.LabelFrame(frame_alerts, text="Alerts Log")
            frame_log.pack(fill="both", expand=1, padx=10, pady=10)
            
            # Create listbox with scrollbar
            scrollbar = ttk.Scrollbar(frame_log)
            scrollbar.pack(side="right", fill="y")
            
            self.listbox_log = tk.Listbox(frame_log, height=10, width=100, 
                                         yscrollcommand=scrollbar.set, 
                                         **self.listbox_style)
            self.listbox_log.pack(side="left", fill="both", expand=1, padx=5, pady=5)
            
            scrollbar.config(command=self.listbox_log.yview)
            
            # Add some initial log entries
            self.listbox_log.insert(tk.END, "Alert system initialized")
            self.listbox_log.insert(tk.END, f"Current time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.listbox_log.insert(tk.END, "No alerts detected yet")
        
        def save_thresholds(self):
            """Save the threshold values from the input fields"""
            try:
                # Try to convert values to float
                cpu_val = float(self.cpu_threshold_var.get())
                memory_val = float(self.memory_threshold_var.get())
                disk_val = float(self.disk_threshold_var.get())
                
                # Validate values are within range
                if not (0 <= cpu_val <= 100):
                    raise ValueError("CPU threshold must be between 0 and 100")
                if not (0 <= memory_val <= 100):
                    raise ValueError("Memory threshold must be between 0 and 100")
                if not (0 <= disk_val <= 100):
                    raise ValueError("Disk threshold must be between 0 and 100")
                
                # Update thresholds
                self.thresholds["cpu"] = cpu_val
                self.thresholds["memory"] = memory_val
                self.thresholds["disk"] = disk_val
                
                if self.has_gpu:
                    gpu_val = float(self.gpu_threshold_var.get())
                    temp_val = float(self.temp_threshold_var.get())
                    
                    if not (0 <= gpu_val <= 100):
                        raise ValueError("GPU threshold must be between 0 and 100")
                    if not (0 <= temp_val <= 100):
                        raise ValueError("Temperature threshold must be between 0 and 100")
                    
                    self.thresholds["gpu"] = gpu_val
                    self.thresholds["temperature"] = temp_val
                
                # Add log entry
                log_entry = f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - Thresholds updated"
                self.listbox_log.insert(0, log_entry)
                
                # Show confirmation
                messagebox.showinfo("Thresholds", "Alert thresholds saved successfully")
            
            except ValueError as e:
                # Show error message
                messagebox.showerror("Input Error", str(e))
            except Exception as e:
                # Show error message
                messagebox.showerror("Error", f"Failed to save thresholds: {str(e)}")
        
        def add_alert(self, message):
            """Add an alert to the log"""
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_entry = f"{timestamp} - {message}"
            
            # Add to internal alert log
            self.alert_log.append(log_entry)
            
            # Add to listbox
            self.listbox_log.insert(0, log_entry)
            
            # Show popup
            #messagebox.showwarning("Alert", message)
        
        def update_data(self):
            """Update all system data in a background thread"""
            # Initialize previous disk IO stats
            disk_io_prev = psutil.disk_io_counters()
            prev_time = time.time()
            
            while self.running:
                try:
                    # Update CPU data
                    cpu_percent = psutil.cpu_percent()
                    
                    # Get CPU frequency
                    try:
                        cpu_freq = psutil.cpu_freq()
                        if cpu_freq:
                            cpu_freq_text = f"Current frequency: {cpu_freq.current:.2f} MHz"
                        else:
                            cpu_freq_text = "CPU frequency not available"
                    except:
                        cpu_freq_text = "CPU frequency not available"
                    
                    # Update memory data
                    mem = psutil.virtual_memory()
                    swap = psutil.swap_memory()
                    
                    # Update disk data
                    partitions = psutil.disk_partitions()
                    
                    # Update disk IO
                    current_time = time.time()
                    time_diff = current_time - prev_time
                    
                    if time_diff > 0:
                        disk_io = psutil.disk_io_counters()
                        
                        # Calculate read/write speeds
                        read_bytes = disk_io.read_bytes - disk_io_prev.read_bytes
                        write_bytes = disk_io.write_bytes - disk_io_prev.write_bytes
                        
                        read_speed = round(read_bytes / time_diff / (1024 * 1024), 2)  # MB/s
                        write_speed = round(write_bytes / time_diff / (1024 * 1024), 2)  # MB/s
                        
                        # Update previous values
                        disk_io_prev = disk_io
                        prev_time = current_time
                    else:
                        read_speed = write_speed = 0
                    
                    # Update network data
                    net_io = psutil.net_io_counters()
                    
                    # Calculate network speeds
                    current_time = time.time()
                    time_diff = current_time - self.timestamp_previous
                    
                    if time_diff > 0:
                        bytes_sent = net_io.bytes_sent - self.bytes_sent_previous
                        bytes_recv = net_io.bytes_recv - self.bytes_recv_previous
                        
                        upload_speed = round(bytes_sent / time_diff / 1024, 2)  # KB/s
                        download_speed = round(bytes_recv / time_diff / 1024, 2)  # KB/s
                        
                        # Update previous values
                        self.bytes_sent_previous = net_io.bytes_sent
                        self.bytes_recv_previous = net_io.bytes_recv
                        self.timestamp_previous = current_time
                    else:
                        upload_speed = download_speed = 0
                    
                    # Update GPU data if available
                    if self.has_gpu:
                        gpu_usage, gpu_memory, gpu_temp = self.get_gpu_usage()
                    
                    # Update GUI in the main thread
                    self.rootAllMonitorAllMonitor.after(0, lambda: self.update_ui(
                        cpu_percent, cpu_freq_text, 
                        mem, swap, 
                        partitions, 
                        read_speed, write_speed,
                        upload_speed, download_speed,
                        gpu_usage, gpu_memory, gpu_temp if self.has_gpu else 0
                    ))
                    
                    # Check for alerts
                    self.check_alerts(
                        cpu_percent, 
                        mem.percent, 
                        partitions,
                        gpu_usage, gpu_temp if self.has_gpu else 0
                    )
                    
                    # Sleep for a short time
                    time.sleep(1)
                    
                except Exception as e:
                    print(f"Error updating data: {e}")
                    time.sleep(2)
        
        def check_alerts(self, cpu_percent, memory_percent, partitions, gpu_percent=0, gpu_temp=0):
            """Check for threshold alerts"""
            problem_detected = False
            problems_text = []
            
            # CPU check
            if cpu_percent > self.thresholds["cpu"]:
                problem_detected = True
                message = f"CPU usage is high: {cpu_percent:.1f}% (threshold: {self.thresholds['cpu']}%)"
                problems_text.append(message)
                
                # Add to alert log if not already alerted recently
                if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                    self.add_alert(message)
            
            # Memory check
            if memory_percent > self.thresholds["memory"]:
                problem_detected = True
                message = f"Memory usage is high: {memory_percent:.1f}% (threshold: {self.thresholds['memory']}%)"
                problems_text.append(message)
                
                # Add to alert log if not already alerted recently
                if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                    self.add_alert(message)
            
            # Disk check
            for partition in partitions:
                try:
                    usage = psutil.disk_usage(partition.mountpoint)
                    if usage.percent > self.thresholds["disk"]:
                        problem_detected = True
                        message = f"Disk usage on {partition.mountpoint} is high: {usage.percent:.1f}% (threshold: {self.thresholds['disk']}%)"
                        problems_text.append(message)
                        
                        # Add to alert log if not already alerted recently
                        if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                            self.add_alert(message)
                except:
                    pass
            
            # GPU checks
            if self.has_gpu:
                if gpu_percent > self.thresholds["gpu"]:
                    problem_detected = True
                    message = f"GPU usage is high: {gpu_percent:.1f}% (threshold: {self.thresholds['gpu']}%)"
                    problems_text.append(message)
                    
                    # Add to alert log if not already alerted recently
                    if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                        self.add_alert(message)
                
                if gpu_temp > self.thresholds["temperature"]:
                    problem_detected = True
                    message = f"GPU temperature is high: {gpu_temp:.1f}°C (threshold: {self.thresholds['temperature']}°C)"
                    problems_text.append(message)
                    
                    # Add to alert log if not already alerted recently
                    if not any(message in alert for alert in self.alert_log[-10:] if self.alert_log):
                        self.add_alert(message)
            
            # Update the problems frame
            def update_problems():
                # Remove all widgets
                for widget in self.frame_problems.winfo_children():
                    widget.destroy()
                
                if problem_detected:
                    # Add each problem as a label
                    for problem in problems_text:
                        ttk.Label(self.frame_problems, text=problem, foreground="red").pack(anchor="w", padx=10, pady=2)
                else:
                    ttk.Label(self.frame_problems, text="No problems detected").pack(anchor="w", padx=10, pady=5)
            
            # Update in main thread
            self.rootAllMonitorAllMonitor.after(0, update_problems)
        
        def update_ui(self, cpu_percent, cpu_freq_text, mem, swap, partitions, read_speed, write_speed, 
                     upload_speed, download_speed, gpu_usage=0, gpu_memory=0, gpu_temp=0):
            """Update the UI with new data"""
            try:
                # Update CPU data
                self.label_cpu.config(text=f"CPU Usage: {cpu_percent:.1f}%")
                self.label_cpu_usage.config(text=f"Total usage: {cpu_percent:.1f}%")
                self.progress_cpu["value"] = cpu_percent
                self.label_cpu_freq.config(text=cpu_freq_text)
                
                # Update memory data
                used_mem = round(mem.used / (1024 ** 3), 2)
                total_mem = round(mem.total / (1024 ** 3), 2)
                
                self.label_memory.config(text=f"Memory Usage: {mem.percent:.1f}% ({used_mem} GB / {total_mem} GB)")
                self.label_memory_usage.config(text=f"Usage: {mem.percent:.1f}% ({used_mem} GB / {total_mem} GB)")
                self.progress_memory["value"] = mem.percent
                
                # Update swap data
                used_swap = round(swap.used / (1024 ** 3), 2)
                total_swap = round(swap.total / (1024 ** 3), 2)
                swap_percent = swap.percent if swap.total > 0 else 0
                
                self.label_swap_usage.config(text=f"Swap usage: {swap_percent:.1f}% ({used_swap} GB / {total_swap} GB)")
                self.progress_swap["value"] = swap_percent
                
                # Update disk data
                # Update the first partition in the summary tab
                try:
                    main_partition = partitions[0]
                    usage = psutil.disk_usage(main_partition.mountpoint)
                    used_disk = round(usage.used / (1024 ** 3), 2)
                    total_disk = round(usage.total / (1024 ** 3), 2)
                    
                    self.label_disk.config(text=f"Disk Usage: {usage.percent:.1f}% ({used_disk} GB / {total_disk} GB)")
                except:
                    self.label_disk.config(text="Disk Usage: Not available")
                
                # Update all partition details
                for partition in partitions:
                    try:
                        if partition.mountpoint in self.disk_labels:
                            usage = psutil.disk_usage(partition.mountpoint)
                            usage_percent = usage.percent
                            total_gb = round(usage.total / (1024 ** 3), 2)
                            used_gb = round(usage.used / (1024 ** 3), 2)
                            free_gb = round(usage.free / (1024 ** 3), 2)
                            
                            info_text = f"Partition: {partition.mountpoint} | Total: {total_gb} GB | Used: {used_gb} GB | Free: {free_gb} GB | Usage: {usage_percent}%"
                            self.disk_labels[partition.mountpoint].config(text=info_text)
                            self.disk_progress[partition.mountpoint]["value"] = usage_percent
                    except:
                        pass
                
                # Update disk IO
                self.label_disk_read.config(text=f"Read speed: {read_speed} MB/s")
                self.label_disk_write.config(text=f"Write speed: {write_speed} MB/s")
                
                # Update network data
                self.label_download.config(text=f"Download: {download_speed} KB/s")
                self.label_upload.config(text=f"Upload: {upload_speed} KB/s")
                
                # Update GPU data if available
                if self.has_gpu:
                    self.label_gpu.config(text=f"GPU Usage: {gpu_usage:.1f}%")
                    self.label_gpu_usage.config(text=f"Usage: {gpu_usage:.1f}%")
                    self.progress_gpu["value"] = gpu_usage
                    
                    self.label_gpu_memory.config(text=f"Memory: {gpu_memory:.1f}%")
                    self.progress_gpu_memory["value"] = gpu_memory
                    
                    self.label_gpu_temp.config(text=f"Temperature: {gpu_temp:.1f}°C")
                    self.progress_gpu_temp["value"] = gpu_temp
            
            except Exception as e:
                print(f"Error updating UI: {e}")
        
        def on_closing(self):
            """Handle application closing"""
            self.running = False
            time.sleep(0.5)  # Wait for thread to finish
            self.rootAllMonitorAllMonitor.destroy()

    def main():
        rootAllMonitor = tk.Tk()
        app = HardwareMonitorApplication(rootAllMonitor)
        rootAllMonitor.protocol("WM_DELETE_WINDOW", app.on_closing)
        rootAllMonitor.mainloop()

    if __name__ == "__main__":
        main()

if assemblyvar == 333333333:
    from tkinter import font
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class RetroDebugger:
        def __init__(self, rootasm):
            self.rootasm = rootasm
            self.rootasm.title("Registry x64 Debugger")
            # Full screen și fără bordură
            self.rootasm.attributes('-fullscreen', True)
            self.rootasm.overrideredirect(True)  # Elimină bara de titlu
            
            # Culori de interfață
            self.bg_color = "#000080"  # Albastru închis
            self.text_color = "#FFFFFF"  # Alb
            self.highlight_color = "#FFFF00"  # Galben pentru evidențiere
            self.header_color = "#00FFFF"  # Cyan pentru header
            self.changed_color = "#FF0000"  # Roșu pentru valorile modificate
            
            # Font Roboto Bold pentru toate elementele
            self.font = font.Font(family="Roboto", size=12, weight="bold")
            self.small_font = font.Font(family="Roboto", size=10, weight="bold")
            self.header_font = font.Font(family="Roboto", size=14, weight="bold")
            
            # Configurare rootasm
            self.rootasm.configure(bg=self.bg_color)
            
            # Variabile pentru stare
            self.selected_register = 0
            self.editing_mode = False
            self.edit_value = ""
            
            # Definirea registrilor
            self.registers = {
                "EAX": "0000FFFF",
                "EBX": "00000000",
                "ECX": "AAAAAAAA",
                "EDX": "00001234",
                "ESI": "BBBB0000",
                "EDI": "CCCC0000",
                "EBP": "FFFF0000",
                "ESP": "EEEE1111",
                "CS": "0008",
                "DS": "0010",
                "ES": "0010",
                "SS": "0018",
                "IP": "7C00"
            }
            
            # Istoricul valorilor pentru a marca schimbările
            self.prev_registers = self.registers.copy()
            
            # Inițializarea memoriei hex (32 rânduri x 16 bytes)
            self.memory = {}
            base_addr = 0x7C00  # Adresa de start tipică pentru boot
            for i in range(32):
                addr = base_addr + (i * 16)
                self.memory[addr] = [0 for _ in range(16)]  # Inițial toate zero
            
            # Flag pentru oprirea thread-ului de actualizare
            self.stop_thread = False
            
            # Crearea cadrelor principale
            self.main_frame = tk.Frame(self.rootasm, bg=self.bg_color)
            self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Crearea header-ului
            self.header_frame = tk.Frame(self.main_frame, bg=self.bg_color)
            self.header_frame.pack(fill=tk.X, pady=(5, 15))
            
            self.title_label = tk.Label(
                self.header_frame, 
                text="x64 Debug Monitor v0.2",
                font=self.header_font,
                fg=self.header_color,
                bg=self.bg_color
            )
            self.title_label.pack(side=tk.LEFT)
            
            # Crearea conținutului pe două coloane
            self.content_frame = tk.Frame(self.main_frame, bg=self.bg_color)
            self.content_frame.pack(fill=tk.BOTH, expand=True)
            
            # Cadru pentru registri (partea stângă)
            self.registers_frame = tk.Frame(self.content_frame, bg=self.bg_color, width=400)
            self.registers_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=(0, 20))
            
            # Cadru pentru memoria hex (partea dreaptă)
            self.memory_frame = tk.Frame(self.content_frame, bg=self.bg_color)
            self.memory_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
            
            # Crearea footer-ului
            self.footer_frame = tk.Frame(self.main_frame, bg=self.bg_color)
            self.footer_frame.pack(fill=tk.X, side=tk.BOTTOM, pady=(15, 5))
            
            self.footer_label = tk.Label(
                self.footer_frame, 
                text="↑↓: Select Register   Enter: Edit Value   ESC: Exit   F5: Run/Stop   F11: Toggle Fullscreen",
                font=self.small_font,
                fg=self.text_color,
                bg=self.bg_color
            )
            self.footer_label.pack(side=tk.LEFT)
            
            # Adăugarea evenimentelor de tastatură
            self.rootasm.bind("<Up>", self.move_up)
            self.rootasm.bind("<Down>", self.move_down)
            self.rootasm.bind("<Return>", self.toggle_edit_mode)
            self.rootasm.bind("<Escape>", self.cancel_or_exit)
            self.rootasm.bind("<F5>", self.toggle_run)
            self.rootasm.bind("<KeyPress>", self.handle_key)
            self.rootasm.bind("<F11>", self.toggle_fullscreen)  # Adăugare pentru a ieși din fullscreen
            
            # Flag pentru rularea simulării
            self.is_running = False
            
            # Randomizare memorie inițială
            self.randomize_memory()
            
            # Afișarea registrilor și memoriei
            self.update_display()
            
            # Pornirea thread-ului pentru actualizarea memoriei
            self.updater_thread = threading.Thread(target=self.memory_updater)
            self.updater_thread.daemon = True
            self.updater_thread.start()
        
        def randomize_memory(self):
            """Metoda pentru inițializarea aleatorie a memoriei"""
            for addr in self.memory:
                self.memory[addr] = [random.randint(0, 255) for _ in range(16)]
        
        def update_display(self):
            # Actualizare registri
            self.update_registers_display()
            
            # Actualizare memorie
            self.update_memory_display()
        
        def update_registers_display(self):
            # Ștergerea afișării registrilor anteriori
            for widget in self.registers_frame.winfo_children():
                widget.destroy()
            
            # Titlul registrilor
            reg_title = tk.Label(
                self.registers_frame,
                text="CPU Registers",
                font=self.header_font,
                fg=self.header_color,
                bg=self.bg_color
            )
            reg_title.pack(anchor=tk.W, pady=(0, 20))
            
            # Separator
            separator = tk.Frame(self.registers_frame, height=2, bg=self.text_color)
            separator.pack(fill=tk.X, pady=(0, 20))
            
            # Afișarea fiecărui registru
            for i, (reg_name, reg_value) in enumerate(self.registers.items()):
                # Evidențiere registru selectat
                frame_bg = self.highlight_color if i == self.selected_register else self.bg_color
                text_fg = self.bg_color if i == self.selected_register else self.text_color
                
                # Cadru pentru fiecare rând
                reg_frame = tk.Frame(self.registers_frame, bg=frame_bg)
                reg_frame.pack(fill=tk.X, pady=2)
                
                # Numele registrului
                name_label = tk.Label(
                    reg_frame,
                    text=f"{reg_name}:",
                    font=self.font,
                    fg=text_fg,  # Culoarea textului se schimbă pentru cel selectat
                    bg=frame_bg,
                    width=6,
                    anchor=tk.W
                )
                name_label.pack(side=tk.LEFT, padx=(20, 10))
                
                # Valoarea registrului
                value_text = reg_value
                if self.editing_mode and i == self.selected_register:
                    value_text = self.edit_value + "_"
                
                # Verifică dacă valoarea s-a schimbat
                value_fg = text_fg  # Implicit, culoarea textului depinde de selecție
                if not (i == self.selected_register) and reg_name in self.prev_registers and reg_value != self.prev_registers[reg_name]:
                    value_fg = self.changed_color  # Roșu pentru valorile modificate
                
                value_label = tk.Label(
                    reg_frame,
                    text=value_text,
                    font=self.font,
                    fg=value_fg,
                    bg=frame_bg,
                    anchor=tk.W
                )
                value_label.pack(side=tk.LEFT)
        
        def update_memory_display(self):
            # Ștergerea afișării memoriei anterioare
            for widget in self.memory_frame.winfo_children():
                widget.destroy()
            
            # Titlul memoriei
            mem_title = tk.Label(
                self.memory_frame,
                text="Memory Dump",
                font=self.header_font,
                fg=self.header_color,
                bg=self.bg_color
            )
            mem_title.pack(anchor=tk.W, pady=(0, 20))
            
            # Separator
            separator = tk.Frame(self.memory_frame, height=2, bg=self.text_color)
            separator.pack(fill=tk.X, pady=(0, 20))
            
            # Header pentru memoria hex
            header_frame = tk.Frame(self.memory_frame, bg=self.bg_color)
            header_frame.pack(fill=tk.X)
            
            addr_header = tk.Label(
                header_frame,
                text="Address",
                font=self.small_font,
                fg=self.header_color,
                bg=self.bg_color,
                width=10,
                anchor=tk.W
            )
            addr_header.pack(side=tk.LEFT, padx=(0, 10))
            
            # Header pentru bytes
            for i in range(16):
                byte_header = tk.Label(
                    header_frame,
                    text=f"{i:02X}",
                    font=self.small_font,
                    fg=self.header_color,
                    bg=self.bg_color,
                    width=2,
                    anchor=tk.CENTER
                )
                byte_header.pack(side=tk.LEFT, padx=1)
            
            # Afișarea fiecărui rând de memorie
            mem_canvas = tk.Canvas(self.memory_frame, bg=self.bg_color, highlightthickness=0)
            mem_canvas.pack(fill=tk.BOTH, expand=True)
            
            # Frame în canvas pentru a permite scrolling
            mem_inner_frame = tk.Frame(mem_canvas, bg=self.bg_color)
            mem_canvas.create_window((0, 0), window=mem_inner_frame, anchor=tk.NW)
            
            for i, addr in enumerate(sorted(self.memory.keys())):
                row_frame = tk.Frame(mem_inner_frame, bg=self.bg_color)
                row_frame.pack(fill=tk.X, pady=1)
                
                # Adresa
                addr_label = tk.Label(
                    row_frame,
                    text=f"{addr:08X}",
                    font=self.small_font,
                    fg=self.text_color,
                    bg=self.bg_color,
                    width=10,
                    anchor=tk.W
                )
                addr_label.pack(side=tk.LEFT, padx=(0, 10))
                
                # Bytes - cu posibilitatea de a evidenția bytes modificați recent
                for i, byte in enumerate(self.memory[addr]):
                    # Aleatoriu, unele valori apar evidențiate (simulând o modificare recentă)
                    highlight = random.random() < 0.05 and self.is_running  # 5% șansă de evidențiere când rulează
                    fg_color = self.changed_color if highlight else self.text_color
                    
                    byte_label = tk.Label(
                        row_frame,
                        text=f"{byte:02X}",
                        font=self.small_font,
                        fg=fg_color,
                        bg=self.bg_color,
                        width=2,
                        anchor=tk.CENTER
                    )
                    byte_label.pack(side=tk.LEFT, padx=1)
        
        def move_up(self, event):
            if self.editing_mode:
                return
            
            if self.selected_register > 0:
                self.selected_register -= 1
                self.update_registers_display()
        
        def move_down(self, event):
            if self.editing_mode:
                return
            
            if self.selected_register < len(self.registers) - 1:
                self.selected_register += 1
                self.update_registers_display()
        
        def toggle_edit_mode(self, event):
            reg_name = list(self.registers.keys())[self.selected_register]
            
            if self.editing_mode:
                # Salvează valoarea editată
                if self.is_valid_hex(self.edit_value):
                    padded_value = self.edit_value.zfill(len(self.registers[reg_name]))
                    self.prev_registers[reg_name] = self.registers[reg_name]
                    self.registers[reg_name] = padded_value.upper()
                self.editing_mode = False
            else:
                # Începe editarea
                self.editing_mode = True
                self.edit_value = ""
            
            self.update_registers_display()
        
        def cancel_or_exit(self, event):
            if self.editing_mode:
                self.editing_mode = False
                self.edit_value = ""
                self.update_registers_display()
            else:
                # Oprim thread-ul înainte de a ieși
                self.stop_thread = True
                self.rootasm.destroy()
                
        def toggle_fullscreen(self, event):
            # Pentru a ieși din fullscreen
            is_fullscreen = self.rootasm.attributes('-fullscreen')
            self.rootasm.attributes('-fullscreen', not is_fullscreen)
            if is_fullscreen:
                self.rootasm.overrideredirect(False)  # Readuce bara de titlu
            else:
                self.rootasm.overrideredirect(True)  # Elimină bara de titlu
        
        def toggle_run(self, event):
            self.is_running = not self.is_running
            status = "Running" if self.is_running else "Stopped"
            self.footer_label.config(text=f"↑↓: Select Register   Enter: Edit Value   ESC: Exit   F5: Run/Stop   F11: Toggle Fullscreen   [Status: {status}]")
        
        def is_valid_hex(self, value):
            try:
                int(value, 16)
                return True
            except ValueError:
                return False
        
        def handle_key(self, event):
            if not self.editing_mode:
                return
                
            key = event.char.upper()
            
            # Verifică dacă tasta apăsată este un caracter hexazecimal
            if key in "0123456789ABCDEF":
                reg_name = list(self.registers.keys())[self.selected_register]
                max_length = len(self.registers[reg_name])
                
                if len(self.edit_value) < max_length:
                    self.edit_value += key
                    self.update_registers_display()
            # Backspace
            elif event.keysym == "BackSpace" and self.edit_value:
                self.edit_value = self.edit_value[:-1]
                self.update_registers_display()
        
        def memory_updater(self):
            try:
                while not self.stop_thread:
                    if self.is_running:
                        # Simularea modificării aleatorii a registrilor
                        reg_keys = list(self.registers.keys())
                        reg_to_update = random.choice(reg_keys)
                        
                        # Salvăm vechea valoare
                        self.prev_registers[reg_to_update] = self.registers[reg_to_update]
                        
                        # Generăm o nouă valoare
                        if reg_to_update in ["CS", "DS", "ES", "SS", "IP"]:
                            # Registri de 16 biți
                            new_value = f"{random.randint(0, 0xFFFF):04X}"
                        else:
                            # Registri de 32 biți
                            new_value = f"{random.randint(0, 0xFFFFFFFF):08X}"
                        
                        self.registers[reg_to_update] = new_value
                        
                        # Actualizăm memoria hexazecimală aleator - mai multe locații simultan
                        num_changes = random.randint(3, 8)  # Modificăm între 3 și 8 bytes simultan
                        for _ in range(num_changes):
                            mem_addr = random.choice(list(self.memory.keys()))
                            byte_pos = random.randint(0, 15)
                            self.memory[mem_addr][byte_pos] = random.randint(0, 255)
                        
                        # Actualizăm afișajul în thread-ul principal
                        self.rootasm.after(0, self.update_display)
                        
                    # Interval aleator de actualizare între 0.1 și 0.8 secunde
                    time.sleep(random.uniform(0.1, 0.8))
            except Exception as e:
                print(f"Error in updater thread: {e}")

    if __name__ == "__main__":
        rootasm = tk.Tk()
        app = RetroDebugger(rootasm)
        rootasm.mainloop()

if eventvval == 44445555:
    class Windows95EventViewer:
        def __init__(self, rooteventv):
            self.rooteventv = rooteventv
            self.rooteventv.title("Event Viewer")
            self.rooteventv.geometry("800x600")
            
            # Setări pentru tema Windows 95
            self.configure_win95_theme()
            
            # Variabile pentru filtrare
            self.filter_type = tk.StringVar(value="All")
            self.filter_source = tk.StringVar(value="All")
            self.filter_period = tk.StringVar(value="All")
            
            # Creare interfață
            self.create_menu()
            self.create_toolbar()
            self.create_main_frame()
            self.create_status_bar()
            
            # Inițializare date
            self.events = []
            self.load_events()
            
            # Pornire monitorizare în fundal
            self.monitoring = True
            self.monitor_thread = threading.Thread(target=self.monitor_events)
            self.monitor_thread.daemon = True
            self.monitor_thread.start()
        
        def configure_win95_theme(self):
            # Setează culorile temei Windows 95
            bg_color = "#c0c0c0"  # Gri deschis pentru fundal
            button_color = "#c0c0c0"  # Gri pentru butoane
            text_color = "#000000"  # Negru pentru text
            
            self.rooteventv.configure(bg=bg_color)
            
            # Creează stiluri pentru temă
            style = ttk.Style()
            
            # Configurare font sistem Windows 95
            default_font = font.nametofont("TkDefaultFont")
            default_font.configure(family="Roboto", size=9)
            
            # Configurare stil butoane și alte elemente
            style.configure("W95.TButton", 
                          background=button_color, 
                          foreground=text_color,
                          relief="raised",
                          font=("Roboto", 9))
            
            style.configure("W95.TFrame", background=bg_color)
            style.configure("W95.TLabel", background=bg_color, foreground=text_color)
            style.configure("W95.TCheckbutton", background=bg_color, foreground=text_color)
            
            # Configurare stil pentru listbox și treeview
            style.configure("W95.Treeview", 
                          background="white", 
                          foreground=text_color,
                          fieldbackground="white",
                          borderwidth=1,
                          relief="sunken",
                          font=("Roboto", 9))
            
            style.configure("W95.Treeview.Heading", 
                          background=button_color, 
                          foreground=text_color,
                          relief="raised",
                          font=("Roboto", 9, "bold"))
        
        def create_menu(self):
            # Creare bară de meniu în stil Windows 95
            menu_bar = tk.Menu(self.rooteventv, bg="#c0c0c0", fg="black", relief="raised", borderwidth=1)
            
            # Meniu Fișier
            file_menu = tk.Menu(menu_bar, tearoff=0, bg="#c0c0c0", fg="black")
            file_menu.add_command(label="Save events", command=self.save_events)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rooteventv.quit)
            menu_bar.add_cascade(label="File", menu=file_menu)
            
            # Meniu Vizualizare
            view_menu = tk.Menu(menu_bar, tearoff=0, bg="#c0c0c0", fg="black")
            view_menu.add_command(label="Refresh", command=self.refresh_events)
            view_menu.add_separator()
            view_menu.add_command(label="Filter", command=self.show_filter_dialog)
            menu_bar.add_cascade(label="View", menu=view_menu)
            
            # Meniu Ajutor
            help_menu = tk.Menu(menu_bar, tearoff=0, bg="#c0c0c0", fg="black")
            help_menu.add_command(label="About", command=self.show_about)
            menu_bar.add_cascade(label="Help", menu=help_menu)
            
            self.rooteventv.config(menu=menu_bar)
        
        def create_toolbar(self):
            # Creare bară de unelte în stil Windows 95
            toolbar_frame = tk.Frame(self.rooteventv, bg="#c0c0c0", bd=1, relief="raised")
            toolbar_frame.pack(side=tk.TOP, fill=tk.X)
            
            # Butoane pentru bara de unelte
            refresh_button = ttk.Button(toolbar_frame, text="Refresh", style="W95.TButton", 
                                       command=self.refresh_events)
            refresh_button.pack(side=tk.LEFT, padx=2, pady=2)
            
            filter_button = ttk.Button(toolbar_frame, text="Filter", style="W95.TButton", 
                                      command=self.show_filter_dialog)
            filter_button.pack(side=tk.LEFT, padx=2, pady=2)
            
            # Separator
            separator = ttk.Separator(toolbar_frame, orient="vertical")
            separator.pack(side=tk.LEFT, padx=5, pady=2, fill="y")
            
            # Tipuri de evenimente cu checkbox-uri
            error_var = tk.IntVar(value=1)
            warning_var = tk.IntVar(value=1)
            info_var = tk.IntVar(value=1)
            
            self.filter_vars = {
                "Error": error_var,
                "Warning": warning_var,
                "Information": info_var
            }
            
            error_cb = ttk.Checkbutton(toolbar_frame, text="Errors", variable=error_var, 
                                      style="W95.TCheckbutton", command=self.apply_filters)
            error_cb.pack(side=tk.LEFT, padx=2, pady=2)
            
            warning_cb = ttk.Checkbutton(toolbar_frame, text="Warnings", variable=warning_var, 
                                        style="W95.TCheckbutton", command=self.apply_filters)
            warning_cb.pack(side=tk.LEFT, padx=2, pady=2)
            
            info_cb = ttk.Checkbutton(toolbar_frame, text="Informations", variable=info_var, 
                                     style="W95.TCheckbutton", command=self.apply_filters)
            info_cb.pack(side=tk.LEFT, padx=2, pady=2)
        
        def create_main_frame(self):
            # Creare frame principal cu lista de evenimente
            main_frame = ttk.Frame(self.rooteventv, style="W95.TFrame")
            main_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Creare treeview pentru evenimente
            columns = ("Type", "Date", "Source", "ID", "Description")
            self.tree = ttk.Treeview(main_frame, columns=columns, show="headings", style="W95.Treeview")
            
            # Configurare coloane
            self.tree.heading("Type", text="Type")
            self.tree.heading("Date", text="Date & Time")
            self.tree.heading("Source", text="Source")
            self.tree.heading("ID", text="Event ID")
            self.tree.heading("Description", text="Description")
            
            self.tree.column("Type", width=80, anchor=tk.W)
            self.tree.column("Date", width=150, anchor=tk.W)
            self.tree.column("Source", width=100, anchor=tk.W)
            self.tree.column("ID", width=80, anchor=tk.CENTER)
            self.tree.column("Description", width=350, anchor=tk.W)
            
            # Adăugare scrollbar
            scrollbar_y = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
            self.tree.configure(yscrollcommand=scrollbar_y.set)
            
            # Aranjare elemente
            self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Setare acțiune pentru dublu click
            self.tree.bind("<Double-1>", self.show_event_details)
        
        def create_status_bar(self):
            # Creare bară de stare în stil Windows 95
            self.status_bar = tk.Frame(self.rooteventv, bg="#c0c0c0", bd=1, relief="sunken")
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
            
            # Text pentru bară de stare
            self.status_text = tk.Label(self.status_bar, text="Ready", bg="#c0c0c0", anchor=tk.W, padx=5, pady=2)
            self.status_text.pack(side=tk.LEFT, fill=tk.X)
            
            # Indicator număr evenimente
            self.event_count = tk.Label(self.status_bar, text="Events: 0", bg="#c0c0c0", padx=5, pady=2)
            self.event_count.pack(side=tk.RIGHT)
        
        def load_events(self):
            """Încarcă evenimentele din jurnalele de sistem"""
            self.status_text.config(text="Loading events...")
            self.rooteventv.update()
            
            # Curățare evenimente existente
            self.events = []
            self.tree.delete(*self.tree.get_children())
            
            try:
                os_name = platform.system()
                
                if os_name == "Windows":
                    # Pentru Windows folosim wevtutil sau PowerShell
                    self.load_windows_events()
                elif os_name == "Linux":
                    # Pentru Linux folosim journalctl
                    self.load_linux_events()
                elif os_name == "Darwin":
                    # Pentru macOS folosim log command
                    self.load_macos_events()
                else:
                    messagebox.showerror("Error", f"The operating system {os_name} is not supported.")
                    return
                
                # Aplicare filtre și actualizare interfață
                self.apply_filters()
                self.status_text.config(text="Ready")
            
            except Exception as e:
                messagebox.showerror("Error", f"Unable to load events: {str(e)}")
                self.status_text.config(text="Error loading events")
        
        def load_windows_events(self):
            """Încarcă evenimentele din Event Viewer din Windows"""
            try:
                # Încercăm mai întâi PowerShell pentru mai multe detalii
                command = 'powershell "Get-WinEvent -LogName Application, System -MaxEvents 100 | Select-Object TimeCreated, LevelDisplayName, ProviderName, Id, Message | ConvertTo-Csv -NoTypeInformation"'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if len(lines) > 1:  # Verificăm dacă avem date (prima linie este header)
                        import csv
                        from io import StringIO
                        
                        # Parsare CSV
                        reader = csv.DictReader(StringIO(result.stdout))
                        for row in reader:
                            event_type = row.get('LevelDisplayName', '').strip()
                            # Mapare tipuri de evenimente
                            if event_type.lower() == 'error':
                                event_type = 'Error'
                            elif event_type.lower() == 'warning':
                                event_type = 'Warning'
                            elif event_type.lower() == 'information':
                                event_type = 'Information'
                            
                            timestamp = row.get('TimeCreated', '')
                            source = row.get('ProviderName', '')
                            event_id = row.get('Id', '')
                            description = row.get('Message', '')
                            
                            if description and len(description) > 100:
                                description = description[:100] + "..."
                            
                            self.events.append({
                                'type': event_type,
                                'date': timestamp,
                                'source': source,
                                'id': event_id,
                                'description': description,
                                'details': row.get('Message', '')
                            })
                    else:
                        # Fallback la metoda wevtutil pentru sisteme Windows mai vechi
                        self.load_windows_events_legacy()
                else:
                    # Fallback la metoda wevtutil pentru sisteme Windows mai vechi
                    self.load_windows_events_legacy()
                    
            except Exception as e:
                messagebox.showerror("Error", f"Could not load Windows events: {str(e)}")
        
        def load_windows_events_legacy(self):
            """Metodă alternativă pentru încărcarea evenimentelor din Windows"""
            try:
                command = 'wevtutil qe System /c:20 /rd:true /f:text'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    events_text = result.stdout
                    event_blocks = events_text.split("\n\n")
                    
                    for block in event_blocks:
                        if not block.strip():
                            continue
                        
                        lines = block.strip().split("\n")
                        event_data = {}
                        
                        for line in lines:
                            if ": " in line:
                                key, value = line.split(": ", 1)
                                event_data[key.strip()] = value.strip()
                        
                        # Extragere informații
                        event_type = "Information"  # Valoare implicită
                        if "Level" in event_data:
                            level = event_data["Level"].lower()
                            if "error" in level:
                                event_type = "Error"
                            elif "warn" in level:
                                event_type = "Warning"
                        
                        timestamp = event_data.get("Date", "")
                        source = event_data.get("Provider Name", "")
                        event_id = event_data.get("Event ID", "")
                        description = event_data.get("Description", "")
                        
                        if description and len(description) > 100:
                            description = description[:100] + "..."
                        
                        self.events.append({
                            'type': event_type,
                            'date': timestamp,
                            'source': source,
                            'id': event_id,
                            'description': description,
                            'details': event_data.get("Description", "")
                        })
                else:
                    raise Exception("Failed command: " + result.stderr)
                    
            except Exception as e:
                messagebox.showerror("Error", f"Could not load Windows events (legacy): {str(e)}")
        
        def load_linux_events(self):
            """Încarcă evenimentele din jurnalele Linux"""
            try:
                # Verificăm dacă avem acces la journalctl
                command = 'journalctl -n 100 --no-pager -o json'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    # Parsare JSON pentru fiecare linie
                    import json
                    for line in result.stdout.strip().split('\n'):
                        if not line.strip():
                            continue
                        
                        try:
                            log_entry = json.loads(line)
                            
                            # Determinare tip eveniment
                            priority = int(log_entry.get('PRIORITY', 6))
                            event_type = "Information"
                            if priority <= 3:
                                event_type = "Error"
                            elif priority == 4:
                                event_type = "Warning"
                            
                            # Formatare timestamp
                            timestamp = log_entry.get('__REALTIME_TIMESTAMP', '')
                            if timestamp:
                                timestamp = datetime.datetime.fromtimestamp(int(timestamp) / 1000000).strftime('%Y-%m-%d %H:%M:%S')
                            
                            source = log_entry.get('SYSLOG_IDENTIFIER', log_entry.get('_COMM', ''))
                            message = log_entry.get('MESSAGE', '')
                            
                            if message and len(message) > 100:
                                short_message = message[:100] + "..."
                            else:
                                short_message = message
                            
                            self.events.append({
                                'type': event_type,
                                'date': timestamp,
                                'source': source,
                                'id': log_entry.get('_PID', ''),
                                'description': short_message,
                                'details': message
                            })
                            
                        except json.JSONDecodeError:
                            continue
                else:
                    # Fallback la /var/log
                    self.load_linux_events_legacy()
                    
            except Exception as e:
                messagebox.showerror("Error", f"Unable to load Linux events: {str(e)}")
        
        def load_linux_events_legacy(self):
            """Metodă alternativă pentru încărcarea evenimentelor din Linux folosind fișiere de log"""
            try:
                log_files = ['/var/log/syslog', '/var/log/messages']
                
                for log_file in log_files:
                    if os.path.exists(log_file):
                        with open(log_file, 'r', errors='ignore') as f:
                            lines = f.readlines()[-100:]  # Ultimele 100 de linii
                            
                            for line in lines:
                                line = line.strip()
                                if not line:
                                    continue
                                
                                # Încercare de parsare
                                parts = line.split(' ', 5)
                                if len(parts) >= 6:
                                    date_str = ' '.join(parts[:3])
                                    host = parts[3]
                                    source = parts[4].rstrip(':')
                                    message = parts[5]
                                    
                                    # Determinare tip eveniment
                                    event_type = "Information"
                                    if any(err in line.lower() for err in ['error', 'err', 'fail', 'critical']):
                                        event_type = "Error"
                                    elif any(warn in line.lower() for warn in ['warn', 'alert']):
                                        event_type = "Warning"
                                    
                                    if message and len(message) > 100:
                                        short_message = message[:100] + "..."
                                    else:
                                        short_message = message
                                    
                                    self.events.append({
                                        'type': event_type,
                                        'date': date_str,
                                        'source': source,
                                        'id': '',
                                        'description': short_message,
                                        'details': message
                                    })
            except Exception as e:
                messagebox.showerror("Error", f"Unable to load Linux events (legacy): {str(e)}")
        
        def load_macos_events(self):
            """Încarcă evenimentele din jurnalele macOS"""
            try:
                # Folosim utilitarul log din macOS
                command = 'log show --style compact --last 1h'
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    
                    for line in lines:
                        if not line.strip():
                            continue
                        
                        # Încercare de parsare linie log macOS
                        match = re.match(r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d+).*\[(.*):(\d+)\] (.*)', line)
                        if match:
                            timestamp, source, pid, message = match.groups()
                            
                            # Determinare tip eveniment
                            event_type = "Information"
                            if any(err in line.lower() for err in ['error', 'err', 'fail', 'critical']):
                                event_type = "Error"
                            elif any(warn in line.lower() for warn in ['warn', 'alert']):
                                event_type = "Warning"
                            
                            if message and len(message) > 100:
                                short_message = message[:100] + "..."
                            else:
                                short_message = message
                            
                            self.events.append({
                                'type': event_type,
                                'date': timestamp,
                                'source': source,
                                'id': pid,
                                'description': short_message,
                                'details': message
                            })
                        else:
                            # Încercare alternativă de parsare
                            parts = line.split(' ', 5)
                            if len(parts) >= 6:
                                date_str = ' '.join(parts[:2])
                                source = parts[2]
                                message = parts[5] if len(parts) > 5 else ''
                                
                                # Determinare tip eveniment
                                event_type = "Information"
                                if any(err in line.lower() for err in ['error', 'err', 'fail', 'critical']):
                                    event_type = "Error"
                                elif any(warn in line.lower() for warn in ['warn', 'alert']):
                                    event_type = "Warning"
                                
                                if message and len(message) > 100:
                                    short_message = message[:100] + "..."
                                else:
                                    short_message = message
                                
                                self.events.append({
                                    'type': event_type,
                                    'date': date_str,
                                    'source': source,
                                    'id': '',
                                    'description': short_message,
                                    'details': message
                                })
                else:
                    raise Exception("Failed command: " + result.stderr)
                    
            except Exception as e:
                messagebox.showerror("Error", f"Could not load macOS events: {str(e)}")
        
        def parse_event_date(self, date_str):
            """Parsează string-ul de dată în format datetime"""
            if not date_str:
                return None
                
            # Lista formatelor de dată posibile
            date_formats = [
                '%Y-%m-%d %H:%M:%S',         # Format standard 
                '%Y-%m-%d %H:%M:%S.%f',      # Cu microsecunde
                '%b %d %H:%M:%S %Y',         # Format syslog
                '%Y-%m-%dT%H:%M:%S.%fZ',     # Format ISO
                '%a %b %d %H:%M:%S %Y',      # Format alt syslog
                '%d/%m/%Y %H:%M:%S',         # Format dd/mm/yyyy
                '%m/%d/%Y %H:%M:%S',         # Format mm/dd/yyyy
                '%Y-%m-%dT%H:%M:%S',         # Format ISO fără microsecunde
                '%d %b %Y %H:%M:%S'          # Format zi lună an
            ]
            
            for fmt in date_formats:
                try:
                    return datetime.datetime.strptime(date_str, fmt)
                except ValueError:
                    continue
                    
            return None
        
        def apply_filters(self):
            """Aplică filtrele și actualizează lista de evenimente"""
            # Curățare treeview
            self.tree.delete(*self.tree.get_children())
            
            # Obține filtrele active pentru tipuri de evenimente
            active_types = [tip for tip, var in self.filter_vars.items() if var.get() == 1]
            
            # Obține perioada de filtrat
            now = datetime.datetime.now()
            start_date = None
            
            if self.filter_period.get() == "Last hour":
                start_date = now - datetime.timedelta(hours=1)
            elif self.filter_period.get() == "Last 24 hours":
                start_date = now - datetime.timedelta(days=1)
            elif self.filter_period.get() == "Last week":
                start_date = now - datetime.timedelta(weeks=1)
            
            # Adaugă evenimentele filtrate
            displayed_events = 0
            for event in self.events:
                # Verificare tip eveniment
                if event['type'] not in active_types:
                    continue
                
                # Verificare perioadă (dacă este setată)
                if start_date is not None:
                    event_date = self.parse_event_date(event['date'])
                    # Dacă nu putem parsa data sau este în afara perioadei, sărim peste
                    if event_date is None or event_date < start_date:
                        continue
                
                # Adăugăm evenimentul în treeview
                self.tree.insert("", tk.END, values=(
                    event['type'],
                    event['date'],
                    event['source'],
                    event['id'],
                    event['description']
                ))
                displayed_events += 1
            
            # Actualizare contor și bară de stare
            self.event_count.config(text=f"Events: {displayed_events}")
            
            # Actualizare bară de stare cu informații despre filtre
            filter_info = "Filters: "
            
            # Adaugă informații despre tipurile filtrate
            type_filters = []
            if self.filter_vars["Error"].get() == 1:
                type_filters.append("Errors")
            if self.filter_vars["Warning"].get() == 1:
                type_filters.append("Warnings")
            if self.filter_vars["Information"].get() == 1:
                type_filters.append("Informations")
                
            filter_info += ", ".join(type_filters)
            
            # Adaugă informații despre perioada filtrată
            if self.filter_period.get() != "All":
                filter_info += f" | Period: {self.filter_period.get()}"
                
            self.status_text.config(text=filter_info)
        
        def show_event_details(self, event):
            """Afișează detaliile unui eveniment la dublu click"""
            selection = self.tree.selection()
            if not selection:
                return
                
            item_id = selection[0]
            item_values = self.tree.item(item_id, "values")
            
            # Găsește evenimentul complet
            event_details = None
            for event in self.events:
                if (event['type'] == item_values[0] and 
                    event['date'] == item_values[1] and 
                    event['source'] == item_values[2] and 
                    str(event['id']) == str(item_values[3])):
                    event_details = event
                    break
            
            if event_details:
                # Creare fereastră de detalii în stil Windows 95
                details_window = tk.Toplevel(self.rooteventv)
                details_window.title("Event details")
                details_window.geometry("600x400")
                details_window.configure(bg="#c0c0c0")
                
                # Titlu
                title_frame = tk.Frame(details_window, bg="#000080", relief="raised", borderwidth=1)
                title_frame.pack(fill=tk.X, padx=2, pady=2)
                
                title_label = tk.Label(title_frame, text="Event details", fg="white", bg="#000080", font=("Roboto", 10, "bold"))
                title_label.pack(anchor="w", padx=10, pady=5)
                
                # Informații eveniment
                info_frame = tk.Frame(details_window, bg="#c0c0c0", relief="sunken", borderwidth=1)
                info_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                # Grid pentru informații
                info_labels = [
                    ("Type:", event_details['type']),
                    ("Date & Time:", event_details['date']),
                    ("Source:", event_details['source']),
                    ("Event ID:", event_details['id']),
                ]
                
                for i, (label, value) in enumerate(info_labels):
                    tk.Label(info_frame, text=label, bg="#c0c0c0", anchor="w").grid(row=i, column=0, sticky="w", padx=5, pady=2)
                    tk.Label(info_frame, text=value, bg="#c0c0c0", anchor="w").grid(row=i, column=1, sticky="w", padx=5, pady=2)
                
                # Descriere completă
                tk.Label(info_frame, text="Description:", bg="#c0c0c0", anchor="w").grid(row=len(info_labels), column=0, sticky="nw", padx=5, pady=2)
                
                text_frame = tk.Frame(info_frame, bg="white", relief="sunken", borderwidth=1)
                text_frame.grid(row=len(info_labels), column=1, sticky="nsew", padx=5, pady=2)
                info_frame.grid_rowconfigure(len(info_labels), weight=1)
                info_frame.grid_columnconfigure(1, weight=1)
                
                text_widget = scrolledtext.ScrolledText(text_frame, wrap=tk.WORD, bg="white", relief="flat")
                text_widget.pack(fill=tk.BOTH, expand=True, padx=1, pady=1)
                text_widget.insert(tk.END, event_details.get('details', 'No description available'))
                text_widget.configure(state='disabled')  # Facem textul doar pentru citire
                
                # Butoane
                buttons_frame = tk.Frame(details_window, bg="#c0c0c0")
                buttons_frame.pack(fill=tk.X, padx=5, pady=5)
                
                close_button = tk.Button(buttons_frame, text="Close", bg="#c0c0c0", 
                                       command=details_window.destroy)
                close_button.pack(side=tk.RIGHT, padx=5)
        
        def show_filter_dialog(self):
            """Afișează dialogul pentru filtrare avansată"""
            filter_window = tk.Toplevel(self.rooteventv)
            filter_window.title("Event filtering")
            filter_window.geometry("400x300")
            filter_window.configure(bg="#c0c0c0")
            filter_window.resizable(False, False)
            
            # Titlu
            title_frame = tk.Frame(filter_window, bg="#000080", relief="raised", borderwidth=1)
            title_frame.pack(fill=tk.X, padx=2, pady=2)
            
            title_label = tk.Label(title_frame, text="Event filtering", fg="white", bg="#000080", 
                                  font=("MS Sans Serif", 10, "bold"))
            title_label.pack(anchor="w", padx=10, pady=5)
            
            # Conținut
            content_frame = tk.Frame(filter_window, bg="#c0c0c0", relief="sunken", borderwidth=1)
            content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Tipuri de evenimente
            tk.Label(content_frame, text="Event type:", bg="#c0c0c0", anchor="w").grid(row=0, column=0, 
                                                                                          sticky="w", padx=5, pady=10)
            
            # Radiobuttons pentru tipuri
            types_frame = tk.Frame(content_frame, bg="#c0c0c0")
            types_frame.grid(row=0, column=1, sticky="w", padx=5, pady=5)
            
            type_values = ["All", "Error", "Warning", "Information"]
            for i, value in enumerate(type_values):
                rb = tk.Radiobutton(types_frame, text=value, variable=self.filter_type, value=value, 
                                  bg="#c0c0c0")
                rb.grid(row=0, column=i, padx=5)
            
            # Surse
            tk.Label(content_frame, text="Source:", bg="#c0c0c0", anchor="w").grid(row=1, column=0, 
                                                                                 sticky="w", padx=5, pady=10)
            
            # Combobox pentru surse
            sources = ["All"] + sorted(list(set(event['source'] for event in self.events if event['source'])))
            source_combo = ttk.Combobox(content_frame, textvariable=self.filter_source, values=sources, state="readonly")
            source_combo.grid(row=1, column=1, sticky="w", padx=5, pady=5)
            
            # Perioadă
            tk.Label(content_frame, text="Period:", bg="#c0c0c0", anchor="w").grid(row=2, column=0, 
                                                                                    sticky="w", padx=5, pady=10)
            
            # Radiobuttons pentru perioadă
            period_frame = tk.Frame(content_frame, bg="#c0c0c0")
            period_frame.grid(row=2, column=1, sticky="w", padx=5, pady=5)
            
            period_values = ["All", "Last hour", "Last 24 hours", "Last week"]
            for i, value in enumerate(period_values):
                rb = tk.Radiobutton(period_frame, text=value, variable=self.filter_period, value=value, 
                                  bg="#c0c0c0")
                rb.grid(row=i//2, column=i%2, sticky="w", padx=5, pady=2)
            
            # Butoane
            buttons_frame = tk.Frame(filter_window, bg="#c0c0c0")
            buttons_frame.pack(fill=tk.X, padx=5, pady=5)
            
            apply_button = tk.Button(buttons_frame, text="Apply", bg="#c0c0c0", 
                                   command=lambda: [self.apply_filters(), filter_window.destroy()])
            apply_button.pack(side=tk.RIGHT, padx=5)
            
            cancel_button = tk.Button(buttons_frame, text="Cancel", bg="#c0c0c0", 
                                    command=filter_window.destroy)
            cancel_button.pack(side=tk.RIGHT, padx=5)
        
        def refresh_events(self):
            """Reîmprospătează lista de evenimente"""
            self.load_events()
        
        def save_events(self):
            """Salvează evenimentele într-un fișier"""
            from tkinter import filedialog
            
            file_path = filedialog.asksaveasfilename(
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")],
                title="Save events"
            )
            
            if not file_path:
                return
                
            try:
                with open(file_path, 'w', newline='', encoding='utf-8') as f:
                    import csv
                    writer = csv.writer(f)
                    
                    # Scriere header
                    writer.writerow(["Type", "Date & Time", "Source", "ID", "Description"])
                    
                    # Scriere evenimente
                    for item_id in self.tree.get_children():
                        values = self.tree.item(item_id, "values")
                        writer.writerow(values)
                        
                messagebox.showinfo("Full save", f"The events were saved in {file_path}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Unable to save events: {str(e)}")
        
        def show_about(self):
            """Afișează informații despre aplicație"""
            about_window = tk.Toplevel(self.rooteventv)
            about_window.title("About")
            about_window.geometry("350x200")
            about_window.configure(bg="#c0c0c0")
            about_window.resizable(False, False)
            
            # Titlu
            title_frame = tk.Frame(about_window, bg="#000080", relief="raised", borderwidth=1)
            title_frame.pack(fill=tk.X, padx=2, pady=2)
            
            title_label = tk.Label(title_frame, text="About Event Viewer", fg="white", bg="#000080", 
                                  font=("Roboto", 10, "bold"))
            title_label.pack(anchor="w", padx=10, pady=5)
            
            # Conținut
            content_frame = tk.Frame(about_window, bg="#c0c0c0")
            content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Logo placeholder - înlocuim Frame cu Canvas
            logo_canvas = tk.Canvas(content_frame, width=80, height=80, bg="#c0c0c0", bd=0, highlightthickness=0)
            logo_canvas.pack(side=tk.LEFT, padx=10)
            logo_canvas.create_rectangle(10, 10, 70, 70, fill="#ff0000", outline="")
            logo_canvas.create_rectangle(15, 15, 65, 65, fill="#00ff00", outline="")
            logo_canvas.create_rectangle(20, 20, 60, 60, fill="#0000ff", outline="")
            logo_canvas.create_rectangle(25, 25, 55, 55, fill="#ffff00", outline="")
            
            # Informații
            info_frame = tk.Frame(content_frame, bg="#c0c0c0")
            info_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            tk.Label(info_frame, text="Event Viewer", bg="#c0c0c0", 
                    font=("Roboto", 10, "bold")).pack(anchor="w")
            tk.Label(info_frame, text="Version 1.0", bg="#c0c0c0").pack(anchor="w")
            tk.Label(info_frame, text="© 2024", bg="#c0c0c0").pack(anchor="w")
            tk.Label(info_frame, text="Tudor Marmureanu", bg="#c0c0c0").pack(anchor="w")
            tk.Label(info_frame, text="An application for viewing system logs", 
                    bg="#c0c0c0", wraplength=200).pack(anchor="w")
            
            # Buton închidere
            buttons_frame = tk.Frame(about_window, bg="#c0c0c0")
            buttons_frame.pack(fill=tk.X, padx=5, pady=5)
            
            close_button = tk.Button(buttons_frame, text="OK", bg="#c0c0c0", 
                                   command=about_window.destroy)
            close_button.pack(side=tk.RIGHT, padx=5)
        
        def monitor_events(self):
            """Monitorizează evenimente noi în fundal"""
            while self.monitoring:
                # Verifică la fiecare 30 de secunde
                time.sleep(30)
                
                # Implementarea reală ar trebui să verifice doar evenimente noi
                # și să le adauge la lista existentă fără a reîncărca totul
                # Aici este doar un exemplu simplu
                
                # În thread-ul principal avem acces la interfață
                if self.monitoring:  # Verificăm din nou pentru cazul în care aplicația se închide
                    self.rooteventv.after(0, self.check_new_events)
        
        def check_new_events(self):
            """Verifică și adaugă evenimente noi în thread-ul principal"""
            # Aici ar trebui să implementăm o logică pentru a verifica și adăuga doar evenimente noi
            # Pentru exemplu, doar actualizăm statusul
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            self.status_text.config(text=f"Check for new events: {current_time}")
            
            # Puteți implementa logica reală aici
            
            # Resetează statusul după un timp
            self.rooteventv.after(3000, lambda: self.status_text.config(text="Ready"))

    def main():
        rooteventv = tk.Tk()
        app = Windows95EventViewer(rooteventv)
        rooteventv.mainloop()

    if __name__ == "__main__":
        main()

if proc_varr == 67766776:
    import time
    from collections import deque
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
    from matplotlib.figure import Figure
    import matplotlib.animation as animation
    from datetime import datetime
    import numpy as np
    import subprocess
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        ##image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    class SystemMonitor:
        def __init__(self, rootprcv):
            self.rootprcv = rootprcv
            self.rootprcv.title("Process Viewer - CPU & GPU")
            self.rootprcv.geometry("1400x800")
            self.rootprcv.attributes('-topmost', True)
            
            # Culori dark cu neon
            self.bg_color = "#0a0a0a"
            self.frame_bg = "#1a1a1a"
            self.text_color = "#ffffff"
            self.neon_blue = "#00ffff"
            self.neon_pink = "#ff00ff"
            self.neon_green = "#00ff00"
            self.neon_yellow = "#ffff00"
            self.neon_red = "#ff0000"
            
            self.rootprcv.configure(bg=self.bg_color)
            
            # Date pentru grafice
            self.max_points = 120  # 2 minute de date
            self.cpu_data = deque(maxlen=self.max_points)
            self.gpu_data = deque(maxlen=self.max_points)
            self.time_data = deque(maxlen=self.max_points)
            self.timestamps = deque(maxlen=self.max_points)
            
            # Date pentru core-uri CPU
            self.cpu_cores_count = psutil.cpu_count()
            self.cpu_cores_data = [deque(maxlen=self.max_points) for _ in range(self.cpu_cores_count)]
            
            # Maxime
            self.cpu_max = 0
            self.cpu_max_time = "N/A"
            self.gpu_max = 0
            self.gpu_max_time = "N/A"
            
            # Layer info
            self.gpu_layers = 0
            self.cpu_layers = 0
            
            # GPU detection method
            self.gpu_method = self.detect_gpu_method()
            
            # Inițializare date
            for i in range(self.max_points):
                self.cpu_data.append(0)
                self.gpu_data.append(0)
                self.time_data.append(i)
                self.timestamps.append(datetime.now())
                for core_data in self.cpu_cores_data:
                    core_data.append(0)
            
            self.setup_ui()
            self.start_monitoring()
        
        def detect_gpu_method(self):
            """Detect the best method to get GPU information"""
            # Try nvidia-smi first
            try:
                result = subprocess.run(['nvidia-smi', '--query-gpu=utilization.gpu', '--format=csv,noheader,nounits'], 
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    return 'nvidia-smi'
            except:
                pass
            
            # Try wmi on Windows
            if platform.system() == "Windows":
                try:
                    import wmi
                    return 'wmi'
                except ImportError:
                    pass
            
            # Fallback to basic detection
            return 'basic'
        
        def get_gpu_info_nvidia_smi(self):
            """Get GPU info using nvidia-smi"""
            try:
                # Get GPU utilization
                result = subprocess.run(['nvidia-smi', '--query-gpu=utilization.gpu,memory.used,memory.total,name', 
                                       '--format=csv,noheader,nounits'], 
                                      capture_output=True, text=True, timeout=5)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if lines:
                        data = lines[0].split(', ')
                        if len(data) >= 4:
                            return {
                                'name': data[3].strip(),
                                'load': float(data[0]),
                                'memory_used': float(data[1]),
                                'memory_total': float(data[2])
                            }
            except Exception as e:
                print(f"Error getting GPU info via nvidia-smi: {e}")
            return None
        
        def get_gpu_info_wmi(self):
            """Get GPU info using WMI (Windows only)"""
            try:
                import wmi
                c = wmi.WMI()
                
                # Get GPU info
                for gpu in c.Win32_VideoController():
                    if gpu.Name and 'nvidia' in gpu.Name.lower():
                        # Note: WMI doesn't provide real-time utilization, so we'll simulate
                        return {
                            'name': gpu.Name,
                            'load': np.random.uniform(10, 30),  # Simulated load
                            'memory_used': 1024,  # Simulated
                            'memory_total': 8192  # Simulated
                        }
            except Exception as e:
                print(f"Error getting GPU info via WMI: {e}")
            return None
        
        def get_gpu_info_basic(self):
            """Basic GPU detection fallback"""
            # This is a fallback that provides simulated data
            return {
                'name': 'GPU (Basic Detection)',
                'load': np.random.uniform(5, 25),  # Simulated load
                'memory_used': 512,  # Simulated
                'memory_total': 4096  # Simulated
            }
            
        def setup_ui(self):
            # Frame principal
            main_frame = tk.Frame(self.rootprcv, bg=self.bg_color)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Titlu
            title_label = tk.Label(main_frame, text="PROCESS VIEWER - CPU & GPU", 
                                  font=("Arial Black", 24, "bold"),
                                  bg=self.bg_color, fg=self.neon_blue)
            title_label.pack(pady=(0, 10))
            
            # Frame pentru informații principale
            info_frame = tk.Frame(main_frame, bg=self.frame_bg, relief=tk.RAISED, borderwidth=2)
            info_frame.pack(fill=tk.X, pady=(0, 10))
            
            # CPU Info
            cpu_frame = tk.Frame(info_frame, bg=self.frame_bg)
            cpu_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=20, pady=15)
            
            tk.Label(cpu_frame, text="CPU", font=("Arial", 16, "bold"),
                    bg=self.frame_bg, fg=self.neon_pink).pack()
            
            self.cpu_percent_label = tk.Label(cpu_frame, text="0%", 
                                             font=("Arial", 36, "bold"),
                                             bg=self.frame_bg, fg=self.neon_pink)
            self.cpu_percent_label.pack()
            
            self.cpu_cores_label = tk.Label(cpu_frame, text="Cores: 0", 
                                           font=("Arial", 12),
                                           bg=self.frame_bg, fg=self.text_color)
            self.cpu_cores_label.pack()
            
            self.cpu_freq_label = tk.Label(cpu_frame, text="Freq: 0 MHz", 
                                          font=("Arial", 12),
                                          bg=self.frame_bg, fg=self.text_color)
            self.cpu_freq_label.pack()
            
            self.cpu_max_label = tk.Label(cpu_frame, text="Max: 0%", 
                                         font=("Arial", 10, "bold"),
                                         bg=self.frame_bg, fg=self.neon_yellow)
            self.cpu_max_label.pack()
            
            self.cpu_max_time_label = tk.Label(cpu_frame, text="at N/A", 
                                              font=("Arial", 9),
                                              bg=self.frame_bg, fg=self.text_color)
            self.cpu_max_time_label.pack()
            
            # Separator
            separator = tk.Frame(info_frame, bg=self.neon_blue, width=2)
            separator.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            
            # GPU Info
            gpu_frame = tk.Frame(info_frame, bg=self.frame_bg)
            gpu_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=20, pady=15)
            
            tk.Label(gpu_frame, text="GPU", font=("Arial", 16, "bold"),
                    bg=self.frame_bg, fg=self.neon_green).pack()
            
            self.gpu_percent_label = tk.Label(gpu_frame, text="0%", 
                                             font=("Arial", 36, "bold"),
                                             bg=self.frame_bg, fg=self.neon_green)
            self.gpu_percent_label.pack()
            
            self.gpu_name_label = tk.Label(gpu_frame, text="GPU: N/A", 
                                          font=("Arial", 12),
                                          bg=self.frame_bg, fg=self.text_color)
            self.gpu_name_label.pack()
            
            self.gpu_memory_label = tk.Label(gpu_frame, text="Memory: 0/0 MB", 
                                            font=("Arial", 12),
                                            bg=self.frame_bg, fg=self.text_color)
            self.gpu_memory_label.pack()
            
            self.gpu_max_label = tk.Label(gpu_frame, text="Max: 0%", 
                                         font=("Arial", 10, "bold"),
                                         bg=self.frame_bg, fg=self.neon_yellow)
            self.gpu_max_label.pack()
            
            self.gpu_max_time_label = tk.Label(gpu_frame, text="at N/A", 
                                              font=("Arial", 9),
                                              bg=self.frame_bg, fg=self.text_color)
            self.gpu_max_time_label.pack()
            
            # GPU Method indicator
            self.gpu_method_label = tk.Label(gpu_frame, text=f"Method: {self.gpu_method}", 
                                            font=("Arial", 8),
                                            bg=self.frame_bg, fg=self.text_color)
            self.gpu_method_label.pack()
            
            # Separator
            separator2 = tk.Frame(info_frame, bg=self.neon_blue, width=2)
            separator2.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            
            # Layer Info
            layer_frame = tk.Frame(info_frame, bg=self.frame_bg)
            layer_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=20, pady=15)
            
            tk.Label(layer_frame, text="LAYERS", font=("Arial", 16, "bold"),
                    bg=self.frame_bg, fg=self.neon_blue).pack()
            
            self.gpu_layers_label = tk.Label(layer_frame, text="GPU Layers: 0", 
                                            font=("Arial", 14),
                                            bg=self.frame_bg, fg=self.neon_green)
            self.gpu_layers_label.pack(pady=5)
            
            self.cpu_layers_label = tk.Label(layer_frame, text="CPU Layers: 0", 
                                            font=("Arial", 14),
                                            bg=self.frame_bg, fg=self.neon_pink)
            self.cpu_layers_label.pack(pady=5)
            
            # Frame pentru core-uri CPU
            cores_frame = tk.Frame(main_frame, bg=self.frame_bg, relief=tk.RAISED, borderwidth=2)
            cores_frame.pack(fill=tk.X, pady=(0, 10))
            
            tk.Label(cores_frame, text="CPU CORES ACTIVITY", 
                    font=("Arial", 14, "bold"),
                    bg=self.frame_bg, fg=self.neon_pink).pack(pady=5)
            
            self.cores_container = tk.Frame(cores_frame, bg=self.frame_bg)
            self.cores_container.pack(fill=tk.X, padx=10, pady=10)
            
            self.core_labels = []
            self.core_bars = []
            
            # Creează widget-uri pentru fiecare core
            for i in range(self.cpu_cores_count):
                core_frame = tk.Frame(self.cores_container, bg=self.frame_bg)
                core_frame.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
                
                label = tk.Label(core_frame, text=f"Core {i}", 
                               font=("Arial", 10),
                               bg=self.frame_bg, fg=self.text_color)
                label.pack()
                
                # Progress bar pentru core
                bar_frame = tk.Frame(core_frame, bg=self.frame_bg, height=100, width=30)
                bar_frame.pack_propagate(False)
                bar_frame.pack()
                
                bar = tk.Frame(bar_frame, bg=self.neon_pink, width=30)
                bar.place(x=0, rely=1.0, relheight=0, anchor='sw')
                
                percent_label = tk.Label(core_frame, text="0%", 
                                       font=("Arial", 9),
                                       bg=self.frame_bg, fg=self.text_color)
                percent_label.pack()
                
                self.core_labels.append(percent_label)
                self.core_bars.append(bar)
            
            # Frame pentru grafice
            graph_frame = tk.Frame(main_frame, bg=self.frame_bg, relief=tk.RAISED, borderwidth=2)
            graph_frame.pack(fill=tk.BOTH, expand=True)
            
            # Configurare matplotlib
            plt.style.use('dark_background')
            self.fig = Figure(figsize=(14, 5), dpi=100, facecolor=self.frame_bg)
            self.ax = self.fig.add_subplot(111)
            
            self.ax.set_facecolor(self.bg_color)
            self.ax.set_xlabel('Time (sec)', color=self.text_color)
            self.ax.set_ylabel('Usage (%)', color=self.text_color)
            self.ax.set_ylim(0, 105)
            self.ax.grid(True, alpha=0.3, color=self.text_color)
            
            # Linii pentru grafice
            self.cpu_line, = self.ax.plot([], [], color=self.neon_pink, linewidth=2, 
                                          label='CPU', marker='o', markersize=4)
            self.gpu_line, = self.ax.plot([], [], color=self.neon_green, linewidth=2, 
                                          label='GPU', marker='o', markersize=4)
            
            self.ax.legend(loc='upper right', framealpha=0.8)
            
            # Canvas pentru grafic
            self.canvas = FigureCanvasTkAgg(self.fig, master=graph_frame)
            self.canvas.draw()
            self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Toolbar pentru navigare
            toolbar_frame = tk.Frame(graph_frame, bg=self.frame_bg)
            toolbar_frame.pack(fill=tk.X, padx=10)
            toolbar = NavigationToolbar2Tk(self.canvas, toolbar_frame)
            toolbar.update()
            
            # Annotation pentru hover
            self.annotation = self.ax.annotate("", xy=(0,0), xytext=(20,20), 
                                             textcoords="offset points",
                                             bbox=dict(boxstyle="round", fc=self.frame_bg, alpha=0.9),
                                             arrowprops=dict(arrowstyle="->", color=self.neon_yellow))
            self.annotation.set_visible(False)
            
            # Conectare evenimente mouse
            self.canvas.mpl_connect('motion_notify_event', self.on_hover)
            
            # Animație
            self.ani = animation.FuncAnimation(self.fig, self.update_graph, 
                                             interval=1000, blit=False)
            
        def on_hover(self, event):
            if event.inaxes == self.ax:
                # Găsește cel mai apropiat punct
                if len(self.cpu_data) > 0:
                    x_data = list(range(len(self.cpu_data)))
                    
                    # Convertește coordonatele mouse-ului
                    x_mouse = event.xdata
                    
                    if x_mouse is not None:
                        # Găsește indexul cel mai apropiat
                        idx = min(range(len(x_data)), key=lambda i: abs(x_data[i] - x_mouse))
                        
                        # Obține valorile
                        cpu_val = self.cpu_data[idx]
                        gpu_val = self.gpu_data[idx]
                        time_val = self.timestamps[idx].strftime("%H:%M:%S")
                        
                        # Actualizează annotation
                        self.annotation.xy = (x_data[idx], max(cpu_val, gpu_val))
                        text = f"Time: {time_val}\nCPU: {cpu_val:.1f}%\nGPU: {gpu_val:.1f}%"
                        self.annotation.set_text(text)
                        self.annotation.set_visible(True)
                    else:
                        self.annotation.set_visible(False)
                else:
                    self.annotation.set_visible(False)
            else:
                self.annotation.set_visible(False)
            
            self.canvas.draw_idle()
            
        def get_gpu_info(self):
            """Get GPU info using the detected method"""
            if self.gpu_method == 'nvidia-smi':
                return self.get_gpu_info_nvidia_smi()
            elif self.gpu_method == 'wmi':
                return self.get_gpu_info_wmi()
            else:
                return self.get_gpu_info_basic()
        
        def get_layer_info(self):
            # Simulare - în realitate ar trebui să interoghezi framework-ul ML folosit
            # Pentru demonstrație, calculăm pe baza utilizării memoriei
            gpu_info = self.get_gpu_info()
            if gpu_info and gpu_info['memory_used'] > 0:
                # Estimare layers pe GPU bazat pe memoria folosită
                self.gpu_layers = int(gpu_info['memory_used'] / 100)  # 100MB per layer (exemplu)
                # Restul pe CPU
                self.cpu_layers = max(0, 32 - self.gpu_layers)  # Presupunem 32 layers total
            else:
                self.gpu_layers = 0
                self.cpu_layers = 0
            
        def update_data(self):
            while True:
                try:
                    current_time = datetime.now()
                    
                    # CPU Info general
                    cpu_percent = psutil.cpu_percent(interval=0.1)
                    cpu_freq = psutil.cpu_freq()
                    cpu_cores = psutil.cpu_count()
                    
                    # CPU per core
                    cpu_percent_per_core = psutil.cpu_percent(percpu=True, interval=0.1)
                    
                    # Update CPU labels
                    self.cpu_percent_label.config(text=f"{cpu_percent:.1f}%")
                    self.cpu_cores_label.config(text=f"Cores: {cpu_cores}")
                    if cpu_freq:
                        self.cpu_freq_label.config(text=f"Freq: {cpu_freq.current:.0f} MHz")
                    
                    # Update maxim CPU
                    if cpu_percent > self.cpu_max:
                        self.cpu_max = cpu_percent
                        self.cpu_max_time = current_time.strftime("%H:%M:%S")
                        self.cpu_max_label.config(text=f"Max: {self.cpu_max:.1f}%")
                        self.cpu_max_time_label.config(text=f"at {self.cpu_max_time}")
                    
                    # Update core-uri
                    for i, (core_percent, label, bar) in enumerate(zip(cpu_percent_per_core, self.core_labels, self.core_bars)):
                        label.config(text=f"{core_percent:.0f}%")
                        # Update bar height
                        bar.place(relheight=core_percent/100)
                        # Colorare în funcție de utilizare
                        if core_percent > 80:
                            bar.config(bg=self.neon_red)
                        elif core_percent > 50:
                            bar.config(bg=self.neon_yellow)
                        else:
                            bar.config(bg=self.neon_pink)
                        
                        # Salvează datele pentru fiecare core
                        if i < len(self.cpu_cores_data):
                            self.cpu_cores_data[i].append(core_percent)
                    
                    # GPU Info
                    gpu_info = self.get_gpu_info()
                    if gpu_info:
                        gpu_percent = gpu_info['load']
                        self.gpu_percent_label.config(text=f"{gpu_percent:.1f}%")
                        self.gpu_name_label.config(text=f"GPU: {gpu_info['name'][:30]}")
                        self.gpu_memory_label.config(
                            text=f"Memorie: {gpu_info['memory_used']:.0f}/{gpu_info['memory_total']:.0f} MB"
                        )
                        
                        # Update maxim GPU
                        if gpu_percent > self.gpu_max:
                            self.gpu_max = gpu_percent
                            self.gpu_max_time = current_time.strftime("%H:%M:%S")
                            self.gpu_max_label.config(text=f"Max: {self.gpu_max:.1f}%")
                            self.gpu_max_time_label.config(text=f"at {self.gpu_max_time}")
                    else:
                        gpu_percent = 0
                        self.gpu_percent_label.config(text="N/A")
                        self.gpu_name_label.config(text="GPU: Not detected")
                    
                    # Update layer info
                    self.get_layer_info()
                    self.gpu_layers_label.config(text=f"GPU Layers: {self.gpu_layers}")
                    self.cpu_layers_label.config(text=f"CPU Layers: {self.cpu_layers}")
                    
                    # Adaugă date pentru grafice
                    self.cpu_data.append(cpu_percent)
                    self.gpu_data.append(gpu_percent)
                    self.timestamps.append(current_time)
                    
                    # Efecte vizuale pentru valori mari
                    if cpu_percent > 80:
                        self.cpu_percent_label.config(fg=self.neon_yellow)
                    elif cpu_percent > 90:
                        self.cpu_percent_label.config(fg=self.neon_red)
                    else:
                        self.cpu_percent_label.config(fg=self.neon_pink)
                        
                    if gpu_percent > 80:
                        self.gpu_percent_label.config(fg=self.neon_yellow)
                    elif gpu_percent > 90:
                        self.gpu_percent_label.config(fg=self.neon_red)
                    else:
                        self.gpu_percent_label.config(fg=self.neon_green)
                    
                except Exception as e:
                    print(f"Error updating data: {e}")
                    
                time.sleep(1)
        
        def update_graph(self, frame):
            x_data = list(range(len(self.cpu_data)))
            
            self.cpu_line.set_data(x_data, list(self.cpu_data))
            self.gpu_line.set_data(x_data, list(self.gpu_data))
            
            self.ax.set_xlim(0, self.max_points - 1)
            
            return self.cpu_line, self.gpu_line
        
        def start_monitoring(self):
            monitor_thread = threading.Thread(target=self.update_data, daemon=True)
            monitor_thread.start()

    if __name__ == "__main__":
        rootprcv = tk.Tk()
        app = SystemMonitor(rootprcv)
        rootprcv.mainloop()

if kbbbvar == 5189:
    from tkinter import ttk, font, filedialog, colorchooser, messagebox
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class Win95KnowledgeBase:
        def __init__(self, rootKBBB):
            self.rootKBBB = rootKBBB
            self.rootKBBB.title("Retro Knowledge Base")
            self.rootKBBB.geometry("800x600")
            
            # Culorile Windows 95
            self.win95_bg = "#c0c0c0"
            self.win95_button = "#c0c0c0"
            self.win95_text_bg = "#ffffff"
            self.win95_text_fg = "#000000"
            self.win95_active = "#000080"
            self.win95_highlight = "#0000ff"
            
            # Fonturi
            self.default_font = font.Font(family="MS Sans Serif", size=10)
            
            # Configurare stil Windows 95
            self.rootKBBB.configure(bg=self.win95_bg)
            
            # Variabile pentru fișierul curent
            self.current_file = None
            self.procedures = {}
            self.current_procedure = None
            
            # Crearea interfeței
            self.create_ui()
            
            # Crearea primei proceduri implicite
            self.new_procedure()
        
        def create_ui(self):
            # Cadru principal
            main_frame = tk.Frame(self.rootKBBB, bg=self.win95_bg, bd=1, relief=tk.RAISED)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Meniu
            self.create_menu()
            
            # Cadru pentru toolbar
            toolbar_frame = tk.Frame(main_frame, bg=self.win95_bg, bd=1, relief=tk.RAISED)
            toolbar_frame.pack(fill=tk.X, padx=2, pady=2)
            
            # Butoane toolbar
            new_btn = tk.Button(toolbar_frame, text="New", bg=self.win95_button, 
                              relief=tk.RAISED, bd=2, font=self.default_font,
                              command=self.new_procedure)
            new_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            save_btn = tk.Button(toolbar_frame, text="Save", bg=self.win95_button, 
                               relief=tk.RAISED, bd=2, font=self.default_font,
                               command=self.save_procedure)
            save_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            bold_btn = tk.Button(toolbar_frame, text="B", bg=self.win95_button, 
                              relief=tk.RAISED, bd=2, font=font.Font(family="MS Sans Serif", size=10, weight="bold"),
                              command=self.toggle_bold)
            bold_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            italic_btn = tk.Button(toolbar_frame, text="I", bg=self.win95_button, 
                                relief=tk.RAISED, bd=2, font=font.Font(family="MS Sans Serif", size=10, slant="italic"),
                                command=self.toggle_italic)
            italic_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            text_color_btn = tk.Button(toolbar_frame, text="Text Color", bg=self.win95_button, 
                                     relief=tk.RAISED, bd=2, font=self.default_font,
                                     command=self.choose_text_color)
            text_color_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            bg_color_btn = tk.Button(toolbar_frame, text="BG Color", bg=self.win95_button, 
                                   relief=tk.RAISED, bd=2, font=self.default_font,
                                   command=self.choose_bg_color)
            bg_color_btn.pack(side=tk.LEFT, padx=2, pady=2)
            
            # Combobox pentru mărime font
            font_size_label = tk.Label(toolbar_frame, text="Font:", bg=self.win95_bg, font=self.default_font)
            font_size_label.pack(side=tk.LEFT, padx=2, pady=2)
            
            self.font_size_var = tk.StringVar(value="10")
            font_sizes = ["8", "9", "10", "11", "12", "14", "16", "18", "20", "22", "24", "26", "28", "36", "48", "72"]
            self.font_size_combo = ttk.Combobox(toolbar_frame, textvariable=self.font_size_var, values=font_sizes, width=3)
            self.font_size_combo.pack(side=tk.LEFT, padx=2, pady=2)
            self.font_size_combo.bind("<<ComboboxSelected>>", self.change_font_size)
            
            # Cadru pentru conținut
            content_frame = tk.Frame(main_frame, bg=self.win95_bg)
            content_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # Cadru stânga pentru lista de proceduri
            left_frame = tk.Frame(content_frame, bg=self.win95_bg, bd=1, relief=tk.SUNKEN, width=200)
            left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=2, pady=2)
            left_frame.pack_propagate(False)
            
            # Lista de proceduri
            procedure_label = tk.Label(left_frame, text="Procedures:", bg=self.win95_bg, font=self.default_font)
            procedure_label.pack(anchor=tk.W, padx=5, pady=5)
            
            self.procedure_listbox = tk.Listbox(left_frame, bg=self.win95_text_bg, relief=tk.SUNKEN, bd=2,
                                             selectbackground=self.win95_active, font=self.default_font)
            self.procedure_listbox.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            self.procedure_listbox.bind("<<ListboxSelect>>", self.load_selected_procedure)
            
            # Cadru pentru adăugarea unei noi proceduri
            add_procedure_frame = tk.Frame(left_frame, bg=self.win95_bg)
            add_procedure_frame.pack(fill=tk.X, padx=5, pady=5)
            
            self.new_procedure_name = tk.Entry(add_procedure_frame, bg=self.win95_text_bg, 
                                            relief=tk.SUNKEN, bd=2, font=self.default_font)
            self.new_procedure_name.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 2))
            
            add_btn = tk.Button(add_procedure_frame, text="+", bg=self.win95_button, 
                              relief=tk.RAISED, bd=2, font=self.default_font,
                              command=self.add_new_procedure)
            add_btn.pack(side=tk.RIGHT)
            
            # Cadru dreapta pentru editor text
            right_frame = tk.Frame(content_frame, bg=self.win95_bg, bd=1, relief=tk.SUNKEN)
            right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # Titlu procedură
            title_frame = tk.Frame(right_frame, bg=self.win95_bg)
            title_frame.pack(fill=tk.X, padx=5, pady=5)
            
            title_label = tk.Label(title_frame, text="Title:", bg=self.win95_bg, font=self.default_font)
            title_label.pack(side=tk.LEFT, padx=(0, 5))
            
            self.title_entry = tk.Entry(title_frame, bg=self.win95_text_bg, 
                                     relief=tk.SUNKEN, bd=2, font=self.default_font)
            self.title_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            # Editor text
            self.text_editor = tk.Text(right_frame, bg=self.win95_text_bg, fg=self.win95_text_fg,
                                    relief=tk.SUNKEN, bd=2, font=self.default_font,
                                    wrap=tk.WORD, undo=True)
            self.text_editor.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Scrollbar pentru editor
            scrollbar = tk.Scrollbar(self.text_editor, command=self.text_editor.yview)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.text_editor.config(yscrollcommand=scrollbar.set)
            
            # Status bar
            self.status_bar = tk.Label(main_frame, text="Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W,
                                    font=font.Font(family="MS Sans Serif", size=8), bg=self.win95_bg)
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        def create_menu(self):
            menubar = tk.Menu(self.rootKBBB)
            
            # Meniu Fișier
            file_menu = tk.Menu(menubar, tearoff=0)
            file_menu.add_command(label="New", command=self.new_kb)
            file_menu.add_command(label="Open", command=self.open_kb)
            file_menu.add_command(label="Save", command=self.save_kb)
            file_menu.add_command(label="Save as", command=self.save_kb_as)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootKBBB.quit)
            menubar.add_cascade(label="File", menu=file_menu)
            
            # Meniu Editare
            edit_menu = tk.Menu(menubar, tearoff=0)
            edit_menu.add_command(label="Cut", command=lambda: self.text_editor.event_generate("<<Cut>>"))
            edit_menu.add_command(label="Copy", command=lambda: self.text_editor.event_generate("<<Copy>>"))
            edit_menu.add_command(label="Paste", command=lambda: self.text_editor.event_generate("<<Paste>>"))
            edit_menu.add_separator()
            edit_menu.add_command(label="Bold", command=self.toggle_bold)
            edit_menu.add_command(label="Italic", command=self.toggle_italic)
            edit_menu.add_command(label="Text color", command=self.choose_text_color)
            edit_menu.add_command(label="BG color", command=self.choose_bg_color)
            menubar.add_cascade(label="Edit", menu=edit_menu)
            
            # Meniu Ajutor
            help_menu = tk.Menu(menubar, tearoff=0)
            help_menu.add_command(label="About", command=self.show_about)
            menubar.add_cascade(label="Help", menu=help_menu)
            
            self.rootKBBB.config(menu=menubar)
        
        def add_tag_with_config(self, tag_name, **kwargs):
            """Adaugă un tag cu configurație pentru formatare text"""
            self.text_editor.tag_configure(tag_name, **kwargs)
        
        def toggle_tag(self, tag_name):
            """Comută un tag la selecția curentă"""
            try:
                # Verifică dacă există text selectat
                selected_text = self.text_editor.tag_ranges(tk.SEL)
                if selected_text:
                    start, end = selected_text
                    # Verifică dacă tag-ul există deja în selecție
                    tags = self.text_editor.tag_names(start)
                    if tag_name in tags:
                        self.text_editor.tag_remove(tag_name, start, end)
                    else:
                        self.text_editor.tag_add(tag_name, start, end)
                else:
                    self.status_bar.config(text="Select text to apply formatting.")
            except:
                self.status_bar.config(text="Error applying formatting.")
        
        def toggle_bold(self):
            """Comută textul îngroșat"""
            bold_font = font.Font(family="MS Sans Serif", size=int(self.font_size_var.get()), weight="bold")
            self.add_tag_with_config("bold", font=bold_font)
            self.toggle_tag("bold")
        
        def toggle_italic(self):
            """Comută textul înclinat"""
            italic_font = font.Font(family="MS Sans Serif", size=int(self.font_size_var.get()), slant="italic")
            self.add_tag_with_config("italic", font=italic_font)
            self.toggle_tag("italic")
        
        def choose_text_color(self):
            """Alege culoarea textului"""
            color = colorchooser.askcolor(title="Choose text color.")[1]
            if color:
                self.add_tag_with_config(f"color_{color}", foreground=color)
                self.toggle_tag(f"color_{color}")
        
        def choose_bg_color(self):
            """Alege culoarea de fundal"""
            color = colorchooser.askcolor(title="Choose background color.")[1]
            if color:
                self.add_tag_with_config(f"bg_{color}", background=color)
                self.toggle_tag(f"bg_{color}")
        
        def change_font_size(self, event=None):
            """Schimbă dimensiunea fontului"""
            try:
                size = int(self.font_size_var.get())
                size_font = font.Font(family="MS Sans Serif", size=size)
                tag_name = f"size_{size}"
                self.add_tag_with_config(tag_name, font=size_font)
                
                # Aplică tag-ul la selecție
                selected_text = self.text_editor.tag_ranges(tk.SEL)
                if selected_text:
                    start, end = selected_text
                    # Elimină alte tag-uri de dimensiune
                    for tag in self.text_editor.tag_names(start):
                        if tag.startswith("size_"):
                            self.text_editor.tag_remove(tag, start, end)
                    # Adaugă noul tag
                    self.text_editor.tag_add(tag_name, start, end)
                else:
                    self.status_bar.config(text="Select text to change font size.")
            except:
                self.status_bar.config(text="Error changing font size.")
        
        def new_procedure(self):
            """Creează o nouă procedură"""
            self.current_procedure = f"Procedure {len(self.procedures) + 1}"
            self.procedures[self.current_procedure] = {
                "title": self.current_procedure,
                "content": "",
                "tags": []
            }
            self.update_procedure_list()
            self.clear_editor()
            self.title_entry.insert(0, self.current_procedure)
        
        def add_new_procedure(self):
            """Adaugă o nouă procedură din câmpul de intrare"""
            name = self.new_procedure_name.get().strip()
            if name:
                self.current_procedure = name
                self.procedures[name] = {
                    "title": name,
                    "content": "",
                    "tags": []
                }
                self.update_procedure_list()
                self.clear_editor()
                self.title_entry.insert(0, name)
                self.new_procedure_name.delete(0, tk.END)
            else:
                self.status_bar.config(text="Enter a name for the new procedure.")
        
        def update_procedure_list(self):
            """Actualizează lista de proceduri"""
            self.procedure_listbox.delete(0, tk.END)
            for proc in self.procedures:
                self.procedure_listbox.insert(tk.END, proc)
            # Selectează procedura curentă
            if self.current_procedure:
                for i, proc in enumerate(self.procedures):
                    if proc == self.current_procedure:
                        self.procedure_listbox.selection_set(i)
                        break
        
        def load_selected_procedure(self, event=None):
            """Încarcă procedura selectată"""
            selection = self.procedure_listbox.curselection()
            if selection:
                index = selection[0]
                procedure_name = self.procedure_listbox.get(index)
                
                # Salvează procedura curentă înainte de a o schimba
                if self.current_procedure:
                    self.save_procedure()
                
                # Încarcă noua procedură
                self.current_procedure = procedure_name
                self.load_procedure(procedure_name)
        
        def load_procedure(self, procedure_name):
            """Încarcă o procedură în editor"""
            if procedure_name in self.procedures:
                procedure = self.procedures[procedure_name]
                
                # Curăță editorul
                self.clear_editor()
                
                # Setează titlul
                self.title_entry.insert(0, procedure["title"])
                
                # Setează conținutul
                self.text_editor.insert("1.0", procedure["content"])
                
                # Aplică tag-urile
                for tag_info in procedure["tags"]:
                    tag_name = tag_info["name"]
                    start = tag_info["start"]
                    end = tag_info["end"]
                    config = tag_info["config"]
                    
                    # Creează tag-ul cu configurația sa
                    self.text_editor.tag_configure(tag_name, **config)
                    
                    # Aplică tag-ul
                    self.text_editor.tag_add(tag_name, start, end)
                
                self.status_bar.config(text=f"Procedure '{procedure_name}' loaded")
        
        def save_procedure(self):
            """Salvează procedura curentă"""
            if self.current_procedure:
                # Actualizează titlul
                new_title = self.title_entry.get().strip()
                if new_title and new_title != self.current_procedure:
                    # Dacă titlul s-a schimbat, trebuie să redenumim procedura
                    procedure_data = self.procedures[self.current_procedure]
                    del self.procedures[self.current_procedure]
                    self.current_procedure = new_title
                    self.procedures[new_title] = procedure_data
                
                # Salvează conținutul
                content = self.text_editor.get("1.0", tk.END)
                self.procedures[self.current_procedure]["content"] = content
                self.procedures[self.current_procedure]["title"] = new_title
                
                # Salvează tag-urile
                tags = []
                for tag_name in self.text_editor.tag_names():
                    if tag_name == "sel":  # Ignoră tag-ul de selecție
                        continue
                    
                    # Obține configurația tag-ului
                    config = {}
                    for key in ["font", "foreground", "background"]:
                        value = self.text_editor.tag_cget(tag_name, key)
                        if value:
                            config[key] = value
                    
                    # Obține toate intervalele care au acest tag
                    ranges = self.text_editor.tag_ranges(tag_name)
                    for i in range(0, len(ranges), 2):
                        start = ranges[i]
                        end = ranges[i + 1]
                        tags.append({
                            "name": tag_name,
                            "start": str(start),
                            "end": str(end),
                            "config": config
                        })
                
                self.procedures[self.current_procedure]["tags"] = tags
                
                self.update_procedure_list()
                self.status_bar.config(text=f"Procedure '{self.current_procedure}' saved")
        
        def clear_editor(self):
            """Curăță editorul"""
            self.text_editor.delete("1.0", tk.END)
            self.title_entry.delete(0, tk.END)
            
            # Elimină toate tag-urile
            for tag in self.text_editor.tag_names():
                if tag != "sel":  # Păstrează tag-ul de selecție
                    self.text_editor.tag_delete(tag)
        
        def new_kb(self):
            """Creează o nouă bază de cunoștințe"""
            if self.procedures and messagebox.askyesno("Saving", "Do you want to save the current knowledge base before creating a new one?"):
                self.save_kb()
            
            self.procedures = {}
            self.current_procedure = None
            self.current_file = None
            self.update_procedure_list()
            self.clear_editor()
            self.new_procedure()
            self.status_bar.config(text="Nouă bază de cunoștințe creată")
        
        def open_kb(self):
            """Deschide o bază de cunoștințe"""
            if self.procedures and messagebox.askyesno("Saving", "Do you want to save the current knowledge base before creating a new one?"):
                self.save_kb()
            
            file_path = filedialog.askopenfilename(
                defaultextension=".kb95",
                filetypes=[("Knowledge Base for Multiapp 95", "*.kb95"), ("All files", "*.*")]
            )
            
            if file_path:
                try:
                    with open(file_path, "r", encoding="utf-8") as file:
                        data = json.load(file)
                        self.procedures = data.get("procedures", {})
                        self.current_file = file_path
                        
                        # Încarcă prima procedură dacă există
                        if self.procedures:
                            self.current_procedure = list(self.procedures.keys())[0]
                            self.update_procedure_list()
                            self.load_procedure(self.current_procedure)
                        else:
                            self.new_procedure()
                        
                        self.status_bar.config(text=f"Knowledge base '{os.path.basename(file_path)}' open")
                except Exception as e:
                    messagebox.showerror("Error", f"The file could not be opened: {str(e)}")
        
        def save_kb(self):
            """Salvează baza de cunoștințe"""
            if self.current_procedure:
                self.save_procedure()
            
            if self.current_file:
                self.save_kb_to_file(self.current_file)
            else:
                self.save_kb_as()
        
        def save_kb_as(self):
            """Salvează baza de cunoștințe ca un nou fișier"""
            if self.current_procedure:
                self.save_procedure()
            
            file_path = filedialog.asksaveasfilename(
                defaultextension=".kb95",
                filetypes=[("Knowledge Base for Multiapp 95", "*.kb95"), ("All files", "*.*")]
            )
            
            if file_path:
                self.save_kb_to_file(file_path)
                self.current_file = file_path
        
        def save_kb_to_file(self, file_path):
            """Salvează baza de cunoștințe în fișier"""
            try:
                data = {
                    "procedures": self.procedures
                }
                
                with open(file_path, "w", encoding="utf-8") as file:
                    json.dump(data, file, ensure_ascii=False, indent=2)
                
                self.status_bar.config(text=f"Knowledge base saved in '{os.path.basename(file_path)}'")
            except Exception as e:
                messagebox.showerror("Error", f"The file could not be saved: {str(e)}")
        
        def show_about(self):
            """Afișează informații despre aplicație"""
            messagebox.showinfo(
                "About Knowledge Base",
                "Version 1.0\n\n"
                "A knowledge/procedure management system."
            )

    if __name__ == "__main__":
        rootKBBB = tk.Tk()
        app = Win95KnowledgeBase(rootKBBB)
        rootKBBB.mainloop()
        
if xmleditorvar == 111444555:
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-

    import xml.etree.ElementTree as ET

    class Windows95XMLEditor:
        def __init__(self):
            self.config_dir = "Config"
            self.xml_file = os.path.join(self.config_dir, "config.xml")
            
            # Creează directorul Config dacă nu există
            if not os.path.exists(self.config_dir):
                os.makedirs(self.config_dir)
            self.config_data = {}
            self.menu_items = []
            self.current_selection = 0
            self.modified = False
            
            # Creează fereastra principală
            self.rooXML = tk.Tk()
            self.rooXML.title("Configuration Editor")
            
            # Fullscreen fără decorații
            self.rooXML.attributes('-fullscreen', True)
            self.rooXML.overrideredirect(True)
            
            # Culori Windows 95
            self.colors = {
                'bg': '#c0c0c0',           # Gri clasic Windows 95
                'window_bg': '#ffffff',     # Alb pentru zona de conținut
                'selected_bg': '#000080',   # Albastru închis pentru selecție
                'selected_fg': '#ffffff',   # Alb pentru text selectat
                'button_face': '#c0c0c0',   # Gri pentru butoane
                'button_shadow': '#808080', # Umbră butoane
                'button_highlight': '#ffffff', # Highlight butoane
                'text_color': '#000000',    # Negru pentru text normal
                'title_bg': '#008080',      # Teal pentru titlu
                'title_fg': '#ffffff',      # Alb pentru textul titlului
                'true_color': '#008000',    # Verde pentru True
                'false_color': '#800000'    # Roșu închis pentru False
            }
            
            self.setup_ui()
            self.load_xml()
            self.update_display()
            self.setup_bindings()
            
        def setup_ui(self):
            """Configurează interfața în stil Windows 95"""
            # Container principal
            main_container = tk.Frame(self.rooXML, bg=self.colors['bg'], relief='raised', bd=2)
            main_container.pack(fill='both', expand=True, padx=4, pady=4)
            
            # Bara de titlu
            title_frame = tk.Frame(main_container, bg=self.colors['title_bg'], height=30, relief='raised', bd=2)
            title_frame.pack(fill='x', padx=2, pady=2)
            title_frame.pack_propagate(False)
            
            # Titlu și buton închidere
            title_container = tk.Frame(title_frame, bg=self.colors['title_bg'])
            title_container.pack(fill='both', expand=True, padx=4, pady=2)
            
            title_label = tk.Label(
                title_container,
                text="XML Configuration Editor",
                font=('MS Sans Serif', 11, 'bold'),
                bg=self.colors['title_bg'],
                fg=self.colors['title_fg']
            )
            title_label.pack(side='left')
            
            # Buton de închidere (X)
            close_btn = tk.Button(
                title_container,
                text='×',
                font=('MS Sans Serif', 12, 'bold'),
                bg=self.colors['button_face'],
                fg=self.colors['text_color'],
                relief='raised',
                bd=1,
                width=3,
                command=self.exit_app
            )
            close_btn.pack(side='right')
            
            # Zona principală cu effect 3D
            content_frame = tk.Frame(main_container, bg=self.colors['bg'], relief='sunken', bd=2)
            content_frame.pack(fill='both', expand=True, padx=4, pady=4)
            
            # Header informativ
            info_frame = tk.Frame(content_frame, bg=self.colors['window_bg'], relief='flat', bd=1)
            info_frame.pack(fill='x', padx=6, pady=6)
            
            info_text = f"File: {os.path.basename(self.xml_file)} (in {self.config_dir}/)"
            if self.modified:
                info_text += " [Modified]"
                
            tk.Label(
                info_frame,
                text=info_text,
                font=('MS Sans Serif', 9),
                bg=self.colors['window_bg'],
                fg=self.colors['text_color'],
                anchor='w'
            ).pack(fill='x', padx=4, pady=2)
            
            # Zona pentru lista de opțiuni
            self.list_container = tk.Frame(content_frame, bg=self.colors['window_bg'], relief='sunken', bd=2)
            self.list_container.pack(fill='both', expand=True, padx=6, pady=6)
            
            # Frame pentru items
            self.list_frame = tk.Frame(self.list_container, bg=self.colors['window_bg'])
            self.list_frame.pack(fill='both', expand=True, padx=4, pady=4)
            
            # Footer cu instrucțiuni
            footer_frame = tk.Frame(content_frame, bg=self.colors['bg'], relief='raised', bd=1)
            footer_frame.pack(fill='x', padx=6, pady=6)
            
            instructions_frame = tk.Frame(footer_frame, bg=self.colors['window_bg'], relief='sunken', bd=1)
            instructions_frame.pack(fill='both', expand=True, padx=2, pady=2)
            
            instructions = "Use ↑↓ arrows to navigate • Press ENTER to toggle • Press ESC to exit"
            tk.Label(
                instructions_frame,
                text=instructions,
                font=('MS Sans Serif', 9, 'bold'),
                bg=self.colors['window_bg'],
                fg=self.colors['text_color']
            ).pack(pady=4)
        
        def load_xml(self):
            """Încarcă fișierul XML"""
            try:
                if os.path.exists(self.xml_file):
                    tree = ET.parse(self.xml_file)
                    rooXML = tree.getrooXML()
                    
                    self.config_data.clear()
                    self.menu_items.clear()
                    
                    for child in rooXML:
                        self.config_data[child.tag] = child.text
                        self.menu_items.append(child.tag)
                else:
                    self.config_data = {
                        'checker_instance': 'True',
                        'virtual_instance': 'True',
                        'reading_pane': 'True'
                    }
                    self.menu_items = list(self.config_data.keys())
                    self.save_xml()
            except Exception as e:
                # Dacă apare eroare sau fișierul nu există, creează cu valori default
                self.config_data = {
                    'checker_instance': 'True', 
                    'virtual_instance': 'True',
                    'reading_pane': 'True'
                }
                self.menu_items = list(self.config_data.keys())
                # Creează fișierul cu valorile default
                self.save_xml()
        
        def save_xml(self):
            """Salvează fișierul XML"""
            try:
                rooXML = ET.Element("configuration")
                
                for key, value in self.config_data.items():
                    elem = ET.SubElement(rooXML, key)
                    elem.text = value
                
                tree = ET.ElementTree(rooXML)
                ET.indent(tree, space="    ")
                tree.write(self.xml_file, encoding='utf-8', xml_declaration=True)
                self.modified = False
                return True
            except Exception as e:
                messagebox.showerror("Error", f"Cannot save XML file: {e}")
                return False
        
        def update_display(self):
            """Actualizează afișarea în stil Windows 95"""
            # Șterge toate widget-urile existente
            for widget in self.list_frame.winfo_children():
                widget.destroy()
            
            # Înălțime fixă pentru toate elementele
            item_height = 100
            
            # Creează fiecare element
            for i, item in enumerate(self.menu_items):
                value = self.config_data[item]
                
                # Frame pentru fiecare element cu aspect Windows 95
                if i == self.current_selection:
                    item_frame = tk.Frame(
                        self.list_frame,
                        bg=self.colors['selected_bg'],
                        relief='raised',
                        bd=2,
                        height=item_height
                    )
                    text_color = self.colors['selected_fg']
                    bg_color = self.colors['selected_bg']
                else:
                    item_frame = tk.Frame(
                        self.list_frame,
                        bg=self.colors['window_bg'],
                        relief='flat',
                        bd=1,
                        height=item_height
                    )
                    text_color = self.colors['text_color']
                    bg_color = self.colors['window_bg']
                
                item_frame.pack(fill='x', pady=2, padx=4)
                item_frame.pack_propagate(False)
                
                # Container pentru conținut
                content_container = tk.Frame(item_frame, bg=bg_color)
                content_container.pack(fill='both', expand=True, padx=8, pady=8)
                
                # Numele parametrului
                param_name = item.replace('_', ' ').title()
                name_label = tk.Label(
                    content_container,
                    text=param_name,
                    font=('MS Sans Serif', 14, 'bold'),
                    bg=bg_color,
                    fg=text_color
                )
                name_label.pack(anchor='w')
                
                # Valoarea cu culoare
                value_color = self.colors['true_color'] if value == 'True' else self.colors['false_color']
                if i == self.current_selection:
                    value_display_color = text_color
                else:
                    value_display_color = value_color
                
                value_frame = tk.Frame(content_container, bg=bg_color)
                value_frame.pack(fill='x', pady=(4, 0))
                
                tk.Label(
                    value_frame,
                    text="Value: ",
                    font=('MS Sans Serif', 12),
                    bg=bg_color,
                    fg=text_color
                ).pack(side='left')
                
                value_label = tk.Label(
                    value_frame,
                    text=f"[{value}]",
                    font=('MS Sans Serif', 12, 'bold'),
                    bg=bg_color,
                    fg=value_display_color
                )
                value_label.pack(side='left')
                
                # Indicator pentru selecție
                if i == self.current_selection:
                    indicator = tk.Label(
                        value_frame,
                        text=" ◄ SELECTED",
                        font=('MS Sans Serif', 10, 'bold'),
                        bg=bg_color,
                        fg=text_color
                    )
                    indicator.pack(side='right')
        
        def move_up(self):
            """Mută selecția în sus"""
            if self.current_selection > 0:
                self.current_selection -= 1
                self.update_display()
        
        def move_down(self):
            """Mută selecția în jos"""
            if self.current_selection < len(self.menu_items) - 1:
                self.current_selection += 1
                self.update_display()
        
        def toggle_selected(self):
            """Comută valoarea elementului selectat"""
            if self.menu_items:
                key = self.menu_items[self.current_selection]
                current_value = self.config_data[key]
                new_value = 'False' if current_value == 'True' else 'True'
                self.config_data[key] = new_value
                self.modified = True
                self.update_display()
                
                # Salvează automat
                if self.save_xml():
                    # Flash pentru confirmare
                    original_bg = self.rooXML.cget('bg')
                    self.rooXML.configure(bg='#00ff00')
                    self.rooXML.after(150, lambda: self.rooXML.configure(bg=original_bg))
        
        def exit_app(self):
            """Ieșire din aplicație"""
            if self.modified:
                if messagebox.askyesno("Confirm Exit", "You have unsaved changes. Save before exit?"):
                    self.save_xml()
            self.rooXML.quit()
        
        def setup_bindings(self):
            """Configurează tastele"""
            self.rooXML.bind('<Key>', self.on_key_press)
            self.rooXML.bind('<Button-1>', lambda e: self.rooXML.focus_set())  # Click pentru focus
            self.rooXML.focus_set()
        
        def on_key_press(self, event):
            """Gestionează tastele"""
            if event.keysym == 'Up':
                self.move_up()
            elif event.keysym == 'Down':
                self.move_down()
            elif event.keysym == 'Return':
                self.toggle_selected()
            elif event.keysym == 'Escape':
                self.exit_app()
            elif event.keysym == 'F11':  # Toggle fullscreen
                self.rooXML.attributes('-fullscreen', not self.rooXML.attributes('-fullscreen'))
        
        def run(self):
            """Pornește aplicația"""
            self.rooXML.mainloop()

    def main():
        """Funcția principală"""
        app = Windows95XMLEditor()
        app.run()

    if __name__ == "__main__":
        main()
        
if MDvar == 777666111:
    import webbrowser
    import tempfile
    import re
    from pathlib import Path
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class SimpleMarkdownParser:
        """Simple Markdown parser using only regex"""
        
        def __init__(self):
            self.html_content = ""
            
        def parse(self, markdown_text):
            """Convert Markdown to simple HTML"""
            lines = markdown_text.split('\n')
            html_lines = []
            in_code_block = False
            in_list = False
            
            for line in lines:
                # Code blocks
                if line.strip().startswith('```'):
                    if in_code_block:
                        html_lines.append('</pre>')
                        in_code_block = False
                    else:
                        html_lines.append('<pre><code>')
                        in_code_block = True
                    continue
                    
                if in_code_block:
                    html_lines.append(self.escape_html(line))
                    continue
                
                # Headers
                if line.startswith('#'):
                    level = len(line) - len(line.lstrip('#'))
                    if level <= 6:
                        text = line.lstrip('#').strip()
                        html_lines.append(f'<h{level}>{self.parse_inline(text)}</h{level}>')
                        continue
                
                # Horizontal rule
                if re.match(r'^[-*_]{3,}$', line.strip()):
                    html_lines.append('<hr>')
                    continue
                
                # Lists
                if re.match(r'^\s*[-*+]\s+', line):
                    if not in_list:
                        html_lines.append('<ul>')
                        in_list = True
                    text = re.sub(r'^\s*[-*+]\s+', '', line)
                    html_lines.append(f'<li>{self.parse_inline(text)}</li>')
                    continue
                elif re.match(r'^\s*\d+\.\s+', line):
                    if not in_list:
                        html_lines.append('<ol>')
                        in_list = True
                    text = re.sub(r'^\s*\d+\.\s+', '', line)
                    html_lines.append(f'<li>{self.parse_inline(text)}</li>')
                    continue
                else:
                    if in_list:
                        html_lines.append('</ul>')
                        in_list = False
                
                # Blockquotes
                if line.startswith('>'):
                    text = line.lstrip('>').strip()
                    html_lines.append(f'<blockquote>{self.parse_inline(text)}</blockquote>')
                    continue
                
                # Empty lines
                if not line.strip():
                    html_lines.append('<br>')
                    continue
                
                # Regular paragraphs
                html_lines.append(f'<p>{self.parse_inline(line)}</p>')
            
            # Close any open lists
            if in_list:
                html_lines.append('</ul>')
            if in_code_block:
                html_lines.append('</code></pre>')
                
            return '\n'.join(html_lines)
        
        def parse_inline(self, text):
            """Parse inline formatting"""
            # Bold **text** or __text__
            text = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', text)
            text = re.sub(r'__(.*?)__', r'<strong>\1</strong>', text)
            
            # Italic *text* or _text_
            text = re.sub(r'\*(.*?)\*', r'<em>\1</em>', text)
            text = re.sub(r'_(.*?)_', r'<em>\1</em>', text)
            
            # Code `text`
            text = re.sub(r'`(.*?)`', r'<code>\1</code>', text)
            
            # Links [text](url)
            text = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', r'<a href="\2">\1</a>', text)
            
            # Images ![alt](url)
            text = re.sub(r'!\[([^\]]*)\]\(([^)]+)\)', r'<img src="\2" alt="\1">', text)
            
            return text
        
        def escape_html(self, text):
            """Escape HTML characters"""
            return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    class MarkdownViewer:
        def __init__(self, rootMDDD):
            self.rootMDDD = rootMDDD
            self.rootMDDD.title("Markdown Viewer")
            self.rootMDDD.geometry("800x600")
            
            # Windows 95 color scheme
            self.bg_color = "#c0c0c0"
            self.button_color = "#c0c0c0"
            self.text_bg = "white"
            self.dark_edge = "#808080"
            self.light_edge = "#ffffff"
            
            # Configure rootMDDD window
            self.rootMDDD.configure(bg=self.bg_color)
            
            # Variables
            self.current_file = None
            self.markdown_content = ""
            self.parser = SimpleMarkdownParser()
            
            self.setup_ui()
            
        def setup_ui(self):
            # Menu bar with Windows 95 style
            menubar = tk.Menu(self.rootMDDD, bg=self.bg_color, fg="black", 
                             activebackground="#316AC5", activeforeground="white")
            self.rootMDDD.config(menu=menubar)
            
            file_menu = tk.Menu(menubar, tearoff=0, bg=self.bg_color, fg="black",
                               activebackground="#316AC5", activeforeground="white")
            menubar.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="Open...", command=self.open_file, accelerator="Ctrl+O")
            file_menu.add_command(label="Reload", command=self.reload_file, accelerator="F5")
            file_menu.add_separator()
            file_menu.add_command(label="Export HTML...", command=self.export_html)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootMDDD.quit)
            
            view_menu = tk.Menu(menubar, tearoff=0, bg=self.bg_color, fg="black",
                               activebackground="#316AC5", activeforeground="white")
            menubar.add_cascade(label="View", menu=view_menu)
            view_menu.add_command(label="Preview in Browser", command=self.preview_in_browser)
            
            help_menu = tk.Menu(menubar, tearoff=0, bg=self.bg_color, fg="black",
                               activebackground="#316AC5", activeforeground="white")
            menubar.add_cascade(label="Help", menu=help_menu)
            help_menu.add_command(label="About", command=self.show_about)
            
            # Toolbar with Windows 95 style
            toolbar = tk.Frame(self.rootMDDD, bg=self.bg_color, relief=tk.RAISED, bd=1)
            toolbar.pack(fill=tk.X, padx=2, pady=2)
            
            # Windows 95 style buttons
            self.create_button(toolbar, "Open", self.open_file).pack(side=tk.LEFT, padx=1)
            self.create_button(toolbar, "Reload", self.reload_file).pack(side=tk.LEFT, padx=1)
            
            # Separator
            separator = tk.Frame(toolbar, width=2, bg=self.dark_edge, relief=tk.SUNKEN, bd=1)
            separator.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=2)
            
            self.create_button(toolbar, "Browser Preview", self.preview_in_browser).pack(side=tk.LEFT, padx=1)
            self.create_button(toolbar, "Export HTML", self.export_html).pack(side=tk.LEFT, padx=1)
            
            # Main content area with Windows 95 styling
            main_frame = tk.Frame(self.rootMDDD, bg=self.bg_color)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Notebook-style tabs (manual implementation for Win95 feel)
            self.tab_frame = tk.Frame(main_frame, bg=self.bg_color)
            self.tab_frame.pack(fill=tk.X)
            
            self.tabs = {}
            self.active_tab = "source"
            
            # Create tab buttons
            self.create_tab_button("source", "Markdown Source").pack(side=tk.LEFT)
            self.create_tab_button("preview", "Formatted Preview").pack(side=tk.LEFT)
            self.create_tab_button("html", "Generated HTML").pack(side=tk.LEFT)
            
            # Content frame with sunken border
            content_frame = tk.Frame(main_frame, bg=self.bg_color, relief=tk.SUNKEN, bd=2)
            content_frame.pack(fill=tk.BOTH, expand=True, pady=(5, 0))
            
            # Source text area
            self.source_text = scrolledtext.ScrolledText(
                content_frame,
                wrap=tk.WORD,
                font=("Courier New", 9),
                bg=self.text_bg,
                fg="black",
                relief=tk.SUNKEN,
                bd=1,
                state=tk.DISABLED
            )
            self.source_text.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # Preview text area (hidden initially)
            self.preview_text = scrolledtext.ScrolledText(
                content_frame,
                wrap=tk.WORD,
                font=("MS Sans Serif", 8),
                bg=self.text_bg,
                fg="black",
                relief=tk.SUNKEN,
                bd=1,
                state=tk.DISABLED
            )
            
            # HTML text area (hidden initially)
            self.html_text = scrolledtext.ScrolledText(
                content_frame,
                wrap=tk.WORD,
                font=("Courier New", 8),
                bg="#f0f0f0",
                fg="black",
                relief=tk.SUNKEN,
                bd=1,
                state=tk.DISABLED
            )
            
            # Status bar with Windows 95 style
            status_frame = tk.Frame(self.rootMDDD, bg=self.bg_color, relief=tk.SUNKEN, bd=1)
            status_frame.pack(side=tk.BOTTOM, fill=tk.X)
            
            self.status_var = tk.StringVar()
            self.status_var.set("Ready - Select a Markdown file to begin")
            status_label = tk.Label(status_frame, textvariable=self.status_var, 
                                   bg=self.bg_color, fg="black", anchor=tk.W, 
                                   font=("MS Sans Serif", 8))
            status_label.pack(side=tk.LEFT, padx=5, pady=2)
            
            # Keyboard bindings
            self.rootMDDD.bind('<Control-o>', lambda e: self.open_file())
            self.rootMDDD.bind('<F5>', lambda e: self.reload_file())
            
            # Configure text formatting
            self.setup_preview_tags()
            
            # Show welcome message
            self.show_welcome()
            
        def create_button(self, parent, text, command):
            """Create a Windows 95 style button"""
            btn = tk.Button(parent, text=text, command=command,
                           bg=self.button_color, fg="black",
                           relief=tk.RAISED, bd=2,
                           font=("MS Sans Serif", 8),
                           padx=8, pady=2)
            return btn
        
        def create_tab_button(self, tab_id, text):
            """Create a tab button"""
            btn = tk.Button(self.tab_frame, text=text,
                           command=lambda: self.switch_tab(tab_id),
                           bg=self.button_color if tab_id != self.active_tab else "white",
                           fg="black",
                           relief=tk.RAISED if tab_id != self.active_tab else tk.SUNKEN,
                           bd=2,
                           font=("MS Sans Serif", 8),
                           padx=10, pady=2)
            self.tabs[tab_id] = btn
            return btn
        
        def switch_tab(self, tab_id):
            """Switch between tabs"""
            # Update button states
            for tid, btn in self.tabs.items():
                if tid == tab_id:
                    btn.config(relief=tk.SUNKEN, bg="white")
                else:
                    btn.config(relief=tk.RAISED, bg=self.button_color)
            
            # Hide all text widgets
            self.source_text.pack_forget()
            self.preview_text.pack_forget()
            self.html_text.pack_forget()
            
            # Show selected tab content
            if tab_id == "source":
                self.source_text.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            elif tab_id == "preview":
                self.preview_text.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            elif tab_id == "html":
                self.html_text.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            self.active_tab = tab_id
            
        def setup_preview_tags(self):
            """Configure text formatting tags"""
            self.preview_text.tag_configure("h1", font=("MS Sans Serif", 14, "bold"), spacing1=12, spacing3=8)
            self.preview_text.tag_configure("h2", font=("MS Sans Serif", 12, "bold"), spacing1=10, spacing3=6)
            self.preview_text.tag_configure("h3", font=("MS Sans Serif", 10, "bold"), spacing1=8, spacing3=4)
            self.preview_text.tag_configure("bold", font=("MS Sans Serif", 8, "bold"))
            self.preview_text.tag_configure("italic", font=("MS Sans Serif", 8, "italic"))
            self.preview_text.tag_configure("code", font=("Courier New", 8), background="#e0e0e0")
            self.preview_text.tag_configure("blockquote", lmargin1=20, lmargin2=20, background="#f0f0f0")
            
        def show_welcome(self):
            """Show welcome message"""
            welcome_text = """# Welcome to Markdown Viewer!

    This retro Markdown viewer brings you back to the Windows 95 era.
    No external dependencies required - pure Python and C++ standard library.

    ## Features Available:

    - **Markdown Source**: View the original Markdown code
    - **Formatted Preview**: See formatted preview in the application
    - **Generated HTML**: View the HTML generated from Markdown
    - **Browser Preview**: Open preview in your web browser
    - **HTML Export**: Save as standalone HTML file

    ## Supported Markdown:

    ### Headers
    # H1 Header
    ## H2 Header
    ### H3 Header

    ### Text Formatting
    **Bold text** and *italic text*

    ### Code
    `inline code` and code blocks:

    ```
    multi-line code
    block example
    ```

    ### Lists
    - Bullet list item
    - Another item

    1. Numbered list
    2. Second item

    ### Blockquotes
    > This is a blockquote
    > It can span multiple lines

    ### Links and Images
    [Link text](http://example.com)
    ![Alt text](image.jpg)

    ---

    **Get started by opening a Markdown file from the File menu or toolbar!**

    """
            
            self.markdown_content = welcome_text
            self.update_all_views()
            
        def show_about(self):
            """Show about dialog"""
            about_text = """Markdown Viewer
    Version 1.0

    A retro-style Markdown viewer.

    No external dependencies required

    © 2024 - Tudor Marmureanu"""
            
            messagebox.showinfo("About Markdown Viewer", about_text)
            
        def open_file(self):
            """Open a Markdown file"""
            file_path = filedialog.askopenfilename(
                title="Open Markdown File",
                filetypes=[
                    ("Markdown files", "*.md *.markdown *.mdown *.mkd *.txt"),
                    ("All files", "*.*")
                ]
            )
            
            if file_path:
                self.load_file(file_path)
                
        def load_file(self, file_path):
            """Load file content"""
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                self.current_file = file_path
                self.markdown_content = content
                
                # Update window title
                filename = os.path.basename(file_path)
                self.rootMDDD.title(f"Markdown Viewer - {filename}")
                
                # Update content
                self.update_all_views()
                
                self.status_var.set(f"Loaded: {file_path} ({len(content)} characters)")
                
            except Exception as e:
                messagebox.showerror("Error", f"Could not load file:\n{str(e)}")
                
        def update_all_views(self):
            """Update all views"""
            self.update_source_view()
            self.update_preview()
            self.update_html_view()
            
        def update_source_view(self):
            """Update the Markdown source view"""
            self.source_text.config(state=tk.NORMAL)
            self.source_text.delete(1.0, tk.END)
            self.source_text.insert(1.0, self.markdown_content)
            self.source_text.config(state=tk.DISABLED)
            
        def update_preview(self):
            """Update the formatted preview"""
            if not self.markdown_content:
                return
                
            try:
                self.preview_text.config(state=tk.NORMAL)
                self.preview_text.delete(1.0, tk.END)
                
                lines = self.markdown_content.split('\n')
                
                for line in lines:
                    # Headers
                    if line.startswith('#'):
                        level = len(line) - len(line.lstrip('#'))
                        if level <= 6:
                            text = line.lstrip('#').strip()
                            self.preview_text.insert(tk.END, text + '\n', f"h{min(level, 3)}")
                            continue
                    
                    # Process inline formatting
                    self.process_line_formatting(line)
                    self.preview_text.insert(tk.END, '\n')
                
                self.preview_text.config(state=tk.DISABLED)
                
            except Exception as e:
                messagebox.showerror("Preview Error", f"Error generating preview:\n{str(e)}")
        
        def process_line_formatting(self, line):
            """Process inline formatting for a line"""
            if line.startswith('>'):
                text = line.lstrip('>').strip()
                self.preview_text.insert(tk.END, "  " + text, "blockquote")
                return
                
            # Simple bold/italic/code processing
            parts = re.split(r'(\*\*.*?\*\*|\*.*?\*|`.*?`)', line)
            for part in parts:
                if part.startswith('**') and part.endswith('**'):
                    text = part[2:-2]
                    self.preview_text.insert(tk.END, text, "bold")
                elif part.startswith('*') and part.endswith('*'):
                    text = part[1:-1]
                    self.preview_text.insert(tk.END, text, "italic")
                elif part.startswith('`') and part.endswith('`'):
                    text = part[1:-1]
                    self.preview_text.insert(tk.END, text, "code")
                else:
                    self.preview_text.insert(tk.END, part)
        
        def update_html_view(self):
            """Update the HTML view"""
            if not self.markdown_content:
                return
                
            try:
                html = self.parser.parse(self.markdown_content)
                
                self.html_text.config(state=tk.NORMAL)
                self.html_text.delete(1.0, tk.END)
                self.html_text.insert(1.0, html)
                self.html_text.config(state=tk.DISABLED)
                
            except Exception as e:
                messagebox.showerror("HTML Error", f"Error generating HTML:\n{str(e)}")
                
        def reload_file(self):
            """Reload current file"""
            if self.current_file and os.path.exists(self.current_file):
                self.load_file(self.current_file)
            else:
                messagebox.showwarning("Warning", "No file loaded to reload.")
                
        def preview_in_browser(self):
            """Open preview in browser"""
            if not self.markdown_content:
                messagebox.showwarning("Warning", "No content to preview.")
                return
                
            try:
                html = self.parser.parse(self.markdown_content)
                
                # Create HTML template with retro styling
                html_template = f"""<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Markdown Preview</title>
        <style>
            body {{
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                max-width: 800px;
                margin: 0 auto;
                padding: 40px 20px;
                line-height: 1.6;
                color: #333;
            }}
            h1, h2, h3, h4, h5, h6 {{
                margin-top: 30px;
                margin-bottom: 15px;
                color: #2c3e50;
            }}
            h1 {{ font-size: 2em; border-bottom: 2px solid #eee; padding-bottom: 10px; }}
            h2 {{ font-size: 1.5em; border-bottom: 1px solid #eee; padding-bottom: 5px; }}
            pre {{
                background: #f8f9fa;
                padding: 15px;
                border-radius: 6px;
                overflow-x: auto;
                border-left: 4px solid #007acc;
            }}
            code {{
                background: #f1f3f4;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 0.9em;
            }}
            blockquote {{
                border-left: 4px solid #dfe2e5;
                margin: 0;
                padding-left: 20px;
                color: #6a737d;
                font-style: italic;
            }}
            table {{
                border-collapse: collapse;
                width: 100%;
                margin: 20px 0;
            }}
            th, td {{
                border: 1px solid #dfe2e5;
                padding: 12px;
                text-align: left;
            }}
            th {{
                background-color: #f6f8fa;
                font-weight: 600;
            }}
            ul, ol {{ padding-left: 30px; }}
            li {{ margin: 5px 0; }}
            a {{ color: #0366d6; text-decoration: none; }}
            a:hover {{ text-decoration: underline; }}
            hr {{ border: none; height: 1px; background: #e1e4e8; margin: 30px 0; }}
            img {{ max-width: 100%; height: auto; }}
        </style>
    </head>
    <body>
        <div class="window">
            <h1 style="color: #000080; border-bottom: 1px solid #808080; padding-bottom: 5px;">
                Markdown Preview
            </h1>
            {html}
        </div>
    </body>
    </html>"""
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False, encoding='utf-8') as f:
                    f.write(html_template)
                    temp_file = f.name
                
                webbrowser.open(f'file://{temp_file}')
                self.status_var.set("Preview opened in browser")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error opening preview:\n{str(e)}")
                
        def export_html(self):
            """Export content as HTML file"""
            if not self.markdown_content:
                messagebox.showwarning("Warning", "No content to export.")
                return
                
            file_path = filedialog.asksaveasfilename(
                title="Save as HTML",
                defaultextension=".html",
                filetypes=[("HTML files", "*.html"), ("All files", "*.*")]
            )
            
            if file_path:
                try:
                    html = self.parser.parse(self.markdown_content)
                    
                    html_template = f"""<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Markdown Export</title>
        
    </head>
    <body>
        <div class="window">
            {html}
        </div>
    </body>
    </html>"""
                    
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(html_template)
                    
                    self.status_var.set(f"Exported: {file_path}")
                    messagebox.showinfo("Success", f"File exported successfully to:\n{file_path}")
                    
                except Exception as e:
                    messagebox.showerror("Error", f"Export error:\n{str(e)}")

    def main():
        rootMDDD = tk.Tk()
        app = MarkdownViewer(rootMDDD)
        rootMDDD.mainloop()

    if __name__ == "__main__":
        main()
        
if archVar == 777666012:
    import stat
    import time
    import hashlib
    from pathlib import Path
    import mimetypes
    import platform
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class FileArcheologist:
        def __init__(self):
            self.rootARCH = tk.Tk()
            self.rootARCH.title("File Archeologist")
            self.rootARCH.geometry("800x600")
            self.rootARCH.configure(bg='#c0c0c0')
            
            # Windows 95 style configuration
            self.setup_styles()
            self.create_widgets()
            self.current_path = ""
            
        def setup_styles(self):
            """Configure Windows 95 retro styling"""
            style = ttk.Style()
            
            # Configure colors to match Windows 95
            self.colors = {
                'bg': '#c0c0c0',
                'button_bg': '#c0c0c0',
                'button_active': '#dfdfdf',
                'text_bg': 'white',
                'highlight': '#0078d4',
                'border': '#808080',
                'dark_border': '#404040'
            }
            
        def create_widgets(self):
            """Create the main interface"""
            # Menu bar
            menubar = tk.Menu(self.rootARCH, bg=self.colors['bg'])
            self.rootARCH.config(menu=menubar)
            
            file_menu = tk.Menu(menubar, tearoff=0, bg=self.colors['bg'])
            menubar.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="Open File...", command=self.select_file)
            file_menu.add_command(label="Open Folder...", command=self.select_folder)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootARCH.quit)
            
            # Toolbar
            toolbar = tk.Frame(self.rootARCH, bg=self.colors['bg'], relief='raised', bd=1)
            toolbar.pack(fill='x', padx=2, pady=2)
            
            tk.Button(toolbar, text="Open File", command=self.select_file,
                     bg=self.colors['button_bg'], relief='raised', bd=2,
                     font=('MS Sans Serif', 8)).pack(side='left', padx=2)
            
            tk.Button(toolbar, text="Open Folder", command=self.select_folder,
                     bg=self.colors['button_bg'], relief='raised', bd=2,
                     font=('MS Sans Serif', 8)).pack(side='left', padx=2)
            
            tk.Button(toolbar, text="Analyze", command=self.analyze_current,
                     bg=self.colors['button_bg'], relief='raised', bd=2,
                     font=('MS Sans Serif', 8)).pack(side='left', padx=2)
            
            # Main container
            main_frame = tk.Frame(self.rootARCH, bg=self.colors['bg'])
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Path display
            path_frame = tk.Frame(main_frame, bg=self.colors['bg'], relief='sunken', bd=2)
            path_frame.pack(fill='x', pady=(0, 5))
            
            tk.Label(path_frame, text="Path:", bg=self.colors['bg'], 
                    font=('MS Sans Serif', 8, 'bold')).pack(side='left', padx=5)
            
            self.path_var = tk.StringVar()
            self.path_label = tk.Label(path_frame, textvariable=self.path_var,
                                      bg=self.colors['text_bg'], relief='sunken', bd=1,
                                      font=('MS Sans Serif', 8), anchor='w')
            self.path_label.pack(fill='x', padx=5, pady=2)
            
            # Create notebook for tabs
            self.notebook = ttk.Notebook(main_frame)
            self.notebook.pack(fill='both', expand=True)
            
            # General tab
            self.general_tab = tk.Frame(self.notebook, bg=self.colors['bg'])
            self.notebook.add(self.general_tab, text="General")
            
            # Details tab
            self.details_tab = tk.Frame(self.notebook, bg=self.colors['bg'])
            self.notebook.add(self.details_tab, text="Details")
            
            # Security tab
            self.security_tab = tk.Frame(self.notebook, bg=self.colors['bg'])
            self.notebook.add(self.security_tab, text="Security")
            
            # Hash tab
            self.hash_tab = tk.Frame(self.notebook, bg=self.colors['bg'])
            self.notebook.add(self.hash_tab, text="Hash")
            
            self.create_general_tab()
            self.create_details_tab()
            self.create_security_tab()
            self.create_hash_tab()
            
            # Status bar
            self.status_bar = tk.Label(self.rootARCH, text="Ready", bg=self.colors['bg'],
                                      relief='sunken', bd=1, anchor='w',
                                      font=('MS Sans Serif', 8))
            self.status_bar.pack(fill='x', side='bottom')
            
        def create_general_tab(self):
            """Create general information tab"""
            # Create scrollable frame
            canvas = tk.Canvas(self.general_tab, bg=self.colors['bg'])
            scrollbar = tk.Scrollbar(self.general_tab, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg=self.colors['bg'])
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # General info fields
            self.general_info = {}
            fields = [
                "Name", "Type", "Location", "Size", "Size on disk",
                "Created", "Modified", "Accessed", "Attributes"
            ]
            
            for i, field in enumerate(fields):
                frame = tk.Frame(scrollable_frame, bg=self.colors['bg'])
                frame.pack(fill='x', padx=10, pady=2)
                
                tk.Label(frame, text=f"{field}:", bg=self.colors['bg'],
                        font=('MS Sans Serif', 8, 'bold'), width=15, anchor='w').pack(side='left')
                
                var = tk.StringVar()
                self.general_info[field] = var
                tk.Label(frame, textvariable=var, bg=self.colors['text_bg'],
                        relief='sunken', bd=1, font=('MS Sans Serif', 8),
                        anchor='w').pack(fill='x', padx=(5, 0))
            
        def create_details_tab(self):
            """Create details tab with file content preview"""
            # Text widget for file content preview
            text_frame = tk.Frame(self.details_tab, bg=self.colors['bg'])
            text_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            tk.Label(text_frame, text="File Content Preview:", bg=self.colors['bg'],
                    font=('MS Sans Serif', 8, 'bold')).pack(anchor='w')
            
            # Create text widget with scrollbars
            text_container = tk.Frame(text_frame, bg=self.colors['bg'], relief='sunken', bd=2)
            text_container.pack(fill='both', expand=True, pady=(5, 0))
            
            self.content_text = tk.Text(text_container, wrap='word', bg=self.colors['text_bg'],
                                       font=('Courier New', 9), state='disabled')
            
            v_scrollbar = tk.Scrollbar(text_container, orient='vertical', command=self.content_text.yview)
            h_scrollbar = tk.Scrollbar(text_container, orient='horizontal', command=self.content_text.xview)
            
            self.content_text.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            self.content_text.grid(row=0, column=0, sticky='nsew')
            v_scrollbar.grid(row=0, column=1, sticky='ns')
            h_scrollbar.grid(row=1, column=0, sticky='ew')
            
            text_container.grid_rowconfigure(0, weight=1)
            text_container.grid_columnconfigure(0, weight=1)
            
        def create_security_tab(self):
            """Create security/permissions tab"""
            # Create scrollable frame
            canvas = tk.Canvas(self.security_tab, bg=self.colors['bg'])
            scrollbar = tk.Scrollbar(self.security_tab, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg=self.colors['bg'])
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Security info fields
            self.security_info = {}
            fields = [
                "Owner", "Group", "Permissions (Octal)", "Permissions (String)",
                "Read Permission", "Write Permission", "Execute Permission",
                "Hidden", "System", "Archive"
            ]
            
            for field in fields:
                frame = tk.Frame(scrollable_frame, bg=self.colors['bg'])
                frame.pack(fill='x', padx=10, pady=2)
                
                tk.Label(frame, text=f"{field}:", bg=self.colors['bg'],
                        font=('MS Sans Serif', 8, 'bold'), width=20, anchor='w').pack(side='left')
                
                var = tk.StringVar()
                self.security_info[field] = var
                tk.Label(frame, textvariable=var, bg=self.colors['text_bg'],
                        relief='sunken', bd=1, font=('MS Sans Serif', 8),
                        anchor='w').pack(fill='x', padx=(5, 0))
        
        def create_hash_tab(self):
            """Create hash calculation tab"""
            hash_frame = tk.Frame(self.hash_tab, bg=self.colors['bg'])
            hash_frame.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Hash algorithms
            self.hash_info = {}
            algorithms = ["MD5", "SHA1", "SHA256", "SHA512"]
            
            for algo in algorithms:
                frame = tk.Frame(hash_frame, bg=self.colors['bg'])
                frame.pack(fill='x', pady=5)
                
                tk.Label(frame, text=f"{algo}:", bg=self.colors['bg'],
                        font=('MS Sans Serif', 8, 'bold'), width=10, anchor='w').pack(side='left')
                
                var = tk.StringVar()
                self.hash_info[algo] = var
                
                entry = tk.Entry(frame, textvariable=var, bg=self.colors['text_bg'],
                               relief='sunken', bd=1, font=('Courier New', 8),
                               state='readonly')
                entry.pack(fill='x', padx=(5, 0))
            
            # Calculate button
            calc_frame = tk.Frame(hash_frame, bg=self.colors['bg'])
            calc_frame.pack(fill='x', pady=(10, 0))
            
            tk.Button(calc_frame, text="Calculate Hashes", command=self.calculate_hashes,
                     bg=self.colors['button_bg'], relief='raised', bd=2,
                     font=('MS Sans Serif', 8)).pack()
            
        def select_file(self):
            """Select a file to analyze"""
            file_path = filedialog.askopenfilename(
                title="Select File to Analyze",
                filetypes=[("All Files", "*.*")]
            )
            if file_path:
                self.current_path = file_path
                self.analyze_path(file_path)
                
        def select_folder(self):
            """Select a folder to analyze"""
            folder_path = filedialog.askdirectory(title="Select Folder to Analyze")
            if folder_path:
                self.current_path = folder_path
                self.analyze_path(folder_path)
                
        def analyze_current(self):
            """Re-analyze current path"""
            if self.current_path:
                self.analyze_path(self.current_path)
            else:
                messagebox.showwarning("No Path", "Please select a file or folder first.")
                
        def analyze_path(self, path):
            """Analyze the selected path"""
            try:
                self.status_bar.config(text="Analyzing...")
                self.rootARCH.update()
                
                self.path_var.set(path)
                
                # Get basic file info
                stat_info = os.stat(path)
                is_file = os.path.isfile(path)
                
                # General information
                self.general_info["Name"].set(os.path.basename(path))
                self.general_info["Type"].set("File" if is_file else "Folder")
                self.general_info["Location"].set(os.path.dirname(path))
                
                # Size information
                if is_file:
                    size = stat_info.st_size
                    self.general_info["Size"].set(self.format_size(size))
                    
                    # Calculate size on disk (approximate)
                    block_size = 4096  # Common block size
                    size_on_disk = ((size + block_size - 1) // block_size) * block_size
                    self.general_info["Size on disk"].set(self.format_size(size_on_disk))
                else:
                    folder_size = self.get_folder_size(path)
                    self.general_info["Size"].set(self.format_size(folder_size))
                    self.general_info["Size on disk"].set(self.format_size(folder_size))
                
                # Time information
                self.general_info["Created"].set(time.ctime(stat_info.st_ctime))
                self.general_info["Modified"].set(time.ctime(stat_info.st_mtime))
                self.general_info["Accessed"].set(time.ctime(stat_info.st_atime))
                
                # Attributes
                attributes = self.get_attributes(stat_info, path)
                self.general_info["Attributes"].set(attributes)
                
                # Security information
                self.update_security_info(stat_info, path)
                
                # File content preview
                if is_file:
                    self.preview_file_content(path)
                else:
                    self.preview_folder_content(path)
                    
                self.status_bar.config(text=f"Analysis complete: {os.path.basename(path)}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error analyzing path: {str(e)}")
                self.status_bar.config(text="Error occurred")
                
        def get_folder_size(self, path):
            """Calculate total size of folder"""
            total_size = 0
            try:
                for dirpath, dirnames, filenames in os.walk(path):
                    for filename in filenames:
                        file_path = os.path.join(dirpath, filename)
                        try:
                            total_size += os.path.getsize(file_path)
                        except (OSError, IOError):
                            pass
            except (OSError, IOError):
                pass
            return total_size
            
        def format_size(self, size):
            """Format file size in human readable format"""
            for unit in ['bytes', 'KB', 'MB', 'GB', 'TB']:
                if size < 1024.0:
                    return f"{size:.1f} {unit}"
                size /= 1024.0
            return f"{size:.1f} PB"
            
        def get_attributes(self, stat_info, path):
            """Get file attributes"""
            attrs = []
            
            # Unix-style permissions
            if stat.S_ISDIR(stat_info.st_mode):
                attrs.append("Directory")
            if stat.S_ISREG(stat_info.st_mode):
                attrs.append("Regular File")
            if stat.S_ISLNK(stat_info.st_mode):
                attrs.append("Symbolic Link")
                
            # Check if hidden (starts with dot on Unix-like systems)
            if os.path.basename(path).startswith('.'):
                attrs.append("Hidden")
                
            return ", ".join(attrs) if attrs else "Normal"
            
        def update_security_info(self, stat_info, path):
            """Update security/permissions information"""
            try:
                # Basic permissions
                mode = stat_info.st_mode
                
                # Octal permissions
                octal_perms = oct(stat.S_IMODE(mode))
                self.security_info["Permissions (Octal)"].set(octal_perms)
                
                # String permissions
                perms = stat.filemode(mode)
                self.security_info["Permissions (String)"].set(perms)
                
                # Individual permissions
                self.security_info["Read Permission"].set("Yes" if os.access(path, os.R_OK) else "No")
                self.security_info["Write Permission"].set("Yes" if os.access(path, os.W_OK) else "No")
                self.security_info["Execute Permission"].set("Yes" if os.access(path, os.X_OK) else "No")
                
                # Owner information (Unix-like systems)
                try:
                    import pwd
                    owner = pwd.getpwuid(stat_info.st_uid).pw_name
                    self.security_info["Owner"].set(owner)
                except (ImportError, KeyError):
                    self.security_info["Owner"].set(f"UID: {stat_info.st_uid}")
                    
                try:
                    import grp
                    group = grp.getgrgid(stat_info.st_gid).gr_name
                    self.security_info["Group"].set(group)
                except (ImportError, KeyError):
                    self.security_info["Group"].set(f"GID: {stat_info.st_gid}")
                    
                # Windows-specific attributes
                if platform.system() == "Windows":
                    import win32api
                    attrs = win32api.GetFileAttributes(path)
                    self.security_info["Hidden"].set("Yes" if attrs & 2 else "No")
                    self.security_info["System"].set("Yes" if attrs & 4 else "No")
                    self.security_info["Archive"].set("Yes" if attrs & 32 else "No")
                else:
                    self.security_info["Hidden"].set("N/A")
                    self.security_info["System"].set("N/A")
                    self.security_info["Archive"].set("N/A")
                    
            except Exception as e:
                for key in self.security_info:
                    self.security_info[key].set("Error")
                    
        def preview_file_content(self, path):
            """Preview file content"""
            try:
                self.content_text.config(state='normal')
                self.content_text.delete(1.0, tk.END)
                
                # Try to determine if file is text-based
                mime_type, _ = mimetypes.guess_type(path)
                
                max_size = 1024 * 1024  # 1MB limit for preview
                file_size = os.path.getsize(path)
                
                if file_size > max_size:
                    self.content_text.insert(tk.END, f"File too large for preview ({self.format_size(file_size)})\n")
                    self.content_text.insert(tk.END, "Only text files under 1MB can be previewed.")
                elif mime_type and mime_type.startswith('text'):
                    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read(8192)  # Read first 8KB
                        self.content_text.insert(tk.END, content)
                        if file_size > 8192:
                            self.content_text.insert(tk.END, "\n\n... (truncated)")
                else:
                    # Binary file - show hex preview
                    with open(path, 'rb') as f:
                        data = f.read(256)  # Read first 256 bytes
                        hex_output = self.format_hex_dump(data)
                        self.content_text.insert(tk.END, "Binary file - Hex dump (first 256 bytes):\n\n")
                        self.content_text.insert(tk.END, hex_output)
                        
                self.content_text.config(state='disabled')
                
            except Exception as e:
                self.content_text.config(state='normal')
                self.content_text.delete(1.0, tk.END)
                self.content_text.insert(tk.END, f"Error reading file: {str(e)}")
                self.content_text.config(state='disabled')
                
        def preview_folder_content(self, path):
            """Preview folder content"""
            try:
                self.content_text.config(state='normal')
                self.content_text.delete(1.0, tk.END)
                
                items = os.listdir(path)
                items.sort()
                
                self.content_text.insert(tk.END, f"Folder Contents ({len(items)} items):\n\n")
                
                for item in items[:100]:  # Limit to first 100 items
                    item_path = os.path.join(path, item)
                    if os.path.isdir(item_path):
                        self.content_text.insert(tk.END, f"{item}\n")
                    else:
                        size = os.path.getsize(item_path)
                        self.content_text.insert(tk.END, f"{item} ({self.format_size(size)})\n")
                        
                if len(items) > 100:
                    self.content_text.insert(tk.END, f"\n... and {len(items) - 100} more items")
                    
                self.content_text.config(state='disabled')
                
            except Exception as e:
                self.content_text.config(state='normal')
                self.content_text.delete(1.0, tk.END)
                self.content_text.insert(tk.END, f"Error reading folder: {str(e)}")
                self.content_text.config(state='disabled')
                
        def format_hex_dump(self, data):
            """Format binary data as hex dump"""
            lines = []
            for i in range(0, len(data), 16):
                chunk = data[i:i+16]
                hex_part = ' '.join(f'{b:02x}' for b in chunk)
                ascii_part = ''.join(chr(b) if 32 <= b <= 126 else '.' for b in chunk)
                lines.append(f'{i:08x}: {hex_part:<48} {ascii_part}')
            return '\n'.join(lines)
            
        def calculate_hashes(self):
            """Calculate file hashes"""
            if not self.current_path or not os.path.isfile(self.current_path):
                messagebox.showwarning("No File", "Please select a file first.")
                return
                
            try:
                self.status_bar.config(text="Calculating hashes...")
                self.rootARCH.update()
                
                # Clear previous values
                for algo in self.hash_info:
                    self.hash_info[algo].set("Calculating...")
                self.rootARCH.update()
                
                algorithms = {
                    'MD5': hashlib.md5(),
                    'SHA1': hashlib.sha1(),
                    'SHA256': hashlib.sha256(),
                    'SHA512': hashlib.sha512()
                }
                
                with open(self.current_path, 'rb') as f:
                    while chunk := f.read(8192):
                        for hasher in algorithms.values():
                            hasher.update(chunk)
                            
                for algo, hasher in algorithms.items():
                    self.hash_info[algo].set(hasher.hexdigest())
                    self.rootARCH.update()
                    
                self.status_bar.config(text="Hash calculation complete")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error calculating hashes: {str(e)}")
                for algo in self.hash_info:
                    self.hash_info[algo].set("Error")
                self.status_bar.config(text="Hash calculation failed")
                
        def run(self):
            """Start the application"""
            self.rootARCH.mainloop()

    if __name__ == "__main__":
        app = FileArcheologist()
        app.run()
        
if expensevar == 777666013:
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    import matplotlib
    from datetime import datetime
    import numpy as np

    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    # Configurarea matplotlib pentru a evita thread-urile persistente
    matplotlib.use('Agg')  # Folosește backend non-interactiv
    plt.ioff()  # Dezactivează modul interactiv

    class ExpenseTracker:
        def __init__(self, root_exps):
            self.root_exps = root_exps
            self.root_exps.title("Expense Tracker")
            self.root_exps.geometry("800x600")
            self.root_exps.configure(bg='#c0c0c0')
            
            # Configurează evenimentul de închidere
            self.root_exps.protocol("WM_DELETE_WINDOW", self.on_closing)
            
            # Windows 95 style settings
            self.setup_retro_style()
            
            # Application data
            self.expenses = []
            self.categories = ["Food", "Transport", "Entertainment", 
                              "Housing", "Clothing", "Healthcare", "Education", "Other"]
            
            # Load existing data
            self.load_data()
            
            # Create interface
            self.create_interface()
            
        def on_closing(self):
            """Gestionează închiderea aplicației"""
            try:
                # Salvează datele înainte de închidere
                self.save_data()
                
                # Închide toate figurile matplotlib
                plt.close('all')
                
                # Curăță memoria matplotlib
                plt.clf()
                plt.cla()
                
                # Distruge fereastra
                self.root_exps.destroy()
                
                # Forțează ieșirea din aplicație
                sys.exit(0)
                
            except Exception as e:
                print(f"Error during closing: {e}")
                # Forțează închiderea chiar dacă apar erori
                os._exit(0)
            
        def setup_retro_style(self):
            """Configure Windows 95 retro style"""
            style = ttk.Style()
            style.theme_use('clam')  # Closest to Windows 95
            
            # Windows 95 colors
            bg_color = '#c0c0c0'
            button_color = '#c0c0c0'
            
            style.configure('Retro.TButton', 
                           background=button_color,
                           relief='raised',
                           borderwidth=2,
                           font=('MS Sans Serif', 8))
            
            style.configure('Retro.TFrame', 
                           background=bg_color,
                           relief='raised',
                           borderwidth=1)
            
        def create_interface(self):
            """Create main interface"""
            # Main frame
            main_frame = tk.Frame(self.root_exps, bg='#c0c0c0', relief='raised', bd=1)
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Windows 95 style title
            title_frame = tk.Frame(main_frame, bg='#008080', relief='raised', bd=2)
            title_frame.pack(fill='x', pady=(0, 10))
            
            title_label = tk.Label(title_frame, text="EXPENSE TRACKER", 
                                  font=('MS Sans Serif', 12, 'bold'),
                                  bg='#008080', fg='white')
            title_label.pack(pady=5)
            
            # Frame for adding expense
            add_frame = tk.LabelFrame(main_frame, text="Add New Expense", 
                                     font=('MS Sans Serif', 8, 'bold'),
                                     bg='#c0c0c0', relief='groove', bd=2)
            add_frame.pack(fill='x', pady=(0, 10), padx=5)
            
            # Controls for adding
            controls_frame = tk.Frame(add_frame, bg='#c0c0c0')
            controls_frame.pack(fill='x', padx=10, pady=10)
            
            # Amount
            tk.Label(controls_frame, text="Amount ($):", font=('MS Sans Serif', 8),
                    bg='#c0c0c0').grid(row=0, column=0, sticky='w', padx=(0, 5))
            self.amount_var = tk.StringVar()
            amount_entry = tk.Entry(controls_frame, textvariable=self.amount_var,
                                   font=('MS Sans Serif', 8), relief='sunken', bd=2)
            amount_entry.grid(row=0, column=1, padx=(0, 10))
            
            # Category
            tk.Label(controls_frame, text="Category:", font=('MS Sans Serif', 8),
                    bg='#c0c0c0').grid(row=0, column=2, sticky='w', padx=(0, 5))
            self.category_var = tk.StringVar(value=self.categories[0])
            category_combo = ttk.Combobox(controls_frame, textvariable=self.category_var,
                                         values=self.categories, font=('MS Sans Serif', 8),
                                         state='readonly', width=15)
            category_combo.grid(row=0, column=3, padx=(0, 10))
            
            # Description
            tk.Label(controls_frame, text="Description:", font=('MS Sans Serif', 8),
                    bg='#c0c0c0').grid(row=1, column=0, sticky='w', pady=(10, 0))
            self.desc_var = tk.StringVar()
            desc_entry = tk.Entry(controls_frame, textvariable=self.desc_var,
                                 font=('MS Sans Serif', 8), relief='sunken', bd=2, width=40)
            desc_entry.grid(row=1, column=1, columnspan=2, pady=(10, 0), sticky='ew')
            
            # Windows 95 style buttons
            button_frame = tk.Frame(controls_frame, bg='#c0c0c0')
            button_frame.grid(row=1, column=3, pady=(10, 0), padx=(10, 0))
            
            add_btn = tk.Button(button_frame, text="Add", 
                               command=self.add_expense,
                               font=('MS Sans Serif', 8, 'bold'),
                               bg='#c0c0c0', relief='raised', bd=2,
                               cursor='hand2', width=8)
            add_btn.pack(side='left', padx=(0, 5))
            
            clear_btn = tk.Button(button_frame, text="Clear All", 
                                 command=self.clear_all,
                                 font=('MS Sans Serif', 8),
                                 bg='#c0c0c0', relief='raised', bd=2,
                                 cursor='hand2', width=8)
            clear_btn.pack(side='left')
            
            # Frame for statistics and charts
            stats_frame = tk.Frame(main_frame, bg='#c0c0c0')
            stats_frame.pack(fill='both', expand=True, padx=5)
            
            # Frame for expense list
            list_frame = tk.LabelFrame(stats_frame, text="Expense History", 
                                      font=('MS Sans Serif', 8, 'bold'),
                                      bg='#c0c0c0', relief='groove', bd=2)
            list_frame.pack(fill='both', expand=True, side='left', padx=(0, 5))
            
            # Treeview for expenses
            columns = ('Date', 'Amount', 'Category', 'Description')
            self.tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=8)
            
            # Configure columns
            self.tree.heading('Date', text='Date')
            self.tree.heading('Amount', text='Amount ($)')
            self.tree.heading('Category', text='Category')
            self.tree.heading('Description', text='Description')
            
            self.tree.column('Date', width=80)
            self.tree.column('Amount', width=80)
            self.tree.column('Category', width=100)
            self.tree.column('Description', width=150)
            
            # Scrollbar for treeview
            scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=self.tree.yview)
            self.tree.configure(yscrollcommand=scrollbar.set)
            
            self.tree.pack(side='left', fill='both', expand=True, padx=5, pady=5)
            scrollbar.pack(side='right', fill='y', pady=5)
            
            # Bind for deletion
            self.tree.bind('<Delete>', self.delete_selected)
            self.tree.bind('<Double-1>', self.edit_expense)
            
            # Frame for charts
            chart_frame = tk.LabelFrame(stats_frame, text="Statistics", 
                                       font=('MS Sans Serif', 8, 'bold'),
                                       bg='#c0c0c0', relief='groove', bd=2)
            chart_frame.pack(fill='both', expand=True, side='right')
            
            # Chart buttons
            chart_buttons = tk.Frame(chart_frame, bg='#c0c0c0')
            chart_buttons.pack(fill='x', padx=5, pady=5)
            
            pie_btn = tk.Button(chart_buttons, text="Pie Chart", 
                               command=self.show_pie_chart,
                               font=('MS Sans Serif', 8),
                               bg='#c0c0c0', relief='raised', bd=2, width=10)
            pie_btn.pack(side='left', padx=(0, 5))
            
            bar_btn = tk.Button(chart_buttons, text="Bar Chart", 
                               command=self.show_bar_chart,
                               font=('MS Sans Serif', 8),
                               bg='#c0c0c0', relief='raised', bd=2, width=10)
            bar_btn.pack(side='left')
            
            # Summary button
            summary_btn = tk.Button(chart_buttons, text="Summary", 
                                  command=self.show_summary,
                                  font=('MS Sans Serif', 8),
                                  bg='#c0c0c0', relief='raised', bd=2, width=10)
            summary_btn.pack(side='left', padx=(5, 0))
            
            # Frame for chart display
            self.chart_frame = tk.Frame(chart_frame, bg='#c0c0c0')
            self.chart_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Windows 95 style status bar
            status_frame = tk.Frame(main_frame, bg='#c0c0c0', relief='sunken', bd=1)
            status_frame.pack(fill='x', side='bottom')
            
            self.status_label = tk.Label(status_frame, text="Ready", 
                                        font=('MS Sans Serif', 8),
                                        bg='#c0c0c0', anchor='w')
            self.status_label.pack(side='left', padx=5, pady=2)
            
            self.total_label = tk.Label(status_frame, text="Total: $0.00", 
                                       font=('MS Sans Serif', 8, 'bold'),
                                       bg='#c0c0c0', anchor='e')
            self.total_label.pack(side='right', padx=5, pady=2)
            
            # Update display
            self.update_display()
            self.show_summary()  # Show summary by default
            
        def add_expense(self):
            """Add a new expense"""
            try:
                amount = float(self.amount_var.get())
                category = self.category_var.get()
                description = self.desc_var.get() or "No description"
                
                if amount <= 0:
                    messagebox.showerror("Error", "Amount must be greater than 0!")
                    return
                
                expense = {
                    'date': datetime.now().strftime('%Y-%m-%d'),
                    'amount': amount,
                    'category': category,
                    'description': description
                }
                
                self.expenses.append(expense)
                self.save_data()
                self.update_display()
                
                # Clear form
                self.amount_var.set('')
                self.desc_var.set('')
                
                self.status_label.config(text=f"Added: ${amount:.2f} - {category}")
                
            except ValueError:
                messagebox.showerror("Error", "Please enter a valid amount!")
                
        def delete_selected(self, event=None):
            """Delete selected expense"""
            selected = self.tree.selection()
            if selected:
                if messagebox.askyesno("Confirm", "Are you sure you want to delete this expense?"):
                    item = self.tree.item(selected[0])
                    date_str = item['values'][0]
                    amount = float(item['values'][1])
                    
                    # Find and delete from list
                    for i, expense in enumerate(self.expenses):
                        if (expense['date'] == date_str and 
                            expense['amount'] == amount):
                            del self.expenses[i]
                            break
                    
                    self.save_data()
                    self.update_display()
                    self.status_label.config(text="Expense deleted")
        
        def clear_all(self):
            """Delete all expenses"""
            if messagebox.askyesno("Warning", "Are you sure you want to delete ALL expenses?\nThis action cannot be undone!"):
                self.expenses.clear()
                self.save_data()
                self.update_display()
                self.status_label.config(text="All expenses cleared")
        
        def edit_expense(self, event=None):
            """Allow editing an expense"""
            selected = self.tree.selection()
            if selected:
                item = self.tree.item(selected[0])
                values = item['values']
                
                # Populate form with existing data
                self.amount_var.set(str(values[1]))
                self.category_var.set(values[2])
                self.desc_var.set(values[3])
                
                # Delete old expense
                self.delete_selected()
                
        def update_display(self):
            """Update display with current data"""
            # Clear treeview
            for item in self.tree.get_children():
                self.tree.delete(item)
                
            # Add expenses
            total = 0
            for expense in sorted(self.expenses, key=lambda x: x['date'], reverse=True):
                self.tree.insert('', 'end', values=(
                    expense['date'],
                    f"{expense['amount']:.2f}",
                    expense['category'],
                    expense['description']
                ))
                total += expense['amount']
                
            # Update total
            self.total_label.config(text=f"Total: ${total:.2f}")
            
        def show_summary(self):
            """Show summary statistics"""
            # Clear chart frame
            for widget in self.chart_frame.winfo_children():
                widget.destroy()
                
            if not self.expenses:
                no_data_label = tk.Label(self.chart_frame, text="No expenses to display\n\nAdd some expenses to see statistics!", 
                                       font=('MS Sans Serif', 10),
                                       bg='#c0c0c0', fg='#666666',
                                       justify='center')
                no_data_label.pack(expand=True)
                return
            
            # Calculate statistics
            total = sum(expense['amount'] for expense in self.expenses)
            count = len(self.expenses)
            avg = total / count if count > 0 else 0
            
            category_totals = {}
            for expense in self.expenses:
                cat = expense['category']
                category_totals[cat] = category_totals.get(cat, 0) + expense['amount']
            
            top_category = max(category_totals.items(), key=lambda x: x[1]) if category_totals else ("None", 0)
            
            # Create summary display
            summary_frame = tk.Frame(self.chart_frame, bg='#c0c0c0', relief='sunken', bd=1)
            summary_frame.pack(fill='both', expand=True, padx=10, pady=10)
            
            tk.Label(summary_frame, text="EXPENSE SUMMARY", 
                    font=('MS Sans Serif', 10, 'bold'),
                    bg='#c0c0c0').pack(pady=(10, 20))
            
            # Statistics
            stats_text = f"""Total Expenses: ${total:.2f}
    Number of Transactions: {count}
    Average per Transaction: ${avg:.2f}
    Top Category: {top_category[0]} (${top_category[1]:.2f})

    Categories Breakdown:"""
            
            tk.Label(summary_frame, text=stats_text, 
                    font=('MS Sans Serif', 9),
                    bg='#c0c0c0', justify='left').pack(pady=(0, 10))
            
            # Category breakdown
            for category, amount in sorted(category_totals.items(), key=lambda x: x[1], reverse=True):
                percentage = (amount / total) * 100 if total > 0 else 0
                category_text = f"{category}: ${amount:.2f} ({percentage:.1f}%)"
                tk.Label(summary_frame, text=category_text, 
                        font=('MS Sans Serif', 8),
                        bg='#c0c0c0', fg='#333333').pack(anchor='w', padx=20)
            
            self.status_label.config(text="Summary displayed")
            
        def show_pie_chart(self):
            """Display pie chart by categories"""
            if not self.expenses:
                messagebox.showinfo("Info", "No expenses to display!")
                return
                
            # Calculate totals by category
            category_totals = {}
            for expense in self.expenses:
                cat = expense['category']
                category_totals[cat] = category_totals.get(cat, 0) + expense['amount']
            
            # Clear chart frame
            for widget in self.chart_frame.winfo_children():
                widget.destroy()
                
            # Create chart
            fig, ax = plt.subplots(figsize=(6, 4))
            fig.patch.set_facecolor('#c0c0c0')
            
            colors = ['#ff9999', '#66b3ff', '#99ff99', '#ffcc99', 
                     '#ff99cc', '#c2c2f0', '#ffb3e6', '#c4e17f']
            
            wedges, texts, autotexts = ax.pie(category_totals.values(), 
                                             labels=category_totals.keys(),
                                             autopct='%1.1f%%',
                                             colors=colors[:len(category_totals)],
                                             startangle=90)
            
            ax.set_title('Expenses by Category', fontsize=12, fontweight='bold')
            
            # Integrate into tkinter
            canvas = FigureCanvasTkAgg(fig, self.chart_frame)
            canvas.draw()
            canvas.get_tk_widget().pack(fill='both', expand=True)
            
            self.status_label.config(text="Pie chart displayed")
            
        def show_bar_chart(self):
            """Display bar chart by categories"""
            if not self.expenses:
                messagebox.showinfo("Info", "No expenses to display!")
                return
                
            # Calculate totals by category
            category_totals = {}
            for expense in self.expenses:
                cat = expense['category']
                category_totals[cat] = category_totals.get(cat, 0) + expense['amount']
            
            # Clear chart frame
            for widget in self.chart_frame.winfo_children():
                widget.destroy()
                
            # Create chart
            fig, ax = plt.subplots(figsize=(6, 4))
            fig.patch.set_facecolor('#c0c0c0')
            
            categories = list(category_totals.keys())
            amounts = list(category_totals.values())
            
            bars = ax.bar(categories, amounts, color='#4CAF50', alpha=0.8)
            ax.set_title('Expenses by Category', fontsize=12, fontweight='bold')
            ax.set_ylabel('Amount ($)')
            ax.tick_params(axis='x', rotation=45)
            
            # Add values on bars
            for bar, amount in zip(bars, amounts):
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height,
                       f'${amount:.0f}',
                       ha='center', va='bottom', fontsize=9)
            
            plt.tight_layout()
            
            # Integrate into tkinter
            canvas = FigureCanvasTkAgg(fig, self.chart_frame)
            canvas.draw()
            canvas.get_tk_widget().pack(fill='both', expand=True)
            
            self.status_label.config(text="Bar chart displayed")
            
        def save_data(self):
            """Save data to JSON file"""
            try:
                with open('expenses.json', 'w', encoding='utf-8') as f:
                    json.dump(self.expenses, f, ensure_ascii=False, indent=2)
            except Exception as e:
                messagebox.showerror("Error", f"Could not save data: {e}")
                
        def load_data(self):
            """Load data from JSON file"""
            try:
                if os.path.exists('expenses.json'):
                    with open('expenses.json', 'r', encoding='utf-8') as f:
                        self.expenses = json.load(f)
            except Exception as e:
                messagebox.showwarning("Warning", f"Could not load data: {e}")
                self.expenses = []

    def main():
        root_exps = tk.Tk()
        
        # Windows 95 configurations
        root_exps.configure(bg='#c0c0c0')
        
        # Try to set icon (optional)
        try:
            root_exps.iconbitmap('money.ico')
        except:
            pass
        
        app = ExpenseTracker(root_exps)
        
        # Windows 95 style welcome message
        messagebox.showinfo("Expense Tracker", 
                           "Welcome to Expense Tracker!\n\n" +
                           "Features:\n" +
                           "• Add expenses with categories\n" +
                           "• View interactive charts\n" +
                           "• Edit: double-click on expense\n" +
                           "• Delete: select and press Delete\n\n" +
                           "All data is saved automatically!")
        
        try:
            root_exps.mainloop()
        except KeyboardInterrupt:
            app.on_closing()
        finally:
            # Asigură-te că procesul se închide complet
            try:
                plt.close('all')
                sys.exit(0)
            except:
                os._exit(0)

    if __name__ == "__main__":
        main()
        
if scrpVar == 777666014:
    from datetime import datetime
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    class Win95ScriptRunner:
        def __init__(self):
            self.root_scr = tk.Tk()
            self.setup_window()
            self.scripts = {}
            self.load_scripts()
            self.setup_gui()
            self.running_process = None
            
        def setup_window(self):
            self.root_scr.title("Script Runner")
            self.root_scr.geometry("800x600")
            self.root_scr.configure(bg='#c0c0c0')
            
            # Windows 95 style configuration
            style = ttk.Style()
            style.theme_use('classic')
            
            # Custom colors for Windows 95 look
            self.bg_color = '#c0c0c0'
            self.button_color = '#c0c0c0'
            self.text_color = '#000000'
            self.highlight_color = '#0000ff'
            
        def setup_gui(self):
            # Main frame
            main_frame = tk.Frame(self.root_scr, bg=self.bg_color, relief='raised', bd=2)
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Title bar
            title_frame = tk.Frame(main_frame, bg='#000080', height=25)
            title_frame.pack(fill='x', pady=(0, 5))
            title_frame.pack_propagate(False)
            
            title_label = tk.Label(title_frame, text="Script Runner", 
                                  bg='#000080', fg='white', font=('MS Sans Serif', 8, 'bold'))
            title_label.pack(side='left', padx=5, pady=2)
            
            # Toolbar
            toolbar = tk.Frame(main_frame, bg=self.bg_color, relief='raised', bd=1)
            toolbar.pack(fill='x', pady=(0, 5))
            
            # Toolbar buttons with Windows 95 style
            btn_new = tk.Button(toolbar, text="New Script", command=self.add_script,
                               relief='raised', bd=2, bg=self.button_color, font=('MS Sans Serif', 8))
            btn_new.pack(side='left', padx=2, pady=2)
            
            btn_edit = tk.Button(toolbar, text="Edit", command=self.edit_script,
                                relief='raised', bd=2, bg=self.button_color, font=('MS Sans Serif', 8))
            btn_edit.pack(side='left', padx=2, pady=2)
            
            btn_delete = tk.Button(toolbar, text="Delete", command=self.delete_script,
                                  relief='raised', bd=2, bg=self.button_color, font=('MS Sans Serif', 8))
            btn_delete.pack(side='left', padx=2, pady=2)
            
            btn_refresh = tk.Button(toolbar, text="Refresh", command=self.refresh_scripts,
                                   relief='raised', bd=2, bg=self.button_color, font=('MS Sans Serif', 8))
            btn_refresh.pack(side='left', padx=2, pady=2)
            
            # Main content area
            content_frame = tk.Frame(main_frame, bg=self.bg_color, relief='sunken', bd=2)
            content_frame.pack(fill='both', expand=True)
            
            # Left panel - Script list
            left_panel = tk.Frame(content_frame, bg=self.bg_color, width=250, relief='sunken', bd=1)
            left_panel.pack(side='left', fill='y', padx=5, pady=5)
            left_panel.pack_propagate(False)
            
            tk.Label(left_panel, text="Available Scripts", bg=self.bg_color, 
                    font=('MS Sans Serif', 8, 'bold')).pack(anchor='w', padx=5, pady=5)
            
            # Script listbox with scrollbar
            listbox_frame = tk.Frame(left_panel, bg=self.bg_color)
            listbox_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            self.script_listbox = tk.Listbox(listbox_frame, font=('MS Sans Serif', 8),
                                            bg='white', selectmode='single',
                                            relief='sunken', bd=2)
            scrollbar = tk.Scrollbar(listbox_frame, orient='vertical', command=self.script_listbox.yview)
            self.script_listbox.configure(yscrollcommand=scrollbar.set)
            
            self.script_listbox.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
            
            # Bind double click to run script
            self.script_listbox.bind('<Double-Button-1>', self.run_selected_script)
            
            # Right panel - Output and controls
            right_panel = tk.Frame(content_frame, bg=self.bg_color, relief='sunken', bd=1)
            right_panel.pack(side='right', fill='both', expand=True, padx=5, pady=5)
            
            # Control buttons
            control_frame = tk.Frame(right_panel, bg=self.bg_color)
            control_frame.pack(fill='x', padx=5, pady=5)
            
            self.run_button = tk.Button(control_frame, text="Run Script", command=self.run_selected_script,
                                       relief='raised', bd=2, bg='#00ff00', font=('MS Sans Serif', 8, 'bold'))
            self.run_button.pack(side='left', padx=5)
            
            self.stop_button = tk.Button(control_frame, text="Stop", command=self.stop_script,
                                        relief='raised', bd=2, bg='#ff0000', font=('MS Sans Serif', 8, 'bold'),
                                        state='disabled')
            self.stop_button.pack(side='left', padx=5)
            
            # Output area
            tk.Label(right_panel, text="Output Console", bg=self.bg_color, 
                    font=('MS Sans Serif', 8, 'bold')).pack(anchor='w', padx=5, pady=(10, 5))
            
            self.output_text = scrolledtext.ScrolledText(right_panel, height=20, width=50,
                                                        font=('Courier New', 8), bg='black', fg='#00ff00',
                                                        relief='sunken', bd=2)
            self.output_text.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Status bar
            status_frame = tk.Frame(main_frame, bg=self.bg_color, relief='sunken', bd=1, height=25)
            status_frame.pack(fill='x', side='bottom')
            status_frame.pack_propagate(False)
            
            self.status_label = tk.Label(status_frame, text="Ready", bg=self.bg_color, 
                                        font=('MS Sans Serif', 8), anchor='w')
            self.status_label.pack(fill='x', padx=5, pady=2)
            
            # Load initial scripts
            self.refresh_script_list()
            
        def load_scripts(self):
            """Load scripts from JSON file"""
            try:
                if os.path.exists('scripts.json'):
                    with open('scripts.json', 'r', encoding='utf-8') as f:
                        self.scripts = json.load(f)
                else:
                    # Default scripts
                    self.scripts = {
                        "System Info": {
                            "command": "python -c \"import platform; print('System:', platform.system()); print('Version:', platform.version()); print('Machine:', platform.machine())\"",
                            "category": "System",
                            "description": "Display system information"
                        },
                        "List Files": {
                            "command": "dir" if sys.platform == "win32" else "ls -la",
                            "category": "Files",
                            "description": "List files in current directory"
                        },
                        "Python Version": {
                            "command": "python --version",
                            "category": "Development",
                            "description": "Show Python version"
                        },
                        "Disk Usage": {
                            "command": "python -c \"import shutil; total, used, free = shutil.disk_usage('.'); print(f'Total: {total//1024//1024//1024}GB'); print(f'Used: {used//1024//1024//1024}GB'); print(f'Free: {free//1024//1024//1024}GB')\"",
                            "category": "System",
                            "description": "Show disk usage"
                        },
                        "Current Time": {
                            "command": "python -c \"from datetime import datetime; print('Current time:', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\"",
                            "category": "Utilities",
                            "description": "Display current date and time"
                        }
                    }
                    self.save_scripts()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load scripts: {e}")
                self.scripts = {}
        
        def save_scripts(self):
            """Save scripts to JSON file"""
            try:
                with open('scripts.json', 'w', encoding='utf-8') as f:
                    json.dump(self.scripts, f, indent=2, ensure_ascii=False)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save scripts: {e}")
        
        def refresh_script_list(self):
            """Refresh the script list display"""
            self.script_listbox.delete(0, tk.END)
            for name, script in self.scripts.items():
                category = script.get('category', 'General')
                self.script_listbox.insert(tk.END, f"[{category}] {name}")
        
        def add_script(self):
            """Add a new script"""
            dialog = ScriptDialog(self.root_scr, "Add New Script")
            result = dialog.show()
            
            if result:
                name, command, category, description = result
                if name in self.scripts:
                    messagebox.showerror("Error", "Script name already exists!")
                    return
                    
                self.scripts[name] = {
                    "command": command,
                    "category": category,
                    "description": description
                }
                self.save_scripts()
                self.refresh_script_list()
                self.update_status(f"Added script: {name}")
        
        def edit_script(self):
            """Edit selected script"""
            selection = self.script_listbox.curselection()
            if not selection:
                messagebox.showwarning("Warning", "Please select a script to edit")
                return
                
            item_text = self.script_listbox.get(selection[0])
            script_name = item_text.split('] ', 1)[1]
            
            if script_name not in self.scripts:
                messagebox.showerror("Error", "Script not found!")
                return
                
            script = self.scripts[script_name]
            dialog = ScriptDialog(self.root_scr, "Edit Script", script_name, 
                                 script['command'], script['category'], script['description'])
            result = dialog.show()
            
            if result:
                name, command, category, description = result
                
                # If name changed, remove old entry
                if name != script_name:
                    del self.scripts[script_name]
                    
                self.scripts[name] = {
                    "command": command,
                    "category": category,
                    "description": description
                }
                self.save_scripts()
                self.refresh_script_list()
                self.update_status(f"Updated script: {name}")
        
        def delete_script(self):
            """Delete selected script"""
            selection = self.script_listbox.curselection()
            if not selection:
                messagebox.showwarning("Warning", "Please select a script to delete")
                return
                
            item_text = self.script_listbox.get(selection[0])
            script_name = item_text.split('] ', 1)[1]
            
            if messagebox.askyesno("Confirm Delete", f"Delete script '{script_name}'?"):
                if script_name in self.scripts:
                    del self.scripts[script_name]
                    self.save_scripts()
                    self.refresh_script_list()
                    self.update_status(f"Deleted script: {script_name}")
        
        def refresh_scripts(self):
            """Refresh script list"""
            self.load_scripts()
            self.refresh_script_list()
            self.update_status("Scripts refreshed")
        
        def run_selected_script(self, event=None):
            """Run the selected script"""
            selection = self.script_listbox.curselection()
            if not selection:
                messagebox.showwarning("Warning", "Please select a script to run")
                return
                
            item_text = self.script_listbox.get(selection[0])
            script_name = item_text.split('] ', 1)[1]
            
            if script_name not in self.scripts:
                messagebox.showerror("Error", "Script not found!")
                return
                
            self.run_script(script_name)
        
        def run_script(self, script_name):
            """Execute a script in a separate thread"""
            if self.running_process:
                messagebox.showwarning("Warning", "A script is already running!")
                return
                
            script = self.scripts[script_name]
            command = script['command']
            
            # Clear output
            self.output_text.delete(1.0, tk.END)
            self.output_text.insert(tk.END, f">>> Running: {script_name}\n")
            self.output_text.insert(tk.END, f">>> Command: {command}\n")
            self.output_text.insert(tk.END, f">>> Started at: {datetime.now().strftime('%H:%M:%S')}\n\n")
            
            # Update UI state
            self.run_button.config(state='disabled')
            self.stop_button.config(state='normal')
            self.update_status(f"Running: {script_name}")
            
            # Start script in thread
            thread = threading.Thread(target=self._execute_script, args=(command, script_name))
            thread.daemon = True
            thread.start()
        
        def _execute_script(self, command, script_name):
            """Execute script in subprocess"""
            try:
                # Determine shell based on OS
                shell = True if sys.platform == "win32" else False
                
                self.running_process = subprocess.Popen(
                    command,
                    shell=shell,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1,
                    universal_newlines=True
                )
                
                # Read output line by line
                for line in iter(self.running_process.stdout.readline, ''):
                    if line:
                        self.root_scr.after(0, self._update_output, line)
                
                self.running_process.wait()
                return_code = self.running_process.returncode
                
                # Update UI when finished
                self.root_scr.after(0, self._script_finished, script_name, return_code)
                
            except Exception as e:
                self.root_scr.after(0, self._script_error, script_name, str(e))
            finally:
                self.running_process = None
        
        def _update_output(self, text):
            """Update output text (called from main thread)"""
            self.output_text.insert(tk.END, text)
            self.output_text.see(tk.END)
            self.root_scr.update_idletasks()
        
        def _script_finished(self, script_name, return_code):
            """Handle script completion"""
            self.output_text.insert(tk.END, f"\n>>> Finished: {script_name}\n")
            self.output_text.insert(tk.END, f">>> Exit code: {return_code}\n")
            self.output_text.insert(tk.END, f">>> Ended at: {datetime.now().strftime('%H:%M:%S')}\n")
            
            self.run_button.config(state='normal')
            self.stop_button.config(state='disabled')
            
            if return_code == 0:
                self.update_status(f"Completed: {script_name}")
            else:
                self.update_status(f"Failed: {script_name} (exit code: {return_code})")
        
        def _script_error(self, script_name, error):
            """Handle script error"""
            self.output_text.insert(tk.END, f"\n>>> ERROR running {script_name}: {error}\n")
            self.run_button.config(state='normal')
            self.stop_button.config(state='disabled')
            self.update_status(f"Error: {script_name}")
        
        def stop_script(self):
            """Stop running script"""
            if self.running_process:
                try:
                    self.running_process.terminate()
                    self.output_text.insert(tk.END, "\n>>> Script terminated by user\n")
                    self.update_status("Script stopped")
                except Exception as e:
                    self.output_text.insert(tk.END, f"\n>>> Error stopping script: {e}\n")
                finally:
                    self.run_button.config(state='normal')
                    self.stop_button.config(state='disabled')
                    self.running_process = None
        
        def update_status(self, message):
            """Update status bar"""
            self.status_label.config(text=f"{datetime.now().strftime('%H:%M:%S')} - {message}")
        
        def run(self):
            """Start the application"""
            self.root_scr.mainloop()


    class ScriptDialog:
        def __init__(self, parent, title, name="", command="", category="General", description=""):
            self.result = None
            self.dialog = tk.Toplevel(parent)
            self.dialog.title(title)
            self.dialog.geometry("500x400")
            self.dialog.configure(bg='#c0c0c0')
            self.dialog.resizable(False, False)
            self.dialog.transient(parent)
            self.dialog.grab_set()
            
            # Center the dialog
            self.dialog.geometry("+%d+%d" % (parent.winfo_root_scrx() + 50, parent.winfo_root_scry() + 50))
            
            self.setup_dialog(name, command, category, description)
        
        def setup_dialog(self, name, command, category, description):
            # Main frame
            main_frame = tk.Frame(self.dialog, bg='#c0c0c0', relief='raised', bd=2)
            main_frame.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Name field
            tk.Label(main_frame, text="Script Name:", bg='#c0c0c0', font=('MS Sans Serif', 8)).pack(anchor='w', pady=5)
            self.name_entry = tk.Entry(main_frame, font=('MS Sans Serif', 8), relief='sunken', bd=2)
            self.name_entry.pack(fill='x', pady=(0, 10))
            self.name_entry.insert(0, name)
            
            # Category field
            tk.Label(main_frame, text="Category:", bg='#c0c0c0', font=('MS Sans Serif', 8)).pack(anchor='w', pady=5)
            self.category_entry = tk.Entry(main_frame, font=('MS Sans Serif', 8), relief='sunken', bd=2)
            self.category_entry.pack(fill='x', pady=(0, 10))
            self.category_entry.insert(0, category)
            
            # Command field
            tk.Label(main_frame, text="Command:", bg='#c0c0c0', font=('MS Sans Serif', 8)).pack(anchor='w', pady=5)
            self.command_text = scrolledtext.ScrolledText(main_frame, height=8, font=('Courier New', 8),
                                                         relief='sunken', bd=2)
            self.command_text.pack(fill='both', expand=True, pady=(0, 10))
            self.command_text.insert(1.0, command)
            
            # Description field
            tk.Label(main_frame, text="Description:", bg='#c0c0c0', font=('MS Sans Serif', 8)).pack(anchor='w', pady=5)
            self.desc_entry = tk.Entry(main_frame, font=('MS Sans Serif', 8), relief='sunken', bd=2)
            self.desc_entry.pack(fill='x', pady=(0, 15))
            self.desc_entry.insert(0, description)
            
            # Buttons
            button_frame = tk.Frame(main_frame, bg='#c0c0c0')
            button_frame.pack(fill='x')
            
            tk.Button(button_frame, text="OK", command=self.ok_clicked, 
                     relief='raised', bd=2, bg='#c0c0c0', font=('MS Sans Serif', 8), width=10).pack(side='right', padx=5)
            tk.Button(button_frame, text="Cancel", command=self.cancel_clicked,
                     relief='raised', bd=2, bg='#c0c0c0', font=('MS Sans Serif', 8), width=10).pack(side='right')
            
            # Focus on name entry
            self.name_entry.focus()
        
        def ok_clicked(self):
            name = self.name_entry.get().strip()
            command = self.command_text.get(1.0, tk.END).strip()
            category = self.category_entry.get().strip()
            description = self.desc_entry.get().strip()
            
            if not name or not command:
                messagebox.showerror("Error", "Name and Command are required!")
                return
                
            self.result = (name, command, category, description)
            self.dialog.destroy()
        
        def cancel_clicked(self):
            self.dialog.destroy()
        
        def show(self):
            self.dialog.wait_window()
            return self.result


    if __name__ == "__main__":
        app = Win95ScriptRunner()
        app.run()
        
if recoveryVarr == 777666090:
    import tkinter.font as tkFont
    import time
    import hashlib
    import struct
    from datetime import datetime
    from pathlib import Path
    import winreg
    import tempfile
    import glob
    from collections import defaultdict
    import ctypes
    from ctypes import wintypes
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class RetroRecoverApp:
        def __init__(self):
            self.rootrecovv = tk.Tk()
            self.setup_window()
            self.setup_fonts()
            self.setup_variables()
            self.create_menu()
            self.create_toolbar()
            self.create_main_interface()
            self.create_status_bar()
            self.clear_results()
            
            # Recovery engine
            self.recovery_engine = RealFileRecoveryEngine()
            self.is_scanning = False
            
        def setup_window(self):
            self.rootrecovv.title("Recover Tunnel")
            self.rootrecovv.geometry("900x700")
            self.rootrecovv.configure(bg='#c0c0c0')
            self.rootrecovv.resizable(True, True)
            
            # Windows 95 icon (if available)
            try:
                self.rootrecovv.iconbitmap('icon.ico')
            except:
                pass
                
        def setup_fonts(self):
            self.default_font = tkFont.Font(family="MS Sans Serif", size=8)
            self.bold_font = tkFont.Font(family="MS Sans Serif", size=8, weight="bold")
            self.title_font = tkFont.Font(family="MS Sans Serif", size=10, weight="bold")
            
        def setup_variables(self):
            self.scan_progress = tk.DoubleVar()
            self.status_text = tk.StringVar(value="Ready")
            self.current_operation = tk.StringVar(value="")
            self.files_found = tk.IntVar(value=0)
            self.recoverable_files = []
            
        def create_menu(self):
            menubar = tk.Menu(self.rootrecovv, bg='#c0c0c0', relief='raised', bd=1)
            self.rootrecovv.config(menu=menubar)
            
            # File Menu
            file_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0')
            menubar.add_cascade(label="File", menu=file_menu, underline=0)
            file_menu.add_command(label="New Scan", command=self.new_scan, underline=0)
            file_menu.add_command(label="Open Recovery Log", command=self.open_log, underline=0)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootrecovv.quit, underline=1)
            
            # Tools Menu
            tools_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0')
            menubar.add_cascade(label="Tools", menu=tools_menu, underline=0)
            tools_menu.add_command(label="Scan Recycle Bin", command=self.scan_recycle_bin, underline=5)
            tools_menu.add_command(label="Scan Temp Files", command=self.scan_temp_files, underline=5)
            tools_menu.add_command(label="Recent Files Scan", command=self.scan_recent_files, underline=0)
            tools_menu.add_separator()
            tools_menu.add_command(label="Settings", command=self.show_settings, underline=0)
            
            # Help Menu
            help_menu = tk.Menu(menubar, tearoff=0, bg='#c0c0c0')
            menubar.add_cascade(label="Help", menu=help_menu, underline=0)
            help_menu.add_command(label="About", command=self.show_about, underline=0)
            
        def create_toolbar(self):
            toolbar = tk.Frame(self.rootrecovv, bg='#c0c0c0', relief='raised', bd=1, height=40)
            toolbar.pack(fill='x', pady=2)
            
            # Toolbar buttons with 3D effect
            btn_new = tk.Button(toolbar, text="New Scan", font=self.default_font,
                               relief='raised', bd=2, padx=10, pady=2,
                               command=self.new_scan, bg='#c0c0c0')
            btn_new.pack(side='left', padx=2, pady=2)
            
            btn_recycle = tk.Button(toolbar, text="Recycle Bin", font=self.default_font,
                                   relief='raised', bd=2, padx=10, pady=2,
                                   command=self.scan_recycle_bin, bg='#c0c0c0')
            btn_recycle.pack(side='left', padx=2, pady=2)
            
            btn_temp = tk.Button(toolbar, text="Temp Files", font=self.default_font,
                                relief='raised', bd=2, padx=10, pady=2,
                                command=self.scan_temp_files, bg='#c0c0c0')
            btn_temp.pack(side='left', padx=2, pady=2)
            
            btn_recover = tk.Button(toolbar, text="Recover Selected", font=self.default_font,
                                   relief='raised', bd=2, padx=10, pady=2,
                                   command=self.recover_selected, bg='#c0c0c0')
            btn_recover.pack(side='left', padx=2, pady=2)
            
            btn_preview = tk.Button(toolbar, text="Preview", font=self.default_font,
                                   relief='raised', bd=2, padx=10, pady=2,
                                   command=self.preview_file, bg='#c0c0c0')
            btn_preview.pack(side='left', padx=2, pady=2)
            
            # Separator
            separator = tk.Frame(toolbar, width=2, bg='#808080', relief='sunken', bd=1)
            separator.pack(side='left', fill='y', padx=5, pady=2)
            
            btn_clear = tk.Button(toolbar, text="Clear", font=self.default_font,
                                 relief='raised', bd=2, padx=10, pady=2,
                                 command=self.clear_results, bg='#c0c0c0')
            btn_clear.pack(side='left', padx=2, pady=2)
            
            btn_stop = tk.Button(toolbar, text="Stop", font=self.default_font,
                                relief='raised', bd=2, padx=10, pady=2,
                                command=self.stop_scan, bg='#c0c0c0')
            btn_stop.pack(side='left', padx=2, pady=2)
            
        def create_main_interface(self):
            # Main container
            main_frame = tk.Frame(self.rootrecovv, bg='#c0c0c0')
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Left panel - Scan options
            left_panel = tk.LabelFrame(main_frame, text="Recovery Options", font=self.bold_font,
                                      bg='#c0c0c0', relief='groove', bd=2)
            left_panel.pack(side='left', fill='y', padx=(0, 5))
            
            # Recovery types
            tk.Label(left_panel, text="Recovery Types:", font=self.bold_font, bg='#c0c0c0').pack(anchor='w', padx=5, pady=5)
            
            self.recovery_types = {
                'Recycle Bin Files': tk.BooleanVar(value=True),
                'Temporary Files': tk.BooleanVar(value=True),
                'Recent Documents': tk.BooleanVar(value=True),
                'Browser Cache': tk.BooleanVar(value=False),
                'System Restore Points': tk.BooleanVar(value=False)
            }
            
            for recovery_type, var in self.recovery_types.items():
                cb = tk.Checkbutton(left_panel, text=recovery_type, variable=var,
                                   font=self.default_font, bg='#c0c0c0')
                cb.pack(anchor='w', padx=10, pady=1)
                
            # File types
            tk.Label(left_panel, text="File Types:", font=self.bold_font, bg='#c0c0c0').pack(anchor='w', padx=5, pady=(15,2))
            
            self.file_types = {
                'Documents': tk.BooleanVar(value=True),
                'Images': tk.BooleanVar(value=True),
                'Videos': tk.BooleanVar(value=True),
                'Audio': tk.BooleanVar(value=True),
                'Archives': tk.BooleanVar(value=True),
                'All Files': tk.BooleanVar(value=False)
            }
            
            for file_type, var in self.file_types.items():
                cb = tk.Checkbutton(left_panel, text=file_type, variable=var,
                                   font=self.default_font, bg='#c0c0c0')
                cb.pack(anchor='w', padx=10, pady=1)
                
            # Quick actions
            tk.Label(left_panel, text="Quick Actions:", font=self.bold_font, bg='#c0c0c0').pack(anchor='w', padx=5, pady=(15,5))
            
            btn_quick_recycle = tk.Button(left_panel, text="Quick Recycle Scan", 
                                         font=self.default_font, relief='raised', bd=2,
                                         command=self.scan_recycle_bin, bg='#c0c0c0')
            btn_quick_recycle.pack(fill='x', padx=5, pady=2)
            
            btn_quick_temp = tk.Button(left_panel, text="Quick Temp Scan", 
                                      font=self.default_font, relief='raised', bd=2,
                                      command=self.scan_temp_files, bg='#c0c0c0')
            btn_quick_temp.pack(fill='x', padx=5, pady=2)
            
            # Right panel - Results
            right_panel = tk.Frame(main_frame, bg='#c0c0c0')
            right_panel.pack(side='right', fill='both', expand=True)
            
            # Results label
            results_label = tk.Label(right_panel, text="Recoverable Files", 
                                    font=self.bold_font, bg='#c0c0c0')
            results_label.pack(anchor='w', pady=(0,5))
            
            # Treeview for results
            tree_frame = tk.Frame(right_panel, relief='sunken', bd=2)
            tree_frame.pack(fill='both', expand=True)
            
            # Create treeview with classic styling
            style = ttk.Style()
            style.configure("Classic.Treeview", background="white", foreground="black")
            style.configure("Classic.Treeview.Heading", background="#c0c0c0", foreground="black")
            
            self.tree = ttk.Treeview(tree_frame, style="Classic.Treeview")
            self.tree['columns'] = ('Size', 'Type', 'Location', 'Date Modified', 'Status')
            self.tree.heading('#0', text='File Name')
            self.tree.heading('Size', text='Size')
            self.tree.heading('Type', text='Type')
            self.tree.heading('Location', text='Original Location')
            self.tree.heading('Date Modified', text='Date Modified')
            self.tree.heading('Status', text='Status')
            
            # Column widths
            self.tree.column('#0', width=200)
            self.tree.column('Size', width=80)
            self.tree.column('Type', width=80)
            self.tree.column('Location', width=200)
            self.tree.column('Date Modified', width=120)
            self.tree.column('Status', width=100)
            
            # Scrollbars
            v_scrollbar = tk.Scrollbar(tree_frame, orient='vertical', command=self.tree.yview)
            h_scrollbar = tk.Scrollbar(tree_frame, orient='horizontal', command=self.tree.xview)
            self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            self.tree.pack(side='left', fill='both', expand=True)
            v_scrollbar.pack(side='right', fill='y')
            h_scrollbar.pack(side='bottom', fill='x')
            
            # Progress frame
            progress_frame = tk.Frame(right_panel, bg='#c0c0c0')
            progress_frame.pack(fill='x', pady=(5,0))
            
            # Progress bar
            self.progress_bar = tk.Canvas(progress_frame, height=20, bg='white', relief='sunken', bd=2)
            self.progress_bar.pack(fill='x', pady=2)
            
            # Operation status
            self.operation_label = tk.Label(progress_frame, textvariable=self.current_operation,
                                           font=self.default_font, bg='#c0c0c0')
            self.operation_label.pack(anchor='w')
            
        def create_status_bar(self):
            status_frame = tk.Frame(self.rootrecovv, bg='#c0c0c0', relief='sunken', bd=1)
            status_frame.pack(fill='x', side='bottom')
            
            self.status_label = tk.Label(status_frame, textvariable=self.status_text,
                                        font=self.default_font, bg='#c0c0c0', anchor='w')
            self.status_label.pack(side='left', padx=5)
            
            separator1 = tk.Frame(status_frame, width=2, bg='#808080', relief='sunken', bd=1)
            separator1.pack(side='left', fill='y', padx=2)
            
            self.files_label = tk.Label(status_frame, text="Files found: 0",
                                       font=self.default_font, bg='#c0c0c0')
            self.files_label.pack(side='left', padx=5)
            
            separator2 = tk.Frame(status_frame, width=2, bg='#808080', relief='sunken', bd=1)
            separator2.pack(side='left', fill='y', padx=2)
            
            self.time_label = tk.Label(status_frame, text=datetime.now().strftime("%H:%M:%S"),
                                      font=self.default_font, bg='#c0c0c0')
            self.time_label.pack(side='right', padx=5)
            
            # Update time every second
            self.update_time()
            
        def update_time(self):
            self.time_label.config(text=datetime.now().strftime("%H:%M:%S"))
            self.rootrecovv.after(1000, self.update_time)
            
        def update_progress(self, value, operation=""):
            # Update progress bar
            self.progress_bar.delete("all")
            
            # Force canvas to update its dimensions first
            self.progress_bar.update_idletasks()
            width = self.progress_bar.winfo_width()
            height = self.progress_bar.winfo_height()
            
            if width > 1 and height > 1:
                fill_width = int((value / 100) * (width - 4))
                if fill_width > 0:
                    block_width = 8
                    blocks = max(1, fill_width // block_width)
                    for i in range(blocks):
                        x1 = 2 + i * block_width
                        x2 = min(x1 + block_width - 1, width - 2)
                        if x2 > x1:
                            self.progress_bar.create_rectangle(x1, 2, x2, height-2,
                                                             fill='#0000ff', outline='#0000ff')
            
            if operation:
                self.current_operation.set(operation)
            
            # Force immediate update of all UI elements
            self.rootrecovv.update()
            
        def new_scan(self):
            if self.is_scanning:
                messagebox.showwarning("Scan in Progress", "Please stop the current scan before starting a new one.")
                return
                
            # Reset stop flag
            self.recovery_engine.stopped = False
            
            # Clear previous results
            for item in self.tree.get_children():
                self.tree.delete(item)
                
            self.recoverable_files.clear()
            self.files_found.set(0)
            
            # Start comprehensive scan
            self.is_scanning = True
            self.status_text.set("Starting comprehensive scan...")
            
            scan_thread = threading.Thread(target=self.perform_comprehensive_scan)
            scan_thread.daemon = True
            scan_thread.start()
            
        def perform_comprehensive_scan(self):
            try:
                selected_types = [rtype for rtype, var in self.recovery_types.items() if var.get()]
                total_operations = len(selected_types)
                current_operation = 0
                
                if 'Recycle Bin Files' in selected_types and not self.recovery_engine.stopped:
                    current_operation += 1
                    base_progress = int(((current_operation - 1) / total_operations) * 100)
                    self.recovery_engine.scan_recycle_bin(lambda p, op, f=None: self.scan_callback(
                        base_progress + (p // total_operations), op, f))
                    
                if 'Temporary Files' in selected_types and not self.recovery_engine.stopped:
                    current_operation += 1
                    base_progress = int(((current_operation - 1) / total_operations) * 100)
                    self.recovery_engine.scan_temp_files(lambda p, op, f=None: self.scan_callback(
                        base_progress + (p // total_operations), op, f))
                    
                if 'Recent Documents' in selected_types and not self.recovery_engine.stopped:
                    current_operation += 1
                    base_progress = int(((current_operation - 1) / total_operations) * 100)
                    self.recovery_engine.scan_recent_files(lambda p, op, f=None: self.scan_callback(
                        base_progress + (p // total_operations), op, f))
                    
                if 'Browser Cache' in selected_types and not self.recovery_engine.stopped:
                    current_operation += 1
                    base_progress = int(((current_operation - 1) / total_operations) * 100)
                    self.recovery_engine.scan_browser_cache(lambda p, op, f=None: self.scan_callback(
                        base_progress + (p // total_operations), op, f))
                    
            except Exception as e:
                messagebox.showerror("Scan Error", f"An error occurred during scanning: {str(e)}")
            finally:
                self.is_scanning = False
                self.recovery_engine.stopped = False  # Reset for next scan
                if self.recovery_engine.stopped:
                    self.status_text.set("Scan stopped by user")
                    self.current_operation.set("Scan cancelled")
                else:
                    self.status_text.set("Scan completed")
                    self.current_operation.set("Scan finished successfully")
                self.update_progress(100, "")
                
        def scan_recycle_bin(self):
            if self.is_scanning:
                return
                
            self.recovery_engine.stopped = False  # Reset stop flag
            self.is_scanning = True
            self.status_text.set("Scanning Recycle Bin...")
            
            scan_thread = threading.Thread(target=self._scan_recycle_bin_thread)
            scan_thread.daemon = True
            scan_thread.start()
            
        def _scan_recycle_bin_thread(self):
            try:
                self.recovery_engine.scan_recycle_bin(self.scan_callback)
            finally:
                self.is_scanning = False
                self.status_text.set("Recycle Bin scan completed")
                
        def scan_temp_files(self):
            if self.is_scanning:
                return
                
            self.recovery_engine.stopped = False  # Reset stop flag
            self.is_scanning = True
            self.status_text.set("Scanning temporary files...")
            
            scan_thread = threading.Thread(target=self._scan_temp_files_thread)
            scan_thread.daemon = True
            scan_thread.start()
            
        def _scan_temp_files_thread(self):
            try:
                self.recovery_engine.scan_temp_files(self.scan_callback)
            finally:
                self.is_scanning = False
                self.status_text.set("Temporary files scan completed")
                
        def scan_recent_files(self):
            if self.is_scanning:
                return
                
            self.recovery_engine.stopped = False  # Reset stop flag
            self.is_scanning = True
            self.status_text.set("Scanning recent files...")
            
            scan_thread = threading.Thread(target=self._scan_recent_files_thread)
            scan_thread.daemon = True
            scan_thread.start()
            
        def _scan_recent_files_thread(self):
            try:
                self.recovery_engine.scan_recent_files(self.scan_callback)
            finally:
                self.is_scanning = False
                self.status_text.set("Recent files scan completed")
                
        def scan_callback(self, progress, operation, found_file=None):
            self.update_progress(progress, operation)
            
            if found_file:
                # Add found file to tree
                self.tree.insert('', 'end', text=found_file['name'],
                               values=(found_file['size'], found_file['type'],
                                     found_file['location'], found_file['date'], found_file['status']))
                self.recoverable_files.append(found_file)
                self.files_found.set(len(self.recoverable_files))
                self.files_label.config(text=f"Files found: {self.files_found.get()}")
                
        def stop_scan(self):
            self.is_scanning = False
            self.recovery_engine.stopped = True
            self.status_text.set("Stopping scan...")
            self.current_operation.set("Scan stopped by user")
            self.update_progress(0, "Scan stopped")
            
        def recover_selected(self):
            selected_items = self.tree.selection()
            if not selected_items:
                messagebox.showwarning("No Selection", "Please select files to recover.")
                return
                
            # Ask for destination folder
            dest_folder = filedialog.askdirectory(title="Select Recovery Destination")
            if not dest_folder:
                return
                
            # Start recovery
            recovery_thread = threading.Thread(target=self.perform_recovery,
                                             args=(selected_items, dest_folder))
            recovery_thread.daemon = True
            recovery_thread.start()
            
        def perform_recovery(self, selected_items, dest_folder):
            try:
                total_files = len(selected_items)
                recovered = 0
                failed = 0
                
                for i, item in enumerate(selected_items):
                    file_name = self.tree.item(item)['text']
                    progress = int((i / total_files) * 100)
                    self.update_progress(progress, f"Recovering {file_name}...")
                    
                    # Find the file info
                    file_info = None
                    for f in self.recoverable_files:
                        if f['name'] == file_name:
                            file_info = f
                            break
                            
                    if file_info and 'full_path' in file_info:
                        try:
                            # Perform actual recovery
                            dest_path = os.path.join(dest_folder, file_name)
                            if os.path.exists(file_info['full_path']):
                                shutil.copy2(file_info['full_path'], dest_path)
                                recovered += 1
                            else:
                                failed += 1
                        except Exception as e:
                            print(f"Failed to recover {file_name}: {e}")
                            failed += 1
                    else:
                        failed += 1
                    
                self.update_progress(100, "Recovery completed")
                
                if recovered > 0:
                    messagebox.showinfo("Recovery Complete", 
                                      f"Successfully recovered {recovered} files to {dest_folder}\n"
                                      f"Failed to recover: {failed} files")
                else:
                    messagebox.showwarning("Recovery Failed", 
                                         "No files could be recovered. They may have been permanently deleted.")
                
            except Exception as e:
                messagebox.showerror("Recovery Error", f"An error occurred during recovery: {str(e)}")
                
        def preview_file(self):
            selected_item = self.tree.selection()
            if not selected_item:
                messagebox.showwarning("No Selection", "Please select a file to preview.")
                return
                
            file_name = self.tree.item(selected_item[0])['text']
            
            # Find the file info
            file_info = None
            for f in self.recoverable_files:
                if f['name'] == file_name:
                    file_info = f
                    break
                    
            if file_info and 'full_path' in file_info:
                self.show_preview_window(file_name, file_info['full_path'])
            else:
                messagebox.showwarning("Preview Error", "Cannot preview this file.")
            
        def show_preview_window(self, file_name, file_path):
            preview_window = tk.Toplevel(self.rootrecovv)
            preview_window.title(f"Preview: {file_name}")
            preview_window.geometry("500x400")
            preview_window.configure(bg='#c0c0c0')
            
            # Preview content
            text_area = tk.Text(preview_window, bg='white', font=self.default_font, wrap='word')
            scrollbar = tk.Scrollbar(preview_window, orient='vertical', command=text_area.yview)
            text_area.configure(yscrollcommand=scrollbar.set)
            
            text_area.pack(side='left', fill='both', expand=True, padx=10, pady=10)
            scrollbar.pack(side='right', fill='y', pady=10)
            
            try:
                if os.path.exists(file_path):
                    file_size = os.path.getsize(file_path)
                    if file_size < 1024 * 1024:  # Less than 1MB
                        try:
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                text_area.insert('1.0', content)
                        except:
                            text_area.insert('1.0', f"File: {file_name}\nPath: {file_path}\n\n")
                            text_area.insert('end', "Binary file or unsupported format.\nUse external application to view.")
                    else:
                        text_area.insert('1.0', f"File: {file_name}\nPath: {file_path}\nSize: {file_size} bytes\n\n")
                        text_area.insert('end', "File too large to preview.")
                else:
                    text_area.insert('1.0', f"File: {file_name}\nPath: {file_path}\n\n")
                    text_area.insert('end', "File no longer exists at this location.")
            except Exception as e:
                text_area.insert('1.0', f"Error previewing file: {str(e)}")
                
            text_area.config(state='disabled')
            
        def show_settings(self):
            settings_window = tk.Toplevel(self.rootrecovv)
            settings_window.title("Settings")
            settings_window.geometry("400x300")
            settings_window.configure(bg='#c0c0c0')
            settings_window.resizable(False, False)
            
            tk.Label(settings_window, text="RetroRecover Pro Settings", 
                    font=self.title_font, bg='#c0c0c0').pack(pady=10)
            
            # Recovery settings
            frame1 = tk.LabelFrame(settings_window, text="Recovery Options", 
                                  font=self.bold_font, bg='#c0c0c0')
            frame1.pack(fill='x', padx=10, pady=5)
            
            self.create_log = tk.BooleanVar(value=True)
            self.verify_files = tk.BooleanVar(value=True)
            
            tk.Checkbutton(frame1, text="Create recovery log", variable=self.create_log,
                          font=self.default_font, bg='#c0c0c0').pack(anchor='w', padx=5)
            tk.Checkbutton(frame1, text="Verify recovered files", variable=self.verify_files,
                          font=self.default_font, bg='#c0c0c0').pack(anchor='w', padx=5)
            
            # Scan settings
            frame2 = tk.LabelFrame(settings_window, text="Scan Settings", 
                                  font=self.bold_font, bg='#c0c0c0')
            frame2.pack(fill='x', padx=10, pady=5)
            
            tk.Label(frame2, text="Max file age (days):", font=self.default_font, bg='#c0c0c0').pack(anchor='w', padx=5)
            self.max_age_var = tk.StringVar(value="30")
            tk.Entry(frame2, textvariable=self.max_age_var, width=10).pack(anchor='w', padx=5, pady=2)
            
            # Buttons
            btn_frame = tk.Frame(settings_window, bg='#c0c0c0')
            btn_frame.pack(pady=20)
            
            tk.Button(btn_frame, text="OK", font=self.default_font, 
                     relief='raised', bd=2, padx=20, command=settings_window.destroy).pack(side='left', padx=5)
            tk.Button(btn_frame, text="Cancel", font=self.default_font, 
                     relief='raised', bd=2, padx=20, command=settings_window.destroy).pack(side='left', padx=5)
        
        def clear_results(self):
            """Clear all current results"""
            for item in self.tree.get_children():
                self.tree.delete(item)
                
            self.recoverable_files.clear()
            self.files_found.set(0)
            self.files_label.config(text="Files found: 0")
            self.status_text.set("Results cleared")
            self.current_operation.set("")
            self.update_progress(0, "Ready")
        
        def show_about(self):
            about_window = tk.Toplevel(self.rootrecovv)
            about_window.title("About RetroRecover Pro")
            about_window.geometry("450x350")
            about_window.configure(bg='#c0c0c0')
            about_window.resizable(False, False)
            
            tk.Label(about_window, text="RetroRecover Pro", 
                    font=tkFont.Font(family="MS Sans Serif", size=14, weight="bold"), 
                    bg='#c0c0c0').pack(pady=20)
            
            tk.Label(about_window, text="Version 1.0 - Real Recovery", 
                    font=self.default_font, bg='#c0c0c0').pack()
            
            tk.Label(about_window, text="Advanced Real File Recovery Tool", 
                    font=self.default_font, bg='#c0c0c0').pack(pady=5)
            
            info_text = """
    This software helps you recover real deleted files from:
    • Recycle Bin (including hidden files)
    • Temporary file locations
    • Recent document lists
    • Browser cache files
    • System restore points

    Features:
    • Multiple recovery sources
    • File preview capabilities
    • Batch recovery operations

    CAUTION: This tool accesses real system files and folders.
    Use responsibly and ensure you have proper permissions.

    Copyright © 2024 Tudor Marmureanu
            """
            
            text_widget = tk.Text(about_window, bg='white', font=self.default_font, 
                                 wrap='word', height=12, width=50)
            text_widget.pack(padx=20, pady=10)
            text_widget.insert('1.0', info_text)
            text_widget.config(state='disabled')
            
            tk.Button(about_window, text="OK", font=self.default_font, 
                     relief='raised', bd=2, padx=20, 
                     command=about_window.destroy).pack(pady=10)
            
        def open_log(self):
            log_file = "recovery_log.txt"
            if os.path.exists(log_file):
                try:
                    os.startfile(log_file)
                except:
                    messagebox.showinfo("Recovery Log", f"Log file location: {os.path.abspath(log_file)}")
            else:
                messagebox.showinfo("Recovery Log", "No recovery logs found.")
            
        def run(self):
            self.rootrecovv.mainloop()


    class RealFileRecoveryEngine:
        """Real file recovery engine that actually scans system locations"""
        
        def __init__(self):
            self.stopped = False
            self.file_extensions = {
                'Documents': ['.txt', '.doc', '.docx', '.pdf', '.rtf', '.odt'],
                'Images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.ico'],
                'Videos': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm'],
                'Audio': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma'],
                'Archives': ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2']
            }
            
        def scan_recycle_bin(self, callback):
            """Scan Windows Recycle Bin for deleted files"""
            self.stopped = False
            found_files = []
            
            try:
                # Get all drives
                drives = [f"{chr(i)}:\\" for i in range(65, 91) if os.path.exists(f"{chr(i)}:\\")]
                
                total_drives = len(drives)
                
                for i, drive in enumerate(drives):
                    if self.stopped:
                        break
                        
                    progress = int((i / total_drives) * 100)
                    callback(progress, f"Scanning drive {drive}...")
                    
                    # Check for Recycle Bin folders
                    recycle_paths = [
                        os.path.join(drive, '$Recycle.Bin'),
                        os.path.join(drive, 'RECYCLER'),
                        os.path.join(drive, 'Recycled')
                    ]
                    
                    for recycle_path in recycle_paths:
                        if self.stopped:
                            break
                            
                        if os.path.exists(recycle_path):
                            self._scan_directory_recursive(recycle_path, callback, found_files, "Recycle Bin")
                            
            except Exception as e:
                print(f"Error scanning recycle bin: {e}")
                
            callback(100, "Recycle bin scan completed")
            
        def scan_temp_files(self, callback):
            """Scan temporary file locations"""
            self.stopped = False
            found_files = []
            
            try:
                temp_paths = [
                    tempfile.gettempdir(),
                    os.environ.get('TEMP', ''),
                    os.environ.get('TMP', ''),
                    os.path.join(os.environ.get('USERPROFILE', ''), 'AppData', 'Local', 'Temp'),
                    r'C:\Windows\Temp'
                ]
                
                # Remove duplicates and empty paths
                temp_paths = list(set([path for path in temp_paths if path and os.path.exists(path)]))
                total_paths = len(temp_paths)
                
                for i, temp_path in enumerate(temp_paths):
                    if self.stopped:
                        break
                        
                    progress = int((i / total_paths) * 100)
                    callback(progress, f"Scanning {temp_path}...")
                    
                    self._scan_directory_recursive(temp_path, callback, found_files, "Temp Files")
                    
            except Exception as e:
                print(f"Error scanning temp files: {e}")
                
            callback(100, "Temp files scan completed")
            
        def scan_recent_files(self, callback):
            """Scan recent files from various sources"""
            self.stopped = False
            found_files = []
            
            try:
                user_profile = os.environ.get('USERPROFILE', '')
                
                # Recent document paths
                recent_paths = [
                    os.path.join(user_profile, 'Recent'),
                    os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Recent'),
                    os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Office', 'Recent'),
                ]
                
                total_paths = len(recent_paths) + 1  # +1 for registry scan
                current_path = 0
                
                for recent_path in recent_paths:
                    if self.stopped:
                        break
                        
                    progress = int((current_path / total_paths) * 100)
                    callback(progress, f"Scanning recent files...")
                    
                    if os.path.exists(recent_path):
                        self._scan_directory_recursive(recent_path, callback, found_files, "Recent Files")
                        
                    current_path += 1
                    
                # Scan registry for recent files
                if not self.stopped:
                    progress = int((current_path / total_paths) * 100)
                    self._scan_registry_recent_files(callback, found_files)
                    
            except Exception as e:
                print(f"Error scanning recent files: {e}")
                
            callback(100, "Recent files scan completed")
        
        def scan_browser_cache(self, callback):
            """Scan browser cache directories"""
            self.stopped = False
            found_files = []
            
            try:
                user_profile = os.environ.get('USERPROFILE', '')
                cache_paths = [
                    # Chrome
                    os.path.join(user_profile, 'AppData', 'Local', 'Google', 'Chrome', 'User Data', 'Default', 'Cache'),
                    # Firefox
                    os.path.join(user_profile, 'AppData', 'Local', 'Mozilla', 'Firefox', 'Profiles'),
                    # Edge
                    os.path.join(user_profile, 'AppData', 'Local', 'Microsoft', 'Edge', 'User Data', 'Default', 'Cache'),
                    # Internet Explorer
                    os.path.join(user_profile, 'AppData', 'Local', 'Microsoft', 'Windows', 'INetCache'),
                ]
                
                total_paths = len(cache_paths)
                
                for i, cache_path in enumerate(cache_paths):
                    if self.stopped:
                        break
                        
                    progress = int((i / total_paths) * 100)
                    callback(progress, f"Scanning browser cache...")
                    
                    if os.path.exists(cache_path):
                        self._scan_directory_recursive(cache_path, callback, found_files, "Browser Cache")
                        
            except Exception as e:
                print(f"Error scanning browser cache: {e}")
                
            callback(100, "Browser cache scan completed")
            
        def _scan_directory_recursive(self, directory, callback, found_files, source):
            """Recursively scan directory for recoverable files"""
            try:
                total_files = 0
                processed_files = 0
                
                # First pass: count files for progress calculation
                try:
                    for rootrecovv, dirs, files in os.walk(directory):
                        total_files += len(files)
                        # Limit depth to avoid counting too many files
                        if len(rootrecovv.split(os.sep)) - len(directory.split(os.sep)) > 3:
                            dirs.clear()
                except:
                    total_files = 100  # Fallback estimate
                
                # Second pass: process files
                for rootrecovv, dirs, files in os.walk(directory):
                    if self.stopped:
                        break
                        
                    for file_name in files:
                        if self.stopped:
                            break
                            
                        processed_files += 1
                        progress = min(99, int((processed_files / max(total_files, 1)) * 100))
                        callback(progress, f"Scanning: {file_name[:30]}...")
                        
                        file_path = os.path.join(rootrecovv, file_name)
                        
                        try:
                            if os.path.exists(file_path) and os.path.isfile(file_path):
                                file_info = self._get_file_info(file_path, source)
                                if file_info:
                                    found_files.append(file_info)
                                    callback(progress, f"Found: {file_name}", file_info)
                                    
                        except (OSError, PermissionError):
                            continue
                            
                    # Limit depth to avoid infinite loops
                    if len(rootrecovv.split(os.sep)) - len(directory.split(os.sep)) > 3:
                        dirs.clear()
                        
            except (OSError, PermissionError):
                pass
                
        def _get_file_info(self, file_path, source):
            """Get detailed information about a file"""
            try:
                stat_info = os.stat(file_path)
                file_size = stat_info.st_size
                
                # Skip very small files (likely not user data)
                if file_size < 100:
                    return None
                    
                # Skip system files
                file_name = os.path.basename(file_path)
                if file_name.startswith('.') or file_name.startswith('~'):
                    return None
                    
                file_ext = os.path.splitext(file_name)[1].lower()
                file_type = self._get_file_type(file_ext)
                
                # Format file size
                size_str = self._format_file_size(file_size)
                
                # Format date
                mod_time = datetime.fromtimestamp(stat_info.st_mtime)
                date_str = mod_time.strftime("%Y-%m-%d %H:%M")
                
                # Determine recoverability status
                status = "Recoverable"
                if not os.access(file_path, os.R_OK):
                    status = "Access Denied"
                elif file_size == 0:
                    status = "Empty File"
                    
                return {
                    'name': file_name,
                    'size': size_str,
                    'type': file_type,
                    'location': source,
                    'date': date_str,
                    'status': status,
                    'full_path': file_path,
                    'file_size': file_size
                }
                
            except (OSError, PermissionError):
                return None
                
        def _get_file_type(self, extension):
            """Determine file type from extension"""
            for file_type, extensions in self.file_extensions.items():
                if extension in extensions:
                    return file_type
            return "Other"
            
        def _format_file_size(self, size_bytes):
            """Format file size in human readable format"""
            if size_bytes == 0:
                return "0 B"
            size_names = ["B", "KB", "MB", "GB"]
            i = 0
            while size_bytes >= 1024 and i < len(size_names) - 1:
                size_bytes /= 1024.0
                i += 1
            return f"{size_bytes:.1f} {size_names[i]}"
            
        def _scan_registry_recent_files(self, callback, found_files):
            """Scan Windows registry for recent file entries"""
            try:
                # Recent docs registry key
                reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 
                                       r"Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs")
                
                callback(50, "Scanning registry recent files...")
                
                i = 0
                while True:
                    try:
                        value_name, value_data, value_type = winreg.EnumValue(reg_key, i)
                        
                        # Try to extract file path from registry data
                        if isinstance(value_data, bytes) and len(value_data) > 0:
                            # Decode as UTF-16 and clean up
                            try:
                                path_str = value_data.decode('utf-16le', errors='ignore').strip('\x00')
                                if path_str and os.path.exists(path_str):
                                    file_info = self._get_file_info(path_str, "Registry Recent")
                                    if file_info:
                                        found_files.append(file_info)
                                        callback(50, f"Found registry entry: {os.path.basename(path_str)}", file_info)
                            except:
                                pass
                                
                        i += 1
                    except WindowsError:
                        break
                        
                winreg.CloseKey(reg_key)
                
            except Exception as e:
                print(f"Error scanning registry: {e}")


    if __name__ == "__main__":
        # Create and run the application
        app = RetroRecoverApp()
        app.run()
        
if fishervar == 777666091:
    import time
    import struct
    from pathlib import Path
    import hashlib
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class RetroFileRecovery:
        def __init__(self, rootfish):
            self.rootfish = rootfish
            self.rootfish.title("File Fisher")
            self.rootfish.geometry("640x480")
            self.rootfish.configure(bg='#c0c0c0')
            #self.rootfish.resizable(False, False)
            
            # Windows 95 style configuration
            self.setup_styles()
            
            # Variables
            self.scanning = False
            self.recovered_files = []
            self.scan_progress = 0
            
            self.create_widgets()
            
        def setup_styles(self):
            """Configure Windows 95 style colors and fonts"""
            self.bg_color = '#c0c0c0'
            self.button_bg = '#c0c0c0'
            self.button_fg = '#000000'
            self.text_bg = '#ffffff'
            self.font_main = ('MS Sans Serif', 8)
            self.font_title = ('MS Sans Serif', 8, 'bold')
            
        def create_widgets(self):
            """Create the main interface"""
            # Title bar effect
            title_frame = tk.Frame(self.rootfish, bg='#000080', height=25)
            title_frame.pack(fill='x')
            title_frame.pack_propagate(False)
            
            title_label = tk.Label(title_frame, text="File Fisher", 
                                  bg='#000080', fg='white', font=self.font_title)
            title_label.pack(side='left', padx=5, pady=2)
            
            # Main container
            main_frame = tk.Frame(self.rootfish, bg=self.bg_color, relief='raised', bd=2)
            main_frame.pack(fill='both', expand=True, padx=2, pady=2)
            
            # Top section - Drive selection
            drive_frame = tk.LabelFrame(main_frame, text="Select Drive to Scan", 
                                       bg=self.bg_color, font=self.font_main, relief='groove', bd=2)
            drive_frame.pack(fill='x', padx=10, pady=5)
            
            self.drive_var = tk.StringVar()
            self.drive_combo = ttk.Combobox(drive_frame, textvariable=self.drive_var, 
                                           state='readonly', width=20)
            self.drive_combo.pack(side='left', padx=5, pady=5)
            
            refresh_btn = tk.Button(drive_frame, text="Refresh", command=self.refresh_drives,
                                   bg=self.button_bg, font=self.font_main, relief='raised', bd=2)
            refresh_btn.pack(side='left', padx=5)
            
            # Scan options
            options_frame = tk.LabelFrame(main_frame, text="Scan Options", 
                                         bg=self.bg_color, font=self.font_main, relief='groove', bd=2)
            options_frame.pack(fill='x', padx=10, pady=5)
            
            self.deep_scan_var = tk.BooleanVar()
            deep_check = tk.Checkbutton(options_frame, text="Deep Scan (slower but more thorough)",
                                       variable=self.deep_scan_var, bg=self.bg_color, font=self.font_main)
            deep_check.pack(anchor='w', padx=5, pady=2)
            
            self.file_types_var = tk.StringVar(value="All Files")
            file_type_frame = tk.Frame(options_frame, bg=self.bg_color)
            file_type_frame.pack(fill='x', padx=5, pady=2)
            
            tk.Label(file_type_frame, text="File Types:", bg=self.bg_color, font=self.font_main).pack(side='left')
            file_type_combo = ttk.Combobox(file_type_frame, textvariable=self.file_types_var,
                                          values=["All Files", "Images (jpg,png,gif)", "Documents (doc,pdf,txt)", 
                                                 "Videos (mp4,avi,mov)", "Audio (mp3,wav,flac)"], width=25)
            file_type_combo.pack(side='left', padx=5)
            
            # Control buttons
            control_frame = tk.Frame(main_frame, bg=self.bg_color)
            control_frame.pack(fill='x', padx=10, pady=5)
            
            self.scan_btn = tk.Button(control_frame, text="Start Scan", command=self.start_scan,
                                     bg='#008000', fg='white', font=self.font_main, 
                                     relief='raised', bd=2, width=12)
            self.scan_btn.pack(side='left', padx=5)
            
            self.stop_btn = tk.Button(control_frame, text="Stop Scan", command=self.stop_scan,
                                     bg='#800000', fg='white', font=self.font_main, 
                                     relief='raised', bd=2, width=12, state='disabled')
            self.stop_btn.pack(side='left', padx=5)
            
            self.recover_btn = tk.Button(control_frame, text="Extract Selected", command=self.recover_files,
                                        bg='#000080', fg='white', font=self.font_main, 
                                        relief='raised', bd=2, width=15, state='disabled')
            self.recover_btn.pack(side='right', padx=5)
            
            # Progress section
            progress_frame = tk.LabelFrame(main_frame, text="Scan Progress", 
                                          bg=self.bg_color, font=self.font_main, relief='groove', bd=2)
            progress_frame.pack(fill='x', padx=10, pady=5)
            
            self.progress_var = tk.StringVar(value="Ready to scan...")
            progress_label = tk.Label(progress_frame, textvariable=self.progress_var,
                                     bg=self.bg_color, font=self.font_main)
            progress_label.pack(pady=5)
            
            self.progress_bar = ttk.Progressbar(progress_frame, mode='determinate')
            self.progress_bar.pack(fill='x', padx=10, pady=5)
            
            # Results section
            results_frame = tk.LabelFrame(main_frame, text="Found Files", 
                                         bg=self.bg_color, font=self.font_main, relief='groove', bd=2)
            results_frame.pack(fill='both', expand=True, padx=10, pady=5)
            
            # Treeview with scrollbars
            tree_frame = tk.Frame(results_frame, bg=self.bg_color)
            tree_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            self.tree = ttk.Treeview(tree_frame, columns=('Size', 'Type', 'Status'), show='tree headings')
            self.tree.heading('#0', text='File Name')
            self.tree.heading('Size', text='Size')
            self.tree.heading('Type', text='Type')
            self.tree.heading('Status', text='Status')
            
            self.tree.column('#0', width=200)
            self.tree.column('Size', width=80)
            self.tree.column('Type', width=80)
            self.tree.column('Status', width=100)
            
            # Scrollbars
            v_scrollbar = ttk.Scrollbar(tree_frame, orient='vertical', command=self.tree.yview)
            h_scrollbar = ttk.Scrollbar(tree_frame, orient='horizontal', command=self.tree.xview)
            self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            self.tree.pack(side='left', fill='both', expand=True)
            v_scrollbar.pack(side='right', fill='y')
            h_scrollbar.pack(side='bottom', fill='x')
            
            # Status bar
            status_frame = tk.Frame(self.rootfish, bg='#808080', relief='sunken', bd=1)
            status_frame.pack(fill='x', side='bottom')
            
            self.status_var = tk.StringVar(value="Ready")
            status_label = tk.Label(status_frame, textvariable=self.status_var,
                                   bg='#808080', fg='white', font=self.font_main, anchor='w')
            status_label.pack(fill='x', padx=5, pady=1)
            
            # Initialize
            self.refresh_drives()
            
        def refresh_drives(self):
            """Refresh available drives list"""
            drives = []
            # Get available drives (Windows)
            if os.name == 'nt':
                import string
                for letter in string.ascii_uppercase:
                    drive = f"{letter}:\\"
                    if os.path.exists(drive):
                        drives.append(drive)
            else:
                # Unix-like systems
                drives = ['/']
                
            self.drive_combo['values'] = drives
            if drives:
                self.drive_combo.set(drives[0])
                
        def start_scan(self):
            """Start the file recovery scan"""
            if not self.drive_var.get():
                messagebox.showwarning("Warning", "Please select a drive to scan!")
                return
                
            self.scanning = True
            self.scan_btn.config(state='disabled')
            self.stop_btn.config(state='normal')
            self.recover_btn.config(state='disabled')
            
            # Clear previous results
            for item in self.tree.get_children():
                self.tree.delete(item)
            self.recovered_files.clear()
            
            # Start scan in separate thread
            scan_thread = threading.Thread(target=self.perform_scan)
            scan_thread.daemon = True
            scan_thread.start()
            
        def stop_scan(self):
            """Stop the current scan"""
            self.scanning = False
            self.scan_btn.config(state='normal')
            self.stop_btn.config(state='disabled')
            if self.recovered_files:
                self.recover_btn.config(state='normal')
            self.progress_var.set("Scan stopped by user")
            self.status_var.set("Scan stopped")
            
        def perform_scan(self):
            """Perform the actual file scanning"""
            drive = self.drive_var.get()
            deep_scan = self.deep_scan_var.get()
            file_types = self.get_file_extensions()
            
            self.progress_var.set(f"Scanning {drive}...")
            self.status_var.set("Scanning...")
            
            total_files = 0
            scanned_files = 0
            
            try:
                # First pass - count files for progress
                if self.scanning:
                    for rootfish, dirs, files in os.walk(drive):
                        total_files += len(files)
                        if not self.scanning:
                            break
                            
                self.progress_bar.config(maximum=total_files)
                
                # Second pass - actual scanning
                for rootfish, dirs, files in os.walk(drive):
                    if not self.scanning:
                        break
                        
                    for file in files:
                        if not self.scanning:
                            break
                            
                        file_path = os.path.join(rootfish, file)
                        scanned_files += 1
                        
                        # Update progress
                        self.progress_bar.config(value=scanned_files)
                        self.progress_var.set(f"Scanning: {file} ({scanned_files}/{total_files})")
                        self.rootfish.update_idletasks()
                        
                        # Check if file matches criteria - MODIFIED: afișează tot
                        if self.is_file_match(file_path, file_types):
                            self.add_found_file(file_path)
                            
                        # Small delay to prevent UI freezing
                        time.sleep(0.001)
                        
            except Exception as e:
                messagebox.showerror("Error", f"Scan error: {str(e)}")
                
            # Scan completed
            if self.scanning:
                self.progress_var.set(f"Scan completed! Found {len(self.recovered_files)} files")
                self.status_var.set(f"Found {len(self.recovered_files)} files")
            
            self.scanning = False
            self.scan_btn.config(state='normal')
            self.stop_btn.config(state='disabled')
            if self.recovered_files:
                self.recover_btn.config(state='normal')
                
        def get_file_extensions(self):
            """Get file extensions based on selected type"""
            file_type = self.file_types_var.get()
            
            extensions = {
                "All Files": [],
                "Images (jpg,png,gif)": ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.ico'],
                "Documents (doc,pdf,txt)": ['.doc', '.docx', '.pdf', '.txt', '.rtf', '.odt', '.ods', '.odp', '.md', '.html', '.htm', '.xls', '.xlsx', '.csv', '.rtf', '.ppt', '.pptx', '.json', '.log'],
                "Videos (mp4,avi,mov)": ['.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv'],
                "Audio (mp3,wav,flac)": ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma']
            }
            
            return extensions.get(file_type, [])
            
        def is_file_match(self, file_path, file_types):
            """Check if file matches the selected criteria"""
            try:
                # Check file extension if specific type is selected
                if file_types:
                    _, ext = os.path.splitext(file_path.lower())
                    if ext not in file_types:
                        return False
                        
                # If "All Files" or file matches extension filter, include it
                return True
                        
            except Exception:
                return False
                
        def add_found_file(self, file_path):
            """Add a found file to the results"""
            try:
                file_name = os.path.basename(file_path)
                
                # Get file info
                if os.path.exists(file_path):
                    size = os.path.getsize(file_path)
                    status = "Existing"
                else:
                    size = 0
                    status = "Not Found"
                    
                size_str = self.format_size(size)
                _, ext = os.path.splitext(file_name)
                file_type = ext.upper()[1:] if ext else "Unknown"
                
                # Add to tree
                item = self.tree.insert('', 'end', text=file_name, 
                                       values=(size_str, file_type, status))
                
                # Store file info
                self.recovered_files.append({
                    'path': file_path,
                    'name': file_name,
                    'size': size,
                    'type': file_type,
                    'status': status,
                    'item': item
                })
                
            except Exception as e:
                print(f"Error adding file {file_path}: {e}")
                
        def format_size(self, size):
            """Format file size in human readable format"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024:
                    return f"{size:.1f} {unit}"
                size /= 1024
            return f"{size:.1f} TB"
            
        def recover_files(self):
            """Recover selected files"""
            selected_items = self.tree.selection()
            if not selected_items:
                messagebox.showwarning("Warning", "Please select files to fish!")
                return
                
            # Choose recovery location
            recovery_dir = filedialog.askdirectory(title="Select Fishing Location")
            if not recovery_dir:
                return
                
            # Start recovery
            self.status_var.set("Copying files...")
            recovered_count = 0
            
            for item in selected_items:
                try:
                    # Find file info
                    file_info = None
                    for f in self.recovered_files:
                        if f['item'] == item:
                            file_info = f
                            break
                            
                    if file_info:
                        success = self.copy_single_file(file_info, recovery_dir)
                        if success:
                            recovered_count += 1
                            # Update status in tree
                            self.tree.set(item, 'Status', 'Copied')
                            
                except Exception as e:
                    print(f"Copy error: {e}")
                    
            messagebox.showinfo("Copy Complete", 
                               f"Successfully copied {recovered_count} out of {len(selected_items)} files!")
            self.status_var.set(f"Copied {recovered_count} files")
            
        def copy_single_file(self, file_info, recovery_dir):
            """Copy a single file"""
            try:
                source_path = file_info['path']
                dest_path = os.path.join(recovery_dir, file_info['name'])
                
                # If source exists, copy it
                if os.path.exists(source_path):
                    import shutil
                    shutil.copy2(source_path, dest_path)
                    return True
                else:
                    # File doesn't exist - can't copy
                    return False
                    
            except Exception as e:
                print(f"Error copying {file_info['name']}: {e}")
                return False

    def main():
        rootfish = tk.Tk()
        app = RetroFileRecovery(rootfish)
        
        # Set Windows 95 style icon (if available)
        try:
            rootfish.iconbitmap('recovery.ico')  # You can add your own icon
        except:
            pass
            
        rootfish.mainloop()

    if __name__ == "__main__":
        main()
        
if muapdash == 777666092:
    import string

    class Windows95Dashboard:
        def __init__(self, rootDASH):
            self.rootDASH = rootDASH
            self.rootDASH.title("Multiapp Dashboard")
            self.rootDASH.geometry("800x650")
            self.rootDASH.configure(bg='#c0c0c0')
            #self.rootDASH.resizable(False, False)
            self.rootDASH.overrideredirect(True)
            self.create_title_bar()
            # Variabile pentru funcționalitatea de drag
            self.start_x = 0
            self.start_y = 0
            
            # Bind evenimente pentru drag pe întreaga fereastră
            self.rootDASH.bind('<Button-1>', self.start_drag)
            self.rootDASH.bind('<B1-Motion>', self.do_drag)
            
            # Windows 95 color scheme
            self.bg_color = '#c0c0c0'
            self.button_color = '#c0c0c0'
            self.text_color = '#000000'
            self.highlight_color = '#0000ff'
            
            # Configure style for ttk widgets
            self.style = ttk.Style()
            self.style.theme_use('clam')
            
            # Sample data
            #self.serial_number = "WIN95-" + ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            self.serial_number = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
            self.accounts = [
                {"username": "chatbot", "password": "aichatbot", "status": "Active"},
                {"username": "alert", "password": "monitor", "status": "Active"},
                {"username": "backupmanager", "password": "backupmngr", "status": "Active"},
                {"username": "calendar", "password": "calendar", "status": "Active"},
                {"username": "check", "password": "devices", "status": "Active"},
                {"username": "comparator", "password": "comparator", "status": "Active"},
                {"username": "contact", "password": "manager", "status": "Active"},
                {"username": "diagram", "password": "beta", "status": "Active"},
                {"username": "mindmap", "password": "diagram", "status": "Active"},
                {"username": "cryptoV2", "password": "security", "status": "Active"},
                {"username": "eventviewer", "password": "eventviewer", "status": "Active"},
                {"username": "excel", "password": "lite", "status": "Active"},
                {"username": "expense", "password": "tracker", "status": "Active"},
                {"username": "fetcher", "password": "repair", "status": "Active"},
                {"username": "history", "password": "files", "status": "Active"},
                {"username": "fisher", "password": "file", "status": "Active"},
                {"username": "hardware", "password": "lite", "status": "Active"},
                {"username": "it", "password": "copy", "status": "Active"},
                {"username": "junk", "password": "manager", "status": "Active"},
                {"username": "kbmanager", "password": "knowladgebase", "status": "Active"},
                {"username": "kbretro", "password": "kbretro", "status": "Active"},
                {"username": "launcher", "password": "launcher", "status": "Active"},
                {"username": "md", "password": "mdviewer", "status": "Active"},
                {"username": "multifile", "password": "editor", "status": "Active"},
                {"username": "bandmonitoring", "password": "networking", "status": "Active"},
                {"username": "notepad", "password": "notepad", "status": "Active"},
                {"username": "reader", "password": "office", "status": "Active"},
                {"username": "paint", "password": "paint", "status": "Active"},
                {"username": "passgen", "password": "passgen", "status": "Active"},
                {"username": "passgenV2", "password": "passgenV2", "status": "Active"},
                {"username": "password", "password": "manager", "status": "Active"},
                {"username": "pausemanager", "password": "pauze", "status": "Active"},
                {"username": "convertorpdf", "password": "toword", "status": "Active"},
                {"username": "pdftools", "password": "enjoyit", "status": "Active"},
                {"username": "pdfviewer", "password": "pdfviewer", "status": "Active"},
                {"username": "process", "password": "viewer", "status": "Active"},
                {"username": "ide", "password": "pycharm", "status": "Active"},
                {"username": "ide", "password": "vscode", "status": "Active"},
                {"username": "quizmaker", "password": "quizmaker", "status": "Active"},
                {"username": "quiz", "password": "test", "status": "Active"},
                {"username": "recovery", "password": "tunnel", "status": "Active"},
                {"username": "renamemanager", "password": "renamer", "status": "Active"},
                {"username": "safe", "password": "checker", "status": "Active"},
                {"username": "screenrec", "password": "screenrec", "status": "Active"},
                {"username": "script", "password": "agent", "status": "Active"},
                {"username": "shell", "password": "integrator", "status": "Active"},
                {"username": "sql", "password": "editor", "status": "Active"},
                {"username": "system", "password": "realtime", "status": "Active"},
                {"username": "taskmanager", "password": "terminator", "status": "Active"},
                {"username": "terminal", "password": "terminal", "status": "Active"},
                {"username": "textreplace", "password": "textfind", "status": "Active"},
                {"username": "traffic", "password": "network", "status": "Active"},
                {"username": "commander", "password": "total", "status": "Active"},
                {"username": "user", "password": "nopass", "status": "Active"},
                {"username": "whiteboard", "password": "presentation", "status": "Active"},
                {"username": "xml", "password": "editor", "status": "Active"},
                {"username": "zipmanager", "password": "zipmngr", "status": "Active"},
                {"username": "zippass", "password": "wordsmith", "status": "Active"}
            ]
            
            # Get system information
            self.system_info = self.get_system_info()
            self.network_info = self.get_network_info()
            
            # Auto-refresh settings
            self.auto_refresh_enabled = False
            self.refresh_interval = 5000  # 5 seconds
            self.refresh_timer = None
            
            self.create_widgets()
        
        def start_drag(self, event):
            """Inițiază procesul de drag"""
            self.start_x = event.x
            self.start_y = event.y
        
        def do_drag(self, event):
            """Execută mutarea ferestrei"""
            # Calculează noua poziție
            x = self.rootDASH.winfo_x() + event.x - self.start_x
            y = self.rootDASH.winfo_y() + event.y - self.start_y
            
            # Mută fereastra
            self.rootDASH.geometry(f"+{x}+{y}")
        
        def create_title_bar(self):
            """Create Windows 95 style title bar"""
            title_frame = tk.Frame(self.rootDASH, bg='#008080', height=25)
            title_frame.pack(fill='x', side='top')
            title_frame.pack_propagate(False)
            
            # Title text with logo
            title_label = tk.Label(title_frame, text="Multiapp 95 Professional Dashboard", bg='#008080', fg='white', font=('MS Sans Serif', 8, 'bold'))
            title_label.pack(side='left', padx=5, pady=2)
            
            # Window controls
            controls_frame = tk.Frame(title_frame, bg='#008080')
            controls_frame.pack(side='right', padx=2)
            
            for symbol in ['_', '□', '×']:
                if symbol == '_':
                    # Minimizare fereastră
                    #command = lambda: self.rootDASH.iconify()
                    #command = lambda: self.rootDASH.withdraw()
                    command = None
                elif symbol == '□':
                    # Maximizare/Restaurare fereastră - inline logic
                    command = lambda: self.rootDASH.state('normal') if self.rootDASH.state() == 'zoomed' else self.rootDASH.state('zoomed')
                elif symbol == '×':
                    # Închidere fereastră
                    command = self.rootDASH.quit
                else:
                    command = None
                
                btn = tk.Button(controls_frame, text=symbol, 
                               bg='#c0c0c0', fg='black',
                               font=('MS Sans Serif', 8, 'bold'),
                               width=3, height=1, bd=1,
                               relief='raised',
                               command=command)
                btn.pack(side='left', padx=1)
        
        def create_widgets(self):
            # Title bar simulation
            title_frame = tk.Frame(self.rootDASH, bg='#c0c0c0', height=25)
            title_frame.pack(fill='x', padx=2, pady=2)
            title_frame.pack_propagate(False)
            
            title_label = tk.Label(title_frame, text="", 
                                  bg='#c0c0c0', fg='white', font=('MS Sans Serif', 8, 'bold'))
            title_label.pack(side='left', padx=5, pady=2)
            
            # Main content frame with Windows 95 border effect
            main_frame = tk.Frame(self.rootDASH, bg=self.bg_color, relief='raised', bd=2)
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Serial Number Section
            serial_frame = tk.LabelFrame(main_frame, text="Serial Number", 
                                       bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                       relief='groove', bd=2)
            serial_frame.pack(fill='x', padx=10, pady=10)
            
            serial_display = tk.Frame(serial_frame, bg='white', relief='sunken', bd=2)
            serial_display.pack(fill='x', padx=10, pady=10)
            
            serial_label = tk.Label(serial_display, text=self.serial_number, 
                                   bg='white', fg=self.text_color, 
                                   font=('Courier New', 12, 'bold'), pady=5)
            serial_label.pack()
            
            # Buttons for serial number
            serial_btn_frame = tk.Frame(serial_frame, bg=self.bg_color)
            serial_btn_frame.pack(pady=5)
            
            #refresh_btn = tk.Button(serial_btn_frame, text="Refresh", command=self.refresh_serial, bg=self.button_color, relief='raised', bd=2, font=('MS Sans Serif', 8))
            #refresh_btn.pack(side='left', padx=5)
            
            copy_btn = tk.Button(serial_btn_frame, text="Copy", 
                                command=self.copy_serial, bg=self.button_color,
                                relief='raised', bd=2, font=('MS Sans Serif', 8))
            copy_btn.pack(side='left', padx=5)
            
            # Auto-refresh control section
            refresh_control_frame = tk.LabelFrame(main_frame, text="Auto Refresh Settings", 
                                                bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                                relief='groove', bd=2)
            refresh_control_frame.pack(fill='x', padx=10, pady=5)
            
            # Auto-refresh toggle
            self.auto_refresh_var = tk.BooleanVar()
            self.refresh_toggle = tk.Checkbutton(refresh_control_frame, 
                                               text="Enable Auto Refresh (Hardware & Network)",
                                               variable=self.auto_refresh_var,
                                               command=self.toggle_auto_refresh,
                                               bg=self.bg_color, 
                                               font=('MS Sans Serif', 8),
                                               relief='flat')
            self.refresh_toggle.pack(side='left', padx=10, pady=5)
            
            # Refresh interval setting
            interval_frame = tk.Frame(refresh_control_frame, bg=self.bg_color)
            interval_frame.pack(side='left', padx=20, pady=5)
            
            tk.Label(interval_frame, text="Interval:", bg=self.bg_color, 
                    font=('MS Sans Serif', 8)).pack(side='left')
            
            self.interval_var = tk.StringVar(value="5")
            interval_combo = ttk.Combobox(interval_frame, textvariable=self.interval_var, 
                                        values=["5", "10", "15", "30", "60"], 
                                        width=5, font=('MS Sans Serif', 8), state="readonly")
            interval_combo.pack(side='left', padx=5)
            interval_combo.bind("<<ComboboxSelected>>", self.update_refresh_interval)
            
            tk.Label(interval_frame, text="seconds", bg=self.bg_color, 
                    font=('MS Sans Serif', 8)).pack(side='left', padx=5)
            
            # Status indicator
            self.refresh_status_label = tk.Label(refresh_control_frame, 
                                               text="● Auto Refresh: OFF", 
                                               bg=self.bg_color, fg='red',
                                               font=('MS Sans Serif', 8, 'bold'))
            self.refresh_status_label.pack(side='right', padx=10, pady=5)
            
            # Create notebook for tabbed interface
            notebook = ttk.Notebook(main_frame)
            notebook.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Accounts Tab
            accounts_tab = tk.Frame(notebook, bg=self.bg_color)
            notebook.add(accounts_tab, text="User Accounts")
            
            # Hardware Tab
            hardware_tab = tk.Frame(notebook, bg=self.bg_color)
            notebook.add(hardware_tab, text="Hardware Info")
            
            # Network Tab
            network_tab = tk.Frame(notebook, bg=self.bg_color)
            notebook.add(network_tab, text="Network Info")
            
            # Create content for each tab
            self.create_accounts_tab(accounts_tab)
            self.create_hardware_tab(hardware_tab)
            self.create_network_tab(network_tab)
            
            # Status bar
            status_frame = tk.Frame(self.rootDASH, bg=self.bg_color, relief='sunken', bd=1)
            status_frame.pack(fill='x', side='bottom')
            
            self.status_label = tk.Label(status_frame, text=f"Ready - {len(self.accounts)} accounts loaded", 
                                       bg=self.bg_color, fg=self.text_color, 
                                       font=('MS Sans Serif', 8), anchor='w')
            self.status_label.pack(side='left', padx=5)
            
            time_label = tk.Label(status_frame, text="12:34 PM", 
                                 bg=self.bg_color, fg=self.text_color, 
                                 font=('MS Sans Serif', 8))
            time_label.pack(side='right', padx=5)
        
        def get_system_info(self):
            """Get hardware and system information"""
            try:
                info = {}
                
                # System info
                info['os'] = f"{platform.system()} {platform.release()}"
                info['processor'] = platform.processor() or "Unknown"
                info['architecture'] = platform.architecture()[0]
                info['machine'] = platform.machine()
                info['computer_name'] = platform.node()
                
                # Memory info
                memory = psutil.virtual_memory()
                info['total_ram'] = f"{memory.total // (1024**3)} GB"
                info['available_ram'] = f"{memory.available // (1024**3)} GB"
                info['ram_usage'] = f"{memory.percent}%"
                
                # CPU info
                info['cpu_cores'] = psutil.cpu_count(logical=False)
                info['cpu_threads'] = psutil.cpu_count(logical=True)
                info['cpu_usage'] = f"{psutil.cpu_percent(interval=1)}%"
                
                # Disk info
                disk = psutil.disk_usage('/')
                info['disk_total'] = f"{disk.total // (1024**3)} GB"
                info['disk_used'] = f"{disk.used // (1024**3)} GB"
                info['disk_free'] = f"{disk.free // (1024**3)} GB"
                info['disk_usage'] = f"{round(disk.used/disk.total*100, 1)}%"
                
                return info
            except Exception as e:
                return {"error": str(e)}
        
        def get_network_info(self):
            """Get network information"""
            try:
                info = {}
                
                # Get hostname and IP
                info['hostname'] = socket.gethostname()
                info['local_ip'] = socket.gethostbyname(socket.gethostname())
                
                # Network interfaces
                interfaces = psutil.net_if_addrs()
                info['interfaces'] = []
                
                for interface_name, interface_addresses in interfaces.items():
                    for address in interface_addresses:
                        if address.family == socket.AF_INET:
                            info['interfaces'].append({
                                'name': interface_name,
                                'ip': address.address,
                                'netmask': address.netmask
                            })
                
                # Network stats
                net_stats = psutil.net_io_counters()
                info['bytes_sent'] = f"{net_stats.bytes_sent // (1024**2)} MB"
                info['bytes_recv'] = f"{net_stats.bytes_recv // (1024**2)} MB"
                info['packets_sent'] = net_stats.packets_sent
                info['packets_recv'] = net_stats.packets_recv
                
                return info
            except Exception as e:
                return {"error": str(e)}
        
        def create_accounts_tab(self, parent):
            """Create the accounts tab content"""
            # Accounts list with Windows 95 style
            list_frame = tk.Frame(parent, bg='white', relief='sunken', bd=2)
            list_frame.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Headers
            header_frame = tk.Frame(list_frame, bg='#c0c0c0', relief='raised', bd=1)
            header_frame.pack(fill='x')
            
            tk.Label(header_frame, text="Username", bg='#c0c0c0', font=('MS Sans Serif', 8, 'bold'),
                    width=15, anchor='w', relief='raised', bd=1).pack(side='left', fill='y')
            tk.Label(header_frame, text="Password", bg='#c0c0c0', font=('MS Sans Serif', 8, 'bold'),
                    width=25, anchor='w', relief='raised', bd=1).pack(side='left', fill='y')
            tk.Label(header_frame, text="Status", bg='#c0c0c0', font=('MS Sans Serif', 8, 'bold'),
                    width=10, anchor='w', relief='raised', bd=1).pack(side='left', fill='y')
            
            # Scrollable accounts list
            self.accounts_listbox = tk.Listbox(list_frame, bg='white', fg=self.text_color,
                                             font=('Courier New', 8), relief='sunken', bd=0,
                                             selectbackground='#0000ff', selectforeground='white')
            self.accounts_listbox.pack(fill='both', expand=True)
            
            # Populate accounts
            self.populate_accounts()
            
            # Account management buttons
            btn_frame = tk.Frame(parent, bg=self.bg_color)
            btn_frame.pack(pady=5)
            
            #add_btn = tk.Button(btn_frame, text="Add Account", command=self.add_account, bg=self.button_color, relief='raised', bd=2, font=('MS Sans Serif', 8))
            #add_btn.pack(side='left', padx=5)
            
            #edit_btn = tk.Button(btn_frame, text="Edit Account", command=self.edit_account, bg=self.button_color, relief='raised', bd=2, font=('MS Sans Serif', 8))
            #edit_btn.pack(side='left', padx=5)
            
            #delete_btn = tk.Button(btn_frame, text="Delete Account", command=self.delete_account, bg=self.button_color, relief='raised', bd=2, font=('MS Sans Serif', 8))
            #delete_btn.pack(side='left', padx=5)
        
        def create_hardware_tab(self, parent):
            """Create the hardware information tab"""
            # Create scrollable frame
            canvas = tk.Canvas(parent, bg=self.bg_color)
            scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg=self.bg_color)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # System Information Group
            sys_frame = tk.LabelFrame(scrollable_frame, text="System Information", 
                                    bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                    relief='groove', bd=2)
            sys_frame.pack(fill='x', padx=10, pady=5)
            
            sys_info = [
                ("Operating System:", self.system_info.get('os', 'Unknown')),
                ("Computer Name:", self.system_info.get('computer_name', 'Unknown')),
                ("Processor:", self.system_info.get('processor', 'Unknown')),
                ("Architecture:", self.system_info.get('architecture', 'Unknown')),
                ("Machine Type:", self.system_info.get('machine', 'Unknown'))
            ]
            
            for i, (label, value) in enumerate(sys_info):
                tk.Label(sys_frame, text=label, bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                        anchor='w').grid(row=i, column=0, sticky='w', padx=10, pady=2)
                tk.Label(sys_frame, text=value, bg=self.bg_color, font=('MS Sans Serif', 8),
                        anchor='w', fg='#000080').grid(row=i, column=1, sticky='w', padx=10, pady=2)
            
            # Memory Information Group
            mem_frame = tk.LabelFrame(scrollable_frame, text="Memory Information", 
                                    bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                    relief='groove', bd=2)
            mem_frame.pack(fill='x', padx=10, pady=5)
            
            mem_info = [
                ("Total RAM:", self.system_info.get('total_ram', 'Unknown')),
                ("Available RAM:", self.system_info.get('available_ram', 'Unknown')),
                ("RAM Usage:", self.system_info.get('ram_usage', 'Unknown'))
            ]
            
            for i, (label, value) in enumerate(mem_info):
                tk.Label(mem_frame, text=label, bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                        anchor='w').grid(row=i, column=0, sticky='w', padx=10, pady=2)
                tk.Label(mem_frame, text=value, bg=self.bg_color, font=('MS Sans Serif', 8),
                        anchor='w', fg='#000080').grid(row=i, column=1, sticky='w', padx=10, pady=2)
            
            # CPU Information Group
            cpu_frame = tk.LabelFrame(scrollable_frame, text="Processor Information", 
                                    bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                    relief='groove', bd=2)
            cpu_frame.pack(fill='x', padx=10, pady=5)
            
            cpu_info = [
                ("CPU Cores:", str(self.system_info.get('cpu_cores', 'Unknown'))),
                ("CPU Threads:", str(self.system_info.get('cpu_threads', 'Unknown'))),
                ("CPU Usage:", self.system_info.get('cpu_usage', 'Unknown'))
            ]
            
            for i, (label, value) in enumerate(cpu_info):
                tk.Label(cpu_frame, text=label, bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                        anchor='w').grid(row=i, column=0, sticky='w', padx=10, pady=2)
                tk.Label(cpu_frame, text=value, bg=self.bg_color, font=('MS Sans Serif', 8),
                        anchor='w', fg='#000080').grid(row=i, column=1, sticky='w', padx=10, pady=2)
            
            # Disk Information Group
            disk_frame = tk.LabelFrame(scrollable_frame, text="Disk Information", 
                                     bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                     relief='groove', bd=2)
            disk_frame.pack(fill='x', padx=10, pady=5)
            
            disk_info = [
                ("Total Disk Space:", self.system_info.get('disk_total', 'Unknown')),
                ("Used Disk Space:", self.system_info.get('disk_used', 'Unknown')),
                ("Free Disk Space:", self.system_info.get('disk_free', 'Unknown')),
                ("Disk Usage:", self.system_info.get('disk_usage', 'Unknown'))
            ]
            
            for i, (label, value) in enumerate(disk_info):
                tk.Label(disk_frame, text=label, bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                        anchor='w').grid(row=i, column=0, sticky='w', padx=10, pady=2)
                tk.Label(disk_frame, text=value, bg=self.bg_color, font=('MS Sans Serif', 8),
                        anchor='w', fg='#000080').grid(row=i, column=1, sticky='w', padx=10, pady=2)
            
            # Refresh button
            refresh_hw_btn = tk.Button(scrollable_frame, text="Refresh Hardware Info", 
                                      command=self.refresh_hardware_info, bg=self.button_color,
                                      relief='raised', bd=2, font=('MS Sans Serif', 8))
            refresh_hw_btn.pack(pady=10)
            
            # Store reference to hardware tab elements for updates
            self.hardware_tab_frame = scrollable_frame
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
        
        def create_network_tab(self, parent):
            """Create the network information tab"""
            # Create scrollable frame
            canvas = tk.Canvas(parent, bg=self.bg_color)
            scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg=self.bg_color)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Basic Network Info
            basic_frame = tk.LabelFrame(scrollable_frame, text="Basic Network Information", 
                                      bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                      relief='groove', bd=2)
            basic_frame.pack(fill='x', padx=10, pady=5)
            
            basic_info = [
                ("Hostname:", self.network_info.get('hostname', 'Unknown')),
                ("Local IP:", self.network_info.get('local_ip', 'Unknown'))
            ]
            
            for i, (label, value) in enumerate(basic_info):
                tk.Label(basic_frame, text=label, bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                        anchor='w').grid(row=i, column=0, sticky='w', padx=10, pady=2)
                tk.Label(basic_frame, text=value, bg=self.bg_color, font=('MS Sans Serif', 8),
                        anchor='w', fg='#000080').grid(row=i, column=1, sticky='w', padx=10, pady=2)
            
            # Network Interfaces
            if 'interfaces' in self.network_info:
                interfaces_frame = tk.LabelFrame(scrollable_frame, text="Network Interfaces", 
                                               bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                               relief='groove', bd=2)
                interfaces_frame.pack(fill='x', padx=10, pady=5)
                
                # Headers
                tk.Label(interfaces_frame, text="Interface", bg='#c0c0c0', font=('MS Sans Serif', 8, 'bold'),
                        width=15, anchor='w', relief='raised', bd=1).grid(row=0, column=0, sticky='ew')
                tk.Label(interfaces_frame, text="IP Address", bg='#c0c0c0', font=('MS Sans Serif', 8, 'bold'),
                        width=15, anchor='w', relief='raised', bd=1).grid(row=0, column=1, sticky='ew')
                tk.Label(interfaces_frame, text="Netmask", bg='#c0c0c0', font=('MS Sans Serif', 8, 'bold'),
                        width=15, anchor='w', relief='raised', bd=1).grid(row=0, column=2, sticky='ew')
                
                for i, interface in enumerate(self.network_info['interfaces'], 1):
                    tk.Label(interfaces_frame, text=interface['name'], bg=self.bg_color, 
                            font=('MS Sans Serif', 8), anchor='w').grid(row=i, column=0, sticky='w', padx=5, pady=1)
                    tk.Label(interfaces_frame, text=interface['ip'], bg=self.bg_color, 
                            font=('MS Sans Serif', 8), anchor='w', fg='#000080').grid(row=i, column=1, sticky='w', padx=5, pady=1)
                    tk.Label(interfaces_frame, text=interface['netmask'], bg=self.bg_color, 
                            font=('MS Sans Serif', 8), anchor='w', fg='#000080').grid(row=i, column=2, sticky='w', padx=5, pady=1)
            
            # Network Statistics
            stats_frame = tk.LabelFrame(scrollable_frame, text="Network Statistics", 
                                      bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                                      relief='groove', bd=2)
            stats_frame.pack(fill='x', padx=10, pady=5)
            
            stats_info = [
                ("Bytes Sent:", self.network_info.get('bytes_sent', 'Unknown')),
                ("Bytes Received:", self.network_info.get('bytes_recv', 'Unknown')),
                ("Packets Sent:", str(self.network_info.get('packets_sent', 'Unknown'))),
                ("Packets Received:", str(self.network_info.get('packets_recv', 'Unknown')))
            ]
            
            for i, (label, value) in enumerate(stats_info):
                tk.Label(stats_frame, text=label, bg=self.bg_color, font=('MS Sans Serif', 8, 'bold'),
                        anchor='w').grid(row=i, column=0, sticky='w', padx=10, pady=2)
                tk.Label(stats_frame, text=value, bg=self.bg_color, font=('MS Sans Serif', 8),
                        anchor='w', fg='#000080').grid(row=i, column=1, sticky='w', padx=10, pady=2)
            
            # Refresh button
            refresh_net_btn = tk.Button(scrollable_frame, text="Refresh Network Info", 
                                       command=self.refresh_network_info, bg=self.button_color,
                                       relief='raised', bd=2, font=('MS Sans Serif', 8))
            refresh_net_btn.pack(pady=10)
            
            # Store reference to network tab elements for updates
            self.network_tab_frame = scrollable_frame
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
        
        def refresh_hardware_info(self):
            """Refresh hardware information"""
            self.system_info = self.get_system_info()
            self.update_hardware_display()
            self.update_status("Hardware information refreshed")
        
        def refresh_network_info(self):
            """Refresh network information"""
            self.network_info = self.get_network_info()
            self.update_network_display()
            self.update_status("Network information refreshed")
        
        def update_hardware_display(self):
            """Update hardware information display"""
            try:
                # Find and update hardware information labels
                for widget in self.hardware_tab_frame.winfo_children():
                    if isinstance(widget, tk.LabelFrame):
                        frame_text = widget.cget('text')
                        if "System Information" in frame_text:
                            self.update_info_frame(widget, [
                                ("Operating System:", self.system_info.get('os', 'Unknown')),
                                ("Computer Name:", self.system_info.get('computer_name', 'Unknown')),
                                ("Processor:", self.system_info.get('processor', 'Unknown')),
                                ("Architecture:", self.system_info.get('architecture', 'Unknown')),
                                ("Machine Type:", self.system_info.get('machine', 'Unknown'))
                            ])
                        elif "Memory Information" in frame_text:
                            self.update_info_frame(widget, [
                                ("Total RAM:", self.system_info.get('total_ram', 'Unknown')),
                                ("Available RAM:", self.system_info.get('available_ram', 'Unknown')),
                                ("RAM Usage:", self.system_info.get('ram_usage', 'Unknown'))
                            ])
                        elif "Processor Information" in frame_text:
                            self.update_info_frame(widget, [
                                ("CPU Cores:", str(self.system_info.get('cpu_cores', 'Unknown'))),
                                ("CPU Threads:", str(self.system_info.get('cpu_threads', 'Unknown'))),
                                ("CPU Usage:", self.system_info.get('cpu_usage', 'Unknown'))
                            ])
                        elif "Disk Information" in frame_text:
                            self.update_info_frame(widget, [
                                ("Total Disk Space:", self.system_info.get('disk_total', 'Unknown')),
                                ("Used Disk Space:", self.system_info.get('disk_used', 'Unknown')),
                                ("Free Disk Space:", self.system_info.get('disk_free', 'Unknown')),
                                ("Disk Usage:", self.system_info.get('disk_usage', 'Unknown'))
                            ])
            except Exception as e:
                print(f"Error updating hardware display: {e}")
        
        def update_network_display(self):
            """Update network information display"""
            try:
                # Find and update network information labels
                for widget in self.network_tab_frame.winfo_children():
                    if isinstance(widget, tk.LabelFrame):
                        frame_text = widget.cget('text')
                        if "Basic Network Information" in frame_text:
                            self.update_info_frame(widget, [
                                ("Hostname:", self.network_info.get('hostname', 'Unknown')),
                                ("Local IP:", self.network_info.get('local_ip', 'Unknown'))
                            ])
                        elif "Network Statistics" in frame_text:
                            self.update_info_frame(widget, [
                                ("Bytes Sent:", self.network_info.get('bytes_sent', 'Unknown')),
                                ("Bytes Received:", self.network_info.get('bytes_recv', 'Unknown')),
                                ("Packets Sent:", str(self.network_info.get('packets_sent', 'Unknown'))),
                                ("Packets Received:", str(self.network_info.get('packets_recv', 'Unknown')))
                            ])
            except Exception as e:
                print(f"Error updating network display: {e}")
        
        def update_info_frame(self, frame, info_list):
            """Update information in a label frame"""
            try:
                # Find value labels (second column) and update them
                labels = [child for child in frame.winfo_children() if isinstance(child, tk.Label)]
                value_labels = [label for i, label in enumerate(labels) if i % 2 == 1]  # Every second label is a value
                
                for i, (_, new_value) in enumerate(info_list):
                    if i < len(value_labels):
                        value_labels[i].config(text=new_value)
            except Exception as e:
                print(f"Error updating info frame: {e}")
        
        def toggle_auto_refresh(self):
            """Toggle auto refresh on/off"""
            self.auto_refresh_enabled = self.auto_refresh_var.get()
            
            if self.auto_refresh_enabled:
                self.start_auto_refresh()
                self.refresh_status_label.config(text="● Auto Refresh: ON", fg='green')
                self.update_status("Auto refresh enabled")
            else:
                self.stop_auto_refresh()
                self.refresh_status_label.config(text="● Auto Refresh: OFF", fg='red')
                self.update_status("Auto refresh disabled")
        
        def update_refresh_interval(self, event=None):
            """Update the refresh interval"""
            try:
                new_interval = int(self.interval_var.get()) * 1000  # Convert to milliseconds
                self.refresh_interval = new_interval
                
                # Restart timer if auto refresh is enabled
                if self.auto_refresh_enabled:
                    self.stop_auto_refresh()
                    self.start_auto_refresh()
                
                self.update_status(f"Refresh interval set to {self.interval_var.get()} seconds")
            except ValueError:
                pass
        
        def start_auto_refresh(self):
            """Start the auto refresh timer"""
            if self.refresh_timer:
                self.rootDASH.after_cancel(self.refresh_timer)
            
            self.auto_refresh_cycle()
        
        def stop_auto_refresh(self):
            """Stop the auto refresh timer"""
            if self.refresh_timer:
                self.rootDASH.after_cancel(self.refresh_timer)
                self.refresh_timer = None
        
        def auto_refresh_cycle(self):
            """Auto refresh cycle - updates hardware and network info"""
            if self.auto_refresh_enabled:
                # Update system info
                self.system_info = self.get_system_info()
                self.network_info = self.get_network_info()
                
                # Update displays
                self.update_hardware_display()
                self.update_network_display()
                
                # Update status with timestamp
                import datetime
                timestamp = datetime.datetime.now().strftime("%H:%M:%S")
                self.update_status(f"Auto refresh completed at {timestamp}")
                
                # Schedule next refresh
                self.refresh_timer = self.rootDASH.after(self.refresh_interval, self.auto_refresh_cycle)
        
        def populate_accounts(self):
            self.accounts_listbox.delete(0, tk.END)
            for account in self.accounts:
                status_indicator = "●" if account["status"] == "Active" else "○"
                # Format each field to match the header widths exactly
                username_part = f"{account['username']:<15}"
                password_part = f"{account['password']:<25}" 
                status_part = f"{status_indicator} {account['status']:<10}"
                line = f"{username_part}{password_part}{status_part}"
                self.accounts_listbox.insert(tk.END, line)
        
        def refresh_serial(self):
            #self.serial_number = "R46BX-JHR2J-PG7ER-24QFG-MWKVR" + ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            self.serial_number = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
            # Update the serial display
            for widget in self.rootDASH.winfo_children():
                if isinstance(widget, tk.Frame):
                    for child in widget.winfo_children():
                        if isinstance(child, tk.LabelFrame) and "Serial Number" in str(child.cget('text')):
                            for grandchild in child.winfo_children():
                                if isinstance(grandchild, tk.Frame) and str(grandchild.cget('bg')) == 'white':
                                    for label in grandchild.winfo_children():
                                        if isinstance(label, tk.Label):
                                            label.config(text=self.serial_number)
            self.update_status("Serial number refreshed")
        
        def copy_serial(self):
            self.rootDASH.clipboard_clear()
            self.rootDASH.clipboard_append(self.serial_number)
            self.update_status("Serial number copied to clipboard")
            messagebox.showinfo("Copied", "Serial number copied to clipboard!")
        
        def add_account(self):
            self.account_dialog("Add Account")
        
        def edit_account(self):
            selection = self.accounts_listbox.curselection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select an account to edit.")
                return
            
            index = selection[0]
            self.account_dialog("Edit Account", self.accounts[index], index)
        
        def delete_account(self):
            selection = self.accounts_listbox.curselection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select an account to delete.")
                return
            
            if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this account?"):
                index = selection[0]
                deleted_account = self.accounts.pop(index)
                self.populate_accounts()
                self.update_status(f"Account '{deleted_account['username']}' deleted")
        
        def account_dialog(self, title, account=None, index=None):
            dialog = tk.Toplevel(self.rootDASH)
            dialog.title(title)
            dialog.geometry("350x200")
            dialog.configure(bg=self.bg_color)
            dialog.resizable(False, False)
            dialog.grab_set()
            
            # Center the dialog
            dialog.transient(self.rootDASH)
            
            # Form fields
            tk.Label(dialog, text="Username:", bg=self.bg_color, font=('MS Sans Serif', 8)).grid(row=0, column=0, sticky='w', padx=10, pady=5)
            username_entry = tk.Entry(dialog, font=('MS Sans Serif', 8), relief='sunken', bd=2)
            username_entry.grid(row=0, column=1, padx=10, pady=5, sticky='ew')
            
            tk.Label(dialog, text="Email:", bg=self.bg_color, font=('MS Sans Serif', 8)).grid(row=1, column=0, sticky='w', padx=10, pady=5)
            email_entry = tk.Entry(dialog, font=('MS Sans Serif', 8), relief='sunken', bd=2)
            email_entry.grid(row=1, column=1, padx=10, pady=5, sticky='ew')
            
            tk.Label(dialog, text="Status:", bg=self.bg_color, font=('MS Sans Serif', 8)).grid(row=2, column=0, sticky='w', padx=10, pady=5)
            status_var = tk.StringVar(value="Active")
            status_combo = ttk.Combobox(dialog, textvariable=status_var, values=["Active", "Inactive"], 
                                       font=('MS Sans Serif', 8), state="readonly")
            status_combo.grid(row=2, column=1, padx=10, pady=5, sticky='ew')
            
            # Pre-fill if editing
            if account:
                username_entry.insert(0, account['username'])
                email_entry.insert(0, account['password'])
                status_var.set(account['status'])
            
            dialog.grid_columnconfigure(1, weight=1)
            
            # Buttons
            btn_frame = tk.Frame(dialog, bg=self.bg_color)
            btn_frame.grid(row=3, column=0, columnspan=2, pady=20)
            
            def save_account():
                username = username_entry.get().strip()
                email = email_entry.get().strip()
                status = status_var.get()
                
                if not username or not email:
                    messagebox.showerror("Error", "Please fill all fields.")
                    return
                
                new_account = {"username": username, "password": password, "status": status}
                
                if index is not None:  # Editing
                    self.accounts[index] = new_account
                    self.update_status(f"Account '{username}' updated")
                else:  # Adding
                    self.accounts.append(new_account)
                    self.update_status(f"Account '{username}' added")
                
                self.populate_accounts()
                dialog.destroy()
            
            save_btn = tk.Button(btn_frame, text="Save", command=save_account, 
                                bg=self.button_color, relief='raised', bd=2, font=('MS Sans Serif', 8))
            save_btn.pack(side='left', padx=5)
            
            cancel_btn = tk.Button(btn_frame, text="Cancel", command=dialog.destroy, 
                                  bg=self.button_color, relief='raised', bd=2, font=('MS Sans Serif', 8))
            cancel_btn.pack(side='left', padx=5)
            
            username_entry.focus()
        
        def update_status(self, message):
            self.status_label.config(text=f"{message} - {len(self.accounts)} accounts loaded")

    def main():
        rootDASH = tk.Tk()
        app = Windows95Dashboard(rootDASH)
        
        # Cleanup auto refresh timer when closing
        def on_closing():
            app.stop_auto_refresh()
            rootDASH.destroy()
        
        rootDASH.protocol("WM_DELETE_WINDOW", on_closing)
        rootDASH.mainloop()

    if __name__ == "__main__":
        main()
        
if mindmapvar == 7776660999:
    from tkinter import colorchooser

    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()
    
    class Connection:
        def __init__(self, node1_id, node2_id, direction="bidirectional"):
            self.node1_id = node1_id  # Starting node
            self.node2_id = node2_id  # Ending node
            self.direction = direction  # "bidirectional", "node1_to_node2", "node2_to_node1"
            self.id = f"conn_{node1_id}_{node2_id}"
            
        def get_reverse_direction(self):
            if self.direction == "node1_to_node2":
                return "node2_to_node1"
            elif self.direction == "node2_to_node1":
                return "node1_to_node2"
            else:
                return "bidirectional"
        
        def cycle_direction(self):
            """Cycle through: bidirectional -> node1_to_node2 -> node2_to_node1 -> bidirectional"""
            if self.direction == "bidirectional":
                self.direction = "node1_to_node2"
            elif self.direction == "node1_to_node2":
                self.direction = "node2_to_node1"
            else:
                self.direction = "bidirectional"

    class Node:
        def __init__(self, x, y, text="New Node", color="#C0C0C0"):
            self.x = x
            self.y = y
            self.text = text
            self.color = color
            self.width = 120
            self.height = 40
            self.connections = []  # List of connected node IDs (kept for backward compatibility)
            self.id = None
            
        def contains_point(self, x, y):
            return (self.x - self.width//2 <= x <= self.x + self.width//2 and
                    self.y - self.height//2 <= y <= self.y + self.height//2)
        
        def get_connection_point(self, target_node):
            """Get the best connection point on the edge of this node towards target"""
            dx = target_node.x - self.x
            dy = target_node.y - self.y
            
            # Calculate intersection with rectangle
            if dx == 0:
                return (self.x, self.y + (self.height//2 if dy > 0 else -self.height//2))
            if dy == 0:
                return (self.x + (self.width//2 if dx > 0 else -self.width//2), self.y)
            
            # General case
            slope = dy / dx
            
            # Check intersection with vertical edges
            if dx > 0:
                x_edge = self.x + self.width//2
            else:
                x_edge = self.x - self.width//2
            y_at_edge = self.y + slope * (x_edge - self.x)
            
            if abs(y_at_edge - self.y) <= self.height//2:
                return (x_edge, y_at_edge)
            
            # Check intersection with horizontal edges
            if dy > 0:
                y_edge = self.y + self.height//2
            else:
                y_edge = self.y - self.height//2
            x_at_edge = self.x + (y_edge - self.y) / slope
            
            return (x_at_edge, y_edge)

    class Win95Button(tk.Frame):
        def __init__(self, parent, text, command=None, width=None, **kwargs):
            super().__init__(parent, **kwargs)
            self.command = command
            self.pressed = False
            
            # Configure frame
            self.configure(relief="raised", bd=2, bg="#C0C0C0")
            
            # Create label
            self.label = tk.Label(self, text=text, font=("MS Sans Serif", 8),
                                 bg="#C0C0C0", fg="black")
            if width:
                self.label.configure(width=width)
            self.label.pack(padx=4, pady=2)
            
            # Bind events
            self.bind("<Button-1>", self.on_press)
            self.bind("<ButtonRelease-1>", self.on_release)
            self.label.bind("<Button-1>", self.on_press)
            self.label.bind("<ButtonRelease-1>", self.on_release)
            
        def on_press(self, event):
            self.configure(relief="sunken")
            self.pressed = True
            
        def on_release(self, event):
            if self.pressed:
                self.configure(relief="raised")
                self.pressed = False
                if self.command:
                    self.command()

    class MindMapTool:
        def __init__(self, root_MIND):
            self.root_MIND = root_MIND
            self.root_MIND.title("Mind Mapping Tool")
            self.root_MIND.geometry("1200x800")
            self.root_MIND.configure(bg="#C0C0C0")
            
            # Windows 95 color scheme
            self.colors = {
                'bg': '#C0C0C0',
                'button_face': '#C0C0C0',
                'button_highlight': '#FFFFFF',
                'button_shadow': '#808080',
                'button_dark_shadow': '#404040',
                'window_frame': '#404040',
                'active_title': '#000080',
                'inactive_title': '#808080',
                'text': '#000000'
            }
            
            self.nodes = {}
            self.connections = {}  # New: Store connections separately
            self.selected_node = None
            self.selected_connection = None  # New: Track selected connection
            self.dragging = False
            self.drag_start_x = 0
            self.drag_start_y = 0
            self.connecting_mode = False
            self.connect_start_node = None
            self.node_counter = 0
            
            self.bg_color = "#C0C0C0"
            
            # Display mode: True for 3D, False for 2D
            self.display_3d = True
            
            self.setup_ui()
            self.setup_bindings()
            
        def setup_ui(self):
            # Configure root_MIND window style
            self.root_MIND.configure(bg=self.colors['bg'])
            
            # Create title bar frame (simulated)
            title_frame = tk.Frame(self.root_MIND, bg=self.colors['active_title'], height=25)
            title_frame.pack(fill=tk.X)
            title_frame.pack_propagate(False)
            
            title_label = tk.Label(title_frame, text="Mind Mapping Tool", 
                                  font=("MS Sans Serif", 8, "bold"),
                                  bg=self.colors['active_title'], fg="white")
            title_label.pack(side=tk.LEFT, padx=5, pady=3)
            
            # Create main frame with border
            main_frame = tk.Frame(self.root_MIND, bg=self.colors['bg'], relief="raised", bd=2)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            '''
            # Menu bar (simulated)
            menubar_frame = tk.Frame(main_frame, bg=self.colors['bg'], relief="raised", bd=1)
            menubar_frame.pack(fill=tk.X)
            
            # File menu
            file_menu = tk.Label(menubar_frame, text="File", font=("MS Sans Serif", 8),
                               bg=self.colors['bg'], fg=self.colors['text'], padx=8, pady=2)
            file_menu.pack(side=tk.LEFT)
            
            edit_menu = tk.Label(menubar_frame, text="Edit", font=("MS Sans Serif", 8),
                               bg=self.colors['bg'], fg=self.colors['text'], padx=8, pady=2)
            edit_menu.pack(side=tk.LEFT)
            
            view_menu = tk.Label(menubar_frame, text="View", font=("MS Sans Serif", 8),
                               bg=self.colors['bg'], fg=self.colors['text'], padx=8, pady=2)
            view_menu.pack(side=tk.LEFT)
            '''
            # Toolbar with Win95 style buttons
            toolbar = tk.Frame(main_frame, bg=self.colors['bg'], relief="raised", bd=1)
            toolbar.pack(fill=tk.X, pady=2)
            
            # Left toolbar
            left_toolbar = tk.Frame(toolbar, bg=self.colors['bg'])
            left_toolbar.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=2)
            
            # Create Win95 style buttons
            Win95Button(left_toolbar, "Add Node", self.add_node_dialog, width=10).pack(side=tk.LEFT, padx=1)
            Win95Button(left_toolbar, "Delete", self.delete_selected_node, width=8).pack(side=tk.LEFT, padx=1)
            Win95Button(left_toolbar, "Connect", self.toggle_connect_mode, width=8).pack(side=tk.LEFT, padx=1)
            Win95Button(left_toolbar, "Edit", self.edit_selected_node, width=6).pack(side=tk.LEFT, padx=1)
            Win95Button(left_toolbar, "Color", self.change_node_color, width=6).pack(side=tk.LEFT, padx=1)
            
            # Separator
            sep1 = tk.Frame(left_toolbar, width=2, bg=self.colors['button_shadow'], relief="sunken", bd=1)
            sep1.pack(side=tk.LEFT, fill=tk.Y, padx=5)
            
            Win95Button(left_toolbar, "Save", self.save_mindmap, width=6).pack(side=tk.LEFT, padx=1)
            Win95Button(left_toolbar, "Load", self.load_mindmap, width=6).pack(side=tk.LEFT, padx=1)
            Win95Button(left_toolbar, "Clear", self.clear_all, width=6).pack(side=tk.LEFT, padx=1)
            
            # Separator
            sep2 = tk.Frame(left_toolbar, width=2, bg=self.colors['button_shadow'], relief="sunken", bd=1)
            sep2.pack(side=tk.LEFT, fill=tk.Y, padx=5)
            
            Win95Button(left_toolbar, "Auto Layout", self.auto_layout, width=10).pack(side=tk.LEFT, padx=1)
            
            # Separator
            sep3 = tk.Frame(left_toolbar, width=2, bg=self.colors['button_shadow'], relief="sunken", bd=1)
            sep3.pack(side=tk.LEFT, fill=tk.Y, padx=5)
            
            # 2D/3D Toggle button
            self.display_button = Win95Button(left_toolbar, "3D View", self.toggle_display_mode, width=8)
            self.display_button.pack(side=tk.LEFT, padx=1)
            
            # Status bar frame
            status_frame = tk.Frame(main_frame, bg=self.colors['bg'], relief="sunken", bd=2)
            status_frame.pack(fill=tk.X, side=tk.BOTTOM)
            
            self.status_var = tk.StringVar()
            self.status_var.set("Ready - Double-click to add node, click to select, drag to move, click arrows to change direction")
            self.status_label = tk.Label(status_frame, textvariable=self.status_var,
                                       font=("MS Sans Serif", 8), bg=self.colors['bg'],
                                       fg=self.colors['text'], anchor="w")
            self.status_label.pack(side=tk.LEFT, padx=5, pady=2, fill=tk.X, expand=True)
            
            # Canvas frame with Win95 style borders
            canvas_frame = tk.Frame(main_frame, bg=self.colors['bg'], relief="sunken", bd=2)
            canvas_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Create canvas with Win95 colors
            self.canvas = tk.Canvas(canvas_frame, bg="#FFFFFF", scrollregion=(0, 0, 2000, 2000),
                                   highlightthickness=0, relief="flat")
            
            # Scrollbars with Win95 style
            v_scrollbar = tk.Scrollbar(canvas_frame, orient=tk.VERTICAL, command=self.canvas.yview,
                                      bg=self.colors['bg'], troughcolor=self.colors['bg'],
                                      relief="raised", bd=1)
            h_scrollbar = tk.Scrollbar(canvas_frame, orient=tk.HORIZONTAL, command=self.canvas.xview,
                                      bg=self.colors['bg'], troughcolor=self.colors['bg'],
                                      relief="raised", bd=1)
            
            self.canvas.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            # Pack scrollbars and canvas
            v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
        def toggle_display_mode(self):
            """Toggle between 2D and 3D display modes"""
            self.display_3d = not self.display_3d
            
            # Update button text
            if self.display_3d:
                self.display_button.label.configure(text="3D View")
                self.status_var.set("Switched to 3D display mode")
            else:
                self.display_button.label.configure(text="2D View")
                self.status_var.set("Switched to 2D display mode")
            
            # Redraw all nodes with new display mode
            self.draw_connections()
            
        def draw_node(self, node):
            """Draw node using current display mode"""
            if self.display_3d:
                self.draw_node_3d(node)
            else:
                self.draw_node_2d(node)
        
        def create_win95_dialog(self, title, width=300, height=150):
            """Create a Windows 95 style dialog"""
            dialog = tk.Toplevel(self.root_MIND)
            dialog.title(title)
            dialog.geometry(f"{width}x{height}")
            dialog.transient(self.root_MIND)
            dialog.grab_set()
            dialog.configure(bg=self.colors['bg'])
            dialog.resizable(False, False)
            
            # Title bar simulation
            title_frame = tk.Frame(dialog, bg=self.colors['active_title'], height=20)
            title_frame.pack(fill=tk.X)
            title_frame.pack_propagate(False)
            
            title_label = tk.Label(title_frame, text=title, font=("MS Sans Serif", 8, "bold"),
                                  bg=self.colors['active_title'], fg="white")
            title_label.pack(side=tk.LEFT, padx=5, pady=2)
            
            # Main content frame
            content_frame = tk.Frame(dialog, bg=self.colors['bg'], relief="raised", bd=2)
            content_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            return dialog, content_frame
            
        def setup_bindings(self):
            self.canvas.bind("<Double-Button-1>", self.on_double_click)
            self.canvas.bind("<Button-1>", self.on_click)
            self.canvas.bind("<B1-Motion>", self.on_drag)
            self.canvas.bind("<ButtonRelease-1>", self.on_release)
            self.canvas.bind("<Button-3>", self.on_right_click)  # Right-click menu
            
        def add_node_dialog(self):
            dialog, content_frame = self.create_win95_dialog("Add Node", 320, 180)
            
            # Label
            label = tk.Label(content_frame, text="Node Text:", font=("MS Sans Serif", 8),
                            bg=self.colors['bg'], fg=self.colors['text'])
            label.pack(pady=(15, 5))
            
            # Entry with Win95 style
            entry_frame = tk.Frame(content_frame, relief="sunken", bd=2, bg="white")
            entry_frame.pack(pady=5, padx=20, fill=tk.X)
            
            text_entry = tk.Entry(entry_frame, font=("MS Sans Serif", 8), bg="white",
                                 fg="black", relief="flat", bd=0)
            text_entry.pack(padx=2, pady=2, fill=tk.X)
            text_entry.focus()
            
            # Button frame
            button_frame = tk.Frame(content_frame, bg=self.colors['bg'])
            button_frame.pack(pady=15)
            
            def create_node():
                text = text_entry.get().strip()
                if text:
                    x = random.randint(100, 500)
                    y = random.randint(100, 400)
                    self.create_node(x, y, text)
                    dialog.destroy()
            
            def cancel():
                dialog.destroy()
            
            Win95Button(button_frame, "OK", create_node, width=8).pack(side=tk.LEFT, padx=5)
            Win95Button(button_frame, "Cancel", cancel, width=8).pack(side=tk.LEFT, padx=5)
            
            # Bind Enter key
            text_entry.bind("<Return>", lambda e: create_node())
            
        def create_node(self, x, y, text="New Node", color="#87CEEB"):
            node = Node(x, y, text, color)
            node_id = f"node_{self.node_counter}"
            node.id = node_id
            self.node_counter += 1
            self.nodes[node_id] = node
            self.draw_node(node)
            return node_id
        
        def draw_node_3d(self, node):
            # Clear previous drawings for this node
            self.canvas.delete(f"node_{node.id}")
            
            # Calculate coordinates
            x1 = node.x - node.width // 2
            y1 = node.y - node.height // 2
            x2 = node.x + node.width // 2
            y2 = node.y + node.height // 2
            
            # Highlight selected node
            outline_color = "#FF0000" if self.selected_node == node.id else "#000000"
            outline_width = 3 if self.selected_node == node.id else 1
            
            # Draw Win95 style button (raised/sunken effect)
            if self.selected_node == node.id:
                # Selected node - sunken appearance
                # Dark shadow (bottom-right)
                self.canvas.create_line(x2-1, y1+1, x2-1, y2-1, x1+1, y2-1,
                                      fill=self.colors['button_dark_shadow'], width=1,
                                      tags=f"node_{node.id}")
                # Shadow (inner bottom-right)
                self.canvas.create_line(x2-2, y1+2, x2-2, y2-2, x1+2, y2-2,
                                      fill=self.colors['button_shadow'], width=1,
                                      tags=f"node_{node.id}")
                # Highlight (top-left)
                self.canvas.create_line(x1+1, y2-2, x1+1, y1+1, x2-2, y1+1,
                                      fill=self.colors['button_highlight'], width=1,
                                      tags=f"node_{node.id}")
            else:
                # Normal node - raised appearance
                # Highlight (top-left)
                self.canvas.create_line(x1, y2-1, x1, y1, x2-1, y1,
                                      fill=self.colors['button_highlight'], width=1,
                                      tags=f"node_{node.id}")
                # Shadow (bottom-right)
                self.canvas.create_line(x2-1, y1+1, x2-1, y2-1, x1+1, y2-1,
                                      fill=self.colors['button_shadow'], width=1,
                                      tags=f"node_{node.id}")
                # Dark shadow (outer bottom-right)
                self.canvas.create_line(x2, y1, x2, y2, x1, y2,
                                      fill=self.colors['button_dark_shadow'], width=1,
                                      tags=f"node_{node.id}")
            
            # Fill the button face
            self.canvas.create_rectangle(x1+1, y1+1, x2-1, y2-1,
                                       fill=node.color, outline="",
                                       tags=f"node_{node.id}")
            
            # Add selection border if selected
            if self.selected_node == node.id:
                self.canvas.create_rectangle(x1, y1, x2, y2,
                                           fill="", outline=outline_color, width=outline_width,
                                           tags=f"node_{node.id}")
            
            # Draw text
            self.canvas.create_text(node.x, node.y,
                                  text=node.text,
                                  font=("MS Sans Serif", 8, "bold"),
                                  fill="black",
                                  tags=f"node_{node.id}")

        def draw_node_2d(self, node):
            # Clear previous drawings for this node
            self.canvas.delete(f"node_{node.id}")
            
            # Calculate coordinates
            x1 = node.x - node.width // 2
            y1 = node.y - node.height // 2
            x2 = node.x + node.width // 2
            y2 = node.y + node.height // 2
            
            # Highlight selected node
            outline_color = "#FF0000" if self.selected_node == node.id else "#000000"
            outline_width = 3 if self.selected_node == node.id else 1
            
            self.canvas.create_rectangle(x1, y1, x2, y2, 
                                       fill=node.color, 
                                       outline=outline_color,
                                       width=outline_width,
                                       tags=f"node_{node.id}")
            
            # Draw text
            self.canvas.create_text(node.x, node.y, 
                                  text=node.text, 
                                  font=("Arial", 10, "bold"),
                                  tags=f"node_{node.id}")
            
        def draw_connections(self):
            # Clear all connection lines
            self.canvas.delete("connection")
            
            # Draw all connections
            for conn_id, connection in self.connections.items():
                if connection.node1_id in self.nodes and connection.node2_id in self.nodes:
                    node1 = self.nodes[connection.node1_id]
                    node2 = self.nodes[connection.node2_id]
                    
                    # Get connection points on edges
                    start_point = node1.get_connection_point(node2)
                    end_point = node2.get_connection_point(node1)
                    
                    # Calculate midpoint for click detection
                    mid_x = (start_point[0] + end_point[0]) / 2
                    mid_y = (start_point[1] + end_point[1]) / 2
                    
                    # Color for selected connection
                    line_color = "#FF0000" if self.selected_connection == conn_id else "#000000"
                    line_width = 3 if self.selected_connection == conn_id else 2
                    
                    if connection.direction == "bidirectional":
                        # Draw bidirectional arrow (arrow on both ends)
                        self.canvas.create_line(start_point[0], start_point[1],
                                              end_point[0], end_point[1],
                                              width=line_width, fill=line_color,
                                              arrow=tk.BOTH, arrowshape=(8, 10, 3),
                                              tags=("connection", conn_id))
                    elif connection.direction == "node1_to_node2":
                        # Arrow from node1 to node2
                        self.canvas.create_line(start_point[0], start_point[1],
                                              end_point[0], end_point[1],
                                              width=line_width, fill=line_color,
                                              arrow=tk.LAST, arrowshape=(8, 10, 3),
                                              tags=("connection", conn_id))
                    elif connection.direction == "node2_to_node1":
                        # Arrow from node2 to node1
                        self.canvas.create_line(start_point[0], start_point[1],
                                              end_point[0], end_point[1],
                                              width=line_width, fill=line_color,
                                              arrow=tk.FIRST, arrowshape=(8, 10, 3),
                                              tags=("connection", conn_id))
                    
                    # Create an invisible clickable area around the line midpoint
                    self.canvas.create_oval(mid_x-10, mid_y-10, mid_x+10, mid_y+10,
                                          fill="", outline="", width=0,
                                          tags=("connection_clickable", conn_id))
            
            # Ensure nodes are drawn on top
            for node in self.nodes.values():
                self.draw_node(node)
        
        def get_connection_at_position(self, x, y):
            """Find connection at given position"""
            # Get all items at this position
            items = self.canvas.find_overlapping(x-5, y-5, x+5, y+5)
            
            for item in items:
                tags = self.canvas.gettags(item)
                for tag in tags:
                    if tag.startswith("conn_"):
                        return tag
            
            return None
        
        def on_double_click(self, event):
            x = self.canvas.canvasx(event.x)
            y = self.canvas.canvasy(event.y)
            
            # Check if clicked on existing node
            clicked_node = self.get_node_at_position(x, y)
            if not clicked_node:
                # Create new node
                text = f"Node {len(self.nodes) + 1}"
                self.create_node(x, y, text)
                self.draw_connections()
                
        def on_click(self, event):
            x = self.canvas.canvasx(event.x)
            y = self.canvas.canvasy(event.y)
            
            # Check if clicked on a connection first
            clicked_connection = self.get_connection_at_position(x, y)
            if clicked_connection and not self.connecting_mode:
                if clicked_connection in self.connections:
                    # Cycle through connection directions
                    self.connections[clicked_connection].cycle_direction()
                    self.selected_connection = clicked_connection
                    self.selected_node = None
                    self.draw_connections()
                    
                    # Update status
                    conn = self.connections[clicked_connection]
                    node1_text = self.nodes[conn.node1_id].text
                    node2_text = self.nodes[conn.node2_id].text
                    
                    if conn.direction == "bidirectional":
                        direction_text = "bidirectional"
                    elif conn.direction == "node1_to_node2":
                        direction_text = f"from {node1_text} to {node2_text}"
                    else:
                        direction_text = f"from {node2_text} to {node1_text}"
                    
                    self.status_var.set(f"Connection changed to: {direction_text}")
                    return
            
            clicked_node = self.get_node_at_position(x, y)
            
            if self.connecting_mode:
                if clicked_node:
                    if self.connect_start_node is None:
                        self.connect_start_node = clicked_node
                        self.status_var.set(f"Select second node to connect to {self.nodes[clicked_node].text}")
                    else:
                        if clicked_node != self.connect_start_node:
                            self.connect_nodes(self.connect_start_node, clicked_node)
                        self.connect_start_node = None
                        self.connecting_mode = False
                        self.status_var.set("Ready")
                return
            
            if clicked_node:
                self.selected_node = clicked_node
                self.selected_connection = None
                self.dragging = True
                self.drag_start_x = x
                self.drag_start_y = y
                self.draw_connections()  # Redraw to show selection
            else:
                self.selected_node = None
                self.selected_connection = None
                self.draw_connections()  # Redraw to remove selection
                
        def on_drag(self, event):
            if self.dragging and self.selected_node:
                x = self.canvas.canvasx(event.x)
                y = self.canvas.canvasy(event.y)
                
                dx = x - self.drag_start_x
                dy = y - self.drag_start_y
                
                node = self.nodes[self.selected_node]
                node.x += dx
                node.y += dy
                
                self.drag_start_x = x
                self.drag_start_y = y
                
                self.draw_connections()
                
        def on_release(self, event):
            self.dragging = False
            
        def on_right_click(self, event):
            x = self.canvas.canvasx(event.x)
            y = self.canvas.canvasy(event.y)
            
            # Check if right-clicked on connection
            clicked_connection = self.get_connection_at_position(x, y)
            if clicked_connection and clicked_connection in self.connections:
                self.selected_connection = clicked_connection
                self.show_connection_context_menu(event, clicked_connection)
                return
            
            clicked_node = self.get_node_at_position(x, y)
            if clicked_node:
                self.selected_node = clicked_node
                self.show_context_menu(event, clicked_node)
                
        def show_context_menu(self, event, node_id):
            context_menu = tk.Menu(self.root_MIND, tearoff=0, font=("MS Sans Serif", 8),
                                  bg=self.colors['bg'], fg=self.colors['text'],
                                  activebackground=self.colors['active_title'], activeforeground="white")
            
            context_menu.add_command(label="Edit Node", command=lambda: self.edit_node(node_id))
            context_menu.add_command(label="Change Color", command=lambda: self.change_node_color_for_id(node_id))
            context_menu.add_command(label="Delete Node", command=lambda: self.delete_node(node_id))
            context_menu.add_command(label="Disconnect All", command=lambda: self.disconnect_all(node_id))
            context_menu.add_separator()
            context_menu.add_command(label="Connect to...", command=lambda: self.start_connect_from_node(node_id))
            
            try:
                context_menu.tk_popup(event.x_root, event.y_root)
            finally:
                context_menu.grab_release()
        
        def show_connection_context_menu(self, event, conn_id):
            context_menu = tk.Menu(self.root_MIND, tearoff=0, font=("MS Sans Serif", 8),
                                  bg=self.colors['bg'], fg=self.colors['text'],
                                  activebackground=self.colors['active_title'], activeforeground="white")
            
            connection = self.connections[conn_id]
            node1_text = self.nodes[connection.node1_id].text
            node2_text = self.nodes[connection.node2_id].text
            
            context_menu.add_command(label="Delete Connection", command=lambda: self.delete_connection(conn_id))
            context_menu.add_separator()
            context_menu.add_command(label="Bidirectional", command=lambda: self.set_connection_direction(conn_id, "bidirectional"))
            context_menu.add_command(label=f"{node1_text} → {node2_text}", command=lambda: self.set_connection_direction(conn_id, "node1_to_node2"))
            context_menu.add_command(label=f"{node2_text} → {node1_text}", command=lambda: self.set_connection_direction(conn_id, "node2_to_node1"))
            
            try:
                context_menu.tk_popup(event.x_root, event.y_root)
            finally:
                context_menu.grab_release()
        
        def set_connection_direction(self, conn_id, direction):
            if conn_id in self.connections:
                self.connections[conn_id].direction = direction
                self.draw_connections()
                self.status_var.set(f"Connection direction changed to {direction}")
        
        def delete_connection(self, conn_id):
            if conn_id in self.connections:
                del self.connections[conn_id]
                self.selected_connection = None
                self.draw_connections()
                self.status_var.set("Connection deleted")
        
        def start_connect_from_node(self, node_id):
            self.connecting_mode = True
            self.connect_start_node = node_id
            self.status_var.set(f"Select node to connect to {self.nodes[node_id].text}")
            
        def get_node_at_position(self, x, y):
            for node_id, node in self.nodes.items():
                if node.contains_point(x, y):
                    return node_id
            return None
            
        def toggle_connect_mode(self):
            self.connecting_mode = not self.connecting_mode
            if self.connecting_mode:
                self.connect_start_node = None
                self.status_var.set("Click on two nodes to connect them")
            else:
                self.connect_start_node = None
                self.status_var.set("Ready")
                
        def connect_nodes(self, node1_id, node2_id):
            # Check if connection already exists
            conn_id = f"conn_{node1_id}_{node2_id}"
            reverse_conn_id = f"conn_{node2_id}_{node1_id}"
            
            if conn_id not in self.connections and reverse_conn_id not in self.connections:
                connection = Connection(node1_id, node2_id)
                self.connections[conn_id] = connection
                
                # Add to nodes' connection lists for backward compatibility
                if node2_id not in self.nodes[node1_id].connections:
                    self.nodes[node1_id].connections.append(node2_id)
                if node1_id not in self.nodes[node2_id].connections:
                    self.nodes[node2_id].connections.append(node1_id)
                
                self.draw_connections()
                self.status_var.set(f"Connected {self.nodes[node1_id].text} and {self.nodes[node2_id].text}")
            else:
                self.status_var.set("Connection already exists")
        
        def edit_selected_node(self):
            if self.selected_node:
                self.edit_node(self.selected_node)
            else:
                messagebox.showwarning("No Selection", "Please select a node first.")
        
        def edit_node(self, node_id):
            node = self.nodes[node_id]
            dialog, content_frame = self.create_win95_dialog("Edit Node", 320, 180)
            
            # Label
            label = tk.Label(content_frame, text="Node Text:", font=("MS Sans Serif", 8),
                            bg=self.colors['bg'], fg=self.colors['text'])
            label.pack(pady=(15, 5))
            
            # Entry with Win95 style
            entry_frame = tk.Frame(content_frame, relief="sunken", bd=2, bg="white")
            entry_frame.pack(pady=5, padx=20, fill=tk.X)
            
            text_entry = tk.Entry(entry_frame, font=("MS Sans Serif", 8), bg="white",
                                 fg="black", relief="flat", bd=0)
            text_entry.pack(padx=2, pady=2, fill=tk.X)
            text_entry.insert(0, node.text)
            text_entry.focus()
            text_entry.select_range(0, tk.END)
            
            # Button frame
            button_frame = tk.Frame(content_frame, bg=self.colors['bg'])
            button_frame.pack(pady=15)
            
            def save_changes():
                new_text = text_entry.get().strip()
                if new_text:
                    node.text = new_text
                    self.draw_connections()
                    self.status_var.set(f"Node text updated to: {new_text}")
                    dialog.destroy()
            
            def cancel():
                dialog.destroy()
            
            Win95Button(button_frame, "OK", save_changes, width=8).pack(side=tk.LEFT, padx=5)
            Win95Button(button_frame, "Cancel", cancel, width=8).pack(side=tk.LEFT, padx=5)
            
            # Bind Enter key
            text_entry.bind("<Return>", lambda e: save_changes())
            
        def disconnect_all(self, node_id):
            if node_id not in self.nodes:
                return
                
            node = self.nodes[node_id]
            
            # Remove all connections that involve this node from the connections dictionary
            connections_to_remove = []
            for conn_id, connection in self.connections.items():
                if connection.node1_id == node_id or connection.node2_id == node_id:
                    connections_to_remove.append(conn_id)
            
            # Actually remove the connections
            for conn_id in connections_to_remove:
                del self.connections[conn_id]
            
            # Remove this node from other nodes' connections (for backward compatibility)
            for other_node in self.nodes.values():
                if node_id in other_node.connections:
                    other_node.connections.remove(node_id)
                    
            # Clear this node's connections
            node.connections.clear()
            
            # Clear selection if this connection was selected
            if self.selected_connection in connections_to_remove:
                self.selected_connection = None
            
            self.draw_connections()
            self.status_var.set(f"Disconnected all connections from '{node.text}'")
        
        def change_node_color(self):
            if self.selected_node:
                self.change_node_color_for_id(self.selected_node)
            else:
                messagebox.showwarning("No Selection", "Please select a node first.")
        
        def change_node_color_for_id(self, node_id):
            node = self.nodes[node_id]
            color = colorchooser.askcolor(initialcolor=node.color)[1]
            if color:
                node.color = color
                self.draw_connections()
                self.status_var.set(f"Node color changed to {color}")
        
        def delete_selected_node(self):
            if self.selected_node:
                result = messagebox.askyesno("Confirm Delete", 
                                           f"Delete node '{self.nodes[self.selected_node].text}'?")
                if result:
                    self.delete_node(self.selected_node)
            else:
                messagebox.showinfo("Information", "Please select a node first!")
        
        def delete_node(self, node_id):
            if node_id not in self.nodes:
                return
                
            # Remove connections to this node
            for other_node in self.nodes.values():
                if node_id in other_node.connections:
                    other_node.connections.remove(node_id)
                    
            # Remove the node
            del self.nodes[node_id]
            self.selected_node = None
            
            # Clear and redraw
            self.canvas.delete("all")
            self.draw_connections()
            self.status_var.set(f"Deleted node")
        
        def clear_all(self):
            result = messagebox.askyesno("Clear All", "Are you sure you want to delete all nodes and connections?")
            if result:
                self.nodes.clear()
                self.connections.clear()
                self.selected_node = None
                self.selected_connection = None
                self.node_counter = 0
                self.canvas.delete("all")
                self.status_var.set("All nodes and connections cleared")
        
        def save_mindmap(self):
            if not self.nodes:
                messagebox.showwarning("Nothing to Save", "There are no nodes to save.")
                return
            
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
            )
            
            if filename:
                try:
                    data = {
                        'nodes': {},
                        'connections': {},
                        'node_counter': self.node_counter
                    }
                    
                    # Save nodes
                    for node_id, node in self.nodes.items():
                        data['nodes'][node_id] = {
                            'x': node.x,
                            'y': node.y,
                            'text': node.text,
                            'color': node.color,
                            'connections': node.connections
                        }
                    
                    # Save connections
                    for conn_id, connection in self.connections.items():
                        data['connections'][conn_id] = {
                            'node1_id': connection.node1_id,
                            'node2_id': connection.node2_id,
                            'direction': connection.direction
                        }
                    
                    with open(filename, 'w') as f:
                        json.dump(data, f, indent=2)
                    
                    self.status_var.set(f"Mind map saved to {filename}")
                    
                except Exception as e:
                    messagebox.showerror("Save Error", f"Failed to save file: {str(e)}")
        
        def load_mindmap(self):
            filename = filedialog.askopenfilename(
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
            )
            
            if filename:
                try:
                    with open(filename, 'r') as f:
                        data = json.load(f)
                    
                    # Clear existing data
                    self.nodes.clear()
                    self.connections.clear()
                    self.canvas.delete("all")
                    
                    # Load node counter
                    self.node_counter = data.get('node_counter', 0)
                    
                    # Load nodes
                    for node_id, node_data in data['nodes'].items():
                        node = Node(
                            node_data['x'],
                            node_data['y'],
                            node_data['text'],
                            node_data['color']
                        )
                        node.id = node_id
                        node.connections = node_data.get('connections', [])
                        self.nodes[node_id] = node
                    
                    # Load connections
                    connections_data = data.get('connections', {})
                    for conn_id, conn_data in connections_data.items():
                        connection = Connection(
                            conn_data['node1_id'],
                            conn_data['node2_id'],
                            conn_data.get('direction', 'bidirectional')
                        )
                        self.connections[conn_id] = connection
                    
                    self.selected_node = None
                    self.selected_connection = None
                    self.draw_connections()
                    self.status_var.set(f"Mind map loaded from {filename}")
                    
                except Exception as e:
                    messagebox.showerror("Load Error", f"Failed to load file: {str(e)}")
        
        def auto_layout(self):
            if not self.nodes:
                messagebox.showwarning("No Nodes", "There are no nodes to arrange.")
                return
            
            # Simple circular layout
            center_x = 400
            center_y = 300
            radius = 200
            
            nodes_list = list(self.nodes.values())
            angle_step = 2 * math.pi / len(nodes_list)
            
            for i, node in enumerate(nodes_list):
                angle = i * angle_step
                node.x = center_x + radius * math.cos(angle)
                node.y = center_y + radius * math.sin(angle)
            
            self.draw_connections()
            self.status_var.set("Auto layout applied")

    def main():
        root = tk.Tk()
        app = MindMapTool(root)
        root.mainloop()

    if __name__ == "__main__":
        main()
        
if multifilevar == 77766609999:
    from tkinter import ttk, filedialog, messagebox, scrolledtext, simpledialog, colorchooser
    import csv
    import xml.etree.ElementTree as ET
    import xml.dom.minidom
    import re
    from datetime import datetime
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class CSVViewer:
        def __init__(self, parent, data):
            self.window = tk.Toplevel(parent)
            self.window.title("CSV Table Viewer")
            self.window.geometry("800x500")
            self.window.configure(bg="#c0c0c0")
            
            # Create treeview for table display
            frame = tk.Frame(self.window, bg="#c0c0c0")
            frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            self.tree = ttk.Treeview(frame)
            
            if data:
                # Set up columns
                self.tree["columns"] = [f"col{i}" for i in range(len(data[0]))]
                self.tree["show"] = "headings"
                
                # Configure column headings
                for i, header in enumerate(data[0]):
                    self.tree.heading(f"col{i}", text=header)
                    self.tree.column(f"col{i}", width=100)
                
                # Insert data
                for row in data[1:]:
                    self.tree.insert("", "end", values=row)
            
            # Scrollbars
            v_scroll = ttk.Scrollbar(frame, orient="vertical", command=self.tree.yview)
            h_scroll = ttk.Scrollbar(frame, orient="horizontal", command=self.tree.xview)
            self.tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
            
            self.tree.pack(side="left", fill="both", expand=True)
            v_scroll.pack(side="right", fill="y")
            h_scroll.pack(side="bottom", fill="x")

    class FindReplaceDialog:
        def __init__(self, parent, text_widget):
            self.parent = parent
            self.text_widget = text_widget
            self.window = tk.Toplevel(parent)
            self.window.title("Find & Replace")
            self.window.geometry("400x200")
            self.window.configure(bg="#c0c0c0")
            self.window.transient(parent)
            self.window.grab_set()
            
            self.setup_ui()
            
        def setup_ui(self):
            # Find section
            find_frame = tk.Frame(self.window, bg="#c0c0c0")
            find_frame.pack(fill=tk.X, padx=10, pady=5)
            
            tk.Label(find_frame, text="Find:", bg="#c0c0c0").pack(anchor=tk.W)
            self.find_var = tk.StringVar()
            self.find_entry = tk.Entry(find_frame, textvariable=self.find_var, width=40)
            self.find_entry.pack(fill=tk.X, pady=2)
            
            # Replace section
            replace_frame = tk.Frame(self.window, bg="#c0c0c0")
            replace_frame.pack(fill=tk.X, padx=10, pady=5)
            
            tk.Label(replace_frame, text="Replace with:", bg="#c0c0c0").pack(anchor=tk.W)
            self.replace_var = tk.StringVar()
            self.replace_entry = tk.Entry(replace_frame, textvariable=self.replace_var, width=40)
            self.replace_entry.pack(fill=tk.X, pady=2)
            
            # Options
            options_frame = tk.Frame(self.window, bg="#c0c0c0")
            options_frame.pack(fill=tk.X, padx=10, pady=5)
            
            self.case_sensitive = tk.BooleanVar()
            self.whole_word = tk.BooleanVar()
            
            tk.Checkbutton(options_frame, text="Case sensitive", variable=self.case_sensitive, bg="#c0c0c0").pack(anchor=tk.W)
            tk.Checkbutton(options_frame, text="Whole word only", variable=self.whole_word, bg="#c0c0c0").pack(anchor=tk.W)
            
            # Buttons
            btn_frame = tk.Frame(self.window, bg="#c0c0c0")
            btn_frame.pack(fill=tk.X, padx=10, pady=10)
            
            btn_style = {"bg": "#c0c0c0", "relief": tk.RAISED, "bd": 2, "padx": 10}
            
            tk.Button(btn_frame, text="Find Next", command=self.find_next, **btn_style).pack(side=tk.LEFT, padx=2)
            tk.Button(btn_frame, text="Replace", command=self.replace_current, **btn_style).pack(side=tk.LEFT, padx=2)
            tk.Button(btn_frame, text="Replace All", command=self.replace_all, **btn_style).pack(side=tk.LEFT, padx=2)
            tk.Button(btn_frame, text="Close", command=self.window.destroy, **btn_style).pack(side=tk.RIGHT, padx=2)
            
            self.find_entry.focus()
            
        def find_next(self):
            search_text = self.find_var.get()
            if not search_text:
                return
                
            # Get current cursor position
            start_pos = self.text_widget.index(tk.INSERT)
            
            # Search for text
            pos = self.text_widget.search(search_text, start_pos, tk.END, 
                                         nocase=not self.case_sensitive.get())
            
            if pos:
                # Select found text
                end_pos = f"{pos}+{len(search_text)}c"
                self.text_widget.tag_remove(tk.SEL, "1.0", tk.END)
                self.text_widget.tag_add(tk.SEL, pos, end_pos)
                self.text_widget.mark_set(tk.INSERT, end_pos)
                self.text_widget.see(pos)
            else:
                messagebox.showinfo("Find", "Text not found")
                
        def replace_current(self):
            if self.text_widget.tag_ranges(tk.SEL):
                self.text_widget.delete(tk.SEL_FIRST, tk.SEL_LAST)
                self.text_widget.insert(tk.INSERT, self.replace_var.get())
                
        def replace_all(self):
            search_text = self.find_var.get()
            replace_text = self.replace_var.get()
            
            if not search_text:
                return
                
            content = self.text_widget.get("1.0", tk.END)
            if not self.case_sensitive.get():
                count = content.lower().count(search_text.lower())
                content = re.sub(re.escape(search_text), replace_text, content, flags=re.IGNORECASE)
            else:
                count = content.count(search_text)
                content = content.replace(search_text, replace_text)
                
            self.text_widget.delete("1.0", tk.END)
            self.text_widget.insert("1.0", content)
            
            messagebox.showinfo("Replace All", f"Replaced {count} occurrences")

    class Win95FileEditor:
        def __init__(self, root_edt):
            self.root_edt = root_edt
            self.root_edt.title("Multi-Format File Editor")
            self.root_edt.geometry("1000x700")
            
            # Windows 95 color scheme
            self.bg_color = "#c0c0c0"
            self.button_color = "#c0c0c0"
            self.text_bg = "#ffffff"
            self.menu_bg = "#c0c0c0"
            
            self.root_edt.configure(bg=self.bg_color)
            
            self.current_file = None
            self.current_format = None
            self.file_modified = False
            self.recent_files = []
            self.bookmarks = []
            self.find_dialog = None
            
            # Editor settings
            self.font_family = "Courier New"
            self.font_size = 10
            self.tab_size = 4
            self.show_line_numbers = True
            self.word_wrap = True
            self.syntax_highlighting = True
            
            self.setup_ui()
            self.load_settings()
            
        def setup_ui(self):
            # Menu bar
            self.setup_menu()
            
            # Toolbar
            self.setup_toolbar()
            
            # Main content area with panels
            self.setup_main_area()
            
            # Status bar
            self.setup_status_bar()
            
            # Bind events
            self.bind_events()
            
        def setup_menu(self):
            menubar = tk.Menu(self.root_edt, bg=self.menu_bg, fg="black")
            self.root_edt.config(menu=menubar)
            
            # File menu
            file_menu = tk.Menu(menubar, tearoff=0, bg=self.menu_bg, fg="black")
            menubar.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="New", command=self.new_file, accelerator="Ctrl+N")
            file_menu.add_command(label="Open...", command=self.open_file, accelerator="Ctrl+O")
            
            # Recent files submenu
            self.recent_menu = tk.Menu(file_menu, tearoff=0, bg=self.menu_bg, fg="black")
            file_menu.add_cascade(label="Recent Files", menu=self.recent_menu)
            
            file_menu.add_separator()
            file_menu.add_command(label="Save", command=self.save_file, accelerator="Ctrl+S")
            file_menu.add_command(label="Save As...", command=self.save_as_file, accelerator="Ctrl+Shift+S")
            file_menu.add_command(label="Save All", command=self.save_all_files)
            file_menu.add_separator()
            file_menu.add_command(label="Print...", command=self.print_file, accelerator="Ctrl+P")
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.exit_application)
            
            # Edit menu
            edit_menu = tk.Menu(menubar, tearoff=0, bg=self.menu_bg, fg="black")
            menubar.add_cascade(label="Edit", menu=edit_menu)
            edit_menu.add_command(label="Undo", command=self.undo, accelerator="Ctrl+Z")
            edit_menu.add_command(label="Redo", command=self.redo, accelerator="Ctrl+Y")
            edit_menu.add_separator()
            edit_menu.add_command(label="Cut", command=self.cut_text, accelerator="Ctrl+X")
            edit_menu.add_command(label="Copy", command=self.copy_text, accelerator="Ctrl+C")
            edit_menu.add_command(label="Paste", command=self.paste_text, accelerator="Ctrl+V")
            edit_menu.add_separator()
            edit_menu.add_command(label="Select All", command=self.select_all, accelerator="Ctrl+A")
            edit_menu.add_command(label="Find & Replace...", command=self.show_find_replace, accelerator="Ctrl+H")
            edit_menu.add_separator()
            edit_menu.add_command(label="Go to Line...", command=self.goto_line, accelerator="Ctrl+G")
            edit_menu.add_command(label="Toggle Bookmark", command=self.toggle_bookmark, accelerator="Ctrl+B")
            
            # View menu
            view_menu = tk.Menu(menubar, tearoff=0, bg=self.menu_bg, fg="black")
            menubar.add_cascade(label="View", menu=view_menu)
            view_menu.add_checkbutton(label="Line Numbers", command=self.toggle_line_numbers)
            view_menu.add_checkbutton(label="Word Wrap", command=self.toggle_word_wrap)
            view_menu.add_checkbutton(label="Syntax Highlighting", command=self.toggle_syntax_highlighting)
            view_menu.add_separator()
            view_menu.add_command(label="Zoom In", command=self.zoom_in, accelerator="Ctrl++")
            view_menu.add_command(label="Zoom Out", command=self.zoom_out, accelerator="Ctrl+-")
            view_menu.add_command(label="Reset Zoom", command=self.reset_zoom, accelerator="Ctrl+0")
            
            # Format menu
            format_menu = tk.Menu(menubar, tearoff=0, bg=self.menu_bg, fg="black")
            menubar.add_cascade(label="Format", menu=format_menu)
            format_menu.add_command(label="Format JSON", command=self.format_json)
            format_menu.add_command(label="Format XML", command=self.format_xml)
            format_menu.add_command(label="Minify JSON", command=self.minify_json)
            format_menu.add_command(label="Escape JSON", command=self.escape_json)
            format_menu.add_separator()
            format_menu.add_command(label="Sort Lines", command=self.sort_lines)
            format_menu.add_command(label="Remove Duplicate Lines", command=self.remove_duplicates)
            format_menu.add_command(label="Convert to Uppercase", command=self.to_uppercase)
            format_menu.add_command(label="Convert to Lowercase", command=self.to_lowercase)
            
            # Tools menu
            tools_menu = tk.Menu(menubar, tearoff=0, bg=self.menu_bg, fg="black")
            menubar.add_cascade(label="Tools", menu=tools_menu)
            tools_menu.add_command(label="Validate JSON", command=self.validate_json)
            tools_menu.add_command(label="Validate XML", command=self.validate_xml)
            tools_menu.add_command(label="Validate CSV", command=self.validate_csv)
            tools_menu.add_separator()
            tools_menu.add_command(label="View CSV as Table", command=self.view_csv_table)
            tools_menu.add_command(label="JSON to CSV", command=self.json_to_csv)
            tools_menu.add_command(label="CSV to JSON", command=self.csv_to_json)
            tools_menu.add_separator()
            tools_menu.add_command(label="Count Words/Lines", command=self.count_stats)
            tools_menu.add_command(label="Encode/Decode", command=self.show_encode_decode)
            
            # Settings menu
            settings_menu = tk.Menu(menubar, tearoff=0, bg=self.menu_bg, fg="black")
            menubar.add_cascade(label="Settings", menu=settings_menu)
            settings_menu.add_command(label="Font...", command=self.change_font)
            settings_menu.add_command(label="Colors...", command=self.change_colors)
            settings_menu.add_command(label="Tab Size...", command=self.change_tab_size)
            settings_menu.add_command(label="Preferences...", command=self.show_preferences)
            
            # Help menu
            help_menu = tk.Menu(menubar, tearoff=0, bg=self.menu_bg, fg="black")
            menubar.add_cascade(label="Help", menu=help_menu)
            help_menu.add_command(label="Keyboard Shortcuts", command=self.show_shortcuts)
            help_menu.add_command(label="About...", command=self.show_about)
            
        def setup_toolbar(self):
            # Main toolbar
            self.toolbar = tk.Frame(self.root_edt, bg=self.bg_color, relief=tk.RAISED, bd=1)
            self.toolbar.pack(fill=tk.X, padx=2, pady=2)
            
            btn_style = {"bg": self.button_color, "fg": "black", "relief": tk.RAISED, 
                        "bd": 2, "font": ("MS Sans Serif", 8), "padx": 6, "pady": 2}
            
            # File operations
            tk.Button(self.toolbar, text="New", command=self.new_file, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(self.toolbar, text="Open", command=self.open_file, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(self.toolbar, text="Save", command=self.save_file, **btn_style).pack(side=tk.LEFT, padx=1)
            
            self.add_separator()
            
            # Edit operations
            tk.Button(self.toolbar, text="Cut", command=self.cut_text, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(self.toolbar, text="Copy", command=self.copy_text, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(self.toolbar, text="Paste", command=self.paste_text, **btn_style).pack(side=tk.LEFT, padx=1)
            
            self.add_separator()
            
            # Format operations
            tk.Button(self.toolbar, text="Format", command=self.format_current, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(self.toolbar, text="Validate", command=self.validate_current, **btn_style).pack(side=tk.LEFT, padx=1)
            
            self.add_separator()
            
            # View operations
            tk.Button(self.toolbar, text="Find", command=self.show_find_replace, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(self.toolbar, text="Zoom+", command=self.zoom_in, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(self.toolbar, text="Zoom-", command=self.zoom_out, **btn_style).pack(side=tk.LEFT, padx=1)
            
            # Format indicator
            self.format_label = tk.Label(self.toolbar, text="Format: Unknown", bg=self.bg_color, 
                                       font=("MS Sans Serif", 8), relief=tk.SUNKEN, bd=1)
            self.format_label.pack(side=tk.RIGHT, padx=5)
            
        def add_separator(self):
            tk.Frame(self.toolbar, width=2, bg="#808080", relief=tk.SUNKEN, bd=1).pack(
                side=tk.LEFT, fill=tk.Y, padx=3, pady=2)
            
        def setup_main_area(self):
            # Main paned window
            self.main_paned = tk.PanedWindow(self.root_edt, orient=tk.HORIZONTAL, bg=self.bg_color, 
                                            relief=tk.SUNKEN, bd=2, sashwidth=5)
            self.main_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
            
            # Left panel for file browser and bookmarks
            self.left_panel = tk.Frame(self.main_paned, bg=self.bg_color, width=200)
            self.main_paned.add(self.left_panel, minsize=150)
            
            # Notebook for left panel tabs
            self.left_notebook = ttk.Notebook(self.left_panel)
            self.left_notebook.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # File browser tab
            self.setup_file_browser()
            
            # Bookmarks tab
            self.setup_bookmarks_panel()
            
            # Right panel for editor
            self.editor_frame = tk.Frame(self.main_paned, bg=self.bg_color)
            self.main_paned.add(self.editor_frame, minsize=400)
            
            # Editor with line numbers
            self.setup_editor()
            
        def setup_file_browser(self):
            browser_frame = tk.Frame(self.left_notebook, bg=self.bg_color)
            self.left_notebook.add(browser_frame, text="Files")
            
            # Directory navigation
            nav_frame = tk.Frame(browser_frame, bg=self.bg_color)
            nav_frame.pack(fill=tk.X, padx=2, pady=2)
            
            tk.Label(nav_frame, text="Directory:", bg=self.bg_color, font=("MS Sans Serif", 8)).pack(anchor=tk.W)
            
            self.current_dir = tk.StringVar(value=os.getcwd())
            dir_frame = tk.Frame(nav_frame, bg=self.bg_color)
            dir_frame.pack(fill=tk.X, pady=2)
            
            self.dir_entry = tk.Entry(dir_frame, textvariable=self.current_dir, font=("MS Sans Serif", 8))
            self.dir_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            tk.Button(dir_frame, text="...", command=self.browse_directory, 
                     bg=self.button_color, relief=tk.RAISED, bd=1, padx=5).pack(side=tk.RIGHT)
            
            # File listbox
            list_frame = tk.Frame(browser_frame, bg=self.bg_color, relief=tk.SUNKEN, bd=1)
            list_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            self.file_listbox = tk.Listbox(list_frame, bg="white", font=("MS Sans Serif", 8))
            file_scroll = tk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.file_listbox.yview)
            self.file_listbox.configure(yscrollcommand=file_scroll.set)
            
            self.file_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            file_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            
            self.file_listbox.bind('<Double-Button-1>', self.open_from_browser)
            
            self.refresh_file_browser()
            
        def setup_bookmarks_panel(self):
            bookmarks_frame = tk.Frame(self.left_notebook, bg=self.bg_color)
            self.left_notebook.add(bookmarks_frame, text="Bookmarks")
            
            # Bookmarks listbox
            self.bookmarks_listbox = tk.Listbox(bookmarks_frame, bg="white", font=("MS Sans Serif", 8))
            self.bookmarks_listbox.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # Bookmarks buttons
            btn_frame = tk.Frame(bookmarks_frame, bg=self.bg_color)
            btn_frame.pack(fill=tk.X, padx=2, pady=2)
            
            btn_style = {"bg": self.button_color, "relief": tk.RAISED, "bd": 1, "font": ("MS Sans Serif", 8)}
            
            tk.Button(btn_frame, text="Go", command=self.goto_bookmark, **btn_style).pack(side=tk.LEFT, padx=1)
            tk.Button(btn_frame, text="Delete", command=self.delete_bookmark, **btn_style).pack(side=tk.LEFT, padx=1)
            
        def setup_editor(self):
            editor_container = tk.Frame(self.editor_frame, bg=self.bg_color, relief=tk.SUNKEN, bd=2)
            editor_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
            
            # Line numbers and text editor frame
            text_frame = tk.Frame(editor_container, bg=self.bg_color)
            text_frame.pack(fill=tk.BOTH, expand=True)
            
            # Line numbers
            self.line_numbers = tk.Text(text_frame, width=4, padx=3, takefocus=0,
                                       border=0, state='disabled', wrap='none',
                                       bg="#f0f0f0", fg="#666666", font=(self.font_family, self.font_size))
            self.line_numbers.pack(side=tk.LEFT, fill=tk.Y)
            
            # Main text editor
            self.text_editor = scrolledtext.ScrolledText(
                text_frame,
                wrap=tk.WORD if self.word_wrap else tk.NONE,
                bg=self.text_bg,
                fg="black",
                font=(self.font_family, self.font_size),
                relief=tk.FLAT,
                insertbackground="black",
                selectbackground="#0078d4",
                selectforeground="white",
                undo=True,
                maxundo=50
            )
            self.text_editor.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Bind events for line numbers
            self.text_editor.bind('<Key>', self.on_text_change)
            self.text_editor.bind('<Button-1>', self.update_line_numbers)
            self.text_editor.bind('<MouseWheel>', self.on_mousewheel)
            
            # Configure syntax highlighting tags
            self.setup_syntax_highlighting()
            
        def setup_syntax_highlighting(self):
            # JSON syntax highlighting
            self.text_editor.tag_configure("json_key", foreground="#0000FF")
            self.text_editor.tag_configure("json_string", foreground="#008000")
            self.text_editor.tag_configure("json_number", foreground="#FF0000")
            self.text_editor.tag_configure("json_keyword", foreground="#800080")
            
            # XML syntax highlighting
            self.text_editor.tag_configure("xml_tag", foreground="#0000FF")
            self.text_editor.tag_configure("xml_attribute", foreground="#FF0000")
            self.text_editor.tag_configure("xml_value", foreground="#008000")
            
        def setup_status_bar(self):
            status_frame = tk.Frame(self.root_edt, bg=self.bg_color, relief=tk.RAISED, bd=1)
            status_frame.pack(side=tk.BOTTOM, fill=tk.X)
            
            self.status_bar = tk.Label(status_frame, text="Ready", relief=tk.SUNKEN, bd=1,
                                      bg=self.bg_color, fg="black", font=("MS Sans Serif", 8), anchor=tk.W)
            self.status_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            # Line/Column indicator
            self.line_col_label = tk.Label(status_frame, text="Ln 1, Col 1", relief=tk.SUNKEN, bd=1,
                                          bg=self.bg_color, fg="black", font=("MS Sans Serif", 8))
            self.line_col_label.pack(side=tk.RIGHT, padx=2)
            
            # File size indicator
            self.file_size_label = tk.Label(status_frame, text="0 bytes", relief=tk.SUNKEN, bd=1,
                                           bg=self.bg_color, fg="black", font=("MS Sans Serif", 8))
            self.file_size_label.pack(side=tk.RIGHT, padx=2)
            
        def bind_events(self):
            # Keyboard shortcuts
            self.root_edt.bind('<Control-n>', lambda e: self.new_file())
            self.root_edt.bind('<Control-o>', lambda e: self.open_file())
            self.root_edt.bind('<Control-s>', lambda e: self.save_file())
            self.root_edt.bind('<Control-Shift-S>', lambda e: self.save_as_file())
            self.root_edt.bind('<Control-p>', lambda e: self.print_file())
            self.root_edt.bind('<Control-z>', lambda e: self.undo())
            self.root_edt.bind('<Control-y>', lambda e: self.redo())
            self.root_edt.bind('<Control-h>', lambda e: self.show_find_replace())
            self.root_edt.bind('<Control-g>', lambda e: self.goto_line())
            self.root_edt.bind('<Control-b>', lambda e: self.toggle_bookmark())
            self.root_edt.bind('<Control-plus>', lambda e: self.zoom_in())
            self.root_edt.bind('<Control-minus>', lambda e: self.zoom_out())
            self.root_edt.bind('<Control-0>', lambda e: self.reset_zoom())
            
            # Text editor events
            self.text_editor.bind('<KeyRelease>', self.update_cursor_position)
            self.text_editor.bind('<ButtonRelease-1>', self.update_cursor_position)
            
            # Window events
            self.root_edt.protocol("WM_DELETE_WINDOW", self.exit_application)
            
        # File operations
        def new_file(self):
            if self.file_modified and not self.ask_save_changes():
                return
            self.text_editor.delete(1.0, tk.END)
            self.current_file = None
            self.current_format = None
            self.file_modified = False
            self.update_title()
            self.update_format_display()
            self.status_bar.config(text="New file created")
            self.update_line_numbers()
            
        def open_file(self):
            if self.file_modified and not self.ask_save_changes():
                return
                
            file_path = filedialog.askopenfilename(
                title="Open File",
                filetypes=[
                    ("All Supported", "*.csv;*.xml;*.json;*.md;*.txt"),
                    ("CSV files", "*.csv"),
                    ("XML files", "*.xml"),
                    ("JSON files", "*.json"),
                    ("Markdown files", "*.md"),
                    ("Text files", "*.txt"),
                    ("All files", "*.*")
                ]
            )
            
            if file_path:
                self.load_file(file_path)
                
        def load_file(self, file_path):
            try:
                with open(file_path, 'r', encoding='utf-8') as file:
                    content = file.read()
                    self.text_editor.delete(1.0, tk.END)
                    self.text_editor.insert(1.0, content)
                    
                self.current_file = file_path
                self.current_format = self.detect_format(file_path)
                self.file_modified = False
                self.add_to_recent_files(file_path)
                self.update_title()
                self.update_format_display()
                self.update_line_numbers()
                self.apply_syntax_highlighting()
                self.status_bar.config(text=f"Opened: {os.path.basename(file_path)} ({self.current_format})")
                self.update_file_size()
                
            except Exception as e:
                messagebox.showerror("Error", f"Could not open file:\n{str(e)}")
                
        def save_file(self):
            if self.current_file:
                self.save_to_file(self.current_file)
            else:
                self.save_as_file()
                
        def save_as_file(self):
            file_path = filedialog.asksaveasfilename(
                title="Save File As",
                filetypes=[
                    ("CSV files", "*.csv"),
                    ("XML files", "*.xml"),
                    ("JSON files", "*.json"),
                    ("Markdown files", "*.md"),
                    ("Text files", "*.txt"),
                    ("All files", "*.*")
                ]
            )
            
            if file_path:
                self.save_to_file(file_path)
                self.current_file = file_path
                self.current_format = self.detect_format(file_path)
                self.update_title()
                self.update_format_display()
                self.add_to_recent_files(file_path)
                
        def save_to_file(self, file_path):
            try:
                with open(file_path, 'w', encoding='utf-8') as file:
                    content = self.text_editor.get(1.0, tk.END).rstrip('\n')
                    file.write(content)
                self.file_modified = False
                self.update_title()
                self.status_bar.config(text=f"Saved: {os.path.basename(file_path)}")
                self.update_file_size()
            except Exception as e:
                messagebox.showerror("Error", f"Could not save file:\n{str(e)}")
                
        def save_all_files(self):
            if self.current_file and self.file_modified:
                self.save_file()
                
        def print_file(self):
            try:
                if sys.platform.startswith('win'):
                    os.startfile(self.current_file, "print")
                else:
                    messagebox.showinfo("Print", "Print functionality not available on this platform")
            except Exception as e:
                messagebox.showerror("Print Error", f"Could not print file:\n{str(e)}")
                
        # Edit operations
        def undo(self):
            try:
                self.text_editor.edit_undo()
            except tk.TclError:
                pass
                
        def redo(self):
            try:
                self.text_editor.edit_redo()
            except tk.TclError:
                pass
                
        def cut_text(self):
            try:
                self.text_editor.event_generate("<<Cut>>")
            except tk.TclError:
                pass
                
        def copy_text(self):
            try:
                self.text_editor.event_generate("<<Copy>>")
            except tk.TclError:
                pass
                
        def paste_text(self):
            try:
                self.text_editor.event_generate("<<Paste>>")
            except tk.TclError:
                pass
                
        def select_all(self):
            self.text_editor.tag_add(tk.SEL, "1.0", tk.END)
            self.text_editor.mark_set(tk.INSERT, "1.0")
            self.text_editor.see(tk.INSERT)
            
        def show_find_replace(self):
            try:
                # Verificăm dacă dialogul există și fereastra nu a fost distrusă
                if self.find_dialog and self.find_dialog.window.winfo_exists():
                    self.find_dialog.window.lift()
                    self.find_dialog.window.focus_force()
                else:
                    # Fereastra a fost închisă -> o recreăm
                    self.find_dialog = FindReplaceDialog(self.root_edt, self.text_editor)
            except AttributeError:
                # Dacă self.find_dialog nu e definit încă
                self.find_dialog = FindReplaceDialog(self.root_edt, self.text_editor)
        '''
        def show_find_replace(self):
            if self.find_dialog:
                self.find_dialog.window.lift()
            else:
                self.find_dialog = FindReplaceDialog(self.root_edt, self.text_editor)
        '''
                
        def goto_line(self):
            line_num = simpledialog.askinteger("Go to Line", "Enter line number:", 
                                              minvalue=1, maxvalue=int(self.text_editor.index('end').split('.')[0]))
            if line_num:
                self.text_editor.mark_set(tk.INSERT, f"{line_num}.0")
                self.text_editor.see(tk.INSERT)
                self.update_cursor_position()
                
        def toggle_bookmark(self):
            current_line = self.text_editor.index(tk.INSERT).split('.')[0]
            bookmark_text = f"Line {current_line}"
            
            if bookmark_text not in self.bookmarks:
                self.bookmarks.append(bookmark_text)
                self.bookmarks_listbox.insert(tk.END, bookmark_text)
                self.status_bar.config(text=f"Bookmark added at line {current_line}")
            else:
                self.bookmarks.remove(bookmark_text)
                for i in range(self.bookmarks_listbox.size()):
                    if self.bookmarks_listbox.get(i) == bookmark_text:
                        self.bookmarks_listbox.delete(i)
                        break
                self.status_bar.config(text=f"Bookmark removed from line {current_line}")
                
        # View operations
        def toggle_line_numbers(self):
            self.show_line_numbers = not self.show_line_numbers
            if self.show_line_numbers:
                self.line_numbers.pack(side=tk.LEFT, fill=tk.Y, before=self.text_editor)
            else:
                self.line_numbers.pack_forget()
                
        def toggle_word_wrap(self):
            self.word_wrap = not self.word_wrap
            self.text_editor.config(wrap=tk.WORD if self.word_wrap else tk.NONE)
            
        def toggle_syntax_highlighting(self):
            self.syntax_highlighting = not self.syntax_highlighting
            if self.syntax_highlighting:
                self.apply_syntax_highlighting()
            else:
                self.clear_syntax_highlighting()
                
        def zoom_in(self):
            self.font_size = min(self.font_size + 1, 24)
            self.update_font()
            
        def zoom_out(self):
            self.font_size = max(self.font_size - 1, 6)
            self.update_font()
            
        def reset_zoom(self):
            self.font_size = 10
            self.update_font()
            
        def update_font(self):
            font = (self.font_family, self.font_size)
            self.text_editor.config(font=font)
            self.line_numbers.config(font=font)
            self.update_line_numbers()
            
        # Format operations
        def format_current(self):
            if not self.current_format:
                self.current_format = self.guess_format_from_content()
                
            if self.current_format == 'JSON':
                self.format_json()
            elif self.current_format == 'XML':
                self.format_xml()
            elif self.current_format == 'CSV':
                self.validate_csv()
            else:
                messagebox.showinfo("Format", "No formatting available for this file type")
                
        def validate_current(self):
            if not self.current_format:
                self.current_format = self.guess_format_from_content()
                
            if self.current_format == 'JSON':
                self.validate_json()
            elif self.current_format == 'XML':
                self.validate_xml()
            elif self.current_format == 'CSV':
                self.validate_csv()
            else:
                messagebox.showinfo("Validate", "No validation available for this file type")
                
        def format_json(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    parsed = json.loads(content)
                    formatted = json.dumps(parsed, indent=2, ensure_ascii=False, sort_keys=True)
                    self.text_editor.delete(1.0, tk.END)
                    self.text_editor.insert(1.0, formatted)
                    self.status_bar.config(text="JSON formatted successfully")
                    self.file_modified = True
                    self.update_title()
                    self.apply_syntax_highlighting()
            except json.JSONDecodeError as e:
                messagebox.showerror("JSON Error", f"Invalid JSON:\n{str(e)}")
                
        def minify_json(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    parsed = json.loads(content)
                    minified = json.dumps(parsed, separators=(',', ':'), ensure_ascii=False)
                    self.text_editor.delete(1.0, tk.END)
                    self.text_editor.insert(1.0, minified)
                    self.status_bar.config(text="JSON minified successfully")
                    self.file_modified = True
                    self.update_title()
            except json.JSONDecodeError as e:
                messagebox.showerror("JSON Error", f"Invalid JSON:\n{str(e)}")
                
        def escape_json(self):
            content = self.text_editor.get(1.0, tk.END).strip()
            if content:
                escaped = json.dumps(content)
                self.text_editor.delete(1.0, tk.END)
                self.text_editor.insert(1.0, escaped)
                self.status_bar.config(text="Text escaped for JSON")
                self.file_modified = True
                self.update_title()
                
        def format_xml(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    root_edt = ET.fromstring(content)
                    rough_string = ET.tostring(root_edt, encoding='unicode')
                    reparsed = xml.dom.minidom.parseString(rough_string)
                    formatted = reparsed.toprettyxml(indent="  ")
                    # Remove empty lines
                    formatted = '\n'.join([line for line in formatted.split('\n') if line.strip()])
                    self.text_editor.delete(1.0, tk.END)
                    self.text_editor.insert(1.0, formatted)
                    self.status_bar.config(text="XML formatted successfully")
                    self.file_modified = True
                    self.update_title()
                    self.apply_syntax_highlighting()
            except ET.ParseError as e:
                messagebox.showerror("XML Error", f"Invalid XML:\n{str(e)}")
                
        def sort_lines(self):
            content = self.text_editor.get(1.0, tk.END)
            lines = content.split('\n')
            lines.sort()
            sorted_content = '\n'.join(lines)
            self.text_editor.delete(1.0, tk.END)
            self.text_editor.insert(1.0, sorted_content)
            self.status_bar.config(text="Lines sorted")
            self.file_modified = True
            self.update_title()
            
        def remove_duplicates(self):
            content = self.text_editor.get(1.0, tk.END)
            lines = content.split('\n')
            unique_lines = list(dict.fromkeys(lines))  # Preserve order
            unique_content = '\n'.join(unique_lines)
            self.text_editor.delete(1.0, tk.END)
            self.text_editor.insert(1.0, unique_content)
            removed_count = len(lines) - len(unique_lines)
            self.status_bar.config(text=f"Removed {removed_count} duplicate lines")
            self.file_modified = True
            self.update_title()
            
        def to_uppercase(self):
            if self.text_editor.tag_ranges(tk.SEL):
                selected_text = self.text_editor.get(tk.SEL_FIRST, tk.SEL_LAST)
                self.text_editor.delete(tk.SEL_FIRST, tk.SEL_LAST)
                self.text_editor.insert(tk.INSERT, selected_text.upper())
            else:
                content = self.text_editor.get(1.0, tk.END)
                self.text_editor.delete(1.0, tk.END)
                self.text_editor.insert(1.0, content.upper())
            self.file_modified = True
            self.update_title()
            
        def to_lowercase(self):
            if self.text_editor.tag_ranges(tk.SEL):
                selected_text = self.text_editor.get(tk.SEL_FIRST, tk.SEL_LAST)
                self.text_editor.delete(tk.SEL_FIRST, tk.SEL_LAST)
                self.text_editor.insert(tk.INSERT, selected_text.lower())
            else:
                content = self.text_editor.get(1.0, tk.END)
                self.text_editor.delete(1.0, tk.END)
                self.text_editor.insert(1.0, content.lower())
            self.file_modified = True
            self.update_title()
            
        # Validation operations
        def validate_json(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    json.loads(content)
                    messagebox.showinfo("Validation", "JSON is valid!")
                    self.status_bar.config(text="JSON validation successful")
                else:
                    messagebox.showwarning("Validation", "No content to validate")
            except json.JSONDecodeError as e:
                messagebox.showerror("JSON Error", f"Invalid JSON:\n{str(e)}")
                
        def validate_xml(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    ET.fromstring(content)
                    messagebox.showinfo("Validation", "XML is valid!")
                    self.status_bar.config(text="XML validation successful")
                else:
                    messagebox.showwarning("Validation", "No content to validate")
            except ET.ParseError as e:
                messagebox.showerror("XML Error", f"Invalid XML:\n{str(e)}")
                
        def validate_csv(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    lines = content.split('\n')
                    reader = csv.reader(lines)
                    rows = list(reader)
                    
                    if rows:
                        col_count = len(rows[0]) if rows[0] else 0
                        inconsistent_rows = []
                        
                        for i, row in enumerate(rows):
                            if len(row) != col_count:
                                inconsistent_rows.append(i + 1)
                        
                        if inconsistent_rows:
                            messagebox.showwarning(
                                "CSV Validation", 
                                f"CSV has inconsistent column counts.\n"
                                f"Expected {col_count} columns.\n"
                                f"Inconsistent rows: {', '.join(map(str, inconsistent_rows[:10]))}"
                                + ("..." if len(inconsistent_rows) > 10 else "")
                            )
                        else:
                            messagebox.showinfo(
                                "CSV Validation", 
                                f"CSV is valid!\n"
                                f"Rows: {len(rows)}\n"
                                f"Columns: {col_count}"
                            )
                        self.status_bar.config(text=f"CSV validation complete - {len(rows)} rows, {col_count} columns")
                    else:
                        messagebox.showwarning("Validation", "CSV appears to be empty")
                else:
                    messagebox.showwarning("Validation", "No content to validate")
            except Exception as e:
                messagebox.showerror("CSV Error", f"Error parsing CSV:\n{str(e)}")
                
        # Tools operations
        def view_csv_table(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content and self.current_format == 'CSV':
                    lines = content.split('\n')
                    reader = csv.reader(lines)
                    data = list(reader)
                    if data:
                        CSVViewer(self.root_edt, data)
                    else:
                        messagebox.showwarning("CSV Viewer", "No data to display")
                else:
                    messagebox.showwarning("CSV Viewer", "Current file is not a CSV or is empty")
            except Exception as e:
                messagebox.showerror("CSV Viewer Error", f"Error displaying CSV:\n{str(e)}")
                
        def json_to_csv(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    data = json.loads(content)
                    if isinstance(data, list) and data and isinstance(data[0], dict):
                        # Convert list of dictionaries to CSV
                        fieldnames = data[0].keys()
                        csv_content = []
                        csv_content.append(','.join(fieldnames))
                        
                        for item in data:
                            row = []
                            for field in fieldnames:
                                value = str(item.get(field, ''))
                                if ',' in value or '"' in value or '\n' in value:
                                    value = '"' + value.replace('"', '""') + '"'
                                row.append(value)
                            csv_content.append(','.join(row))
                        
                        result = '\n'.join(csv_content)
                        self.text_editor.delete(1.0, tk.END)
                        self.text_editor.insert(1.0, result)
                        self.current_format = 'CSV'
                        self.update_format_display()
                        self.status_bar.config(text="JSON converted to CSV")
                        self.file_modified = True
                        self.update_title()
                    else:
                        messagebox.showerror("Conversion Error", "JSON must be an array of objects to convert to CSV")
            except json.JSONDecodeError as e:
                messagebox.showerror("JSON Error", f"Invalid JSON:\n{str(e)}")
            except Exception as e:
                messagebox.showerror("Conversion Error", f"Error converting JSON to CSV:\n{str(e)}")
                
        def csv_to_json(self):
            try:
                content = self.text_editor.get(1.0, tk.END).strip()
                if content:
                    lines = content.split('\n')
                    reader = csv.DictReader(lines)
                    data = list(reader)
                    json_content = json.dumps(data, indent=2, ensure_ascii=False)
                    
                    self.text_editor.delete(1.0, tk.END)
                    self.text_editor.insert(1.0, json_content)
                    self.current_format = 'JSON'
                    self.update_format_display()
                    self.apply_syntax_highlighting()
                    self.status_bar.config(text="CSV converted to JSON")
                    self.file_modified = True
                    self.update_title()
            except Exception as e:
                messagebox.showerror("Conversion Error", f"Error converting CSV to JSON:\n{str(e)}")
                
        def count_stats(self):
            content = self.text_editor.get(1.0, tk.END)
            
            # Count statistics
            char_count = len(content) - 1  # Subtract 1 for the automatic newline
            char_count_no_spaces = len(content.replace(' ', '').replace('\t', '').replace('\n', ''))
            word_count = len(content.split())
            line_count = content.count('\n')
            paragraph_count = len([p for p in content.split('\n\n') if p.strip()])
            
            stats_message = f"""Document Statistics:
            
    Characters (with spaces): {char_count}
    Characters (without spaces): {char_count_no_spaces}
    Words: {word_count}
    Lines: {line_count}
    Paragraphs: {paragraph_count}"""
            
            messagebox.showinfo("Document Statistics", stats_message)
            
        def show_encode_decode(self):
            # Simple encode/decode dialog
            encode_window = tk.Toplevel(self.root_edt)
            encode_window.title("Encode/Decode")
            encode_window.geometry("500x400")
            encode_window.configure(bg="#c0c0c0")
            encode_window.transient(self.root_edt)
            
            # Input text
            tk.Label(encode_window, text="Input:", bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=5)
            input_text = scrolledtext.ScrolledText(encode_window, height=8, bg="white")
            input_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            # Buttons
            btn_frame = tk.Frame(encode_window, bg="#c0c0c0")
            btn_frame.pack(fill=tk.X, padx=10, pady=5)
            
            def base64_encode():
                import base64
                text = input_text.get(1.0, tk.END).strip()
                encoded = base64.b64encode(text.encode()).decode()
                output_text.delete(1.0, tk.END)
                output_text.insert(1.0, encoded)
                
            def base64_decode():
                import base64
                try:
                    text = input_text.get(1.0, tk.END).strip()
                    decoded = base64.b64decode(text.encode()).decode()
                    output_text.delete(1.0, tk.END)
                    output_text.insert(1.0, decoded)
                except Exception as e:
                    messagebox.showerror("Decode Error", f"Could not decode: {str(e)}")
                    
            def url_encode():
                import urllib.parse
                text = input_text.get(1.0, tk.END).strip()
                encoded = urllib.parse.quote(text)
                output_text.delete(1.0, tk.END)
                output_text.insert(1.0, encoded)
                
            def url_decode():
                import urllib.parse
                text = input_text.get(1.0, tk.END).strip()
                decoded = urllib.parse.unquote(text)
                output_text.delete(1.0, tk.END)
                output_text.insert(1.0, decoded)
            
            btn_style = {"bg": "#c0c0c0", "relief": tk.RAISED, "bd": 2, "padx": 8}
            
            tk.Button(btn_frame, text="Base64 Encode", command=base64_encode, **btn_style).pack(side=tk.LEFT, padx=2)
            tk.Button(btn_frame, text="Base64 Decode", command=base64_decode, **btn_style).pack(side=tk.LEFT, padx=2)
            tk.Button(btn_frame, text="URL Encode", command=url_encode, **btn_style).pack(side=tk.LEFT, padx=2)
            tk.Button(btn_frame, text="URL Decode", command=url_decode, **btn_style).pack(side=tk.LEFT, padx=2)
            
            # Output text
            tk.Label(encode_window, text="Output:", bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=(10,5))
            output_text = scrolledtext.ScrolledText(encode_window, height=8, bg="white")
            output_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
        # Settings operations
        def change_font(self):
            # Simple font dialog
            fonts = ["Courier New", "Arial", "Times New Roman", "Consolas", "Monaco", "Lucida Console"]
            
            font_window = tk.Toplevel(self.root_edt)
            font_window.title("Font Settings")
            font_window.geometry("300x250")
            font_window.configure(bg="#c0c0c0")
            font_window.transient(self.root_edt)
            
            tk.Label(font_window, text="Font Family:", bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=5)
            font_var = tk.StringVar(value=self.font_family)
            font_listbox = tk.Listbox(font_window, height=6)
            for font in fonts:
                font_listbox.insert(tk.END, font)
                if font == self.font_family:
                    font_listbox.selection_set(font_listbox.size()-1)
            font_listbox.pack(fill=tk.X, padx=10, pady=5)
            
            tk.Label(font_window, text="Font Size:", bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=5)
            size_var = tk.IntVar(value=self.font_size)
            size_spinbox = tk.Spinbox(font_window, from_=6, to=24, textvariable=size_var, width=10)
            size_spinbox.pack(anchor=tk.W, padx=10, pady=5)
            
            def apply_font():
                selection = font_listbox.curselection()
                if selection:
                    self.font_family = font_listbox.get(selection[0])
                    self.font_size = size_var.get()
                    self.update_font()
                    font_window.destroy()
            
            btn_frame = tk.Frame(font_window, bg="#c0c0c0")
            btn_frame.pack(fill=tk.X, padx=10, pady=10)
            
            btn_style = {"bg": "#c0c0c0", "relief": tk.RAISED, "bd": 2, "padx": 10}
            tk.Button(btn_frame, text="Apply", command=apply_font, **btn_style).pack(side=tk.LEFT, padx=5)
            tk.Button(btn_frame, text="Cancel", command=font_window.destroy, **btn_style).pack(side=tk.LEFT, padx=5)
            
        def change_colors(self):
            color = colorchooser.askcolor(title="Choose Background Color")
            if color[1]:
                self.text_editor.config(bg=color[1])
                
        def change_tab_size(self):
            new_size = simpledialog.askinteger("Tab Size", "Enter tab size (2-8):", 
                                              minvalue=2, maxvalue=8, initialvalue=self.tab_size)
            if new_size:
                self.tab_size = new_size
                
        def show_preferences(self):
            pref_window = tk.Toplevel(self.root_edt)
            pref_window.title("Preferences")
            pref_window.geometry("400x300")
            pref_window.configure(bg="#c0c0c0")
            pref_window.transient(self.root_edt)
            
            # Create notebook for preference categories
            notebook = ttk.Notebook(pref_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # General tab
            general_frame = tk.Frame(notebook, bg="#c0c0c0")
            notebook.add(general_frame, text="General")
            
            line_num_var = tk.BooleanVar(value=self.show_line_numbers)
            word_wrap_var = tk.BooleanVar(value=self.word_wrap)
            syntax_var = tk.BooleanVar(value=self.syntax_highlighting)
            
            tk.Checkbutton(general_frame, text="Show line numbers", variable=line_num_var, bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=5)
            tk.Checkbutton(general_frame, text="Word wrap", variable=word_wrap_var, bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=5)
            tk.Checkbutton(general_frame, text="Syntax highlighting", variable=syntax_var, bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=5)
            
            # Editor tab
            editor_frame = tk.Frame(notebook, bg="#c0c0c0")
            notebook.add(editor_frame, text="Editor")
            
            tk.Label(editor_frame, text="Tab size:", bg="#c0c0c0").pack(anchor=tk.W, padx=10, pady=5)
            tab_var = tk.IntVar(value=self.tab_size)
            tk.Spinbox(editor_frame, from_=2, to=8, textvariable=tab_var, width=10).pack(anchor=tk.W, padx=10, pady=5)
            
            def apply_preferences():
                self.show_line_numbers = line_num_var.get()
                self.word_wrap = word_wrap_var.get()
                self.syntax_highlighting = syntax_var.get()
                self.tab_size = tab_var.get()
                
                self.toggle_line_numbers() if self.show_line_numbers != bool(self.line_numbers.winfo_viewable()) else None
                self.text_editor.config(wrap=tk.WORD if self.word_wrap else tk.NONE)
                
                if self.syntax_highlighting:
                    self.apply_syntax_highlighting()
                else:
                    self.clear_syntax_highlighting()
                    
                pref_window.destroy()
            
            btn_frame = tk.Frame(pref_window, bg="#c0c0c0")
            btn_frame.pack(fill=tk.X, padx=10, pady=10)
            
            btn_style = {"bg": "#c0c0c0", "relief": tk.RAISED, "bd": 2, "padx": 10}
            tk.Button(btn_frame, text="Apply", command=apply_preferences, **btn_style).pack(side=tk.LEFT, padx=5)
            tk.Button(btn_frame, text="Cancel", command=pref_window.destroy, **btn_style).pack(side=tk.LEFT, padx=5)
            
        # Help operations
        def show_shortcuts(self):
            shortcuts_text = """Keyboard Shortcuts:

    File Operations:
    Ctrl+N - New File
    Ctrl+O - Open File
    Ctrl+S - Save File
    Ctrl+Shift+S - Save As
    Ctrl+P - Print

    Edit Operations:
    Ctrl+Z - Undo
    Ctrl+Y - Redo
    Ctrl+X - Cut
    Ctrl+C - Copy
    Ctrl+V - Paste
    Ctrl+A - Select All
    Ctrl+H - Find & Replace
    Ctrl+G - Go to Line
    Ctrl+B - Toggle Bookmark

    View Operations:
    Ctrl++ - Zoom In
    Ctrl+- - Zoom Out
    Ctrl+0 - Reset Zoom"""
            
            messagebox.showinfo("Keyboard Shortcuts", shortcuts_text)
            
        def show_about(self):
            about_text = """Multi-Format File Editor

    Version 2.0

    Supports: CSV, XML, JSON, Markdown, and Text files

    Features:
    • Syntax highlighting
    • File validation and formatting
    • Find and replace
    • Format conversion
    • Line numbers and bookmarks
    • Encoding/decoding tools
    """
            
            messagebox.showinfo("About", about_text)
            
        # Utility methods
        def detect_format(self, file_path):
            ext = os.path.splitext(file_path)[1].lower()
            format_map = {
                '.csv': 'CSV',
                '.json': 'JSON',
                '.xml': 'XML',
                '.md': 'Markdown',
                '.txt': 'Text'
            }
            return format_map.get(ext, 'Unknown')
            
        def guess_format_from_content(self):
            content = self.text_editor.get(1.0, tk.END).strip()
            if not content:
                return 'Unknown'
                
            # Try JSON
            try:
                json.loads(content)
                return 'JSON'
            except:
                pass
                
            # Try XML
            try:
                ET.fromstring(content)
                return 'XML'
            except:
                pass
                
            # Check for CSV patterns
            lines = content.split('\n')
            if len(lines) > 1:
                first_line_commas = lines[0].count(',')
                if first_line_commas > 0:
                    # Check if other lines have similar comma count
                    similar_count = 0
                    for line in lines[1:5]:  # Check first few lines
                        if abs(line.count(',') - first_line_commas) <= 1:
                            similar_count += 1
                    if similar_count >= len(lines[1:5]) * 0.7:  # 70% similarity
                        return 'CSV'
                        
            return 'Text'
            
        def update_title(self):
            title = "Advanced Multi-Format File Editor"
            if self.current_file:
                title += f" - {os.path.basename(self.current_file)}"
            if self.file_modified:
                title += " *"
            self.root_edt.title(title)
            
        def update_format_display(self):
            format_text = f"Format: {self.current_format or 'Unknown'}"
            self.format_label.config(text=format_text)
            
        def update_line_numbers(self, event=None):
            if not self.show_line_numbers:
                return
                
            line_count = int(self.text_editor.index('end-1c').split('.')[0])
            line_numbers_content = '\n'.join(str(i) for i in range(1, line_count + 1))
            
            self.line_numbers.config(state='normal')
            self.line_numbers.delete(1.0, tk.END)
            self.line_numbers.insert(1.0, line_numbers_content)
            self.line_numbers.config(state='disabled')
            
        def update_cursor_position(self, event=None):
            cursor_pos = self.text_editor.index(tk.INSERT)
            line, col = cursor_pos.split('.')
            self.line_col_label.config(text=f"Ln {line}, Col {int(col) + 1}")
            
        def update_file_size(self):
            content = self.text_editor.get(1.0, tk.END)
            size = len(content.encode('utf-8')) - 1  # Subtract 1 for automatic newline
            if size < 1024:
                size_text = f"{size} bytes"
            elif size < 1024 * 1024:
                size_text = f"{size / 1024:.1f} KB"
            else:
                size_text = f"{size / (1024 * 1024):.1f} MB"
            self.file_size_label.config(text=size_text)
            
        def on_text_change(self, event=None):
            self.file_modified = True
            self.update_title()
            self.update_line_numbers()
            self.update_cursor_position()
            self.update_file_size()
            
            # Apply syntax highlighting after a short delay
            if self.syntax_highlighting:
                self.root_edt.after(100, self.apply_syntax_highlighting)
                
        def on_mousewheel(self, event):
            # Sync line numbers scrolling with text editor
            if self.show_line_numbers:
                self.line_numbers.yview_scroll(int(-1 * (event.delta / 120)), "units")
                
        def apply_syntax_highlighting(self):
            if not self.syntax_highlighting or not self.current_format:
                return
                
            content = self.text_editor.get(1.0, tk.END)
            
            # Clear existing tags
            self.clear_syntax_highlighting()
            
            if self.current_format == 'JSON':
                self.highlight_json(content)
            elif self.current_format == 'XML':
                self.highlight_xml(content)
                
        def clear_syntax_highlighting(self):
            for tag in ['json_key', 'json_string', 'json_number', 'json_keyword',
                       'xml_tag', 'xml_attribute', 'xml_value']:
                self.text_editor.tag_remove(tag, 1.0, tk.END)
                
        def highlight_json(self, content):
            # Simple JSON syntax highlighting using regex
            import re
            
            # Highlight strings (keys and values)
            for match in re.finditer(r'"([^"\\]|\\.)*"', content):
                start_pos = f"1.0+{match.start()}c"
                end_pos = f"1.0+{match.end()}c"
                # Check if it's a key (followed by :)
                if match.end() < len(content) and content[match.end():].lstrip().startswith(':'):
                    self.text_editor.tag_add('json_key', start_pos, end_pos)
                else:
                    self.text_editor.tag_add('json_string', start_pos, end_pos)
                    
            # Highlight numbers
            for match in re.finditer(r'-?\d+\.?\d*', content):
                start_pos = f"1.0+{match.start()}c"
                end_pos = f"1.0+{match.end()}c"
                self.text_editor.tag_add('json_number', start_pos, end_pos)
                
            # Highlight keywords
            for match in re.finditer(r'\b(true|false|null)\b', content):
                start_pos = f"1.0+{match.start()}c"
                end_pos = f"1.0+{match.end()}c"
                self.text_editor.tag_add('json_keyword', start_pos, end_pos)
                
        def highlight_xml(self, content):
            # Simple XML syntax highlighting using regex
            import re
            
            # Highlight tags
            for match in re.finditer(r'<[^>]+>', content):
                start_pos = f"1.0+{match.start()}c"
                end_pos = f"1.0+{match.end()}c"
                self.text_editor.tag_add('xml_tag', start_pos, end_pos)
                
            # Highlight attributes
            for match in re.finditer(r'\w+="[^"]*"', content):
                start_pos = f"1.0+{match.start()}c"
                end_pos = f"1.0+{match.end()}c"
                self.text_editor.tag_add('xml_attribute', start_pos, end_pos)
                
        # File browser operations
        def browse_directory(self):
            directory = filedialog.askdirectory(initialdir=self.current_dir.get())
            if directory:
                self.current_dir.set(directory)
                self.refresh_file_browser()
                
        def refresh_file_browser(self):
            self.file_listbox.delete(0, tk.END)
            
            try:
                directory = self.current_dir.get()
                if not os.path.exists(directory):
                    return
                    
                # Add parent directory option
                if directory != os.path.dirname(directory):
                    self.file_listbox.insert(tk.END, "..")
                    
                # List directories first
                items = []
                for item in os.listdir(directory):
                    path = os.path.join(directory, item)
                    if os.path.isdir(path):
                        items.append(('dir', item))
                    elif item.endswith(('.csv', '.json', '.xml', '.md', '.txt')):
                        items.append(('file', item))
                        
                # Sort items
                items.sort(key=lambda x: (x[0], x[1].lower()))
                
                for item_type, item_name in items:
                    display_name = f"[{item_name}]" if item_type == 'dir' else item_name
                    self.file_listbox.insert(tk.END, display_name)
                    
            except PermissionError:
                messagebox.showerror("Error", "Permission denied accessing directory")
            except Exception as e:
                messagebox.showerror("Error", f"Error listing directory: {str(e)}")
                
        def open_from_browser(self, event):
            selection = self.file_listbox.curselection()
            if not selection:
                return
                
            item = self.file_listbox.get(selection[0])
            
            if item == "..":
                # Go to parent directory
                parent = os.path.dirname(self.current_dir.get())
                self.current_dir.set(parent)
                self.refresh_file_browser()
            elif item.startswith("[") and item.endswith("]"):
                # It's a directory
                dir_name = item[1:-1]
                new_path = os.path.join(self.current_dir.get(), dir_name)
                self.current_dir.set(new_path)
                self.refresh_file_browser()
            else:
                # It's a file
                file_path = os.path.join(self.current_dir.get(), item)
                if self.file_modified and not self.ask_save_changes():
                    return
                self.load_file(file_path)
                
        # Bookmark operations
        def goto_bookmark(self):
            selection = self.bookmarks_listbox.curselection()
            if selection:
                bookmark = self.bookmarks_listbox.get(selection[0])
                line_num = bookmark.split()[1]  # Extract line number from "Line X"
                self.text_editor.mark_set(tk.INSERT, f"{line_num}.0")
                self.text_editor.see(tk.INSERT)
                self.update_cursor_position()
                
        def delete_bookmark(self):
            selection = self.bookmarks_listbox.curselection()
            if selection:
                bookmark = self.bookmarks_listbox.get(selection[0])
                self.bookmarks.remove(bookmark)
                self.bookmarks_listbox.delete(selection[0])
                
        # Recent files operations
        def add_to_recent_files(self, file_path):
            if file_path in self.recent_files:
                self.recent_files.remove(file_path)
            self.recent_files.insert(0, file_path)
            self.recent_files = self.recent_files[:10]  # Keep only 10 recent files
            self.update_recent_menu()
            
        def update_recent_menu(self):
            self.recent_menu.delete(0, tk.END)
            for file_path in self.recent_files:
                self.recent_menu.add_command(
                    label=os.path.basename(file_path),
                    command=lambda f=file_path: self.load_file(f)
                )
                
        def ask_save_changes(self):
            if self.file_modified:
                result = messagebox.askyesnocancel(
                    "Save Changes",
                    "Do you want to save changes to the current file?"
                )
                if result is True:
                    self.save_file()
                    return True
                elif result is False:
                    return True
                else:
                    return False
            return True
            
        def load_settings(self):
            # Load settings from file if it exists
            settings_file = "editor_settings.json"
            try:
                if os.path.exists(settings_file):
                    with open(settings_file, 'r') as f:
                        settings = json.load(f)
                        self.font_family = settings.get('font_family', self.font_family)
                        self.font_size = settings.get('font_size', self.font_size)
                        self.show_line_numbers = settings.get('show_line_numbers', self.show_line_numbers)
                        self.word_wrap = settings.get('word_wrap', self.word_wrap)
                        self.syntax_highlighting = settings.get('syntax_highlighting', self.syntax_highlighting)
                        self.recent_files = settings.get('recent_files', [])
                        self.update_recent_menu()
            except Exception:
                pass  # Ignore errors loading settings
                
        def save_settings(self):
            # Save settings to file
            settings_file = "editor_settings.json"
            try:
                settings = {
                    'font_family': self.font_family,
                    'font_size': self.font_size,
                    'show_line_numbers': self.show_line_numbers,
                    'word_wrap': self.word_wrap,
                    'syntax_highlighting': self.syntax_highlighting,
                    'recent_files': self.recent_files
                }
                with open(settings_file, 'w') as f:
                    json.dump(settings, f, indent=2)
            except Exception:
                pass  # Ignore errors saving settings
                
        def exit_application(self):
            if self.ask_save_changes():
                self.save_settings()
                self.root_edt.quit()


    def main():
        root_edt = tk.Tk()
        app = Win95FileEditor(root_edt)
        root_edt.mainloop()


    if __name__ == "__main__":
        main()
        
if safevar == 444555000888:
    import tempfile
    import psutil
    from datetime import datetime, timedelta

    # Try to import winreg for Windows registry access
    try:
        import winreg
        WINREG_AVAILABLE = True
    except ImportError:
        WINREG_AVAILABLE = False

    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class UnifiedSecurityTool:
        def __init__(self, root_safe):
            self.root_safe = root_safe
            self.root_safe.title("Unified Security Testing & Vulnerability Scanner v2.0")
            self.root_safe.geometry("900x700")
            self.root_safe.configure(bg='#c0c0c0')
            
            # Set Windows 95 style
            self.setup_styles()
            
            # Variables
            self.is_testing = False
            self.scan_running = False
            self.test_results = []
            self.scan_results = {}
            
            # Create GUI
            self.create_widgets()
            
        def setup_styles(self):
            """Setup Windows 95 style appearance"""
            style = ttk.Style()
            style.theme_use('clam')
            
            # Configure colors to match Windows 95
            self.colors = {
                'bg': '#c0c0c0',
                'button': '#c0c0c0',
                'pressed': '#808080',
                'text': '#000000',
                'highlight': '#0000ff',
                'window': '#ffffff'
            }
            
            style.configure('Title.TLabel', 
                           background=self.colors['bg'], 
                           foreground=self.colors['text'],
                           font=('MS Sans Serif', 12, 'bold'))
            
            style.configure('W95.TButton',
                           background=self.colors['button'],
                           foreground=self.colors['text'],
                           font=('MS Sans Serif', 8))
            
            style.configure('W95.TFrame',
                           background=self.colors['bg'],
                           relief='raised',
                           borderwidth=2)
            
        def create_widgets(self):
            """Create the main GUI widgets"""
            # Title
            title_frame = tk.Frame(self.root_safe, bg=self.colors['bg'], relief='raised', bd=2)
            title_frame.pack(fill='x', padx=5, pady=5)
            
            title_label = tk.Label(title_frame, 
                                  text="Unified Security Testing & Vulnerability Scanner", 
                                  bg=self.colors['bg'], 
                                  fg='#000080',
                                  font=('MS Sans Serif', 14, 'bold'))
            title_label.pack(pady=5)
            
            # Create notebook for tabs
            self.notebook = ttk.Notebook(self.root_safe)
            self.notebook.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Create tabs
            self.create_security_tests_tab()
            self.create_vulnerability_scanner_tab()
            
            # Status bar
            self.status_bar = tk.Label(self.root_safe, 
                                      text="Ready", 
                                      bg=self.colors['bg'], 
                                      relief='sunken', 
                                      bd=1,
                                      anchor='w',
                                      font=('MS Sans Serif', 8))
            self.status_bar.pack(side='bottom', fill='x')
            
        def create_security_tests_tab(self):
            """Create security tests tab"""
            tests_frame = tk.Frame(self.notebook, bg=self.colors['bg'])
            self.notebook.add(tests_frame, text="Security Tests")
            
            # Main container
            main_frame = tk.Frame(tests_frame, bg=self.colors['bg'])
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Left panel - Test options
            left_frame = tk.Frame(main_frame, bg=self.colors['bg'], relief='sunken', bd=2)
            left_frame.pack(side='left', fill='y', padx=(0, 5))
            
            test_label = tk.Label(left_frame, 
                                 text="Test Categories", 
                                 bg=self.colors['bg'], 
                                 font=('MS Sans Serif', 10, 'bold'))
            test_label.pack(pady=5)
            
            # Test buttons
            self.create_test_buttons(left_frame)
            
            # Right panel - Results
            right_frame = tk.Frame(main_frame, bg=self.colors['bg'], relief='sunken', bd=2)
            right_frame.pack(side='right', fill='both', expand=True)
            
            results_label = tk.Label(right_frame, 
                                    text="Test Results", 
                                    bg=self.colors['bg'], 
                                    font=('MS Sans Serif', 10, 'bold'))
            results_label.pack(pady=5)
            
            # Results text area
            self.tests_results_text = scrolledtext.ScrolledText(right_frame, 
                                                               width=50, 
                                                               height=25,
                                                               bg='white',
                                                               fg='black',
                                                               font=('Courier New', 9))
            self.tests_results_text.pack(fill='both', expand=True, padx=5, pady=5)
            
        def create_vulnerability_scanner_tab(self):
            """Create vulnerability scanner tab"""
            scanner_frame = tk.Frame(self.notebook, bg=self.colors['bg'])
            self.notebook.add(scanner_frame, text="Vulnerability Scanner")
            
            # Main container
            main_frame = tk.Frame(scanner_frame, bg=self.colors['bg'])
            main_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Left panel - Scan options
            left_frame = tk.Frame(main_frame, bg=self.colors['bg'], relief='sunken', bd=2)
            left_frame.pack(side='left', fill='y', padx=(0, 5))
            
            scan_label = tk.Label(left_frame, text="Scan Options", 
                                 font=('MS Sans Serif', 10, 'bold'),
                                 bg=self.colors['bg'])
            scan_label.pack(pady=10)
            
            # Checkboxes for scan types
            self.scan_options = {}
            scan_types = [
                ("System Info", "system_info"),
                ("Open Ports", "open_ports"),
                ("Running Services", "services"),
                ("User Accounts", "users"),
                ("Registry Security", "registry"),
                ("Network Config", "network"),
                ("Firewall Status", "firewall"),
                ("Antivirus Check", "antivirus"),
                ("Updates Check", "updates"),
                ("Weak Passwords", "passwords")
            ]
            
            for text, key in scan_types:
                var = tk.BooleanVar(value=True)
                self.scan_options[key] = var
                cb = tk.Checkbutton(left_frame, text=text, variable=var,
                                   bg=self.colors['bg'], anchor='w')
                cb.pack(fill='x', padx=10, pady=2)
            
            # Scan button
            scan_btn = tk.Button(left_frame, text="Start Scan", 
                                command=self.start_vulnerability_scan,
                                bg=self.colors['button'], relief='raised', bd=2,
                                font=('MS Sans Serif', 10, 'bold'))
            scan_btn.pack(pady=20, padx=10, fill='x')
            
            # Clear button
            clear_scan_btn = tk.Button(left_frame, text="Clear Results", 
                                      command=self.clear_scan_results,
                                      bg=self.colors['button'], relief='raised', bd=2)
            clear_scan_btn.pack(pady=5, padx=10, fill='x')
            
            # Right panel - Results
            right_frame = tk.Frame(main_frame, bg=self.colors['bg'])
            right_frame.pack(side='right', fill='both', expand=True)
            
            # Results label
            results_label = tk.Label(right_frame, text="Scan Results", 
                                    font=('MS Sans Serif', 10, 'bold'),
                                    bg=self.colors['bg'])
            results_label.pack(pady=(10, 5))
            
            # Results text area with scrollbar
            results_frame = tk.Frame(right_frame, relief='sunken', bd=2)
            results_frame.pack(fill='both', expand=True, padx=5, pady=5)
            
            self.scan_results_text = scrolledtext.ScrolledText(results_frame, 
                                                              bg=self.colors['window'],
                                                              font=('Courier New', 9),
                                                              wrap='word')
            self.scan_results_text.pack(fill='both', expand=True)
            
        def create_test_buttons(self, parent):
            """Create test category buttons"""
            buttons = [
                ("File Tests", self.run_file_tests),
                ("Network Tests", self.run_network_tests),
                ("Process Tests", self.run_process_tests),
                ("Registry Tests", self.run_registry_tests),
                ("Behavior Tests", self.run_behavior_tests),
                ("EICAR Test", self.run_eicar_test),
                ("Clear Results", self.clear_test_results),
                ("Save Report", self.save_test_report)
            ]
            
            for text, command in buttons:
                btn = tk.Button(parent, 
                               text=text,
                               command=command,
                               bg=self.colors['button'],
                               fg='black',
                               font=('MS Sans Serif', 8),
                               width=15,
                               relief='raised',
                               bd=2)
                btn.pack(pady=2, padx=5)
                
        def log_test_result(self, message):
            """Log a test result"""
            timestamp = datetime.now().strftime("%H:%M:%S")
            formatted_message = f"[{timestamp}] {message}\n"
            self.tests_results_text.insert(tk.END, formatted_message)
            self.tests_results_text.see(tk.END)
            self.root_safe.update()
            
        def add_scan_result(self, text, style="normal"):
            """Add scan result with optional styling"""
            self.scan_results_text.insert('end', text)
            self.scan_results_text.see('end')
            self.root_safe.update_idletasks()
            
        def update_status(self, status):
            """Update status bar"""
            self.status_bar.config(text=status)
            self.root_safe.update()
            
        # Security Tests Methods
        def run_file_tests(self):
            """Run safe file-based tests"""
            if self.is_testing:
                return
                
            self.is_testing = True
            self.update_status("Running file tests...")
            
            def file_test_thread():
                try:
                    self.log_test_result("=== FILE TESTS STARTED ===")
                    
                    # Test 1: Create suspicious filename
                    self.log_test_result("Test 1: Creating suspicious filename...")
                    temp_dir = tempfile.gettempdir()
                    suspicious_names = [
                        "virus.exe.txt",
                        "trojan_test.safe",
                        "keylogger_simulation.txt",
                        "suspicious_script.bat.txt"
                    ]
                    
                    for name in suspicious_names:
                        try:
                            file_path = os.path.join(temp_dir, name)
                            with open(file_path, 'w') as f:
                                f.write("# This is a safe test file\n")
                                f.write("# Created by Security Test Suite\n")
                                f.write("# No malicious content\n")
                            self.log_test_result(f"  Created: {name}")
                            time.sleep(0.5)
                            os.remove(file_path)  # Clean up
                            self.log_test_result(f"  Cleaned: {name}")
                        except Exception as e:
                            self.log_test_result(f"  Error with {name}: {str(e)}")
                    
                    # Test 2: Multiple file creation
                    self.log_test_result("Test 2: Rapid file creation test...")
                    for i in range(10):
                        try:
                            file_path = os.path.join(temp_dir, f"test_file_{i}.tmp")
                            with open(file_path, 'w') as f:
                                f.write(f"Test file {i}\n")
                            time.sleep(0.1)
                            os.remove(file_path)
                        except Exception as e:
                            self.log_test_result(f"  Error in rapid creation: {str(e)}")
                    
                    self.log_test_result("Test 2: Rapid file creation completed")
                    
                    # Test 3: Large file creation
                    self.log_test_result("Test 3: Large file creation test...")
                    try:
                        large_file = os.path.join(temp_dir, "large_test_file.tmp")
                        with open(large_file, 'w') as f:
                            for i in range(1000):
                                f.write(f"This is line {i} of the large test file\n")
                        file_size = os.path.getsize(large_file)
                        self.log_test_result(f"  Created large file: {file_size} bytes")
                        os.remove(large_file)
                        self.log_test_result("  Large file cleaned up")
                    except Exception as e:
                        self.log_test_result(f"  Large file test error: {str(e)}")
                    
                    self.log_test_result("=== FILE TESTS COMPLETED ===")
                    
                except Exception as e:
                    self.log_test_result(f"File tests error: {str(e)}")
                finally:
                    self.is_testing = False
                    self.update_status("File tests completed")
            
            threading.Thread(target=file_test_thread, daemon=True).start()
            
        def run_network_tests(self):
            """Run safe network-based tests"""
            if self.is_testing:
                return
                
            self.is_testing = True
            self.update_status("Running network tests...")
            
            def network_test_thread():
                try:
                    self.log_test_result("=== NETWORK TESTS STARTED ===")
                    
                    # Test 1: DNS lookups
                    self.log_test_result("Test 1: DNS lookup test...")
                    test_domains = ["google.com", "microsoft.com", "github.com"]
                    
                    for domain in test_domains:
                        try:
                            ip = socket.gethostbyname(domain)
                            self.log_test_result(f"  {domain} -> {ip}")
                            time.sleep(0.5)
                        except Exception as e:
                            self.log_test_result(f"  DNS lookup failed for {domain}: {str(e)}")
                    
                    # Test 2: Port connectivity check
                    self.log_test_result("Test 2: Port connectivity test...")
                    test_ports = [80, 443, 53, 25]
                    
                    for port in test_ports:
                        try:
                            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            sock.settimeout(2)
                            result = sock.connect_ex(("google.com", port))
                            if result == 0:
                                self.log_test_result(f"  Port {port}: Open")
                            else:
                                self.log_test_result(f"  Port {port}: Closed/Filtered")
                            sock.close()
                            time.sleep(0.3)
                        except Exception as e:
                            self.log_test_result(f"  Port {port} test error: {str(e)}")
                    
                    self.log_test_result("=== NETWORK TESTS COMPLETED ===")
                    
                except Exception as e:
                    self.log_test_result(f"Network tests error: {str(e)}")
                finally:
                    self.is_testing = False
                    self.update_status("Network tests completed")
            
            threading.Thread(target=network_test_thread, daemon=True).start()
            
        def run_process_tests(self):
            """Run safe process-based tests"""
            if self.is_testing:
                return
                
            self.is_testing = True
            self.update_status("Running process tests...")
            
            def process_test_thread():
                try:
                    self.log_test_result("=== PROCESS TESTS STARTED ===")
                    
                    # Test 1: Current process info
                    self.log_test_result("Test 1: Process information...")
                    self.log_test_result(f"  Current PID: {os.getpid()}")
                    self.log_test_result(f"  Python executable: {sys.executable}")
                    
                    # Test 2: System command execution (safe)
                    self.log_test_result("Test 2: Safe system commands...")
                    safe_commands = [
                        ["python", "--version"],
                        ["echo", "Security test message"]
                    ]
                    
                    if os.name == 'nt':  # Windows
                        safe_commands = [
                            ["cmd", "/c", "echo", "Security test message"],
                            ["cmd", "/c", "ver"]
                        ]
                    
                    for cmd in safe_commands:
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
                            self.log_test_result(f"  Command: {' '.join(cmd)}")
                            self.log_test_result(f"  Output: {result.stdout.strip()}")
                            time.sleep(0.5)
                        except Exception as e:
                            self.log_test_result(f"  Command failed: {str(e)}")
                    
                    # Test 3: Memory usage simulation
                    self.log_test_result("Test 3: Memory allocation test...")
                    try:
                        # Allocate and deallocate memory
                        big_list = [i for i in range(100000)]
                        self.log_test_result(f"  Allocated list with {len(big_list)} elements")
                        del big_list
                        self.log_test_result("  Memory deallocated")
                    except Exception as e:
                        self.log_test_result(f"  Memory test error: {str(e)}")
                    
                    self.log_test_result("=== PROCESS TESTS COMPLETED ===")
                    
                except Exception as e:
                    self.log_test_result(f"Process tests error: {str(e)}")
                finally:
                    self.is_testing = False
                    self.update_status("Process tests completed")
            
            threading.Thread(target=process_test_thread, daemon=True).start()
            
        def run_registry_tests(self):
            """Run safe registry-like tests"""
            if self.is_testing:
                return
                
            self.is_testing = True
            self.update_status("Running registry tests...")
            
            def registry_test_thread():
                try:
                    self.log_test_result("=== REGISTRY TESTS STARTED ===")
                    
                    if os.name == 'nt' and WINREG_AVAILABLE:  # Windows
                        try:
                            # Test 1: Read safe registry keys
                            self.log_test_result("Test 1: Reading system information...")
                            
                            safe_keys = [
                                (winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "ProductName"),
                                (winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "CurrentVersion")
                            ]
                            
                            for hkey, subkey, value_name in safe_keys:
                                try:
                                    with winreg.OpenKey(hkey, subkey) as key:
                                        value, _ = winreg.QueryValueEx(key, value_name)
                                        self.log_test_result(f"  {value_name}: {value}")
                                        time.sleep(0.5)
                                except Exception as e:
                                    self.log_test_result(f"  Failed to read {value_name}: {str(e)}")
                            
                        except Exception as e:
                            self.log_test_result(f"  Registry access error: {str(e)}")
                            
                    else:
                        self.log_test_result("  Registry tests only available on Windows")
                        self.log_test_result("  Running alternative system tests...")
                        
                        # Alternative tests for non-Windows systems
                        try:
                            import platform
                            self.log_test_result(f"  System: {platform.system()}")
                            self.log_test_result(f"  Release: {platform.release()}")
                            self.log_test_result(f"  Machine: {platform.machine()}")
                        except Exception as e:
                            self.log_test_result(f"  System info error: {str(e)}")
                    
                    self.log_test_result("=== REGISTRY TESTS COMPLETED ===")
                    
                except Exception as e:
                    self.log_test_result(f"Registry tests error: {str(e)}")
                finally:
                    self.is_testing = False
                    self.update_status("Registry tests completed")
            
            threading.Thread(target=registry_test_thread, daemon=True).start()
            
        def run_behavior_tests(self):
            """Run safe behavior simulation tests"""
            if self.is_testing:
                return
                
            self.is_testing = True
            self.update_status("Running behavior tests...")
            
            def behavior_test_thread():
                try:
                    self.log_test_result("=== BEHAVIOR TESTS STARTED ===")
                    
                    # Test 1: Rapid operations
                    self.log_test_result("Test 1: Rapid operations simulation...")
                    for i in range(20):
                        # Simulate rapid file operations
                        temp_file = os.path.join(tempfile.gettempdir(), f"rapid_test_{i}.tmp")
                        try:
                            with open(temp_file, 'w') as f:
                                f.write(f"Rapid operation {i}")
                            os.remove(temp_file)
                            if i % 5 == 0:
                                self.log_test_result(f"  Completed {i+1}/20 operations")
                        except Exception as e:
                            self.log_test_result(f"  Operation {i} failed: {str(e)}")
                        time.sleep(0.1)
                    
                    # Test 2: CPU usage simulation
                    self.log_test_result("Test 2: CPU usage simulation...")
                    start_time = time.time()
                    while time.time() - start_time < 3:  # Run for 3 seconds
                        # Light CPU work
                        _ = sum(i * i for i in range(1000))
                        time.sleep(0.01)
                    self.log_test_result("  CPU simulation completed")
                    
                    # Test 3: Multiple thread simulation
                    self.log_test_result("Test 3: Multi-threading simulation...")
                    
                    def worker_thread(thread_id):
                        for i in range(5):
                            time.sleep(0.2)
                            self.log_test_result(f"  Thread {thread_id}: Operation {i+1}")
                    
                    threads = []
                    for i in range(3):
                        t = threading.Thread(target=worker_thread, args=(i,))
                        threads.append(t)
                        t.start()
                    
                    for t in threads:
                        t.join()
                    
                    self.log_test_result("=== BEHAVIOR TESTS COMPLETED ===")
                    
                except Exception as e:
                    self.log_test_result(f"Behavior tests error: {str(e)}")
                finally:
                    self.is_testing = False
                    self.update_status("Behavior tests completed")
            
            threading.Thread(target=behavior_test_thread, daemon=True).start()
            
        def run_eicar_test(self):
            """Run EICAR test string test"""
            if self.is_testing:
                return
                
            self.is_testing = True
            self.update_status("Running EICAR test...")
            
            def eicar_test_thread():
                try:
                    self.log_test_result("=== EICAR TEST STARTED ===")
                    self.log_test_result("Creating EICAR test string...")
                    
                    # EICAR test string (safe, used for testing antivirus)
                    eicar_string = "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
                    
                    # Create EICAR test file
                    eicar_file = os.path.join(tempfile.gettempdir(), "eicar_test.txt")
                    
                    try:
                        with open(eicar_file, 'w') as f:
                            f.write(eicar_string)
                        
                        self.log_test_result("  EICAR test file created")
                        self.log_test_result("  Checking if file exists...")
                        
                        time.sleep(2)  # Give antivirus time to react
                        
                        if os.path.exists(eicar_file):
                            self.log_test_result("  EICAR file still exists - No antivirus detection")
                            os.remove(eicar_file)
                            self.log_test_result("  EICAR file manually removed")
                        else:
                            self.log_test_result("  EICAR file was removed - Antivirus detected!")
                            
                    except Exception as e:
                        self.log_test_result(f"  EICAR test error: {str(e)}")
                    
                    self.log_test_result("=== EICAR TEST COMPLETED ===")
                    
                except Exception as e:
                    self.log_test_result(f"EICAR test error: {str(e)}")
                finally:
                    self.is_testing = False
                    self.update_status("EICAR test completed")
            
            threading.Thread(target=eicar_test_thread, daemon=True).start()
            
        def clear_test_results(self):
            """Clear the test results text area"""
            self.tests_results_text.delete(1.0, tk.END)
            self.update_status("Test results cleared")
            
        def save_test_report(self):
            """Save test results to file"""
            try:
                file_path = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
                    title="Save Test Report"
                )
                
                if file_path:
                    with open(file_path, 'w') as f:
                        f.write("Security Test Suite Report\n")
                        f.write("=" * 50 + "\n")
                        f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                        f.write(self.tests_results_text.get(1.0, tk.END))
                    
                    self.update_status(f"Test report saved: {file_path}")
                    messagebox.showinfo("Success", "Test report saved successfully!")
                    
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save test report: {str(e)}")
        
        # Vulnerability Scanner Methods
        def start_vulnerability_scan(self):
            """Start vulnerability scan"""
            if self.scan_running:
                messagebox.showwarning("Scan Running", "A scan is already in progress!")
                return
                
            self.scan_running = True
            self.clear_scan_results()
            self.scan_results_text.insert('end', "=== Windows Vulnerability Scanner ===\n")
            self.scan_results_text.insert('end', f"Scan started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            # Start scan in separate thread
            scan_thread = threading.Thread(target=self.run_vulnerability_scan)
            scan_thread.daemon = True
            scan_thread.start()
            
        def run_vulnerability_scan(self):
            """Run the vulnerability scan"""
            try:
                self.update_status("Scanning system...")
                
                if self.scan_options["system_info"].get():
                    self.scan_system_info()
                    
                if self.scan_options["open_ports"].get():
                    self.scan_open_ports()
                    
                if self.scan_options["services"].get():
                    self.scan_services()
                    
                if self.scan_options["users"].get():
                    self.scan_users()
                    
                if self.scan_options["registry"].get():
                    self.scan_registry()
                    
                if self.scan_options["network"].get():
                    self.scan_network()
                    
                if self.scan_options["firewall"].get():
                    self.scan_firewall()
                    
                if self.scan_options["antivirus"].get():
                    self.scan_antivirus()
                    
                if self.scan_options["updates"].get():
                    self.scan_updates()
                    
                if self.scan_options["passwords"].get():
                    self.scan_passwords()
                    
                self.generate_summary()
                
            except Exception as e:
                self.add_scan_result(f"ERROR: {str(e)}\n", "error")
            finally:
                self.scan_running = False
                self.update_status("Vulnerability scan completed!")
                
        def scan_system_info(self):
            """Scan system information"""
            self.update_status("Scanning system information...")
            self.add_scan_result("SYSTEM INFORMATION\n", "header")
            
            try:
                # OS Information
                import platform
                self.add_scan_result(f"OS: {platform.system()} {platform.release()}\n")
                self.add_scan_result(f"Version: {platform.version()}\n")
                self.add_scan_result(f"Architecture: {platform.architecture()[0]}\n")
                self.add_scan_result(f"Processor: {platform.processor()}\n")
                
                # Memory info
                if hasattr(psutil, 'virtual_memory'):
                    memory = psutil.virtual_memory()
                    self.add_scan_result(f"Total Memory: {memory.total // (1024**3)} GB\n")
                    self.add_scan_result(f"Available Memory: {memory.available // (1024**3)} GB\n")
                    self.add_scan_result(f"Memory Usage: {memory.percent}%\n")
                
                # Disk info
                if hasattr(psutil, 'disk_usage'):
                    disk = psutil.disk_usage('/')
                    self.add_scan_result(f"Total Disk: {disk.total // (1024**3)} GB\n")
                    self.add_scan_result(f"Free Disk: {disk.free // (1024**3)} GB\n")
                    self.add_scan_result(f"Disk Usage: {(disk.used / disk.total) * 100:.1f}%\n")
                
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Error getting system info: {str(e)}\n")
                
        def scan_open_ports(self):
            """Scan for open ports"""
            self.update_status("Scanning open ports...")
            self.add_scan_result("OPEN PORTS SCAN\n", "header")
            
            try:
                # Common ports to check
                common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1433, 3389, 5432]
                open_ports = []
                
                for port in common_ports:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(1)
                        result = sock.connect_ex(('localhost', port))
                        if result == 0:
                            open_ports.append(port)
                            self.add_scan_result(f"Port {port}: OPEN\n")
                        sock.close()
                    except:
                        pass
                        
                if not open_ports:
                    self.add_scan_result("No common ports found open on localhost\n")
                else:
                    self.add_scan_result(f"\nFound {len(open_ports)} open ports\n")
                    
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Error scanning ports: {str(e)}\n")
                
        def scan_services(self):
            """Scan running services"""
            self.update_status("Scanning running services...")
            self.add_scan_result("RUNNING SERVICES\n", "header")
            
            try:
                if os.name == 'nt':  # Windows
                    try:
                        result = subprocess.run(['sc', 'query', 'state=', 'all'], 
                                              capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            services = result.stdout
                            service_count = services.count('SERVICE_NAME:')
                            self.add_scan_result(f"Total services found: {service_count}\n")
                            
                            # Extract some service names
                            lines = services.split('\n')
                            service_names = []
                            for line in lines:
                                if 'SERVICE_NAME:' in line:
                                    service_name = line.split('SERVICE_NAME:')[1].strip()
                                    service_names.append(service_name)
                                    
                            # Display first 10 services
                            self.add_scan_result("Sample services:\n")
                            for i, service in enumerate(service_names[:10]):
                                self.add_scan_result(f"  {service}\n")
                                
                            if len(service_names) > 10:
                                self.add_scan_result(f"  ... and {len(service_names) - 10} more\n")
                                
                        else:
                            self.add_scan_result("Unable to query services\n")
                            
                    except subprocess.TimeoutExpired:
                        self.add_scan_result("Service scan timed out\n")
                    except Exception as e:
                        self.add_scan_result(f"Error scanning services: {str(e)}\n")
                else:
                    # Unix/Linux systems
                    try:
                        result = subprocess.run(['ps', 'aux'], capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            processes = result.stdout.split('\n')
                            self.add_scan_result(f"Running processes: {len(processes) - 1}\n")
                            
                            # Show first few processes
                            self.add_scan_result("Sample processes:\n")
                            for i, process in enumerate(processes[1:11]):  # Skip header, show first 10
                                if process.strip():
                                    parts = process.split()
                                    if len(parts) > 10:
                                        self.add_scan_result(f"  {parts[10]}\n")
                                        
                    except Exception as e:
                        self.add_scan_result(f"Error scanning processes: {str(e)}\n")
                        
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Error in service scan: {str(e)}\n")
                
        def scan_users(self):
            """Scan user accounts"""
            self.update_status("Scanning user accounts...")
            self.add_scan_result("USER ACCOUNTS\n", "header")
            
            try:
                if os.name == 'nt':  # Windows
                    try:
                        result = subprocess.run(['net', 'user'], capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            output = result.stdout
                            self.add_scan_result("Local user accounts:\n")
                            
                            # Parse user list
                            lines = output.split('\n')
                            in_user_section = False
                            for line in lines:
                                if 'User accounts for' in line:
                                    in_user_section = True
                                    continue
                                if in_user_section and line.strip() and not line.startswith('The command'):
                                    # Extract usernames
                                    users = line.split()
                                    for user in users:
                                        if user.strip():
                                            self.add_scan_result(f"  {user}\n")
                                            
                        else:
                            self.add_scan_result("Unable to enumerate users\n")
                            
                    except Exception as e:
                        self.add_scan_result(f"Error scanning users: {str(e)}\n")
                else:
                    # Unix/Linux systems
                    try:
                        with open('/etc/passwd', 'r') as f:
                            users = f.readlines()
                            self.add_scan_result(f"Total users in /etc/passwd: {len(users)}\n")
                            
                            # Show regular users (UID >= 1000)
                            regular_users = []
                            for user in users:
                                parts = user.split(':')
                                if len(parts) >= 3:
                                    try:
                                        uid = int(parts[2])
                                        if uid >= 1000:
                                            regular_users.append(parts[0])
                                    except:
                                        pass
                                        
                            if regular_users:
                                self.add_scan_result("Regular users:\n")
                                for user in regular_users:
                                    self.add_scan_result(f"  {user}\n")
                            else:
                                self.add_scan_result("No regular users found\n")
                                
                    except Exception as e:
                        self.add_scan_result(f"Error reading /etc/passwd: {str(e)}\n")
                        
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Error in user scan: {str(e)}\n")
                
        def scan_registry(self):
            """Scan registry for security settings"""
            self.update_status("Scanning registry...")
            self.add_scan_result("REGISTRY SECURITY SCAN\n", "header")
            
            if os.name != 'nt':
                self.add_scan_result("Registry scan only available on Windows\n\n")
                return
                
            if not WINREG_AVAILABLE:
                self.add_scan_result("Registry access not available\n\n")
                return
                
            try:
                # Check important security settings
                security_keys = [
                    {
                        'hive': winreg.HKEY_LOCAL_MACHINE,
                        'key': r'SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System',
                        'values': ['EnableLUA', 'ConsentPromptBehaviorAdmin', 'FilterAdministratorToken'],
                        'description': 'UAC Settings'
                    },
                    {
                        'hive': winreg.HKEY_LOCAL_MACHINE,
                        'key': r'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon',
                        'values': ['AutoAdminLogon', 'DefaultPassword'],
                        'description': 'Auto Logon Settings'
                    }
                ]
                
                for key_info in security_keys:
                    self.add_scan_result(f"{key_info['description']}:\n")
                    try:
                        with winreg.OpenKey(key_info['hive'], key_info['key']) as reg_key:
                            for value_name in key_info['values']:
                                try:
                                    value, reg_type = winreg.QueryValueEx(reg_key, value_name)
                                    self.add_scan_result(f"  {value_name}: {value}\n")
                                except FileNotFoundError:
                                    self.add_scan_result(f"  {value_name}: Not set\n")
                                except Exception as e:
                                    self.add_scan_result(f"  {value_name}: Error reading ({str(e)})\n")
                                    
                    except Exception as e:
                        self.add_scan_result(f"  Error accessing registry key: {str(e)}\n")
                        
                    self.add_scan_result("\n")
                    
            except Exception as e:
                self.add_scan_result(f"Registry scan error: {str(e)}\n")
                
        def scan_network(self):
            """Scan network configuration"""
            self.update_status("Scanning network configuration...")
            self.add_scan_result("NETWORK CONFIGURATION\n", "header")
            
            try:
                # Get network interfaces
                if hasattr(psutil, 'net_if_addrs'):
                    interfaces = psutil.net_if_addrs()
                    self.add_scan_result(f"Network interfaces found: {len(interfaces)}\n")
                    
                    for interface_name, addresses in interfaces.items():
                        self.add_scan_result(f"\nInterface: {interface_name}\n")
                        for addr in addresses:
                            if addr.family == socket.AF_INET:  # IPv4
                                self.add_scan_result(f"  IPv4: {addr.address}\n")
                                if addr.netmask:
                                    self.add_scan_result(f"  Netmask: {addr.netmask}\n")
                            elif addr.family == socket.AF_INET6:  # IPv6
                                self.add_scan_result(f"  IPv6: {addr.address}\n")
                                
                # Get network statistics
                if hasattr(psutil, 'net_io_counters'):
                    net_stats = psutil.net_io_counters()
                    self.add_scan_result(f"\nNetwork Statistics:\n")
                    self.add_scan_result(f"  Bytes sent: {net_stats.bytes_sent}\n")
                    self.add_scan_result(f"  Bytes received: {net_stats.bytes_recv}\n")
                    self.add_scan_result(f"  Packets sent: {net_stats.packets_sent}\n")
                    self.add_scan_result(f"  Packets received: {net_stats.packets_recv}\n")
                    
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Network scan error: {str(e)}\n")
                
        def scan_firewall(self):
            """Scan firewall status"""
            self.update_status("Checking firewall status...")
            self.add_scan_result("FIREWALL STATUS\n", "header")
            
            try:
                if os.name == 'nt':  # Windows
                    try:
                        result = subprocess.run(['netsh', 'advfirewall', 'show', 'allprofiles', 'state'], 
                                              capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            output = result.stdout
                            self.add_scan_result("Windows Firewall Status:\n")
                            
                            # Parse firewall status
                            lines = output.split('\n')
                            for line in lines:
                                if 'State' in line and ('ON' in line or 'OFF' in line):
                                    self.add_scan_result(f"  {line.strip()}\n")
                                    
                        else:
                            self.add_scan_result("Unable to check firewall status\n")
                            
                    except Exception as e:
                        self.add_scan_result(f"Firewall check error: {str(e)}\n")
                else:
                    # Linux systems
                    try:
                        # Check if ufw is available
                        result = subprocess.run(['which', 'ufw'], capture_output=True, text=True, timeout=5)
                        if result.returncode == 0:
                            result = subprocess.run(['ufw', 'status'], capture_output=True, text=True, timeout=10)
                            if result.returncode == 0:
                                self.add_scan_result("UFW Firewall Status:\n")
                                self.add_scan_result(f"  {result.stdout}\n")
                            else:
                                self.add_scan_result("UFW not accessible\n")
                        else:
                            # Check iptables
                            result = subprocess.run(['iptables', '-L'], capture_output=True, text=True, timeout=10)
                            if result.returncode == 0:
                                rules_count = result.stdout.count('\n')
                                self.add_scan_result(f"iptables rules found: {rules_count}\n")
                            else:
                                self.add_scan_result("No firewall information available\n")
                                
                    except Exception as e:
                        self.add_scan_result(f"Firewall check error: {str(e)}\n")
                        
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Firewall scan error: {str(e)}\n")
                
        def scan_antivirus(self):
            """Check for antivirus software"""
            self.update_status("Checking antivirus software...")
            self.add_scan_result("ANTIVIRUS CHECK\n", "header")
            
            try:
                if os.name == 'nt':  # Windows
                    try:
                        # Check Windows Defender status
                        result = subprocess.run(['powershell', '-Command', 'Get-MpComputerStatus'], 
                                              capture_output=True, text=True, timeout=15)
                        if result.returncode == 0:
                            output = result.stdout
                            if 'AntivirusEnabled' in output:
                                self.add_scan_result("Windows Defender information found:\n")
                                lines = output.split('\n')
                                for line in lines:
                                    if any(keyword in line for keyword in ['AntivirusEnabled', 'RealTimeProtectionEnabled', 'AntivirusSignatureLastUpdated']):
                                        self.add_scan_result(f"  {line.strip()}\n")
                            else:
                                self.add_scan_result("Windows Defender status not available\n")
                        else:
                            self.add_scan_result("Unable to check Windows Defender\n")
                            
                        # Check for other antivirus products via WMI
                        try:
                            result = subprocess.run(['wmic', '/namespace:\\\\root_safe\\SecurityCenter2', 'path', 'AntiVirusProduct', 'get', 'displayName,productState'], 
                                                  capture_output=True, text=True, timeout=15)
                            if result.returncode == 0:
                                output = result.stdout
                                if 'displayName' in output:
                                    self.add_scan_result("\nInstalled Antivirus Products:\n")
                                    lines = output.split('\n')
                                    for line in lines[1:]:  # Skip header
                                        if line.strip() and 'displayName' not in line:
                                            parts = line.strip().split()
                                            if parts:
                                                self.add_scan_result(f"  {' '.join(parts[:-1])}\n")
                                else:
                                    self.add_scan_result("No antivirus products detected via WMI\n")
                        except Exception as e:
                            self.add_scan_result(f"WMI antivirus check failed: {str(e)}\n")
                            
                    except Exception as e:
                        self.add_scan_result(f"Antivirus check error: {str(e)}\n")
                else:
                    # Linux systems
                    common_av = ['clamav', 'freshclam', 'rkhunter', 'chkroot_safekit']
                    found_av = []
                    
                    for av in common_av:
                        try:
                            result = subprocess.run(['which', av], capture_output=True, text=True, timeout=5)
                            if result.returncode == 0:
                                found_av.append(av)
                        except:
                            pass
                            
                    if found_av:
                        self.add_scan_result("Antivirus/Security tools found:\n")
                        for av in found_av:
                            self.add_scan_result(f"  {av}\n")
                    else:
                        self.add_scan_result("No common antivirus tools detected\n")
                        
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Antivirus scan error: {str(e)}\n")
                
        def scan_updates(self):
            """Check system updates"""
            self.update_status("Checking system updates...")
            self.add_scan_result("SYSTEM UPDATES CHECK\n", "header")
            
            try:
                if os.name == 'nt':  # Windows
                    try:
                        # Check Windows Update using PowerShell
                        result = subprocess.run(['powershell', '-Command', 
                                               'Get-HotFix | Sort-Object InstalledOn -Descending | Select-Object -First 5'], 
                                              capture_output=True, text=True, timeout=20)
                        if result.returncode == 0:
                            output = result.stdout
                            if output.strip():
                                self.add_scan_result("Recent Windows Updates:\n")
                                lines = output.split('\n')
                                for line in lines:
                                    if line.strip() and not line.startswith('Source'):
                                        self.add_scan_result(f"  {line.strip()}\n")
                            else:
                                self.add_scan_result("No recent updates information available\n")
                        else:
                            self.add_scan_result("Unable to check Windows updates\n")
                            
                    except Exception as e:
                        self.add_scan_result(f"Windows updates check error: {str(e)}\n")
                else:
                    # Linux systems
                    try:
                        # Check for different package managers
                        package_managers = [
                            (['apt', 'list', '--upgradable'], 'APT'),
                            (['yum', 'check-update'], 'YUM'),
                            (['dnf', 'check-update'], 'DNF'),
                            (['pacman', '-Qu'], 'Pacman')
                        ]
                        
                        update_found = False
                        for cmd, manager in package_managers:
                            try:
                                result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
                                if result.returncode == 0 or (manager == 'YUM' and result.returncode == 100):
                                    output = result.stdout
                                    if output.strip():
                                        update_count = len(output.split('\n')) - 1
                                        self.add_scan_result(f"{manager} - Available updates: {update_count}\n")
                                        update_found = True
                                        break
                            except FileNotFoundError:
                                continue
                            except Exception:
                                continue
                                
                        if not update_found:
                            self.add_scan_result("Unable to check for updates or no package manager found\n")
                            
                    except Exception as e:
                        self.add_scan_result(f"Linux updates check error: {str(e)}\n")
                        
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Updates scan error: {str(e)}\n")
                
        def scan_passwords(self):
            """Check for weak password policies"""
            self.update_status("Checking password policies...")
            self.add_scan_result("PASSWORD POLICY CHECK\n", "header")
            
            try:
                if os.name == 'nt':  # Windows
                    try:
                        # Check local security policy
                        result = subprocess.run(['net', 'accounts'], capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            output = result.stdout
                            self.add_scan_result("Local Password Policy:\n")
                            
                            lines = output.split('\n')
                            for line in lines:
                                if any(keyword in line.lower() for keyword in ['password', 'lockout', 'length', 'age']):
                                    self.add_scan_result(f"  {line.strip()}\n")
                                    
                            # Analyze for weak policies
                            if 'minimum password length: 0' in output.lower():
                                self.add_scan_result("WARNING: No minimum password length set!\n")
                            if 'maximum password age: unlimited' in output.lower():
                                self.add_scan_result("WARNING: Passwords never expire!\n")
                                
                        else:
                            self.add_scan_result("Unable to check password policy\n")
                            
                    except Exception as e:
                        self.add_scan_result(f"Password policy check error: {str(e)}\n")
                else:
                    # Linux systems
                    try:
                        # Check /etc/login.defs for password settings
                        if os.path.exists('/etc/login.defs'):
                            with open('/etc/login.defs', 'r') as f:
                                content = f.read()
                                
                            self.add_scan_result("Password settings from /etc/login.defs:\n")
                            
                            settings = ['PASS_MAX_DAYS', 'PASS_MIN_DAYS', 'PASS_MIN_LEN', 'PASS_WARN_AGE']
                            for setting in settings:
                                for line in content.split('\n'):
                                    if line.startswith(setting) and not line.startswith('#'):
                                        self.add_scan_result(f"  {line.strip()}\n")
                                        
                            # Check for weak settings
                            if 'PASS_MIN_LEN\t0' in content or 'PASS_MIN_LEN 0' in content:
                                self.add_scan_result("WARNING: No minimum password length!\n")
                                
                        else:
                            self.add_scan_result("/etc/login.defs not found\n")
                            
                        # Check PAM configuration
                        pam_files = ['/etc/pam.d/common-password', '/etc/pam.d/system-auth']
                        for pam_file in pam_files:
                            if os.path.exists(pam_file):
                                self.add_scan_result(f"\nPAM configuration found: {pam_file}\n")
                                break
                        else:
                            self.add_scan_result("No PAM password configuration found\n")
                            
                    except Exception as e:
                        self.add_scan_result(f"Linux password check error: {str(e)}\n")
                        
                self.add_scan_result("\n")
                
            except Exception as e:
                self.add_scan_result(f"Password scan error: {str(e)}\n")
                
        def generate_summary(self):
            """Generate scan summary"""
            self.add_scan_result("=" * 50 + "\n")
            self.add_scan_result("SCAN SUMMARY\n")
            self.add_scan_result("=" * 50 + "\n")
            
            scan_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            self.add_scan_result(f"Scan completed at: {scan_time}\n")
            
            # Count selected scans
            selected_scans = sum(1 for option in self.scan_options.values() if option.get())
            self.add_scan_result(f"Scans performed: {selected_scans}\n")
            
            self.add_scan_result("\nRecommendations:\n")
            self.add_scan_result("• Regularly update your system and software\n")
            self.add_scan_result("• Use strong, unique passwords\n")
            self.add_scan_result("• Keep antivirus software updated\n")
            self.add_scan_result("• Enable firewall protection\n")
            self.add_scan_result("• Monitor system for unusual activity\n")
            
            self.update_status("Vulnerability scan completed!")
            
        def clear_scan_results(self):
            """Clear scan results"""
            self.scan_results_text.delete('1.0', 'end')
            
    def main():
        """Main function to run the application"""
        root_safe = tk.Tk()
        app = UnifiedSecurityTool(root_safe)
        
        # Center the window
        root_safe.update_idletasks()
        width = root_safe.winfo_width()
        height = root_safe.winfo_height()
        x = (root_safe.winfo_screenwidth() // 2) - (width // 2)
        y = (root_safe.winfo_screenheight() // 2) - (height // 2)
        root_safe.geometry(f'{width}x{height}+{x}+{y}')
        
        # Start the GUI
        root_safe.mainloop()

    if __name__ == "__main__":
        main()

if trafficvar == 333344440099:
    import time
    import psutil
    import socket
    from collections import defaultdict, deque
    from datetime import datetime
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class Win95Style:
        """Clasa pentru stilizarea Windows 95"""
        
        # Culori Windows 95
        BG_COLOR = "#c0c0c0"
        BUTTON_COLOR = "#c0c0c0"
        ACTIVE_COLOR = "#0078d4"
        TEXT_COLOR = "#000000"
        BORDER_COLOR = "#808080"
        DARK_BORDER = "#404040"
        WINDOW_TITLE_BG = "#008080"
        WINDOW_TITLE_FG = "#ffffff"
        
        @staticmethod
        def apply_button_style(button):
            button.configure(
                bg=Win95Style.BUTTON_COLOR,
                fg=Win95Style.TEXT_COLOR,
                relief="raised",
                bd=2,
                font=("MS Sans Serif", 8)
            )
        
        @staticmethod
        def apply_frame_style(frame):
            frame.configure(
                bg=Win95Style.BG_COLOR,
                relief="groove",
                bd=2
            )

    class NetworkMonitor:
        """Clasa pentru monitorizarea traficului de rețea"""
        
        def __init__(self):
            self.connections = defaultdict(list)
            self.traffic_data = deque(maxlen=100)
            self.service_groups = {
                80: "HTTP",
                443: "HTTPS", 
                22: "SSH",
                21: "FTP",
                25: "SMTP",
                53: "DNS",
                3389: "RDP",
                3306: "MySQL",
                5432: "PostgreSQL",
                6379: "Redis",
                8080: "HTTP-Alt",
                8443: "HTTPS-Alt",
                110: "POP3",
                143: "IMAP",
                993: "IMAPS",
                995: "POP3S",
                587: "SMTP-Alt",
                23: "Telnet",
                135: "RPC",
                139: "NetBIOS",
                445: "SMB",
                1433: "MSSQL",
                1521: "Oracle",
                5984: "CouchDB"
            }
            self.is_monitoring = False
            self.network_stats_old = None
            
        def get_network_connections(self):
            """Obține conexiunile de rețea active reale"""
            connections = []
            try:
                for conn in psutil.net_connections(kind='inet'):
                    if conn.status == 'ESTABLISHED':
                        local_ip = conn.laddr.ip if conn.laddr else "Unknown"
                        local_port = conn.laddr.port if conn.laddr else 0
                        remote_ip = conn.raddr.ip if conn.raddr else "Unknown"
                        remote_port = conn.raddr.port if conn.raddr else 0
                        
                        # Determină serviciul bazat pe portul remote
                        service = self.service_groups.get(remote_port, f"Port {remote_port}")
                        
                        # Încearcă să obțină numele procesului
                        process_name = "Unknown"
                        try:
                            if conn.pid:
                                process = psutil.Process(conn.pid)
                                process_name = process.name()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        
                        connections.append({
                            'local_ip': local_ip,
                            'local_port': local_port,
                            'remote_ip': remote_ip,
                            'remote_port': remote_port,
                            'service': service,
                            'process': process_name,
                            'pid': conn.pid if conn.pid else 0,
                            'status': conn.status,
                            'timestamp': datetime.now()
                        })
                        
            except (psutil.AccessDenied, psutil.NoSuchProcess) as e:
                print(f"Error accessing network connections: {e}")
            
            return connections
        
        def get_network_io_stats(self):
            """Obține statisticile de I/O rețea"""
            try:
                stats = psutil.net_io_counters()
                current_time = time.time()
                
                current_stats = {
                    'bytes_sent': stats.bytes_sent,
                    'bytes_recv': stats.bytes_recv,
                    'packets_sent': stats.packets_sent,
                    'packets_recv': stats.packets_recv,
                    'errin': stats.errin,
                    'errout': stats.errout,
                    'dropin': stats.dropin,
                    'dropout': stats.dropout,
                    'timestamp': current_time
                }
                
                # Calculează viteza dacă avem date anterioare
                if self.network_stats_old:
                    time_diff = current_stats['timestamp'] - self.network_stats_old['timestamp']
                    if time_diff > 0:
                        current_stats['bytes_sent_sec'] = (current_stats['bytes_sent'] - self.network_stats_old['bytes_sent']) / time_diff
                        current_stats['bytes_recv_sec'] = (current_stats['bytes_recv'] - self.network_stats_old['bytes_recv']) / time_diff
                        current_stats['packets_sent_sec'] = (current_stats['packets_sent'] - self.network_stats_old['packets_sent']) / time_diff
                        current_stats['packets_recv_sec'] = (current_stats['packets_recv'] - self.network_stats_old['packets_recv']) / time_diff
                    else:
                        current_stats['bytes_sent_sec'] = 0
                        current_stats['bytes_recv_sec'] = 0
                        current_stats['packets_sent_sec'] = 0
                        current_stats['packets_recv_sec'] = 0
                else:
                    current_stats['bytes_sent_sec'] = 0
                    current_stats['bytes_recv_sec'] = 0
                    current_stats['packets_sent_sec'] = 0
                    current_stats['packets_recv_sec'] = 0
                
                self.network_stats_old = current_stats.copy()
                return current_stats
                
            except Exception as e:
                print(f"Error getting network I/O stats: {e}")
                return None
        
        def get_interface_stats(self):
            """Obține statisticile pentru toate interfețele de rețea"""
            try:
                interfaces = {}
                for interface, stats in psutil.net_io_counters(pernic=True).items():
                    interfaces[interface] = {
                        'bytes_sent': stats.bytes_sent,
                        'bytes_recv': stats.bytes_recv,
                        'packets_sent': stats.packets_sent,
                        'packets_recv': stats.packets_recv,
                        'errin': stats.errin,
                        'errout': stats.errout,
                        'dropin': stats.dropin,
                        'dropout': stats.dropout
                    }
                return interfaces
            except Exception as e:
                print(f"Error getting interface stats: {e}")
                return {}
        
        def resolve_hostname(self, ip_address):
            """Încearcă să rezolve numele de host pentru o adresă IP"""
            try:
                hostname = socket.gethostbyaddr(ip_address)[0]
                return hostname
            except (socket.herror, socket.gaierror):
                return ip_address
        
        def is_local_ip(self, ip):
            """Verifică dacă o adresă IP este locală"""
            try:
                # Adrese IP private
                private_ranges = [
                    ('10.0.0.0', '10.255.255.255'),
                    ('172.16.0.0', '172.31.255.255'),
                    ('192.168.0.0', '192.168.255.255'),
                    ('127.0.0.0', '127.255.255.255')
                ]
                
                import ipaddress
                ip_obj = ipaddress.ip_address(ip)
                return ip_obj.is_private or ip_obj.is_loopback
            except:
                return False
        
        def generate_demo_data(self):
            """Generează date demo pentru demonstrație"""
            demo_ips = [
                "192.168.1.1", "192.168.1.100", "10.0.0.1", 
                "8.8.8.8", "1.1.1.1", "172.16.0.1", "74.125.224.72", "157.240.22.35"
            ]
            demo_services = ["HTTP", "HTTPS", "SSH", "FTP", "DNS", "MySQL"]
            demo_processes = ["chrome.exe", "firefox.exe", "steam.exe", "discord.exe", "skype.exe", "outlook.exe"]
            
            connections = []
            for i in range(random.randint(5, 15)):
                local_ip = "192.168.1." + str(random.randint(100, 200))
                remote_ip = random.choice(demo_ips)
                service = random.choice(demo_services)
                process = random.choice(demo_processes)
                port = random.randint(1024, 65535)
                
                connections.append({
                    'local_ip': local_ip,
                    'local_port': random.randint(1024, 65535),
                    'remote_ip': remote_ip,
                    'remote_port': port,
                    'service': service,
                    'process': process,
                    'pid': random.randint(1000, 9999),
                    'status': 'ESTABLISHED',
                    'timestamp': datetime.now(),
                    'bytes_sent': random.randint(1024, 1024*1024),
                    'bytes_recv': random.randint(1024, 1024*1024)
                })
            
            return connections

    class TrafficVisualizer:
        def __init__(self, rootTRF):
            self.rootTRF = rootTRF
            self.monitor = NetworkMonitor()
            self.setup_window()
            self.create_widgets()
            self.monitoring_thread = None
            self.is_running = False
            self.use_real_data = True  # Flag pentru date reale vs demo
            self.refresh_interval = 2
            self.max_connections = 100
            self.auto_save_enabled = False
            
        def setup_window(self):
            """Configurează fereastra principală"""
            self.rootTRF.title("Traffic Visualizer v1.0")
            self.rootTRF.geometry("1200x800")
            self.rootTRF.configure(bg=Win95Style.BG_COLOR)
            self.rootTRF.resizable(True, True)
            
            # Font Windows 95
            self.default_font = font.Font(family="MS Sans Serif", size=8)
            
            # Icon simulat pentru Windows 95
            try:
                self.rootTRF.iconbitmap(default="")
            except:
                pass
        
        def create_widgets(self):
            """Creează interfața utilizator"""
            # Bara de meniu
            self.create_menu()
            
            # Toolbar
            self.create_toolbar()
            
            # Panoul principal
            main_paned = tk.PanedWindow(self.rootTRF, orient=tk.HORIZONTAL, 
                                       bg=Win95Style.BG_COLOR, sashwidth=5)
            main_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Panoul stâng - Network Map
            self.create_network_map(main_paned)
            
            # Panoul drept - Detalii și statistici
            self.create_details_panel(main_paned)
            
            # Bara de status
            self.create_status_bar()
        
        def create_menu(self):
            """Creează bara de meniu"""
            menubar = tk.Menu(self.rootTRF, bg=Win95Style.BG_COLOR, 
                             fg=Win95Style.TEXT_COLOR, font=self.default_font)
            self.rootTRF.config(menu=menubar)
            
            # File Menu
            file_menu = tk.Menu(menubar, tearoff=0, bg=Win95Style.BG_COLOR, 
                               fg=Win95Style.TEXT_COLOR, font=self.default_font)
            menubar.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="New Session", command=self.new_session)
            file_menu.add_command(label="Save Data", command=self.save_data)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootTRF.quit)
            
            # View Menu
            view_menu = tk.Menu(menubar, tearoff=0, bg=Win95Style.BG_COLOR,
                               fg=Win95Style.TEXT_COLOR, font=self.default_font)
            menubar.add_cascade(label="View", menu=view_menu)
            view_menu.add_command(label="Refresh", command=self.refresh_data)
            view_menu.add_command(label="Clear History", command=self.clear_history)
            view_menu.add_separator()
            view_menu.add_checkbutton(label="Real Data Mode", command=self.toggle_data_mode)
            
            # Tools Menu
            tools_menu = tk.Menu(menubar, tearoff=0, bg=Win95Style.BG_COLOR,
                                fg=Win95Style.TEXT_COLOR, font=self.default_font)
            menubar.add_cascade(label="Tools", menu=tools_menu)
            tools_menu.add_command(label="Settings", command=self.show_settings)
            tools_menu.add_command(label="Network Info", command=self.show_network_info)
            
            # Help Menu
            help_menu = tk.Menu(menubar, tearoff=0, bg=Win95Style.BG_COLOR,
                               fg=Win95Style.TEXT_COLOR, font=self.default_font)
            menubar.add_cascade(label="Help", menu=help_menu)
            help_menu.add_command(label="About", command=self.show_about)
        
        def create_toolbar(self):
            """Creează toolbar-ul"""
            toolbar_frame = tk.Frame(self.rootTRF, bg=Win95Style.BG_COLOR, relief="raised", bd=1)
            toolbar_frame.pack(fill=tk.X, padx=2, pady=2)
            
            # Butoane toolbar
            self.start_btn = tk.Button(toolbar_frame, text="Start", 
                                      command=self.start_monitoring)
            Win95Style.apply_button_style(self.start_btn)
            self.start_btn.pack(side=tk.LEFT, padx=2)
            
            self.stop_btn = tk.Button(toolbar_frame, text="Stop", 
                                     command=self.stop_monitoring, state="disabled")
            Win95Style.apply_button_style(self.stop_btn)
            self.stop_btn.pack(side=tk.LEFT, padx=2)
            
            self.refresh_btn = tk.Button(toolbar_frame, text="Refresh", 
                                        command=self.refresh_data)
            Win95Style.apply_button_style(self.refresh_btn)
            self.refresh_btn.pack(side=tk.LEFT, padx=2)
            
            # Separator
            separator = tk.Frame(toolbar_frame, width=2, bg=Win95Style.DARK_BORDER)
            separator.pack(side=tk.LEFT, fill=tk.Y, padx=5)
            
            # Toggle pentru date reale/demo
            self.data_mode_btn = tk.Button(toolbar_frame, text="Real Data", 
                                          command=self.toggle_data_mode)
            Win95Style.apply_button_style(self.data_mode_btn)
            self.data_mode_btn.pack(side=tk.LEFT, padx=2)
            
            # Demo mode
            self.demo_btn = tk.Button(toolbar_frame, text="Demo Mode", 
                                     command=self.toggle_demo)
            Win95Style.apply_button_style(self.demo_btn)
            self.demo_btn.pack(side=tk.LEFT, padx=2)
            
            # Status indicator
            self.status_indicator = tk.Label(toolbar_frame, text="●", 
                                           fg="red", bg=Win95Style.BG_COLOR,
                                           font=("MS Sans Serif", 12))
            self.status_indicator.pack(side=tk.RIGHT, padx=5)
            
            tk.Label(toolbar_frame, text="Status:", bg=Win95Style.BG_COLOR,
                    font=self.default_font).pack(side=tk.RIGHT)
            
            # Data mode indicator
            self.data_mode_indicator = tk.Label(toolbar_frame, text="[REAL]", 
                                              fg="green", bg=Win95Style.BG_COLOR,
                                              font=("MS Sans Serif", 8, "bold"))
            self.data_mode_indicator.pack(side=tk.RIGHT, padx=10)
        
        def create_network_map(self, parent):
            """Creează harta de rețea"""
            map_frame = tk.Frame(parent, bg=Win95Style.BG_COLOR)
            Win95Style.apply_frame_style(map_frame)
            parent.add(map_frame, minsize=500)
            
            # Titlu
            title_frame = tk.Frame(map_frame, bg=Win95Style.WINDOW_TITLE_BG, height=20)
            title_frame.pack(fill=tk.X)
            title_frame.pack_propagate(False)
            
            tk.Label(title_frame, text="Network Traffic Map", 
                    bg=Win95Style.WINDOW_TITLE_BG, fg=Win95Style.WINDOW_TITLE_FG,
                    font=("MS Sans Serif", 8, "bold")).pack(pady=2)
            
            # Canvas pentru hartă
            canvas_frame = tk.Frame(map_frame, bg=Win95Style.BG_COLOR)
            canvas_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            self.network_canvas = tk.Canvas(canvas_frame, bg="white", 
                                           relief="sunken", bd=2)
            
            # Scrollbars
            v_scrollbar = tk.Scrollbar(canvas_frame, orient="vertical", 
                                      command=self.network_canvas.yview)
            h_scrollbar = tk.Scrollbar(canvas_frame, orient="horizontal", 
                                      command=self.network_canvas.xview)
            
            self.network_canvas.configure(yscrollcommand=v_scrollbar.set,
                                         xscrollcommand=h_scrollbar.set)
            
            # Pack canvas și scrollbars
            self.network_canvas.pack(side="left", fill="both", expand=True)
            v_scrollbar.pack(side="right", fill="y")
            h_scrollbar.pack(side="bottom", fill="x")
            
            # Legende
            legend_frame = tk.Frame(map_frame, bg=Win95Style.BG_COLOR, height=40)
            legend_frame.pack(fill=tk.X, padx=5, pady=2)
            legend_frame.pack_propagate(False)
            
            tk.Label(legend_frame, text="🔵 Local Host", bg=Win95Style.BG_COLOR,
                    font=self.default_font).pack(side=tk.LEFT, padx=5)
            tk.Label(legend_frame, text="🔴 Remote Host", bg=Win95Style.BG_COLOR,
                    font=self.default_font).pack(side=tk.LEFT, padx=5)
            tk.Label(legend_frame, text="🟡 Local Network", bg=Win95Style.BG_COLOR,
                    font=self.default_font).pack(side=tk.LEFT, padx=5)
            tk.Label(legend_frame, text="⭐ Server", bg=Win95Style.BG_COLOR,
                    font=self.default_font).pack(side=tk.LEFT, padx=5)
        
        def create_details_panel(self, parent):
            """Creează panoul de detalii"""
            details_frame = tk.Frame(parent, bg=Win95Style.BG_COLOR)
            Win95Style.apply_frame_style(details_frame)
            parent.add(details_frame, minsize=500)
            
            # Notebook pentru tabs
            self.notebook = ttk.Notebook(details_frame)
            self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Tab 1: Active Connections
            self.create_connections_tab()
            
            # Tab 2: Service Groups
            self.create_services_tab()
            
            # Tab 3: Statistics
            self.create_statistics_tab()
            
            # Tab 4: Network I/O
            self.create_network_io_tab()
            
            # Tab 5: Log
            self.create_log_tab()
        
        def create_connections_tab(self):
            """Creează tab-ul pentru conexiuni active"""
            conn_frame = tk.Frame(self.notebook, bg=Win95Style.BG_COLOR)
            self.notebook.add(conn_frame, text="Active Connections")
            
            # Treeview pentru conexiuni
            columns = ("Local IP", "Local Port", "Remote IP", "Remote Port", "Service", "Process", "PID", "Time")
            self.connections_tree = ttk.Treeview(conn_frame, columns=columns, show="headings", height=15)
            
            # Configurează coloanele
            column_widths = {"Local IP": 120, "Local Port": 80, "Remote IP": 120, "Remote Port": 80, 
                            "Service": 100, "Process": 120, "PID": 60, "Time": 80}
            
            for col in columns:
                self.connections_tree.heading(col, text=col)
                self.connections_tree.column(col, width=column_widths.get(col, 100))
            
            # Scrollbars pentru treeview
            tree_scroll_y = ttk.Scrollbar(conn_frame, orient="vertical", 
                                         command=self.connections_tree.yview)
            tree_scroll_x = ttk.Scrollbar(conn_frame, orient="horizontal", 
                                         command=self.connections_tree.xview)
            
            self.connections_tree.configure(yscrollcommand=tree_scroll_y.set,
                                           xscrollcommand=tree_scroll_x.set)
            
            self.connections_tree.pack(side="left", fill="both", expand=True)
            tree_scroll_y.pack(side="right", fill="y")
            tree_scroll_x.pack(side="bottom", fill="x")
        
        def create_services_tab(self):
            """Creează tab-ul pentru gruparea serviciilor"""
            services_frame = tk.Frame(self.notebook, bg=Win95Style.BG_COLOR)
            self.notebook.add(services_frame, text="Service Groups")
            
            # Listbox pentru servicii
            self.services_listbox = tk.Listbox(services_frame, bg="white", 
                                              font=self.default_font)
            self.services_listbox.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            services_scroll = ttk.Scrollbar(services_frame, orient="vertical",
                                           command=self.services_listbox.yview)
            self.services_listbox.configure(yscrollcommand=services_scroll.set)
            services_scroll.pack(side="right", fill="y")
        
        def create_statistics_tab(self):
            """Creează tab-ul pentru statistici"""
            stats_frame = tk.Frame(self.notebook, bg=Win95Style.BG_COLOR)
            self.notebook.add(stats_frame, text="Statistics")
            
            # Text widget pentru statistici
            self.stats_text = tk.Text(stats_frame, bg="white", font=self.default_font,
                                     state="disabled", wrap=tk.WORD)
            self.stats_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            stats_scroll = ttk.Scrollbar(stats_frame, orient="vertical",
                                        command=self.stats_text.yview)
            self.stats_text.configure(yscrollcommand=stats_scroll.set)
            stats_scroll.pack(side="right", fill="y")
        
        def create_network_io_tab(self):
            """Creează tab-ul pentru I/O rețea"""
            io_frame = tk.Frame(self.notebook, bg=Win95Style.BG_COLOR)
            self.notebook.add(io_frame, text="Network I/O")
            
            # Text widget pentru I/O stats
            self.io_text = tk.Text(io_frame, bg="white", font=("Courier New", 8),
                                  state="disabled", wrap=tk.NONE)
            self.io_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            io_scroll = ttk.Scrollbar(io_frame, orient="vertical",
                                     command=self.io_text.yview)
            self.io_text.configure(yscrollcommand=io_scroll.set)
            io_scroll.pack(side="right", fill="y")
        
        def create_log_tab(self):
            """Creează tab-ul pentru log"""
            log_frame = tk.Frame(self.notebook, bg=Win95Style.BG_COLOR)
            self.notebook.add(log_frame, text="Activity Log")
            
            # Text widget pentru log
            self.log_text = tk.Text(log_frame, bg="black", fg="lime", 
                                   font=("Courier New", 8), state="disabled")
            self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            log_scroll = ttk.Scrollbar(log_frame, orient="vertical",
                                      command=self.log_text.yview)
            self.log_text.configure(yscrollcommand=log_scroll.set)
            log_scroll.pack(side="right", fill="y")
        
        def create_status_bar(self):
            """Creează bara de status"""
            self.status_bar = tk.Frame(self.rootTRF, bg=Win95Style.BG_COLOR, 
                                      relief="sunken", bd=1)
            self.status_bar.pack(fill=tk.X, side=tk.BOTTOM)
            
            self.status_label = tk.Label(self.status_bar, text="Ready", 
                                        bg=Win95Style.BG_COLOR, font=self.default_font,
                                        anchor="w")
            self.status_label.pack(side=tk.LEFT, padx=5)
            
            self.connection_count_label = tk.Label(self.status_bar, text="Connections: 0",
                                                  bg=Win95Style.BG_COLOR, font=self.default_font)
            self.connection_count_label.pack(side=tk.RIGHT, padx=5)
            
            self.traffic_label = tk.Label(self.status_bar, text="Traffic: 0 KB/s",
                                         bg=Win95Style.BG_COLOR, font=self.default_font)
            self.traffic_label.pack(side=tk.RIGHT, padx=5)
        
        def toggle_data_mode(self):
            """Comută între date reale și demo"""
            self.use_real_data = not self.use_real_data
            
            if self.use_real_data:
                self.data_mode_btn.configure(text="Real Data")
                self.data_mode_indicator.configure(text="[REAL]", fg="green")
                self.log_message("Switched to real network data mode")
            else:
                self.data_mode_btn.configure(text="Demo Data")
                self.data_mode_indicator.configure(text="[DEMO]", fg="orange")
                self.log_message("Switched to demo data mode")
        
        def start_monitoring(self):
            """Pornește monitorizarea"""
            if not self.is_running:
                self.is_running = True
                self.start_btn.configure(state="disabled")
                self.stop_btn.configure(state="normal")
                self.status_indicator.configure(fg="green")
                
                mode_text = "real data" if self.use_real_data else "demo data"
                self.status_label.configure(text=f"Monitoring active ({mode_text})...")
                
                self.monitoring_thread = threading.Thread(target=self.monitor_loop, daemon=True)
                self.monitoring_thread.start()
                
                self.log_message(f"Monitoring started in {mode_text} mode")
        
        def stop_monitoring(self):
            """Oprește monitorizarea"""
            if self.is_running:
                self.is_running = False
                self.start_btn.configure(state="normal")
                self.stop_btn.configure(state="disabled")
                self.status_indicator.configure(fg="red")
                self.status_label.configure(text="Monitoring stopped")
                
                self.log_message("Monitoring stopped")
        
        def monitor_loop(self):
            """Loop principal de monitorizare"""
            while self.is_running:
                try:
                    # Alege sursa de date bazat pe modul curent
                    if self.use_real_data:
                        connections = self.monitor.get_network_connections()
                        if not connections:  # Dacă nu sunt date reale disponibile, folosește demo
                            connections = self.monitor.generate_demo_data()
                            self.log_message("No real connections found, using demo data")
                    else:
                        connections = self.monitor.generate_demo_data()
                    
                    # Limitează numărul de conexiuni afișate
                    if len(connections) > self.max_connections:
                        connections = connections[:self.max_connections]
                    
                    # Actualizează interfața în main thread
                    self.rootTRF.after(0, self.update_interface, connections)
                    
                    time.sleep(self.refresh_interval)
                except Exception as e:
                    self.log_message(f"Error in monitoring: {str(e)}")
                    time.sleep(5)
        
        def update_interface(self, connections):
            """Actualizează interfața cu noile date"""
            # Actualizează treeview-ul conexiunilor
            for item in self.connections_tree.get_children():
                self.connections_tree.delete(item)
            for conn in connections:
                timestamp = conn.get('timestamp', datetime.now()).strftime('%H:%M:%S')
                self.connections_tree.insert('', 'end', values=(
                    conn.get('local_ip', 'Unknown'),
                    conn.get('local_port', 0),
                    conn.get('remote_ip', 'Unknown'),
                    conn.get('remote_port', 0),
                    conn.get('service', 'Unknown'),
                    conn.get('process', 'Unknown'),
                    conn.get('pid', 0),
                    timestamp
                ))
            
            # Actualizează canvas-ul de rețea
            self.update_network_canvas(connections)
            
            # Actualizează tab-ul serviciilor
            self.update_services_tab(connections)
            
            # Actualizează statisticile
            self.update_statistics(connections)
            
            # Actualizează Network I/O
            self.update_network_io()
            
            # Actualizează bara de status
            self.connection_count_label.configure(text=f"Connections: {len(connections)}")
            
            # Calculează și afișează traficul
            total_traffic = sum(conn.get('bytes_sent', 0) + conn.get('bytes_recv', 0) for conn in connections)
            traffic_kb = total_traffic / 1024 if total_traffic > 1024 else total_traffic
            unit = "KB" if total_traffic > 1024 else "B"
            self.traffic_label.configure(text=f"Traffic: {traffic_kb:.1f} {unit}/s")
        
        def update_network_canvas(self, connections):
            """Actualizează canvas-ul cu harta de rețea"""
            self.network_canvas.delete("all")
            
            if not connections:
                self.network_canvas.create_text(300, 200, text="No active connections", 
                                               font=("MS Sans Serif", 12), fill="gray")
                return
            
            # Determină pozițiile pentru noduri
            local_ips = set(conn['local_ip'] for conn in connections)
            remote_ips = set(conn['remote_ip'] for conn in connections)
            
            # Creează nodurile locale (partea stângă)
            local_nodes = {}
            y_offset = 50
            for i, ip in enumerate(local_ips):
                x = 100
                y = y_offset + i * 80
                
                # Desenează nodul local
                if self.monitor.is_local_ip(ip):
                    color = "lightblue"
                    symbol = "🔵"
                else:
                    color = "yellow" 
                    symbol = "🟡"
                
                self.network_canvas.create_oval(x-30, y-20, x+30, y+20, 
                                               fill=color, outline="black", width=2)
                self.network_canvas.create_text(x, y-5, text=symbol, font=("MS Sans Serif", 12))
                self.network_canvas.create_text(x, y+35, text=ip, font=("MS Sans Serif", 8))
                
                local_nodes[ip] = (x, y)
            
            # Creează nodurile remote (partea dreaptă)
            remote_nodes = {}
            for i, ip in enumerate(remote_ips):
                x = 500
                y = y_offset + i * 80
                
                # Determină tipul de nod remote
                is_local = self.monitor.is_local_ip(ip)
                if is_local:
                    color = "yellow"
                    symbol = "🟡"
                else:
                    color = "lightcoral"
                    symbol = "🔴"
                
                # Verifică dacă este un server cunoscut
                for conn in connections:
                    if conn['remote_ip'] == ip and conn['remote_port'] in [80, 443, 22, 21]:
                        color = "gold"
                        symbol = "⭐"
                        break
                
                self.network_canvas.create_oval(x-30, y-20, x+30, y+20, 
                                               fill=color, outline="black", width=2)
                self.network_canvas.create_text(x, y-5, text=symbol, font=("MS Sans Serif", 12))
                self.network_canvas.create_text(x, y+35, text=ip, font=("MS Sans Serif", 8))
                
                remote_nodes[ip] = (x, y)
            
            # Desenează conexiunile
            for conn in connections:
                local_ip = conn['local_ip']
                remote_ip = conn['remote_ip']
                
                if local_ip in local_nodes and remote_ip in remote_nodes:
                    x1, y1 = local_nodes[local_ip]
                    x2, y2 = remote_nodes[remote_ip]
                    
                    # Culoarea liniei bazată pe serviciu
                    service = conn.get('service', 'Unknown')
                    if 'HTTP' in service:
                        line_color = "blue"
                    elif 'SSH' in service:
                        line_color = "green"
                    elif 'FTP' in service:
                        line_color = "orange"
                    else:
                        line_color = "gray"
                    
                    # Desenează linia de conexiune
                    self.network_canvas.create_line(x1+30, y1, x2-30, y2, 
                                                   fill=line_color, width=2, arrow=tk.LAST)
                    
                    # Etichetă pentru serviciu
                    mid_x = (x1 + x2) / 2
                    mid_y = (y1 + y2) / 2
                    self.network_canvas.create_text(mid_x, mid_y-10, text=service, 
                                                   font=("MS Sans Serif", 7), fill=line_color)
            
            # Configurează scrollregion
            self.network_canvas.configure(scrollregion=self.network_canvas.bbox("all"))
        
        def update_services_tab(self, connections):
            """Actualizează tab-ul serviciilor"""
            self.services_listbox.delete(0, tk.END)
            
            # Grupează conexiunile după serviciu
            service_groups = defaultdict(list)
            for conn in connections:
                service = conn.get('service', 'Unknown')
                service_groups[service].append(conn)
            
            # Afișează serviciile grupate
            for service, conns in service_groups.items():
                count = len(conns)
                processes = set(conn.get('process', 'Unknown') for conn in conns)
                process_list = ', '.join(list(processes)[:3])  # Limitează la 3 procese
                if len(processes) > 3:
                    process_list += f" (+{len(processes)-3} more)"
                
                self.services_listbox.insert(tk.END, 
                    f"{service} ({count} connections) - {process_list}")
        
        def update_statistics(self, connections):
            """Actualizează tab-ul statisticilor"""
            self.stats_text.configure(state="normal")
            self.stats_text.delete(1.0, tk.END)
            
            if not connections:
                self.stats_text.insert(tk.END, "No data available")
                self.stats_text.configure(state="disabled")
                return
            
            # Calculează statistici
            total_connections = len(connections)
            unique_local_ips = set(conn['local_ip'] for conn in connections)
            unique_remote_ips = set(conn['remote_ip'] for conn in connections)
            unique_services = set(conn['service'] for conn in connections)
            unique_processes = set(conn['process'] for conn in connections)
            
            # Porturile cele mai utilizate
            port_usage = defaultdict(int)
            for conn in connections:
                port_usage[conn['remote_port']] += 1
            
            top_ports = sorted(port_usage.items(), key=lambda x: x[1], reverse=True)[:5]
            
            # Procesele cele mai active
            process_usage = defaultdict(int)
            for conn in connections:
                process_usage[conn['process']] += 1
            
            top_processes = sorted(process_usage.items(), key=lambda x: x[1], reverse=True)[:5]
            
            # Generează raportul
            stats_text = f"""NETWORK TRAFFIC STATISTICS
    ========================================

    Connection Summary:
    • Total active connections: {total_connections}
    • Unique local IPs: {len(unique_local_ips)}
    • Unique remote IPs: {len(unique_remote_ips)}
    • Services detected: {len(unique_services)}
    • Active processes: {len(unique_processes)}

    Top Remote Ports:
    """
            
            for port, count in top_ports:
                service_name = self.monitor.service_groups.get(port, f"Port {port}")
                stats_text += f"• {port} ({service_name}): {count} connections\n"
            
            stats_text += "\nMost Active Processes:\n"
            for process, count in top_processes:
                stats_text += f"• {process}: {count} connections\n"
            
            stats_text += f"\nLocal Network Breakdown:\n"
            local_network_count = sum(1 for conn in connections 
                                     if self.monitor.is_local_ip(conn['remote_ip']))
            external_count = total_connections - local_network_count
            
            stats_text += f"• Local network connections: {local_network_count}\n"
            stats_text += f"• External connections: {external_count}\n"
            
            # Adaugă timestamp
            stats_text += f"\nLast updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            
            self.stats_text.insert(tk.END, stats_text)
            self.stats_text.configure(state="disabled")
        
        def update_network_io(self):
            """Actualizează tab-ul Network I/O"""
            self.io_text.configure(state="normal")
            self.io_text.delete(1.0, tk.END)
            
            # Obține statisticile de I/O
            io_stats = self.monitor.get_network_io_stats()
            interface_stats = self.monitor.get_interface_stats()
            
            if not io_stats:
                self.io_text.insert(tk.END, "Network I/O data not available")
                self.io_text.configure(state="disabled")
                return
            
            # Formatează statisticile generale
            io_text = f"""NETWORK I/O STATISTICS
    {'='*50}

    Global Network Statistics:
    Bytes Sent:     {io_stats.get('bytes_sent', 0):>15,} bytes
    Bytes Received: {io_stats.get('bytes_recv', 0):>15,} bytes
    Packets Sent:   {io_stats.get('packets_sent', 0):>15,} packets
    Packets Recv:   {io_stats.get('packets_recv', 0):>15,} packets

    Current Transfer Rates:
    Upload Speed:   {io_stats.get('bytes_sent_sec', 0):>12,.1f} bytes/sec
    Download Speed: {io_stats.get('bytes_recv_sec', 0):>12,.1f} bytes/sec
    Packets Up:     {io_stats.get('packets_sent_sec', 0):>12,.1f} packets/sec
    Packets Down:   {io_stats.get('packets_recv_sec', 0):>12,.1f} packets/sec

    Error Statistics:
    Input Errors:   {io_stats.get('errin', 0):>15,}
    Output Errors:  {io_stats.get('errout', 0):>15,}
    Dropped In:     {io_stats.get('dropin', 0):>15,}
    Dropped Out:    {io_stats.get('dropout', 0):>15,}

    INTERFACE BREAKDOWN:
    {'='*50}
    """
            
            # Adaugă statisticile pe interfață
            for interface, stats in interface_stats.items():
                io_text += f"\n{interface}:\n"
                io_text += f"  Sent:     {stats['bytes_sent']:>12,} bytes ({stats['packets_sent']:,} packets)\n"
                io_text += f"  Received: {stats['bytes_recv']:>12,} bytes ({stats['packets_recv']:,} packets)\n"
                io_text += f"  Errors:   In={stats['errin']}, Out={stats['errout']}\n"
                io_text += f"  Dropped:  In={stats['dropin']}, Out={stats['dropout']}\n"
            
            io_text += f"\nLast updated: {datetime.now().strftime('%H:%M:%S')}"
            
            self.io_text.insert(tk.END, io_text)
            self.io_text.configure(state="disabled")
        
        def log_message(self, message):
            """Adaugă un mesaj în log"""
            timestamp = datetime.now().strftime('%H:%M:%S')
            log_entry = f"[{timestamp}] {message}\n"
            
            self.log_text.configure(state="normal")
            self.log_text.insert(tk.END, log_entry)
            self.log_text.see(tk.END)  # Scroll la sfârșitul log-ului
            self.log_text.configure(state="disabled")
        
        def refresh_data(self):
            """Reîmprospătează datele manual"""
            if not self.is_running:
                # Dacă monitorizarea nu rulează, fă o actualizare unică
                if self.use_real_data:
                    connections = self.monitor.get_network_connections()
                    if not connections:
                        connections = self.monitor.generate_demo_data()
                        self.log_message("No real connections found, showing demo data")
                else:
                    connections = self.monitor.generate_demo_data()
                
                self.update_interface(connections)
                self.log_message("Data refreshed manually")
            else:
                self.log_message("Auto-refresh is active")
        
        def clear_history(self):
            """Șterge istoricul din toate tab-urile"""
            # Șterge conexiunile
            for item in self.connections_tree.get_children():
                self.connections_tree.delete(item)
            
            # Șterge serviciile
            self.services_listbox.delete(0, tk.END)
            
            # Șterge statisticile
            self.stats_text.configure(state="normal")
            self.stats_text.delete(1.0, tk.END)
            self.stats_text.configure(state="disabled")
            
            # Șterge I/O stats
            self.io_text.configure(state="normal")
            self.io_text.delete(1.0, tk.END)
            self.io_text.configure(state="disabled")
            
            # Șterge log-ul
            self.log_text.configure(state="normal")
            self.log_text.delete(1.0, tk.END)
            self.log_text.configure(state="disabled")
            
            # Șterge canvas-ul
            self.network_canvas.delete("all")
            
            self.log_message("History cleared")
        
        def new_session(self):
            """Creează o nouă sesiune"""
            if self.is_running:
                self.stop_monitoring()
            
            self.clear_history()
            self.status_label.configure(text="New session started")
            self.log_message("New session created")
        
        def save_data(self):
            """Salvează datele curente"""
            try:
                from tkinter import filedialog
                
                filename = filedialog.asksaveasfilename(
                    defaultextension=".json",
                    filetypes=[("JSON files", "*.json"), ("Text files", "*.txt"), ("All files", "*.*")],
                    title="Save Network Data"
                )
                
                if filename:
                    # Colectează datele din toate tab-urile
                    connections_data = []
                    for item in self.connections_tree.get_children():
                        values = self.connections_tree.item(item)['values']
                        connections_data.append({
                            'local_ip': values[0],
                            'local_port': values[1],
                            'remote_ip': values[2],
                            'remote_port': values[3],
                            'service': values[4],
                            'process': values[5],
                            'pid': values[6],
                            'timestamp': values[7]
                        })
                    
                    # Pregătește datele pentru salvare
                    save_data = {
                        'timestamp': datetime.now().isoformat(),
                        'data_mode': 'real' if self.use_real_data else 'demo',
                        'connections': connections_data,
                        'total_connections': len(connections_data)
                    }
                    
                    if filename.endswith('.json'):
                        with open(filename, 'w', encoding='utf-8') as f:
                            json.dump(save_data, f, indent=2, ensure_ascii=False)
                    else:
                        with open(filename, 'w', encoding='utf-8') as f:
                            f.write(f"Network Traffic Data Export\n")
                            f.write(f"Generated: {save_data['timestamp']}\n")
                            f.write(f"Data Mode: {save_data['data_mode']}\n")
                            f.write(f"Total Connections: {save_data['total_connections']}\n\n")
                            
                            for conn in connections_data:
                                f.write(f"{conn['local_ip']}:{conn['local_port']} -> ")
                                f.write(f"{conn['remote_ip']}:{conn['remote_port']} ")
                                f.write(f"({conn['service']}) - {conn['process']} [{conn['pid']}] ")
                                f.write(f"at {conn['timestamp']}\n")
                    
                    self.log_message(f"Data saved to {filename}")
                    self.status_label.configure(text=f"Data saved to {filename}")
                    
            except Exception as e:
                messagebox.showerror("Save Error", f"Failed to save data: {str(e)}")
                self.log_message(f"Save failed: {str(e)}")
        
        def toggle_demo(self):
            """Comută între modul demo și normal"""
            if not self.use_real_data:
                self.use_real_data = True
                self.demo_btn.configure(text="Demo Mode")
                self.data_mode_indicator.configure(text="[REAL]", fg="green")
                self.log_message("Switched to real data mode")
            else:
                self.use_real_data = False
                self.demo_btn.configure(text="Real Mode")
                self.data_mode_indicator.configure(text="[DEMO]", fg="orange")
                self.log_message("Switched to demo mode")
        
        def show_settings(self):
            """Afișează fereastra de setări"""
            settings_window = tk.Toplevel(self.rootTRF)
            settings_window.title("Settings")
            settings_window.geometry("400x300")
            settings_window.configure(bg=Win95Style.BG_COLOR)
            settings_window.resizable(False, False)
            
            # Centrează fereastra
            settings_window.transient(self.rootTRF)
            settings_window.grab_set()
            
            # Frame principal
            main_frame = tk.Frame(settings_window, bg=Win95Style.BG_COLOR)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Setări refresh interval
            tk.Label(main_frame, text="Refresh Interval (seconds):", 
                    bg=Win95Style.BG_COLOR, font=self.default_font).pack(anchor="w")
            
            refresh_frame = tk.Frame(main_frame, bg=Win95Style.BG_COLOR)
            refresh_frame.pack(fill=tk.X, pady=5)
            
            self.refresh_var = tk.StringVar(value=str(self.refresh_interval))
            refresh_entry = tk.Entry(refresh_frame, textvariable=self.refresh_var, width=10)
            refresh_entry.pack(side=tk.LEFT)
            
            # Setări max connections
            tk.Label(main_frame, text="Maximum Connections to Display:", 
                    bg=Win95Style.BG_COLOR, font=self.default_font).pack(anchor="w", pady=(10, 0))
            
            max_conn_frame = tk.Frame(main_frame, bg=Win95Style.BG_COLOR)
            max_conn_frame.pack(fill=tk.X, pady=5)
            
            self.max_conn_var = tk.StringVar(value=str(self.max_connections))
            max_conn_entry = tk.Entry(max_conn_frame, textvariable=self.max_conn_var, width=10)
            max_conn_entry.pack(side=tk.LEFT)
            
            # Checkbox pentru auto-save
            self.auto_save_var = tk.BooleanVar(value=self.auto_save_enabled)
            auto_save_check = tk.Checkbutton(main_frame, text="Auto-save session data",
                                            variable=self.auto_save_var,
                                            bg=Win95Style.BG_COLOR, font=self.default_font)
            auto_save_check.pack(anchor="w", pady=10)
            
            # Butoane
            button_frame = tk.Frame(main_frame, bg=Win95Style.BG_COLOR)
            button_frame.pack(fill=tk.X, pady=(20, 0))
            
            def apply_settings():
                try:
                    self.refresh_interval = max(1, int(self.refresh_var.get()))
                    self.max_connections = max(10, int(self.max_conn_var.get()))
                    self.auto_save_enabled = self.auto_save_var.get()
                    
                    self.log_message("Settings updated successfully")
                    settings_window.destroy()
                except ValueError:
                    messagebox.showerror("Invalid Input", "Please enter valid numbers")
            
            ok_btn = tk.Button(button_frame, text="OK", command=apply_settings)
            Win95Style.apply_button_style(ok_btn)
            ok_btn.pack(side=tk.RIGHT, padx=5)
            
            cancel_btn = tk.Button(button_frame, text="Cancel", command=settings_window.destroy)
            Win95Style.apply_button_style(cancel_btn)
            cancel_btn.pack(side=tk.RIGHT)
        
        def show_network_info(self):
            """Afișează informații despre rețea"""
            info_window = tk.Toplevel(self.rootTRF)
            info_window.title("Network Information")
            info_window.geometry("500x400")
            info_window.configure(bg=Win95Style.BG_COLOR)
            
            # Text widget pentru informații
            info_text = tk.Text(info_window, bg="white", font=("Courier New", 9),
                               state="disabled", wrap=tk.WORD)
            info_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Scrollbar
            info_scroll = ttk.Scrollbar(info_window, orient="vertical", command=info_text.yview)
            info_text.configure(yscrollcommand=info_scroll.set)
            info_scroll.pack(side="right", fill="y")
            
            # Colectează informații despre rețea
            info_text.configure(state="normal")
            
            try:
                import psutil
                
                network_info = "NETWORK INTERFACE INFORMATION\n"
                network_info += "=" * 50 + "\n\n"
                
                # Adrese IP
                addrs = psutil.net_if_addrs()
                for interface_name, interface_addresses in addrs.items():
                    network_info += f"Interface: {interface_name}\n"
                    for address in interface_addresses:
                        if address.family.name == 'AF_INET':
                            network_info += f"  IPv4 Address: {address.address}\n"
                            network_info += f"  Netmask: {address.netmask}\n"
                            if address.broadcast:
                                network_info += f"  Broadcast: {address.broadcast}\n"
                        elif address.family.name == 'AF_INET6':
                            network_info += f"  IPv6 Address: {address.address}\n"
                    network_info += "\n"
                
                # Statistici rețea
                net_stats = psutil.net_if_stats()
                network_info += "INTERFACE STATISTICS\n"
                network_info += "=" * 50 + "\n\n"
                
                for interface_name, stats in net_stats.items():
                    network_info += f"Interface: {interface_name}\n"
                    network_info += f"  Status: {'UP' if stats.isup else 'DOWN'}\n"
                    network_info += f"  Speed: {stats.speed} Mbps\n"
                    network_info += f"  MTU: {stats.mtu}\n\n"
                
            except Exception as e:
                network_info = f"Error retrieving network information: {str(e)}"
            
            info_text.insert(tk.END, network_info)
            info_text.configure(state="disabled")
        
        def show_about(self):
            """Afișează fereastra About"""
            about_text = """Traffic Visualizer v1.0

    A network traffic monitoring tool.

    Features:
    • Real-time network connection monitoring
    • Visual network map
    • Service grouping and statistics
    • Network I/O monitoring
    • Demo mode for testing

    Developed with Python and C++
    Tudor Marmureanu"""
            
            messagebox.showinfo("About Traffic Visualizer", about_text)

    def main():
        """Funcția principală"""
        rootTRF = tk.Tk()
        app = TrafficVisualizer(rootTRF)
        
        # Configurare pentru închiderea aplicației
        def on_closing():
            if app.is_running:
                app.stop_monitoring()
            rootTRF.destroy()
        
        rootTRF.protocol("WM_DELETE_WINDOW", on_closing)
        
        # Log mesaj de pornire
        app.log_message("Traffic Visualizer started")
        app.log_message("Click 'Start' to begin monitoring network traffic")
        
        rootTRF.mainloop()

    if __name__ == "__main__":
        main()
        
if dosboxvar == 3333444400999:
    import getpass
    import glob
    import csv
    import tarfile
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class AdvancedTerminal:
        def __init__(self):
            self.rootdosbox = tk.Tk()
            self.rootdosbox.title("DosBox Terminal")
            self.rootdosbox.geometry("900x700")
            self.rootdosbox.configure(bg='#c0c0c0')
            
            # Configure fonts and colors
            self.font_normal = ('MS Sans Serif', 8)
            self.font_mono = ('Courier New', 10)
            self.color_bg = '#c0c0c0'
            self.color_button = '#c0c0c0'
            self.color_text = '#000000'
            self.color_highlight = '#0000ff'
            
            # Current directory - folosește directorul real curent
            self.current_dir = os.getcwd()
            self.command_history = []
            self.history_index = -1
            self.environment_vars = dict(os.environ)
            
            self.setup_ui()
            
        def setup_ui(self):
            # Menu bar
            self.create_menu()
            
            # Toolbar
            self.create_toolbar()
            
            # Main content area
            self.create_main_area()
            
            # Status bar
            self.create_status_bar()
            
        def create_menu(self):
            menubar = tk.Menu(self.rootdosbox, bg=self.color_bg, fg=self.color_text)
            self.rootdosbox.config(menu=menubar)
            
            # File menu
            file_menu = tk.Menu(menubar, tearoff=0, bg=self.color_bg, fg=self.color_text)
            menubar.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="New", command=self.new_file)
            file_menu.add_command(label="Open...", command=self.open_file)
            file_menu.add_command(label="Save Output...", command=self.save_output)
            file_menu.add_separator()
            file_menu.add_command(label="Exit", command=self.rootdosbox.quit)
            
            # Edit menu
            edit_menu = tk.Menu(menubar, tearoff=0, bg=self.color_bg, fg=self.color_text)
            menubar.add_cascade(label="Edit", menu=edit_menu)
            edit_menu.add_command(label="Copy", command=self.copy_text)
            edit_menu.add_command(label="Paste", command=self.paste_text)
            edit_menu.add_command(label="Select All", command=self.select_all)
            edit_menu.add_command(label="Clear", command=self.clear_terminal)
            
            # Tools menu
            tools_menu = tk.Menu(menubar, tearoff=0, bg=self.color_bg, fg=self.color_text)
            menubar.add_cascade(label="Tools", menu=tools_menu)
            tools_menu.add_command(label="File Manager", command=self.open_file_manager)
            tools_menu.add_command(label="System Info", command=self.show_system_info)
            tools_menu.add_command(label="Process Monitor", command=self.show_processes)
            tools_menu.add_command(label="Network Info", command=self.show_network_info)
            tools_menu.add_command(label="Calculator", command=self.open_calculator)
            
            # Help menu
            help_menu = tk.Menu(menubar, tearoff=0, bg=self.color_bg, fg=self.color_text)
            menubar.add_cascade(label="Help", menu=help_menu)
            help_menu.add_command(label="Commands Help", command=self.show_commands_help)
            help_menu.add_command(label="About", command=self.show_about)
            
        def create_toolbar(self):
            toolbar = tk.Frame(self.rootdosbox, bg=self.color_bg, relief=tk.RAISED, bd=1)
            toolbar.pack(side=tk.TOP, fill=tk.X, padx=2, pady=2)
            
            # Toolbar buttons
            buttons = [
                ("New", self.new_file),
                ("Open", self.open_file),
                ("Save", self.save_output),
                ("|", None),
                ("Copy", self.copy_text),
                ("Paste", self.paste_text),
                ("|", None),
                ("Dir", self.list_directory),
                ("Clear", self.clear_terminal),
                ("|", None),
                ("Processes", self.show_processes),
                ("SysInfo", self.show_system_info)
            ]
            
            for text, command in buttons:
                if text == "|":
                    separator = tk.Frame(toolbar, width=2, bg='#808080')
                    separator.pack(side=tk.LEFT, fill=tk.Y, padx=2)
                else:
                    btn = tk.Button(toolbar, text=text, command=command,
                                  bg=self.color_button, fg=self.color_text,
                                  font=self.font_normal, relief=tk.RAISED, bd=1,
                                  padx=8, pady=2)
                    btn.pack(side=tk.LEFT, padx=1)
                    
        def create_main_area(self):
            # Main frame
            main_frame = tk.Frame(self.rootdosbox, bg=self.color_bg)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
            
            # Terminal/Console
            terminal_frame = tk.Frame(main_frame, bg='#000000', relief=tk.SUNKEN, bd=2)
            terminal_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 4))
            
            # Terminal text widget
            self.terminal = tk.Text(terminal_frame, bg='#000000', fg='#00ff00',
                                   font=self.font_mono, insertbackground='#00ff00',
                                   wrap=tk.WORD, state=tk.DISABLED)
            
            # Terminal scrollbar
            scrollbar = tk.Scrollbar(terminal_frame, command=self.terminal.yview)
            self.terminal.config(yscrollcommand=scrollbar.set)
            
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.terminal.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Command input
            cmd_frame = tk.Frame(main_frame, bg=self.color_bg)
            cmd_frame.pack(fill=tk.X)
            
            tk.Label(cmd_frame, text="Command:", bg=self.color_bg, fg=self.color_text,
                    font=self.font_normal).pack(side=tk.LEFT, padx=(0, 4))
            
            self.cmd_entry = tk.Entry(cmd_frame, font=self.font_mono, bg='#ffffff',
                                     fg='#000000')
            self.cmd_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 4))
            self.cmd_entry.bind('<Return>', self.execute_command)
            self.cmd_entry.bind('<Up>', self.history_up)
            self.cmd_entry.bind('<Down>', self.history_down)
            self.cmd_entry.bind('<Tab>', self.auto_complete)
            
            execute_btn = tk.Button(cmd_frame, text="Execute", command=self.execute_command,
                                   bg=self.color_button, fg=self.color_text,
                                   font=self.font_normal, relief=tk.RAISED, bd=1)
            execute_btn.pack(side=tk.RIGHT)
            
            # Initialize terminal
            self.write_terminal("Advanced Terminal v2.0\n")
            self.write_terminal(f"Welcome {getpass.getuser()}!\n")
            self.write_terminal("Type 'help' or 'commands' for available commands.\n\n")
            self.write_terminal(f"{self.get_prompt()}")
            
        def create_status_bar(self):
            status_frame = tk.Frame(self.rootdosbox, bg=self.color_bg, relief=tk.SUNKEN, bd=1)
            status_frame.pack(side=tk.BOTTOM, fill=tk.X)
            
            self.status_label = tk.Label(status_frame, text="Ready", bg=self.color_bg,
                                        fg=self.color_text, font=self.font_normal,
                                        anchor=tk.W)
            self.status_label.pack(side=tk.LEFT, padx=4, pady=2)
            
            # Current directory display
            self.dir_label = tk.Label(status_frame, text=f"Dir: {self.current_dir}", 
                                     bg=self.color_bg, fg=self.color_text, 
                                     font=self.font_normal)
            self.dir_label.pack(side=tk.LEFT, padx=20)
            
            # Time display
            self.time_label = tk.Label(status_frame, text="", bg=self.color_bg,
                                      fg=self.color_text, font=self.font_normal)
            self.time_label.pack(side=tk.RIGHT, padx=4, pady=2)
            
            self.update_time()
            
        def get_prompt(self):
            return f"{getpass.getuser()}@{socket.gethostname()}:{os.path.basename(self.current_dir)}$ "
            
        def update_time(self):
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            self.time_label.config(text=current_time)
            self.rootdosbox.after(1000, self.update_time)
            
        def write_terminal(self, text):
            self.terminal.config(state=tk.NORMAL)
            self.terminal.insert(tk.END, text)
            self.terminal.config(state=tk.DISABLED)
            self.terminal.see(tk.END)
            
        def execute_command(self, event=None):
            command = self.cmd_entry.get().strip()
            if not command:
                return
                
            self.command_history.append(command)
            self.history_index = len(self.command_history)
            
            self.write_terminal(f"{command}\n")
            self.cmd_entry.delete(0, tk.END)
            
            # Process command
            self.process_command(command)
            
        def process_command(self, command):
            # Handle pipes and redirections
            if '|' in command:
                self.handle_pipe(command)
                return
            elif '>' in command:
                self.handle_redirect(command)
                return
                
            parts = command.split()
            if not parts:
                return
                
            cmd = parts[0].lower()
            args = parts[1:] if len(parts) > 1 else []
            
            # Command dictionary for better organization
            commands = {
                # Basic commands
                'help': self.show_help,
                'commands': self.show_commands_help,
                'dir': self.list_directory,
                'ls': self.list_directory,
                'cd': lambda: self.change_directory(args),
                'pwd': self.print_working_directory,
                'cls': self.clear_terminal,
                'clear': self.clear_terminal,
                'exit': self.rootdosbox.quit,
                'quit': self.rootdosbox.quit,
                
                # File operations
                'type': lambda: self.type_file(args),
                'cat': lambda: self.type_file(args),
                'copy': lambda: self.copy_file(args),
                'cp': lambda: self.copy_file(args),
                'move': lambda: self.move_file(args),
                'mv': lambda: self.move_file(args),
                'del': lambda: self.delete_file(args),
                'rm': lambda: self.delete_file(args),
                'mkdir': lambda: self.make_directory(args),
                'rmdir': lambda: self.remove_directory(args),
                'touch': lambda: self.touch_file(args),
                'find': lambda: self.find_files(args),
                'grep': lambda: self.grep_text(args),
                'wc': lambda: self.word_count(args),
                'head': lambda: self.head_file(args),
                'tail': lambda: self.tail_file(args),
                'chmod': lambda: self.change_permissions(args),
                'du': lambda: self.disk_usage(args),
                'df': self.disk_free,
                
                # System information
                'date': self.show_date,
                'time': self.show_time,
                'ver': self.show_version,
                'whoami': self.whoami,
                'hostname': self.hostname,
                'uname': self.uname,
                'uptime': self.uptime,
                'ps': self.list_processes,
                'top': self.show_top_processes,
                'kill': lambda: self.kill_process(args),
                'env': self.show_environment,
                'set': lambda: self.set_environment(args),
                'unset': lambda: self.unset_environment(args),
                'path': self.show_path,
                
                # Network commands
                'ping': lambda: self.ping_host(args),
                'netstat': self.netstat,
                'ipconfig': self.ipconfig,
                'ifconfig': self.ipconfig,
                'wget': lambda: self.wget_file(args),
                'curl': lambda: self.curl_url(args),
                
                # Text processing
                'echo': lambda: self.echo_text(args),
                'sort': lambda: self.sort_file(args),
                'uniq': lambda: self.unique_lines(args),
                'cut': lambda: self.cut_text(args),
                
                # Archive operations
                'zip': lambda: self.create_zip(args),
                'unzip': lambda: self.extract_zip(args),
                'tar': lambda: self.tar_operations(args),
                
                # System operations
                'history': self.show_history,
                'alias': lambda: self.create_alias(args),
                'which': lambda: self.which_command(args),
                'whereis': lambda: self.whereis_command(args),
                'tree': lambda: self.show_tree(args),
                'calc': lambda: self.calculator(args),
                'base64': lambda: self.base64_encode_decode(args),
                'md5': lambda: self.calculate_hash(args, 'md5'),
                'sha1': lambda: self.calculate_hash(args, 'sha1'),
                'sha256': lambda: self.calculate_hash(args, 'sha256'),
                
                # Python integration
                'python': lambda: self.run_python(args),
                'py': lambda: self.run_python(args),
                'pip': lambda: self.run_pip(args),
                
                # System control
                'service': lambda: self.service_control(args),
                'systemctl': lambda: self.systemctl(args),
                'crontab': lambda: self.crontab_operations(args),
                
                # File editing
                'nano': lambda: self.nano_editor(args),
                'vim': lambda: self.vim_editor(args),
                'edit': lambda: self.simple_editor(args),
            }
            
            if cmd in commands:
                try:
                    commands[cmd]()
                except Exception as e:
                    self.write_terminal(f"Error executing {cmd}: {str(e)}\n")
            else:
                # Try to execute as system command
                self.execute_system_command(command)
                
            self.write_terminal(f"{self.get_prompt()}")
            
        def execute_system_command(self, command):
            try:
                result = subprocess.run(command, shell=True, capture_output=True, 
                                      text=True, cwd=self.current_dir, timeout=30)
                if result.stdout:
                    self.write_terminal(result.stdout)
                if result.stderr:
                    self.write_terminal(f"Error: {result.stderr}")
                if result.returncode != 0:
                    self.write_terminal(f"Command exited with code {result.returncode}\n")
            except subprocess.TimeoutExpired:
                self.write_terminal("Command timed out after 30 seconds\n")
            except Exception as e:
                self.write_terminal(f"Command not found: {command}\n")
                
        def handle_pipe(self, command):
            parts = command.split('|')
            self.write_terminal("Pipe operations not fully implemented yet\n")
            
        def handle_redirect(self, command):
            if '>' in command:
                parts = command.split('>', 1)
                cmd = parts[0].strip()
                filename = parts[1].strip()
                self.write_terminal(f"Redirect to {filename} not fully implemented yet\n")
                
        # File operations
        def list_directory(self):
            try:
                files = os.listdir(self.current_dir)
                self.write_terminal(f"Directory of {self.current_dir}\n\n")
                
                total_size = 0
                file_count = 0
                dir_count = 0
                
                # Sort files and directories
                items = []
                for file in sorted(files):
                    file_path = os.path.join(self.current_dir, file)
                    stat = os.stat(file_path)
                    modified = datetime.datetime.fromtimestamp(stat.st_mtime)
                    
                    if os.path.isdir(file_path):
                        items.append((file, '<DIR>', modified, 0))
                        dir_count += 1
                    else:
                        size = stat.st_size
                        items.append((file, size, modified, size))
                        file_count += 1
                        total_size += size
                
                # Display items
                for name, size, modified, actual_size in items:
                    time_str = modified.strftime("%d/%m/%Y %H:%M")
                    if size == '<DIR>':
                        self.write_terminal(f"{time_str}    <DIR>          {name}\n")
                    else:
                        self.write_terminal(f"{time_str}    {size:>12,} {name}\n")
                
                self.write_terminal(f"\n{file_count} File(s) {total_size:,} bytes\n")
                self.write_terminal(f"{dir_count} Dir(s)\n")
                            
            except Exception as e:
                self.write_terminal(f"Error listing directory: {str(e)}\n")
                
        def change_directory(self, args):
            if not args:
                self.write_terminal(f"{self.current_dir}\n")
                return
                
            new_dir = args[0]
            
            try:
                if new_dir == "..":
                    new_path = os.path.dirname(self.current_dir)
                elif new_dir == "~":
                    new_path = os.path.expanduser("~")
                elif new_dir == "-":
                    # Go to previous directory (not implemented)
                    self.write_terminal("Previous directory not tracked\n")
                    return
                elif os.path.isabs(new_dir):
                    new_path = new_dir
                else:
                    new_path = os.path.join(self.current_dir, new_dir)
                    
                new_path = os.path.abspath(new_path)
                
                if os.path.exists(new_path) and os.path.isdir(new_path):
                    self.current_dir = new_path
                    self.update_status(f"Changed to: {self.current_dir}")
                    self.dir_label.config(text=f"Dir: {self.current_dir}")
                else:
                    self.write_terminal(f"Directory not found: {new_dir}\n")
                    
            except Exception as e:
                self.write_terminal(f"Error changing directory: {str(e)}\n")
                
        def print_working_directory(self):
            self.write_terminal(f"{self.current_dir}\n")
            
        def type_file(self, args):
            if not args:
                self.write_terminal("Usage: type <filename>\n")
                return
                
            filename = args[0]
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    self.write_terminal(content)
                    if not content.endswith('\n'):
                        self.write_terminal('\n')
            except Exception as e:
                self.write_terminal(f"Error reading file: {str(e)}\n")
                
        def copy_file(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: copy <source> <destination>\n")
                return
                
            src = args[0]
            dst = args[1]
            
            try:
                if not os.path.isabs(src):
                    src = os.path.join(self.current_dir, src)
                if not os.path.isabs(dst):
                    dst = os.path.join(self.current_dir, dst)
                    
                if os.path.isdir(src):
                    shutil.copytree(src, dst)
                else:
                    shutil.copy2(src, dst)
                self.write_terminal(f"Copied {args[0]} to {args[1]}\n")
            except Exception as e:
                self.write_terminal(f"Error copying: {str(e)}\n")
                
        def move_file(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: move <source> <destination>\n")
                return
                
            src = args[0]
            dst = args[1]
            
            try:
                if not os.path.isabs(src):
                    src = os.path.join(self.current_dir, src)
                if not os.path.isabs(dst):
                    dst = os.path.join(self.current_dir, dst)
                    
                shutil.move(src, dst)
                self.write_terminal(f"Moved {args[0]} to {args[1]}\n")
            except Exception as e:
                self.write_terminal(f"Error moving: {str(e)}\n")
                
        def delete_file(self, args):
            if not args:
                self.write_terminal("Usage: del <filename>\n")
                return
                
            for filename in args:
                file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
                
                try:
                    if os.path.isdir(file_path):
                        shutil.rmtree(file_path)
                    else:
                        os.remove(file_path)
                    self.write_terminal(f"Deleted: {filename}\n")
                except Exception as e:
                    self.write_terminal(f"Error deleting {filename}: {str(e)}\n")
                    
        def make_directory(self, args):
            if not args:
                self.write_terminal("Usage: mkdir <directory>\n")
                return
                
            for dirname in args:
                dir_path = os.path.join(self.current_dir, dirname) if not os.path.isabs(dirname) else dirname
                
                try:
                    os.makedirs(dir_path, exist_ok=True)
                    self.write_terminal(f"Directory created: {dirname}\n")
                except Exception as e:
                    self.write_terminal(f"Error creating directory {dirname}: {str(e)}\n")
                    
        def remove_directory(self, args):
            if not args:
                self.write_terminal("Usage: rmdir <directory>\n")
                return
                
            for dirname in args:
                dir_path = os.path.join(self.current_dir, dirname) if not os.path.isabs(dirname) else dirname
                
                try:
                    os.rmdir(dir_path)
                    self.write_terminal(f"Directory removed: {dirname}\n")
                except Exception as e:
                    self.write_terminal(f"Error removing directory {dirname}: {str(e)}\n")
                    
        def touch_file(self, args):
            if not args:
                self.write_terminal("Usage: touch <filename>\n")
                return
                
            for filename in args:
                file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
                
                try:
                    with open(file_path, 'a'):
                        pass
                    self.write_terminal(f"File created/touched: {filename}\n")
                except Exception as e:
                    self.write_terminal(f"Error touching file {filename}: {str(e)}\n")
                    
        def find_files(self, args):
            if not args:
                self.write_terminal("Usage: find <pattern>\n")
                return
                
            pattern = args[0]
            search_dir = self.current_dir
            
            if len(args) > 1:
                search_dir = args[1] if os.path.isabs(args[1]) else os.path.join(self.current_dir, args[1])
                
            try:
                matches = []
                for rootdosbox, dirs, files in os.walk(search_dir):
                    for file in files:
                        if pattern in file:
                            matches.append(os.path.join(rootdosbox, file))
                            
                if matches:
                    for match in matches:
                        self.write_terminal(f"{match}\n")
                else:
                    self.write_terminal("No files found matching pattern\n")
            except Exception as e:
                self.write_terminal(f"Error searching: {str(e)}\n")
                
        def grep_text(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: grep <pattern> <filename>\n")
                return
                
            pattern = args[0]
            filename = args[1]
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    line_num = 1
                    for line in f:
                        if pattern in line:
                            self.write_terminal(f"{line_num}: {line}")
                        line_num += 1
            except Exception as e:
                self.write_terminal(f"Error searching file: {str(e)}\n")
                
        def word_count(self, args):
            if not args:
                self.write_terminal("Usage: wc <filename>\n")
                return
                
            filename = args[0]
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.count('\n')
                    words = len(content.split())
                    chars = len(content)
                    self.write_terminal(f"{lines:>8} {words:>8} {chars:>8} {filename}\n")
            except Exception as e:
                self.write_terminal(f"Error reading file: {str(e)}\n")
                
        def head_file(self, args):
            filename = args[0] if args else None
            lines = 10
            
            if len(args) > 1 and args[0] == '-n':
                lines = int(args[1])
                filename = args[2] if len(args) > 2 else None
                
            if not filename:
                self.write_terminal("Usage: head [-n lines] <filename>\n")
                return
                
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    for i, line in enumerate(f):
                        if i >= lines:
                            break
                        self.write_terminal(line)
            except Exception as e:
                self.write_terminal(f"Error reading file: {str(e)}\n")
                
        def tail_file(self, args):
            filename = args[0] if args else None
            lines = 10
            
            if len(args) > 1 and args[0] == '-n':
                lines = int(args[1])
                filename = args[2] if len(args) > 2 else None
                
            if not filename:
                self.write_terminal("Usage: tail [-n lines] <filename>\n")
                return
                
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    all_lines = f.readlines()
                    for line in all_lines[-lines:]:
                        self.write_terminal(line)
            except Exception as e:
                self.write_terminal(f"Error reading file: {str(e)}\n")
                
        # System information commands
        def show_date(self):
            current_date = datetime.datetime.now().strftime("%A, %B %d, %Y")
            self.write_terminal(f"{current_date}\n")
            
        def show_time(self):
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            self.write_terminal(f"{current_time}\n")
            
        def show_version(self):
            self.write_terminal("Advanced Terminal Version 2.0\n")
            self.write_terminal(f"Python {sys.version}\n")
            self.write_terminal(f"Platform: {platform.platform()}\n")
            
        def whoami(self):
            self.write_terminal(f"{getpass.getuser()}\n")
            
        def hostname(self):
            self.write_terminal(f"{socket.gethostname()}\n")
            
        def uname(self):
            self.write_terminal(f"{platform.system()} {platform.release()} {platform.machine()}\n")
            
        def uptime(self):
            try:
                boot_time = psutil.boot_time()
                uptime_seconds = datetime.datetime.now().timestamp() - boot_time
                uptime_str = str(datetime.timedelta(seconds=int(uptime_seconds)))
                self.write_terminal(f"System uptime: {uptime_str}\n")
            except:
                self.write_terminal("Uptime information not available\n")
                
        def list_processes(self):
            try:
                self.write_terminal(f"{'PID':<8} {'Name':<25} {'CPU%':<8} {'Memory%':<10}\n")
                self.write_terminal("-" * 60 + "\n")
                
                for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                    try:
                        info = proc.info
                        self.write_terminal(f"{info['pid']:<8} {info['name'][:24]:<25} "
                                          f"{info['cpu_percent']:<8.1f} {info['memory_percent']:<10.1f}\n")
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
            except Exception as e:
                self.write_terminal(f"Error listing processes: {str(e)}\n")
                
        def show_top_processes(self):
            try:
                processes = []
                for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                    try:
                        processes.append(proc.info)
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                # Sort by CPU usage
                processes.sort(key=lambda x: x['cpu_percent'] or 0, reverse=True)
                
                self.write_terminal("Top processes by CPU usage:\n")
                self.write_terminal(f"{'PID':<8} {'Name':<25} {'CPU%':<8} {'Memory%':<10}\n")
                self.write_terminal("-" * 60 + "\n")
                
                for proc in processes[:10]:  # Top 10
                    self.write_terminal(f"{proc['pid']:<8} {proc['name'][:24]:<25} "
                                      f"{proc['cpu_percent'] or 0:<8.1f} {proc['memory_percent'] or 0:<10.1f}\n")
            except Exception as e:
                self.write_terminal(f"Error showing top processes: {str(e)}\n")
                
        def kill_process(self, args):
            if not args:
                self.write_terminal("Usage: kill <pid>\n")
                return
                
            try:
                pid = int(args[0])
                proc = psutil.Process(pid)
                proc.terminate()
                self.write_terminal(f"Process {pid} terminated\n")
            except ValueError:
                self.write_terminal("Invalid PID\n")
            except psutil.NoSuchProcess:
                self.write_terminal(f"No process with PID {args[0]}\n")
            except psutil.AccessDenied:
                self.write_terminal(f"Access denied to terminate process {args[0]}\n")
            except Exception as e:
                self.write_terminal(f"Error killing process: {str(e)}\n")
                
        def show_environment(self):
            for key, value in sorted(self.environment_vars.items()):
                self.write_terminal(f"{key}={value}\n")
                
        def set_environment(self, args):
            if not args:
                self.show_environment()
                return
                
            if '=' in args[0]:
                key, value = args[0].split('=', 1)
                self.environment_vars[key] = value
                os.environ[key] = value
                self.write_terminal(f"Set {key}={value}\n")
            else:
                self.write_terminal("Usage: set VAR=value\n")
                
        def unset_environment(self, args):
            if not args:
                self.write_terminal("Usage: unset <variable>\n")
                return
                
            for var in args:
                if var in self.environment_vars:
                    del self.environment_vars[var]
                    if var in os.environ:
                        del os.environ[var]
                    self.write_terminal(f"Unset {var}\n")
                else:
                    self.write_terminal(f"Variable {var} not found\n")
                    
        def show_path(self):
            path = os.environ.get('PATH', '')
            for p in path.split(os.pathsep):
                self.write_terminal(f"{p}\n")
                
        def disk_usage(self, args):
            path = args[0] if args else self.current_dir
            if not os.path.isabs(path):
                path = os.path.join(self.current_dir, path)
                
            try:
                total_size = 0
                for dirpath, dirnames, filenames in os.walk(path):
                    for filename in filenames:
                        filepath = os.path.join(dirpath, filename)
                        try:
                            total_size += os.path.getsize(filepath)
                        except:
                            continue
                
                # Convert to human readable format
                for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
                    if total_size < 1024.0:
                        self.write_terminal(f"{total_size:.1f}{unit}\t{path}\n")
                        break
                    total_size /= 1024.0
            except Exception as e:
                self.write_terminal(f"Error calculating disk usage: {str(e)}\n")
                
        def disk_free(self):
            try:
                usage = psutil.disk_usage(self.current_dir)
                total = usage.total
                used = usage.used
                free = usage.free
                
                self.write_terminal(f"{'Filesystem':<15} {'Size':<10} {'Used':<10} {'Avail':<10} {'Use%':<6}\n")
                
                def format_bytes(bytes_val):
                    for unit in ['B', 'K', 'M', 'G', 'T']:
                        if bytes_val < 1024.0:
                            return f"{bytes_val:.1f}{unit}"
                        bytes_val /= 1024.0
                    return f"{bytes_val:.1f}P"
                
                use_percent = (used / total) * 100 if total > 0 else 0
                self.write_terminal(f"{'/':<15} {format_bytes(total):<10} {format_bytes(used):<10} "
                                  f"{format_bytes(free):<10} {use_percent:.1f}%\n")
            except Exception as e:
                self.write_terminal(f"Error getting disk usage: {str(e)}\n")
                
        def change_permissions(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: chmod <mode> <file>\n")
                return
                
            try:
                mode = args[0]
                filename = args[1]
                file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
                
                # Simple permission change (this is platform dependent)
                if mode == '+x':
                    current = os.stat(file_path).st_mode
                    os.chmod(file_path, current | 0o111)
                    self.write_terminal(f"Made {filename} executable\n")
                else:
                    self.write_terminal(f"Permission mode {mode} not supported in this implementation\n")
            except Exception as e:
                self.write_terminal(f"Error changing permissions: {str(e)}\n")
                
        # Network commands
        def ping_host(self, args):
            if not args:
                self.write_terminal("Usage: ping <hostname>\n")
                return
                
            host = args[0]
            count = 4
            
            if len(args) > 1 and args[0] == '-c':
                count = int(args[1])
                host = args[2] if len(args) > 2 else None
                
            if not host:
                self.write_terminal("Usage: ping [-c count] <hostname>\n")
                return
                
            try:
                if platform.system().lower() == 'windows':
                    cmd = f"ping -n {count} {host}"
                else:
                    cmd = f"ping -c {count} {host}"
                    
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                self.write_terminal(result.stdout)
                if result.stderr:
                    self.write_terminal(result.stderr)
            except Exception as e:
                self.write_terminal(f"Error pinging {host}: {str(e)}\n")
                
        def netstat(self):
            try:
                connections = psutil.net_connections()
                self.write_terminal(f"{'Proto':<6} {'Local Address':<22} {'Foreign Address':<22} {'Status':<12}\n")
                self.write_terminal("-" * 70 + "\n")
                
                for conn in connections[:20]:  # Limit to first 20
                    proto = 'TCP' if conn.type == socket.SOCK_STREAM else 'UDP'
                    local = f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else "*:*"
                    remote = f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else "*:*"
                    status = conn.status if hasattr(conn, 'status') else ""
                    
                    self.write_terminal(f"{proto:<6} {local:<22} {remote:<22} {status:<12}\n")
            except Exception as e:
                self.write_terminal(f"Error getting network connections: {str(e)}\n")
                
        def ipconfig(self):
            try:
                interfaces = psutil.net_if_addrs()
                for interface, addrs in interfaces.items():
                    self.write_terminal(f"\n{interface}:\n")
                    for addr in addrs:
                        if addr.family == socket.AF_INET:
                            self.write_terminal(f"  IPv4 Address: {addr.address}\n")
                            self.write_terminal(f"  Netmask: {addr.netmask}\n")
                        elif addr.family == socket.AF_INET6:
                            self.write_terminal(f"  IPv6 Address: {addr.address}\n")
            except Exception as e:
                self.write_terminal(f"Error getting network configuration: {str(e)}\n")
                
        def wget_file(self, args):
            if not args:
                self.write_terminal("Usage: wget <url>\n")
                return
                
            self.write_terminal("Note: wget not implemented - use requests library in Python\n")
            
        def curl_url(self, args):
            if not args:
                self.write_terminal("Usage: curl <url>\n")
                return
                
            self.write_terminal("Note: curl not implemented - use requests library in Python\n")
            
        # Text processing
        def echo_text(self, args):
            text = ' '.join(args)
            # Handle basic escape sequences
            text = text.replace('\\n', '\n').replace('\\t', '\t')
            self.write_terminal(f"{text}\n")
            
        def sort_file(self, args):
            if not args:
                self.write_terminal("Usage: sort <filename>\n")
                return
                
            filename = args[0]
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()
                    lines.sort()
                    for line in lines:
                        self.write_terminal(line)
            except Exception as e:
                self.write_terminal(f"Error sorting file: {str(e)}\n")
                
        def unique_lines(self, args):
            if not args:
                self.write_terminal("Usage: uniq <filename>\n")
                return
                
            filename = args[0]
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()
                    unique_lines = []
                    prev_line = None
                    
                    for line in lines:
                        if line != prev_line:
                            unique_lines.append(line)
                            prev_line = line
                    
                    for line in unique_lines:
                        self.write_terminal(line)
            except Exception as e:
                self.write_terminal(f"Error processing file: {str(e)}\n")
                
        def cut_text(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: cut -d<delimiter> -f<fields> <filename>\n")
                return
                
            # Simple implementation
            self.write_terminal("Note: cut command simplified - use Python string methods for complex operations\n")
            
        # Archive operations
        def create_zip(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: zip <archive.zip> <file1> [file2...]\n")
                return
                
            archive_name = args[0]
            files = args[1:]
            
            try:
                with zipfile.ZipFile(archive_name, 'w') as zipf:
                    for file in files:
                        file_path = os.path.join(self.current_dir, file) if not os.path.isabs(file) else file
                        if os.path.exists(file_path):
                            zipf.write(file_path, file)
                            self.write_terminal(f"Added {file} to {archive_name}\n")
                        else:
                            self.write_terminal(f"File not found: {file}\n")
            except Exception as e:
                self.write_terminal(f"Error creating zip: {str(e)}\n")
                
        def extract_zip(self, args):
            if not args:
                self.write_terminal("Usage: unzip <archive.zip>\n")
                return
                
            archive_name = args[0]
            archive_path = os.path.join(self.current_dir, archive_name) if not os.path.isabs(archive_name) else archive_name
            
            try:
                with zipfile.ZipFile(archive_path, 'r') as zipf:
                    zipf.extractall(self.current_dir)
                    self.write_terminal(f"Extracted {archive_name}\n")
                    for name in zipf.namelist():
                        self.write_terminal(f"  {name}\n")
            except Exception as e:
                self.write_terminal(f"Error extracting zip: {str(e)}\n")
                
        def tar_operations(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: tar -c/-x/-t -f <archive.tar> [files...]\n")
                return
                
            # Simple tar implementation
            self.write_terminal("Note: tar command simplified\n")
            
        # System operations
        def show_history(self):
            self.write_terminal("Command History:\n")
            for i, cmd in enumerate(self.command_history, 1):
                self.write_terminal(f"{i:4d}  {cmd}\n")
                
        def create_alias(self, args):
            if not args:
                self.write_terminal("Usage: alias name=command\n")
                return
                
            self.write_terminal("Note: alias functionality not implemented\n")
            
        def which_command(self, args):
            if not args:
                self.write_terminal("Usage: which <command>\n")
                return
                
            command = args[0]
            try:
                result = subprocess.run(['which', command], capture_output=True, text=True)
                if result.returncode == 0:
                    self.write_terminal(result.stdout)
                else:
                    self.write_terminal(f"{command} not found\n")
            except:
                self.write_terminal(f"which command not available on this system\n")
                
        def whereis_command(self, args):
            if not args:
                self.write_terminal("Usage: whereis <command>\n")
                return
                
            self.write_terminal("Note: whereis command not implemented\n")
            
        def show_tree(self, args):
            path = args[0] if args else self.current_dir
            if not os.path.isabs(path):
                path = os.path.join(self.current_dir, path)
                
            def print_tree(directory, prefix="", max_depth=3, current_depth=0):
                if current_depth >= max_depth:
                    return
                    
                try:
                    items = sorted(os.listdir(directory))
                    dirs = [item for item in items if os.path.isdir(os.path.join(directory, item))]
                    files = [item for item in items if os.path.isfile(os.path.join(directory, item))]
                    
                    # Print directories first
                    for i, dirname in enumerate(dirs):
                        is_last_dir = (i == len(dirs) - 1) and len(files) == 0
                        self.write_terminal(f"{prefix}{'└── ' if is_last_dir else '├── '}{dirname}/\n")
                        
                        new_prefix = prefix + ("    " if is_last_dir else "│   ")
                        print_tree(os.path.join(directory, dirname), new_prefix, max_depth, current_depth + 1)
                    
                    # Then print files
                    for i, filename in enumerate(files):
                        is_last = i == len(files) - 1
                        self.write_terminal(f"{prefix}{'└── ' if is_last else '├── '}{filename}\n")
                        
                except PermissionError:
                    self.write_terminal(f"{prefix}[Permission Denied]\n")
                    
            try:
                self.write_terminal(f"{path}\n")
                print_tree(path)
            except Exception as e:
                self.write_terminal(f"Error showing tree: {str(e)}\n")
                
        def calculator(self, args):
            if not args:
                self.write_terminal("Usage: calc <expression>\n")
                return
                
            expression = ' '.join(args)
            try:
                # Safe evaluation of mathematical expressions
                result = eval(expression, {"__builtins__": {}}, {
                    "abs": abs, "round": round, "min": min, "max": max,
                    "sum": sum, "pow": pow, "sqrt": lambda x: x**0.5,
                    "sin": lambda x: __import__('math').sin(x),
                    "cos": lambda x: __import__('math').cos(x),
                    "tan": lambda x: __import__('math').tan(x),
                    "pi": __import__('math').pi,
                    "e": __import__('math').e
                })
                self.write_terminal(f"{result}\n")
            except Exception as e:
                self.write_terminal(f"Error in calculation: {str(e)}\n")
                
        def base64_encode_decode(self, args):
            if len(args) < 2:
                self.write_terminal("Usage: base64 -e/-d <text>\n")
                return
                
            import base64
            
            mode = args[0]
            text = ' '.join(args[1:])
            
            try:
                if mode == '-e' or mode == 'encode':
                    encoded = base64.b64encode(text.encode()).decode()
                    self.write_terminal(f"{encoded}\n")
                elif mode == '-d' or mode == 'decode':
                    decoded = base64.b64decode(text).decode()
                    self.write_terminal(f"{decoded}\n")
                else:
                    self.write_terminal("Usage: base64 -e/-d <text>\n")
            except Exception as e:
                self.write_terminal(f"Error in base64 operation: {str(e)}\n")
                
        def calculate_hash(self, args, hash_type):
            if not args:
                self.write_terminal(f"Usage: {hash_type} <filename>\n")
                return
                
            import hashlib
            
            filename = args[0]
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            try:
                hash_obj = getattr(hashlib, hash_type)()
                with open(file_path, 'rb') as f:
                    for chunk in iter(lambda: f.read(4096), b""):
                        hash_obj.update(chunk)
                
                self.write_terminal(f"{hash_obj.hexdigest()}  {filename}\n")
            except Exception as e:
                self.write_terminal(f"Error calculating {hash_type}: {str(e)}\n")
                
        # Python integration
        def run_python(self, args):
            if not args:
                self.write_terminal("Python Interactive Mode (type 'exit()' to quit):\n")
                # This would need a more complex implementation for interactive Python
                self.write_terminal("Note: Interactive Python not fully implemented\n")
                return
                
            if args[0].endswith('.py'):
                # Run Python file
                file_path = os.path.join(self.current_dir, args[0]) if not os.path.isabs(args[0]) else args[0]
                try:
                    result = subprocess.run([sys.executable, file_path] + args[1:], 
                                          capture_output=True, text=True, cwd=self.current_dir)
                    if result.stdout:
                        self.write_terminal(result.stdout)
                    if result.stderr:
                        self.write_terminal(result.stderr)
                except Exception as e:
                    self.write_terminal(f"Error running Python script: {str(e)}\n")
            else:
                # Execute Python code
                code = ' '.join(args)
                try:
                    exec(code)
                except Exception as e:
                    self.write_terminal(f"Python error: {str(e)}\n")
                    
        def run_pip(self, args):
            try:
                result = subprocess.run([sys.executable, '-m', 'pip'] + args,
                                      capture_output=True, text=True)
                if result.stdout:
                    self.write_terminal(result.stdout)
                if result.stderr:
                    self.write_terminal(result.stderr)
            except Exception as e:
                self.write_terminal(f"Error running pip: {str(e)}\n")
                
        # System control (placeholder implementations)
        def service_control(self, args):
            self.write_terminal("Note: service command not implemented (Linux/Unix specific)\n")
            
        def systemctl(self, args):
            self.write_terminal("Note: systemctl command not implemented (systemd specific)\n")
            
        def crontab_operations(self, args):
            self.write_terminal("Note: crontab command not implemented (Unix specific)\n")
            
        # File editing (placeholder implementations)
        def nano_editor(self, args):
            self.write_terminal("Note: nano editor not implemented - use external editor\n")
            
        def vim_editor(self, args):
            self.write_terminal("Note: vim editor not implemented - use external editor\n")
            
        def simple_editor(self, args):
            if not args:
                self.write_terminal("Usage: edit <filename>\n")
                return
                
            filename = args[0]
            file_path = os.path.join(self.current_dir, filename) if not os.path.isabs(filename) else filename
            
            # Open simple text editor window
            self.open_text_editor(file_path)
            
        def open_text_editor(self, file_path):
            editor_window = tk.Toplevel(self.rootdosbox)
            editor_window.title(f"Text Editor - {os.path.basename(file_path)}")
            editor_window.geometry("800x600")
            
            # Text widget
            text_widget = tk.Text(editor_window, font=self.font_mono, wrap=tk.WORD)
            scrollbar = tk.Scrollbar(editor_window, command=text_widget.yview)
            text_widget.config(yscrollcommand=scrollbar.set)
            
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Load file content
            try:
                if os.path.exists(file_path):
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        text_widget.insert(tk.END, content)
            except Exception as e:
                text_widget.insert(tk.END, f"Error loading file: {str(e)}")
                
            # Save function
            def save_file():
                try:
                    content = text_widget.get(1.0, tk.END)
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.write_terminal(f"File saved: {file_path}\n")
                except Exception as e:
                    messagebox.showerror("Error", f"Error saving file: {str(e)}")
            
            # Menu for editor
            editor_menu = tk.Menu(editor_window)
            editor_window.config(menu=editor_menu)
            
            file_menu = tk.Menu(editor_menu, tearoff=0)
            editor_menu.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="Save", command=save_file, accelerator="Ctrl+S")
            file_menu.add_command(label="Close", command=editor_window.destroy)
            
            # Keyboard shortcuts
            editor_window.bind('<Control-s>', lambda e: save_file())
            
        def clear_terminal(self):
            self.terminal.config(state=tk.NORMAL)
            self.terminal.delete(1.0, tk.END)
            self.terminal.config(state=tk.DISABLED)
            
        def show_help(self):
            help_text = """Advanced Terminal Help
    =====================

    Basic Commands:
      help, commands    - Show available commands
      dir, ls          - List directory contents
      cd <dir>         - Change directory
      pwd              - Print working directory
      cls, clear       - Clear screen
      exit, quit       - Exit terminal

    File Operations:
      type, cat <file> - Display file contents
      copy, cp <src> <dst> - Copy files
      move, mv <src> <dst> - Move files
      del, rm <file>   - Delete files
      mkdir <dir>      - Create directory
      rmdir <dir>      - Remove directory
      touch <file>     - Create empty file
      find <pattern>   - Find files
      grep <pattern> <file> - Search in file
      wc <file>        - Word count
      head <file>      - Show first lines
      tail <file>      - Show last lines

    System Information:
      date, time       - Show date/time
      whoami           - Show username
      hostname         - Show computer name
      uname            - Show system info
      ps               - List processes
      top              - Show top processes
      kill <pid>       - Kill process
      env              - Show environment variables
      df               - Show disk usage

    Network:
      ping <host>      - Ping host
      netstat          - Show network connections
      ipconfig         - Show network configuration

    Archives:
      zip <archive> <files> - Create zip archive
      unzip <archive>  - Extract zip archive

    Utilities:
      calc <expression> - Calculator
      echo <text>      - Display text
      history          - Show command history
      tree             - Show directory tree
      python <script>  - Run Python script
      edit <file>      - Simple text editor

    Type any command name for more specific help.
    """
            self.write_terminal(help_text)
            
        def show_commands_help(self):
            commands_text = """Available Commands:
    ==================

    File System:
      dir, ls, cd, pwd, mkdir, rmdir, copy, cp, move, mv, del, rm, touch
      find, tree, du, df, chmod

    Text Processing:
      type, cat, grep, wc, head, tail, sort, uniq, cut, echo

    System:
      date, time, ver, whoami, hostname, uname, uptime, ps, top, kill
      env, set, unset, path, history

    Network:
      ping, netstat, ipconfig, ifconfig, wget, curl

    Archives:
      zip, unzip, tar

    Development:
      python, py, pip, calc, base64, md5, sha1, sha256

    Editors:
      edit, nano, vim

    System Control:
      service, systemctl, crontab

    Utilities:
      which, whereis, alias, clear, cls, help, commands, exit, quit

    Use Tab for auto-completion and Up/Down arrows for command history.
    """
            self.write_terminal(commands_text)
            
        def history_up(self, event):
            if self.command_history and self.history_index > 0:
                self.history_index -= 1
                self.cmd_entry.delete(0, tk.END)
                self.cmd_entry.insert(0, self.command_history[self.history_index])
                
        def history_down(self, event):
            if self.command_history and self.history_index < len(self.command_history) - 1:
                self.history_index += 1
                self.cmd_entry.delete(0, tk.END)
                self.cmd_entry.insert(0, self.command_history[self.history_index])
            elif self.history_index == len(self.command_history) - 1:
                self.history_index = len(self.command_history)
                self.cmd_entry.delete(0, tk.END)
                
        def auto_complete(self, event):
            current_text = self.cmd_entry.get()
            if not current_text:
                return
                
            # Simple file/directory completion
            parts = current_text.split()
            if len(parts) == 1:
                # Command completion
                commands = ['help', 'dir', 'ls', 'cd', 'pwd', 'cls', 'clear', 'exit', 'quit',
                           'type', 'cat', 'copy', 'cp', 'move', 'mv', 'del', 'rm', 'mkdir',
                           'rmdir', 'touch', 'find', 'grep', 'wc', 'head', 'tail', 'chmod',
                           'date', 'time', 'ver', 'whoami', 'hostname', 'uname', 'uptime',
                           'ps', 'top', 'kill', 'env', 'set', 'unset', 'path', 'ping',
                           'netstat', 'ipconfig', 'ifconfig', 'echo', 'sort', 'uniq', 'cut',
                           'zip', 'unzip', 'tar', 'history', 'alias', 'which', 'whereis',
                           'tree', 'calc', 'base64', 'md5', 'sha1', 'sha256', 'python',
                           'py', 'pip', 'edit', 'nano', 'vim', 'du', 'df']
                
                matches = [cmd for cmd in commands if cmd.startswith(current_text.lower())]
                if len(matches) == 1:
                    self.cmd_entry.delete(0, tk.END)
                    self.cmd_entry.insert(0, matches[0])
            else:
                # File/directory completion
                last_part = parts[-1]
                try:
                    if os.path.sep in last_part:
                        dir_path = os.path.dirname(last_part)
                        if not os.path.isabs(dir_path):
                            dir_path = os.path.join(self.current_dir, dir_path)
                        filename = os.path.basename(last_part)
                    else:
                        dir_path = self.current_dir
                        filename = last_part
                        
                    matches = []
                    for item in os.listdir(dir_path):
                        if item.startswith(filename):
                            matches.append(item)
                            
                    if len(matches) == 1:
                        new_text = ' '.join(parts[:-1] + [matches[0]])
                        self.cmd_entry.delete(0, tk.END)
                        self.cmd_entry.insert(0, new_text)
                except:
                    pass
                    
            return 'break'  # Prevent default Tab behavior
            
        # Menu functions
        def new_file(self):
            filename = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
            )
            if filename:
                self.open_text_editor(filename)
                
        def open_file(self):
            filename = filedialog.askopenfilename(
                filetypes=[("Text files", "*.txt"), ("Python files", "*.py"), 
                          ("All files", "*.*")]
            )
            if filename:
                if filename.endswith(('.txt', '.py', '.md', '.json', '.xml', '.html', '.css', '.js')):
                    self.open_text_editor(filename)
                else:
                    self.write_terminal(f"Opening {filename}...\n")
                    self.type_file([filename])
                    
        def save_output(self):
            content = self.terminal.get(1.0, tk.END)
            filename = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
            )
            if filename:
                try:
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.update_status(f"Output saved to {filename}")
                except Exception as e:
                    messagebox.showerror("Error", f"Error saving file: {str(e)}")
                    
        def copy_text(self):
            try:
                selected_text = self.terminal.selection_get()
                self.rootdosbox.clipboard_clear()
                self.rootdosbox.clipboard_append(selected_text)
            except tk.TclError:
                # No text selected, copy all terminal content
                content = self.terminal.get(1.0, tk.END)
                self.rootdosbox.clipboard_clear()
                self.rootdosbox.clipboard_append(content)
                
        def paste_text(self):
            try:
                clipboard_text = self.rootdosbox.clipboard_get()
                self.cmd_entry.insert(tk.INSERT, clipboard_text)
            except tk.TclError:
                pass
                
        def select_all(self):
            self.terminal.tag_add(tk.SEL, "1.0", tk.END)
            
        def update_status(self, message):
            self.status_label.config(text=message)
            self.rootdosbox.after(3000, lambda: self.status_label.config(text="Ready"))
            
        # Tool functions
        def open_file_manager(self):
            file_manager = tk.Toplevel(self.rootdosbox)
            file_manager.title("File Manager")
            file_manager.geometry("800x600")
            
            # Create file browser
            main_frame = tk.Frame(file_manager)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
            
            # Path bar
            path_frame = tk.Frame(main_frame)
            path_frame.pack(fill=tk.X, pady=(0, 4))
            
            tk.Label(path_frame, text="Path:").pack(side=tk.LEFT)
            path_var = tk.StringVar(value=self.current_dir)
            path_entry = tk.Entry(path_frame, textvariable=path_var, font=self.font_mono)
            path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(4, 0))
            
            # File list
            list_frame = tk.Frame(main_frame)
            list_frame.pack(fill=tk.BOTH, expand=True)
            
            # Create Treeview for file listing
            columns = ('Name', 'Size', 'Modified', 'Type')
            file_tree = ttk.Treeview(list_frame, columns=columns, show='tree headings')
            
            # Configure columns
            file_tree.heading('#0', text='Name', anchor=tk.W)
            file_tree.heading('Name', text='Name', anchor=tk.W)
            file_tree.heading('Size', text='Size', anchor=tk.E)
            file_tree.heading('Modified', text='Modified', anchor=tk.W)
            file_tree.heading('Type', text='Type', anchor=tk.W)
            
            file_tree.column('#0', width=200, minwidth=100)
            file_tree.column('Name', width=200, minwidth=100)
            file_tree.column('Size', width=100, minwidth=50)
            file_tree.column('Modified', width=150, minwidth=100)
            file_tree.column('Type', width=100, minwidth=50)
            
            # Scrollbars
            v_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=file_tree.yview)
            h_scrollbar = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=file_tree.xview)
            file_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            # Pack scrollbars and treeview
            v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            file_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            def refresh_file_list(directory=None):
                if directory is None:
                    directory = path_var.get()
                    
                # Clear existing items
                for item in file_tree.get_children():
                    file_tree.delete(item)
                    
                try:
                    # Add parent directory entry
                    if directory != os.path.dirname(directory):
                        file_tree.insert('', 'end', text='..', values=('..', '<DIR>', '', 'Directory'))
                    
                    # List directory contents
                    items = os.listdir(directory)
                    
                    # Separate directories and files
                    dirs = []
                    files = []
                    
                    for item in items:
                        item_path = os.path.join(directory, item)
                        try:
                            stat_info = os.stat(item_path)
                            modified = datetime.datetime.fromtimestamp(stat_info.st_mtime).strftime("%Y-%m-%d %H:%M")
                            
                            if os.path.isdir(item_path):
                                dirs.append((item, '<DIR>', modified, 'Directory'))
                            else:
                                size = stat_info.st_size
                                file_type = os.path.splitext(item)[1] or 'File'
                                files.append((item, f"{size:,}", modified, file_type))
                        except OSError:
                            continue
                    
                    # Add directories first
                    for name, size, modified, ftype in sorted(dirs):
                        file_tree.insert('', 'end', text=name, values=(name, size, modified, ftype))
                    
                    # Add files
                    for name, size, modified, ftype in sorted(files):
                        file_tree.insert('', 'end', text=name, values=(name, size, modified, ftype))
                        
                except Exception as e:
                    messagebox.showerror("Error", f"Error listing directory: {str(e)}")
            
            def on_double_click(event):
                selection = file_tree.selection()
                if selection:
                    item = file_tree.item(selection[0])
                    name = item['text']
                    
                    if name == '..':
                        new_path = os.path.dirname(path_var.get())
                    else:
                        new_path = os.path.join(path_var.get(), name)
                    
                    if os.path.isdir(new_path):
                        path_var.set(new_path)
                        refresh_file_list(new_path)
                    else:
                        # Open file
                        self.open_text_editor(new_path)
            
            def on_path_change(event):
                new_path = path_var.get()
                if os.path.isdir(new_path):
                    refresh_file_list(new_path)
            
            # Bind events
            file_tree.bind('<Double-1>', on_double_click)
            path_entry.bind('<Return>', on_path_change)
            
            # Buttons
            button_frame = tk.Frame(main_frame)
            button_frame.pack(fill=tk.X, pady=(4, 0))
            
            tk.Button(button_frame, text="Refresh", command=lambda: refresh_file_list()).pack(side=tk.LEFT, padx=(0, 4))
            tk.Button(button_frame, text="Go to Terminal Dir", 
                     command=lambda: (path_var.set(self.current_dir), refresh_file_list(self.current_dir))).pack(side=tk.LEFT, padx=(0, 4))
            tk.Button(button_frame, text="Close", command=file_manager.destroy).pack(side=tk.RIGHT)
            
            # Initial load
            refresh_file_list()
            
        def show_system_info(self):
            info_window = tk.Toplevel(self.rootdosbox)
            info_window.title("System Information")
            info_window.geometry("600x500")
            
            # Create text widget with scrollbar
            text_frame = tk.Frame(info_window)
            text_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
            
            info_text = tk.Text(text_frame, font=self.font_mono, wrap=tk.WORD)
            scrollbar = tk.Scrollbar(text_frame, command=info_text.yview)
            info_text.config(yscrollcommand=scrollbar.set)
            
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Gather system information
            try:
                info = []
                info.append("SYSTEM INFORMATION")
                info.append("=" * 50)
                info.append(f"System: {platform.system()}")
                info.append(f"Release: {platform.release()}")
                info.append(f"Version: {platform.version()}")
                info.append(f"Machine: {platform.machine()}")
                info.append(f"Processor: {platform.processor()}")
                info.append(f"Architecture: {platform.architecture()[0]}")
                info.append(f"Hostname: {socket.gethostname()}")
                info.append(f"Username: {getpass.getuser()}")
                info.append("")
                
                info.append("PYTHON INFORMATION")
                info.append("=" * 50)
                info.append(f"Python Version: {sys.version}")
                info.append(f"Python Executable: {sys.executable}")
                info.append(f"Python Path: {sys.path[0]}")
                info.append("")
                
                try:
                    info.append("MEMORY INFORMATION")
                    info.append("=" * 50)
                    memory = psutil.virtual_memory()
                    info.append(f"Total Memory: {memory.total / (1024**3):.2f} GB")
                    info.append(f"Available Memory: {memory.available / (1024**3):.2f} GB")
                    info.append(f"Used Memory: {memory.used / (1024**3):.2f} GB")
                    info.append(f"Memory Usage: {memory.percent}%")
                    info.append("")
                    
                    info.append("CPU INFORMATION")
                    info.append("=" * 50)
                    info.append(f"CPU Cores: {psutil.cpu_count()}")
                    info.append(f"CPU Usage: {psutil.cpu_percent(interval=1)}%")
                    info.append("")
                    
                    info.append("DISK INFORMATION")
                    info.append("=" * 50)
                    disk_usage = psutil.disk_usage('/')
                    info.append(f"Total Disk Space: {disk_usage.total / (1024**3):.2f} GB")
                    info.append(f"Used Disk Space: {disk_usage.used / (1024**3):.2f} GB")
                    info.append(f"Free Disk Space: {disk_usage.free / (1024**3):.2f} GB")
                    info.append(f"Disk Usage: {(disk_usage.used / disk_usage.total) * 100:.1f}%")
                    info.append("")
                    
                    info.append("NETWORK INTERFACES")
                    info.append("=" * 50)
                    for interface, addrs in psutil.net_if_addrs().items():
                        info.append(f"Interface: {interface}")
                        for addr in addrs:
                            if addr.family == socket.AF_INET:
                                info.append(f"  IPv4: {addr.address}")
                            elif addr.family == socket.AF_INET6:
                                info.append(f"  IPv6: {addr.address}")
                        info.append("")
                        
                except Exception as e:
                    info.append(f"Error getting detailed system info: {str(e)}")
                    
                # Display information
                info_text.insert(tk.END, "\n".join(info))
                info_text.config(state=tk.DISABLED)
                
            except Exception as e:
                info_text.insert(tk.END, f"Error gathering system information: {str(e)}")
                
            # Close button
            tk.Button(info_window, text="Close", command=info_window.destroy).pack(pady=4)
            
        def show_processes(self):
            proc_window = tk.Toplevel(self.rootdosbox)
            proc_window.title("Process Monitor")
            proc_window.geometry("800x600")
            
            # Create process list
            main_frame = tk.Frame(proc_window)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
            
            # Create Treeview for process listing
            columns = ('PID', 'Name', 'CPU%', 'Memory%', 'Status')
            proc_tree = ttk.Treeview(main_frame, columns=columns, show='headings')
            
            # Configure columns
            proc_tree.heading('PID', text='PID', anchor=tk.W)
            proc_tree.heading('Name', text='Name', anchor=tk.W)
            proc_tree.heading('CPU%', text='CPU%', anchor=tk.E)
            proc_tree.heading('Memory%', text='Memory%', anchor=tk.E)
            proc_tree.heading('Status', text='Status', anchor=tk.W)
            
            proc_tree.column('PID', width=80, minwidth=50)
            proc_tree.column('Name', width=200, minwidth=100)
            proc_tree.column('CPU%', width=80, minwidth=50)
            proc_tree.column('Memory%', width=100, minwidth=70)
            proc_tree.column('Status', width=100, minwidth=70)
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=proc_tree.yview)
            proc_tree.configure(yscrollcommand=scrollbar.set)
            
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            proc_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            def refresh_processes():
                # Clear existing items
                for item in proc_tree.get_children():
                    proc_tree.delete(item)
                    
                try:
                    processes = []
                    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 'status']):
                        try:
                            processes.append(proc.info)
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            continue
                    
                    # Sort by CPU usage
                    processes.sort(key=lambda x: x['cpu_percent'] or 0, reverse=True)
                    
                    # Add to tree
                    for proc in processes:
                        proc_tree.insert('', 'end', values=(
                            proc['pid'],
                            proc['name'][:30],  # Truncate long names
                            f"{proc['cpu_percent'] or 0:.1f}",
                            f"{proc['memory_percent'] or 0:.1f}",
                            proc['status']
                        ))
                        
                except Exception as e:
                    messagebox.showerror("Error", f"Error getting processes: {str(e)}")
            
            def kill_selected_process():
                selection = proc_tree.selection()
                if selection:
                    item = proc_tree.item(selection[0])
                    pid = int(item['values'][0])
                    name = item['values'][1]
                    
                    if messagebox.askyesno("Confirm", f"Kill process {name} (PID: {pid})?"):
                        try:
                            proc = psutil.Process(pid)
                            proc.terminate()
                            messagebox.showinfo("Success", f"Process {pid} terminated")
                            refresh_processes()
                        except Exception as e:
                            messagebox.showerror("Error", f"Error killing process: {str(e)}")
            
            # Buttons
            button_frame = tk.Frame(main_frame)
            button_frame.pack(fill=tk.X, pady=(4, 0))
            
            tk.Button(button_frame, text="Refresh", command=refresh_processes).pack(side=tk.LEFT, padx=(0, 4))
            tk.Button(button_frame, text="Kill Process", command=kill_selected_process).pack(side=tk.LEFT, padx=(0, 4))
            tk.Button(button_frame, text="Close", command=proc_window.destroy).pack(side=tk.RIGHT)
            
            # Auto-refresh
            def auto_refresh():
                refresh_processes()
                proc_window.after(5000, auto_refresh)  # Refresh every 5 seconds
            
            # Initial load
            refresh_processes()
            auto_refresh()
            
        def show_network_info(self):
            net_window = tk.Toplevel(self.rootdosbox)
            net_window.title("Network Information")
            net_window.geometry("700x500")
            
            # Create notebook for tabs
            notebook = ttk.Notebook(net_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
            
            # Interfaces tab
            interfaces_frame = ttk.Frame(notebook)
            notebook.add(interfaces_frame, text="Interfaces")
            
            interfaces_text = tk.Text(interfaces_frame, font=self.font_mono, wrap=tk.WORD)
            interfaces_scroll = tk.Scrollbar(interfaces_frame, command=interfaces_text.yview)
            interfaces_text.config(yscrollcommand=interfaces_scroll.set)
            
            interfaces_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            interfaces_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Connections tab
            connections_frame = ttk.Frame(notebook)
            notebook.add(connections_frame, text="Connections")
            
            connections_text = tk.Text(connections_frame, font=self.font_mono, wrap=tk.WORD)
            connections_scroll = tk.Scrollbar(connections_frame, command=connections_text.yview)
            connections_text.config(yscrollcommand=connections_scroll.set)
            
            connections_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            connections_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Populate network information
            try:
                # Network Interfaces
                interfaces_info = []
                interfaces_info.append("NETWORK INTERFACES")
                interfaces_info.append("=" * 50)
                
                for interface, addrs in psutil.net_if_addrs().items():
                    interfaces_info.append(f"\nInterface: {interface}")
                    interfaces_info.append("-" * 30)
                    
                    for addr in addrs:
                        if addr.family == socket.AF_INET:
                            interfaces_info.append(f"  IPv4 Address: {addr.address}")
                            interfaces_info.append(f"  Netmask: {addr.netmask}")
                            if addr.broadcast:
                                interfaces_info.append(f"  Broadcast: {addr.broadcast}")
                        elif addr.family == socket.AF_INET6:
                            interfaces_info.append(f"  IPv6 Address: {addr.address}")
                            interfaces_info.append(f"  Netmask: {addr.netmask}")
                        elif hasattr(socket, 'AF_PACKET') and addr.family == socket.AF_PACKET:
                            interfaces_info.append(f"  MAC Address: {addr.address}")
                            
                interfaces_text.insert(tk.END, "\n".join(interfaces_info))
                interfaces_text.config(state=tk.DISABLED)
                
                # Network Connections
                connections_info = []
                connections_info.append("NETWORK CONNECTIONS")
                connections_info.append("=" * 70)
                connections_info.append(f"{'Proto':<6} {'Local Address':<22} {'Foreign Address':<22} {'Status':<12}")
                connections_info.append("-" * 70)
                
                for conn in psutil.net_connections():
                    try:
                        proto = 'TCP' if conn.type == socket.SOCK_STREAM else 'UDP'
                        local = f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else "*:*"
                        remote = f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else "*:*"
                        status = conn.status if hasattr(conn, 'status') else ""
                        
                        connections_info.append(f"{proto:<6} {local:<22} {remote:<22} {status:<12}")
                    except:
                        continue
                        
                connections_text.insert(tk.END, "\n".join(connections_info))
                connections_text.config(state=tk.DISABLED)
                
            except Exception as e:
                interfaces_text.insert(tk.END, f"Error getting network information: {str(e)}")
                connections_text.insert(tk.END, f"Error getting connection information: {str(e)}")
                
            # Close button
            tk.Button(net_window, text="Close", command=net_window.destroy).pack(pady=4)
            
        def open_calculator(self):
            calc_window = tk.Toplevel(self.rootdosbox)
            calc_window.title("Calculator")
            calc_window.geometry("300x400")
            calc_window.resizable(False, False)
            
            # Display
            display_var = tk.StringVar(value="0")
            display = tk.Entry(calc_window, textvariable=display_var, font=('Arial', 16),
                              justify=tk.RIGHT, state='readonly', bg='white')
            display.pack(fill=tk.X, padx=4, pady=4)
            
            # Button frame
            button_frame = tk.Frame(calc_window)
            button_frame.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)
            
            # Calculator logic
            self.calc_expression = ""
            self.calc_last_was_operator = False
            
            def button_click(value):
                current = display_var.get()
                
                if value == "C":
                    display_var.set("0")
                    self.calc_expression = ""
                    self.calc_last_was_operator = False
                elif value == "=":
                    try:
                        result = eval(self.calc_expression)
                        display_var.set(str(result))
                        self.calc_expression = str(result)
                        self.calc_last_was_operator = False
                    except:
                        display_var.set("Error")
                        self.calc_expression = ""
                        self.calc_last_was_operator = False
                elif value == "⌫":
                    if len(self.calc_expression) > 0:
                        self.calc_expression = self.calc_expression[:-1]
                        display_var.set(self.calc_expression if self.calc_expression else "0")
                elif value in "+-*/":
                    if self.calc_expression and not self.calc_last_was_operator:
                        self.calc_expression += value
                        display_var.set(self.calc_expression)
                        self.calc_last_was_operator = True
                else:
                    if current == "0" or current == "Error":
                        self.calc_expression = value
                    else:
                        self.calc_expression += value
                    display_var.set(self.calc_expression)
                    self.calc_last_was_operator = False
            
            # Button layout
            buttons = [
                ['C', '⌫', '/', '*'],
                ['7', '8', '9', '-'],
                ['4', '5', '6', '+'],
                ['1', '2', '3', '='],
                ['0', '.', '', '']
            ]
            
            for i, row in enumerate(buttons):
                row_frame = tk.Frame(button_frame)
                row_frame.pack(fill=tk.X, expand=True)
                
                for j, btn_text in enumerate(row):
                    if btn_text:
                        if btn_text == '=':
                            btn = tk.Button(row_frame, text=btn_text, font=('Arial', 14),
                                           command=lambda x=btn_text: button_click(x),
                                           bg='#4CAF50', fg='white')
                            btn.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, 
                                    padx=1, pady=1, rowspan=2 if i == 3 else 1)
                        elif btn_text in 'C⌫':
                            btn = tk.Button(row_frame, text=btn_text, font=('Arial', 14),
                                           command=lambda x=btn_text: button_click(x),
                                           bg='#f44336', fg='white')
                            btn.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=1, pady=1)
                        elif btn_text in '+-*/':
                            btn = tk.Button(row_frame, text=btn_text, font=('Arial', 14),
                                           command=lambda x=btn_text: button_click(x),
                                           bg='#2196F3', fg='white')
                            btn.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=1, pady=1)
                        else:
                            btn = tk.Button(row_frame, text=btn_text, font=('Arial', 14),
                                           command=lambda x=btn_text: button_click(x),
                                           bg='#e0e0e0')
                            if btn_text == '0':
                                btn.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, 
                                        padx=1, pady=1)
                            else:
                                btn.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=1, pady=1)
                    else:
                        # Empty space
                        empty = tk.Frame(row_frame)
                        empty.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
        def show_about(self):
            about_window = tk.Toplevel(self.rootdosbox)
            about_window.title("About DosBox Terminal")
            about_window.geometry("400x300")
            about_window.resizable(False, False)
            
            # Center the window
            about_window.transient(self.rootdosbox)
            about_window.grab_set()
            
            main_frame = tk.Frame(about_window, bg='white')
            main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Title
            title_label = tk.Label(main_frame, text="Advanced Terminal", 
                                  font=('Arial', 16, 'bold'), bg='white')
            title_label.pack(pady=(20, 10))
            
            # Version
            version_label = tk.Label(main_frame, text="Version 2.0", 
                                    font=('Arial', 12), bg='white')
            version_label.pack(pady=5)
            
            # Description
            desc_text = """A DosBox terminal emulator with:
    • File management operations
    • System information tools
    • Network utilities
    • Text processing commands
    • Built-in calculator and text editor
    • Process monitoring
    • Archive operations
    • Python integration"""
            
            desc_label = tk.Label(main_frame, text=desc_text, 
                                 font=('Arial', 10), bg='white', justify=tk.LEFT)
            desc_label.pack(pady=20, padx=20)
            
            # System info
            sys_info = f"Python {sys.version.split()[0]} • {platform.system()} {platform.release()}"
            sys_label = tk.Label(main_frame, text=sys_info, 
                                font=('Arial', 9), bg='white', fg='gray')
            sys_label.pack(pady=10)
            
            # Close button
            tk.Button(main_frame, text="Close", command=about_window.destroy,
                     bg='#e0e0e0', padx=20).pack(pady=20)

    if __name__ == "__main__":
        app = AdvancedTerminal()
        app.rootdosbox.mainloop()
        
if vscodevar == 999955550000:
    import re
    import io
    from datetime import datetime
    import queue
    import uuid
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class VSCodeEditor:
        def __init__(self):
            self.rootVSCODE = tk.Tk()
            self.rootVSCODE.title("VS Code - Python Editor")
            self.rootVSCODE.geometry("1200x800")
            
            # Setare icon pentru aplicație (opțional)
            try:
                self.rootVSCODE.iconbitmap("vscode.ico")  # Necesită un fișier .ico în același folder
            except:
                pass
            
            # Tema dark colors - VS Code specific
            self.colors = {
                'bg': '#1e1e1e',
                'sidebar_bg': '#252526',
                'editor_bg': '#1e1e1e',
                'text': '#d4d4d4',
                'comment': '#6a9955',
                'keyword': '#569cd6',
                'string': '#ce9178',
                'number': '#b5cea8',
                'function': '#dcdcaa',
                'selection': '#264f78',
                'line_number': '#858585',
                'current_line': '#323232',
                'activity_bar': '#333333',
                'tab_active': '#1e1e1e',
                'tab_inactive': '#2d2d2d',
                'status_bar': '#007acc',
                'panel_bg': '#1e1e1e'
            }
            
            self.current_file = None
            self.modified = False
            self.files_opened = []
            self.current_tab_index = 0
            self.search_term = ""
            self.replace_term = ""
            self.terminal_visible = False
            self.explorer_visible = True
            self.current_search_index = 0
            self.search_results = []
            self.terminal_process = None
            
            # Variabile pentru terminalul interactiv
            self.process = None
            self.output_queue = queue.Queue()
            self.error_queue = queue.Queue()
            self.terminal_threads = []
            self.stop_threads = threading.Event()
            self.awaiting_input = False
            self.last_output_incomplete = False  # Urmărește dacă ultima linie de output se termină cu newline
            
            # Autocompletare pentru Python
            self.autocomplete_words = set([
                'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else',
                'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',
                'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield',
                'True', 'False', 'None', 'self', 'cls', 'print', 'len', 'str', 'int', 'float', 'list',
                'dict', 'tuple', 'set', 'open', 'range', 'enumerate', 'zip', 'map', 'filter', 'sum',
                'min', 'max', 'sorted', 'reversed', 'any', 'all', 'isinstance', 'type', '__init__'
            ])
            
            # Inițializează UI
            self.setup_ui()
            self.setup_syntax_highlighting()
            
            # Configurează tema dark pentru all widgets
            self.apply_theme()
            
            self.last_output_time = time.time()
            
        def apply_theme(self):
            # Configurează stilul pentru ttk widgets
            style = ttk.Style()
            style.theme_use('clam')
            
            # Configurează stilul pentru butoane și alte widget-uri
            style.configure('TButton', background=self.colors['sidebar_bg'], foreground=self.colors['text'])
            style.configure('TEntry', fieldbackground=self.colors['editor_bg'], foreground=self.colors['text'])
            style.configure('TFrame', background=self.colors['bg'])
            style.configure('TLabel', background=self.colors['bg'], foreground=self.colors['text'])
            style.configure('TNotebook', background=self.colors['bg'])
            style.configure('TNotebook.Tab', background=self.colors['tab_inactive'], foreground=self.colors['text'], padding=[10, 2])
            style.map('TNotebook.Tab', background=[('selected', self.colors['tab_active'])])
            
            # Configurare specifică pentru Treeview (file explorer)
            style.configure("Treeview", 
                           background=self.colors['sidebar_bg'],
                           foreground=self.colors['text'],
                           fieldbackground=self.colors['sidebar_bg'])
            style.map('Treeview', background=[('selected', self.colors['selection'])])
            
        def setup_ui(self):
            # Configurează tema dark pentru rootVSCODE
            self.rootVSCODE.configure(bg=self.colors['bg'])
            
            # Menu bar
            menubar = tk.Menu(self.rootVSCODE, bg=self.colors['sidebar_bg'], fg=self.colors['text'])
            self.rootVSCODE.config(menu=menubar)
            
            # File menu
            file_menu = tk.Menu(menubar, tearoff=0, bg=self.colors['sidebar_bg'], fg=self.colors['text'])
            menubar.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="New File", command=self.new_file, accelerator="Ctrl+N")
            file_menu.add_command(label="Open File...", command=self.open_file, accelerator="Ctrl+O")
            file_menu.add_command(label="Open Folder...", command=self.open_folder)
            file_menu.add_separator()
            file_menu.add_command(label="Save", command=self.save_file, accelerator="Ctrl+S")
            file_menu.add_command(label="Save As...", command=self.save_as_file, accelerator="Ctrl+Shift+S")
            file_menu.add_command(label="Save All", command=self.save_all_files)
            file_menu.add_separator()
            file_menu.add_command(label="Close Editor", command=self.close_current_file, accelerator="Ctrl+W")
            file_menu.add_command(label="Exit", command=self.exit_application, accelerator="Alt+F4")
            
            # Edit menu
            edit_menu = tk.Menu(menubar, tearoff=0, bg=self.colors['sidebar_bg'], fg=self.colors['text'])
            menubar.add_cascade(label="Edit", menu=edit_menu)
            edit_menu.add_command(label="Undo", command=self.undo, accelerator="Ctrl+Z")
            edit_menu.add_command(label="Redo", command=self.redo, accelerator="Ctrl+Y")
            edit_menu.add_separator()
            edit_menu.add_command(label="Cut", command=self.cut_text, accelerator="Ctrl+X")
            edit_menu.add_command(label="Copy", command=self.copy_text, accelerator="Ctrl+C")
            edit_menu.add_command(label="Paste", command=self.paste_text, accelerator="Ctrl+V")
            edit_menu.add_separator()
            edit_menu.add_command(label="Find", command=self.find_text, accelerator="Ctrl+F")
            edit_menu.add_command(label="Replace", command=self.replace_text, accelerator="Ctrl+H")
            edit_menu.add_separator()
            edit_menu.add_command(label="Comment Line", command=self.comment_line, accelerator="Ctrl+/")
            edit_menu.add_command(label="Indent", command=self.indent, accelerator="Tab")
            edit_menu.add_command(label="Dedent", command=self.dedent, accelerator="Shift+Tab")
            
            # View menu
            view_menu = tk.Menu(menubar, tearoff=0, bg=self.colors['sidebar_bg'], fg=self.colors['text'])
            menubar.add_cascade(label="View", menu=view_menu)
            view_menu.add_command(label="Explorer", command=self.toggle_explorer, accelerator="Ctrl+B")
            view_menu.add_command(label="Terminal", command=self.toggle_terminal, accelerator="Ctrl+`")
            view_menu.add_separator()
            view_menu.add_command(label="Zoom In", command=self.zoom_in, accelerator="Ctrl++")
            view_menu.add_command(label="Zoom Out", command=self.zoom_out, accelerator="Ctrl+-")
            
            # Run menu
            run_menu = tk.Menu(menubar, tearoff=0, bg=self.colors['sidebar_bg'], fg=self.colors['text'])
            menubar.add_cascade(label="Run", menu=run_menu)
            run_menu.add_command(label="Run Python File", command=self.run_python_file, accelerator="F5")
            run_menu.add_command(label="Debug", command=self.debug_python_file, accelerator="Ctrl+F5")
            
            # Main layout with paned windows
            main_paned = ttk.PanedWindow(self.rootVSCODE, orient=tk.HORIZONTAL)
            main_paned.pack(fill=tk.BOTH, expand=True)
            
            # Activity bar (stânga de tot)
            self.activity_bar = tk.Frame(main_paned, bg=self.colors['activity_bar'], width=50)
            self.activity_bar.pack_propagate(False)
            main_paned.add(self.activity_bar)
            
            # Activity bar icons (simulare)
            explorer_icon = tk.Label(self.activity_bar, text="📁", bg=self.colors['activity_bar'], 
                                   fg=self.colors['text'], font=('Segoe UI', 16))
            explorer_icon.pack(pady=(10, 5))
            explorer_icon.bind("<Button-1>", lambda e: self.toggle_explorer())
            
            search_icon = tk.Label(self.activity_bar, text="🔍", bg=self.colors['activity_bar'], 
                                  fg=self.colors['text'], font=('Segoe UI', 16))
            search_icon.pack(pady=5)
            search_icon.bind("<Button-1>", lambda e: self.find_text())
            
            git_icon = tk.Label(self.activity_bar, text="⑂", bg=self.colors['activity_bar'], 
                               fg=self.colors['text'], font=('Segoe UI', 16))
            git_icon.pack(pady=5)
            
            debug_icon = tk.Label(self.activity_bar, text="⏵", bg=self.colors['activity_bar'], 
                                 fg=self.colors['text'], font=('Segoe UI', 16))
            debug_icon.pack(pady=5)
            debug_icon.bind("<Button-1>", lambda e: self.run_python_file())
            
            extensions_icon = tk.Label(self.activity_bar, text="⊞", bg=self.colors['activity_bar'], 
                                      fg=self.colors['text'], font=('Segoe UI', 16))
            extensions_icon.pack(pady=5)
            
            # Sidebar container
            self.sidebar_container = tk.Frame(main_paned, bg=self.colors['sidebar_bg'], width=250)
            self.sidebar_container.pack_propagate(False)
            main_paned.add(self.sidebar_container)
            
            # Explorer sidebar
            self.setup_explorer_sidebar()
            
            # Editor area frame
            editor_container = ttk.Frame(main_paned)
            main_paned.add(editor_container)
            
            # Editor și terminal în PanedWindow vertical
            self.editor_terminal_paned = ttk.PanedWindow(editor_container, orient=tk.VERTICAL)
            self.editor_terminal_paned.pack(fill=tk.BOTH, expand=True)
            
            # Editor frame
            editor_frame = ttk.Frame(self.editor_terminal_paned)
            self.editor_terminal_paned.add(editor_frame, weight=3)
            
            # Tabs pentru fișiere multiple
            self.notebook = ttk.Notebook(editor_frame)
            self.notebook.pack(fill=tk.BOTH, expand=True)
            self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
            
            # Adaugă opțiunea de închidere tab cu buton X sau cu middle-click
            self.notebook.enable_traversal()
            
            # Primul tab (default)
            self.create_editor_tab("untitled")
            
            # Terminal
            self.terminal_frame = ttk.Frame(self.editor_terminal_paned, height=200)
            self.terminal_frame.pack_propagate(False)
            
            # Terminal header
            terminal_header = tk.Frame(self.terminal_frame, bg=self.colors['tab_inactive'], height=30)
            terminal_header.pack(fill=tk.X)
            
            terminal_label = tk.Label(terminal_header, text="TERMINAL", bg=self.colors['tab_inactive'],
                                     fg=self.colors['text'], font=('Consolas', 9, 'bold'))
            terminal_label.pack(side=tk.LEFT, padx=10, pady=5)
            
            close_terminal_btn = tk.Label(terminal_header, text="✕", bg=self.colors['tab_inactive'],
                                         fg=self.colors['text'], cursor="hand2")
            close_terminal_btn.pack(side=tk.RIGHT, padx=10, pady=5)
            close_terminal_btn.bind("<Button-1>", lambda e: self.toggle_terminal())
            
            # Terminal text cu suport pentru input
            self.terminal_output = tk.Text(self.terminal_frame, bg=self.colors['editor_bg'],
                                         fg=self.colors['text'], font=('Consolas', 10),
                                         wrap=tk.WORD)
            self.terminal_output.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Adaugă un prompt marker pentru input
            self.terminal_prompt = ">>> "
            self.terminal_output.tag_configure("prompt", foreground="#4EC9B0")
            self.terminal_output.tag_configure("input", foreground="#CE9178")
            self.terminal_output.tag_configure("error", foreground="red")
            self.terminal_output.tag_configure("input_prompt", foreground="#4EC9B0", font=('Consolas', 10, 'bold'))
            
            # Input field separat pentru terminal
            self.terminal_input = tk.Entry(self.terminal_frame, bg=self.colors['editor_bg'],
                                         fg=self.colors['text'], font=('Consolas', 10),
                                         insertbackground=self.colors['text'], state=tk.DISABLED)
            self.terminal_input.pack(fill=tk.X, padx=5, pady=(0, 5))

            # Binding pentru input field
            self.terminal_input.bind("<Return>", self.on_terminal_input_enter)
            
            # Binding pentru tastele din terminal
            #self.terminal_output.bind("<Return>", self.on_terminal_enter)
            
            # Terminal scrollbar (doar o singură dată)
            terminal_scrollbar = tk.Scrollbar(self.terminal_output, orient=tk.VERTICAL, 
                                             command=self.terminal_output.yview)
            terminal_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.terminal_output.config(yscrollcommand=terminal_scrollbar.set)
            
            interrupt_btn = tk.Label(terminal_header, text="⏹", bg=self.colors['tab_inactive'],
                           fg=self.colors['text'], cursor="hand2")
            interrupt_btn.pack(side=tk.RIGHT, padx=10, pady=5)
            interrupt_btn.bind("<Button-1>", lambda e: self.interrupt_process())
            
            # Variabile pentru procesul în execuție
            self.process = None
            self.awaiting_input = False
            
            # Status bar
            status_container = tk.Frame(self.rootVSCODE, bg=self.colors['status_bar'], height=25)
            status_container.pack(side=tk.BOTTOM, fill=tk.X)
            status_container.pack_propagate(False)
            
            self.status_bar_left = tk.Label(status_container, text="Ready", bg=self.colors['status_bar'],
                                          fg=self.colors['text'], font=('Consolas', 9), anchor='w')
            self.status_bar_left.pack(side=tk.LEFT, padx=10)
            
            self.status_bar_right = tk.Label(status_container, text="Python", bg=self.colors['status_bar'],
                                           fg=self.colors['text'], font=('Consolas', 9), anchor='e')
            self.status_bar_right.pack(side=tk.RIGHT, padx=10)
            
            self.line_col_indicator = tk.Label(status_container, text="Ln 1, Col 1", bg=self.colors['status_bar'],
                                            fg=self.colors['text'], font=('Consolas', 9))
            self.line_col_indicator.pack(side=tk.RIGHT, padx=15)
            
            encoding_indicator = tk.Label(status_container, text="UTF-8", bg=self.colors['status_bar'],
                                        fg=self.colors['text'], font=('Consolas', 9))
            encoding_indicator.pack(side=tk.RIGHT, padx=15)
            
            # Keystroke bindings
            self.bind_keystrokes()
            
        def on_terminal_input_enter(self, event):
            """Gestionează input-ul din field-ul separat de terminal"""
            if not self.process or self.process.poll() is not None:
                return "break"
                
            # Obține input-ul utilizatorului
            user_input = self.terminal_input.get()
            
            # Afișează input-ul în terminal
            self.terminal_output.config(state=tk.NORMAL)
            self.terminal_output.insert(tk.END, f"{user_input}\n", "input")
            self.terminal_output.see(tk.END)
            self.terminal_output.config(state=tk.DISABLED)
            
            # Șterge input field-ul
            self.terminal_input.delete(0, tk.END)
            
            # Trimite input-ul către proces (inclusiv "\n")
            try:
                # Adăugăm \n pentru a simula apăsarea Enter și flush imediat pentru a evita buffering
                input_to_send = user_input + '\n'
                self.process.stdin.write(input_to_send)
                self.process.stdin.flush()
                
                # Resetează starea de așteptare input
                self.awaiting_input = False
            except Exception as e:
                self.terminal_output.config(state=tk.NORMAL)
                self.terminal_output.insert(tk.END, f"Error sending input to process: {str(e)}\n", "error")
                self.terminal_output.see(tk.END)
                self.terminal_output.config(state=tk.DISABLED)
            
            return "break"

        
        '''
        def on_terminal_input_enter(self, event):
            """Gestionează input-ul din field-ul separat de terminal"""
            if not self.process or self.process.poll() is not None:
                return "break"
                
            # Obține input-ul utilizatorului
            user_input = self.terminal_input.get()
            
            # Afișează input-ul în terminal
            self.terminal_output.config(state=tk.NORMAL)
            self.terminal_output.insert(tk.END, f"{user_input}\n", "input")
            self.terminal_output.see(tk.END)
            self.terminal_output.config(state=tk.DISABLED)
            
            # Șterge input field-ul
            self.terminal_input.delete(0, tk.END)
            
            # Trimite input-ul către proces
            try:
                input_to_send = user_input + '\n'
                self.process.stdin.write(input_to_send)
                self.process.stdin.flush()
            except Exception as e:
                self.terminal_output.config(state=tk.NORMAL)
                self.terminal_output.insert(tk.END, f"Error sending input to process: {str(e)}\n", "error")
                self.terminal_output.see(tk.END)
                self.terminal_output.config(state=tk.DISABLED)
            
            return "break"
        '''
        
        def interrupt_process(self):
            """Întrerupe procesul curent"""
            if not self.process or self.process.poll() is not None:
                return
                
            # Dacă procesul rulează, îl întrerupem
            if platform.system() == "Windows":
                try:
                    # Pe Windows, încearcă să trimită un CTRL+Break
                    import ctypes
                    ctypes.windll.kernel32.GenerateConsoleCtrlEvent(1, self.process.pid)
                except:
                    # Alternativă: forțează închiderea
                    self.process.terminate()
            else:
                try:
                    # Pe Unix, trimite un SIGINT (echivalent CTRL+C)
                    import signal
                    self.process.send_signal(signal.SIGINT)
                except:
                    # Alternativă: forțează închiderea
                    self.process.terminate()
            
            # Resetează starea
            self.awaiting_input = False
            
        def setup_explorer_sidebar(self):
            # Curăță sidebar
            for widget in self.sidebar_container.winfo_children():
                widget.destroy()
            
            # Explorer header
            explorer_header = tk.Frame(self.sidebar_container, bg=self.colors['sidebar_bg'])
            explorer_header.pack(fill=tk.X)
            
            explorer_title = tk.Label(explorer_header, text="EXPLORER", bg=self.colors['sidebar_bg'], 
                                     fg=self.colors['text'], font=('Consolas', 9, 'bold'))
            explorer_title.pack(side=tk.LEFT, padx=10, pady=5)
            
            # Butoane pentru Explorer
            new_file_btn = tk.Label(explorer_header, text="📄", bg=self.colors['sidebar_bg'],
                                   fg=self.colors['text'], cursor="hand2")
            new_file_btn.pack(side=tk.RIGHT, padx=(0, 5))
            new_file_btn.bind("<Button-1>", lambda e: self.new_file())
            
            new_folder_btn = tk.Label(explorer_header, text="📁", bg=self.colors['sidebar_bg'],
                                    fg=self.colors['text'], cursor="hand2")
            new_folder_btn.pack(side=tk.RIGHT, padx=(0, 5))
            
            refresh_btn = tk.Label(explorer_header, text="🔄", bg=self.colors['sidebar_bg'],
                                  fg=self.colors['text'], cursor="hand2")
            refresh_btn.pack(side=tk.RIGHT, padx=(0, 5))
            refresh_btn.bind("<Button-1>", lambda e: self.refresh_file_explorer())
            
            collapse_btn = tk.Label(explorer_header, text="⤌", bg=self.colors['sidebar_bg'],
                                   fg=self.colors['text'], cursor="hand2")
            collapse_btn.pack(side=tk.RIGHT, padx=(0, 5))
            
            # File tree with treeview
            self.file_tree = ttk.Treeview(self.sidebar_container, selectmode="browse", show="tree")
            self.file_tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            self.file_tree.bind("<Double-1>", self.on_tree_double_click)
            
            # Scrollbar for file tree
            tree_scroll = ttk.Scrollbar(self.file_tree, orient="vertical", command=self.file_tree.yview)
            tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            self.file_tree.configure(yscrollcommand=tree_scroll.set)
            
            # Configurare treeview style
            style = ttk.Style()
            style.configure("Treeview", 
                           background=self.colors['sidebar_bg'],
                           foreground=self.colors['text'],
                           fieldbackground=self.colors['sidebar_bg'])
            style.map('Treeview', background=[('selected', self.colors['selection'])])
            
            # Open folder label if none is opened
            self.folder_label = tk.Label(self.sidebar_container, 
                                        text="No folder opened\nClick 'Open Folder' to open a project", 
                                        bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                        justify=tk.CENTER)
            self.folder_label.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            self.file_tree.pack_forget()  # Ascunde tree-ul până când se deschide un folder
            
        def create_editor_tab(self, title, content=""):
            # Creează un nou tab cu editor
            tab_frame = ttk.Frame(self.notebook)
            
            # Tab header cu buton de închidere
            tab_header = tk.Frame(tab_frame, bg=self.colors['tab_inactive'])
            tab_header.pack(fill=tk.X)
            
            # Buton de închidere
            close_btn = tk.Label(tab_header, text="✕", bg=self.colors['tab_inactive'],
                               fg=self.colors['text'], cursor="hand2", font=('Consolas', 9))
            close_btn.pack(side=tk.RIGHT, padx=5)
            
            # Editor container
            editor_container = tk.Frame(tab_frame, bg=self.colors['editor_bg'])
            editor_container.pack(fill=tk.BOTH, expand=True)
            
            # Line numbers
            line_numbers = tk.Text(editor_container, width=4, bg=self.colors['editor_bg'],
                                  fg=self.colors['line_number'], font=('Consolas', 11),
                                  state=tk.DISABLED, wrap=tk.NONE, bd=0, padx=5)
            line_numbers.pack(side=tk.LEFT, fill=tk.Y)
            
            # Text editor
            text_editor = tk.Text(editor_container, bg=self.colors['editor_bg'], 
                                 fg=self.colors['text'], font=('Consolas', 11),
                                 insertbackground=self.colors['text'], wrap=tk.NONE,
                                 selectbackground=self.colors['selection'], bd=0,
                                 undo=True, maxundo=100, padx=10, pady=5)
            text_editor.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Highlight line curentă
            text_editor.tag_configure("current_line", background=self.colors['current_line'])
            
            # Scrollbar vertical
            v_scrollbar = tk.Scrollbar(editor_container, orient=tk.VERTICAL)
            v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            v_scrollbar.config(command=lambda *args: self.on_scroll(*args))
            text_editor.config(yscrollcommand=v_scrollbar.set)
            line_numbers.config(yscrollcommand=v_scrollbar.set)
            
            # Scrollbar orizontal
            h_scrollbar = tk.Scrollbar(tab_frame, orient=tk.HORIZONTAL)
            h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            h_scrollbar.config(command=text_editor.xview)
            text_editor.config(xscrollcommand=h_scrollbar.set)
            
            # Adaugă tag-uri pentru text editor
            text_editor.tag_configure('keyword', foreground=self.colors['keyword'])
            text_editor.tag_configure('string', foreground=self.colors['string'])
            text_editor.tag_configure('comment', foreground=self.colors['comment'])
            text_editor.tag_configure('number', foreground=self.colors['number'])
            text_editor.tag_configure('function', foreground=self.colors['function'])
            text_editor.tag_configure('bracket', background='#442e2e')
            
            # Inserează conținut dacă există
            if content:
                text_editor.insert('1.0', content)
            
            # Adaugă tab
            tab_id = self.notebook.add(tab_frame, text=title)
            self.notebook.select(len(self.notebook.tabs()) - 1)
            
            # Index pentru acest tab
            tab_index = len(self.files_opened)
            
            # Conectează butonul de închidere
            close_btn.bind("<Button-1>", lambda e, idx=tab_index: self.close_tab_by_index(idx))
            
            # Adaugă la lista de file-uri deschise
            self.files_opened.append({
                'title': title,
                'path': None,
                'editor': text_editor,
                'line_numbers': line_numbers,
                'modified': False,
                'tab_id': tab_id,
                'close_btn': close_btn
            })
            
            # Bind evenimente
            text_editor.bind('<KeyRelease>', lambda e, editor=text_editor, ln=line_numbers: 
                            self.on_text_change(e, editor, ln))
            text_editor.bind('<Button-1>', lambda e, editor=text_editor, ln=line_numbers: 
                            self.on_text_change(e, editor, ln))
            text_editor.bind("<<Modified>>", lambda e, index=len(self.files_opened)-1: 
                            self.on_content_modified(e, index))
            text_editor.bind('<KeyRelease-parenleft>', lambda e, editor=text_editor: 
                            self.auto_close_bracket(e, editor, '(', ')'))
            text_editor.bind('<KeyRelease-bracketleft>', lambda e, editor=text_editor: 
                            self.auto_close_bracket(e, editor, '[', ']'))
            text_editor.bind('<KeyRelease-braceleft>', lambda e, editor=text_editor: 
                            self.auto_close_bracket(e, editor, '{', '}'))
            text_editor.bind('<KeyRelease-quotedbl>', lambda e, editor=text_editor: 
                            self.auto_close_bracket(e, editor, '"', '"'))
            text_editor.bind('<KeyRelease-quoteright>', lambda e, editor=text_editor: 
                            self.auto_close_bracket(e, editor, "'", "'"))
            text_editor.bind('<KeyRelease-colon>', lambda e, editor=text_editor: 
                            self.auto_indent_after_colon(e, editor))
            text_editor.bind('<KeyRelease-Return>', lambda e, editor=text_editor: 
                            self.auto_indent(e, editor))
            text_editor.bind('<Tab>', lambda e, editor=text_editor: 
                            self.handle_tab(e, editor))
            text_editor.bind('<KeyRelease-period>', lambda e, editor=text_editor: 
                            self.show_autocomplete(e, editor))
            text_editor.bind("<ButtonRelease-1>", lambda e, editor=text_editor, ln=line_numbers: 
                            self.on_editor_click(e, editor, ln))
            # Binding pentru mouse wheel
            text_editor.bind("<MouseWheel>", lambda e, editor=text_editor, ln=line_numbers: 
                            self.on_mousewheel(e, editor, ln))  # Windows
            text_editor.bind("<Button-4>", lambda e, editor=text_editor, ln=line_numbers: 
                            self.on_mousewheel(e, editor, ln))  # Linux scroll up
            text_editor.bind("<Button-5>", lambda e, editor=text_editor, ln=line_numbers: 
                            self.on_mousewheel(e, editor, ln))  # Linux scroll down
            
            # Bind middle-click pentru închidere tab
            self.notebook.bind("<Button-2>", self.on_tab_middle_click)
            
            # Update line numbers
            self.update_line_numbers(text_editor, line_numbers)
            
            # Focus pe editor
            text_editor.focus_set()
            
            return text_editor
            
        def on_mousewheel(self, event, editor, line_numbers):
            # Sincronizează line numbers la scroll cu mouse-ul
            if platform.system() == "Windows":
                # Pentru Windows, evenimentele au proprietatea delta
                editor.yview_scroll(int(-1 * (event.delta / 120)), "units")
            elif platform.system() == "Darwin":  # macOS
                editor.yview_scroll(int(-1 * event.delta), "units")
            else:  # Linux și alte sisteme
                if event.num == 4:  # Scroll up
                    editor.yview_scroll(-1, "units")
                elif event.num == 5:  # Scroll down
                    editor.yview_scroll(1, "units")
                    
            # Sincronizează line numbers
            self.after_scroll_sync(editor, line_numbers)
            return "break"

        def after_scroll_sync(self, editor, line_numbers):
            # Funcție ajutătoare pentru a sincroniza după scroll
            line_numbers.yview_moveto(editor.yview()[0])
            self.rootVSCODE.after(10, lambda: line_numbers.yview_moveto(editor.yview()[0]))
        
        def on_editor_click(self, event, editor, line_numbers):
            # Salvează poziția de scroll actuală înainte de orice operație
            current_scroll_position = editor.yview()[0]
            
            # Procesează click-ul la poziția corectă
            try:
                click_pos = editor.index(f"@{event.x},{event.y}")
                editor.mark_set(tk.INSERT, click_pos)  # Setează cursorul la poziția exactă a click-ului
            except:
                pass
            
            # Highlight-ul liniei curente fără a afecta poziția de scroll
            self.highlight_current_line(editor)
            
            # Actualizează line numbers fără a schimba poziția de scroll a editorului
            self.update_line_numbers_without_scroll(editor, line_numbers)
            
            # Restaurează poziția de scroll a editorului
            editor.yview_moveto(current_scroll_position)
            
            # Sincronizează line_numbers cu poziția editorului (nu invers)
            line_numbers.yview_moveto(editor.yview()[0])
            
            # Update cursor position in status bar
            cursor_pos = editor.index(tk.INSERT)
            line, col = cursor_pos.split('.')
            self.line_col_indicator.config(text=f"Ln {line}, Col {int(col)+1}")
            
        def update_line_numbers_without_scroll(self, editor, line_numbers):
            content = editor.get('1.0', tk.END)
            lines = content.count('\n')
            if lines == 0:
                lines = 1
                
            line_numbers.config(state=tk.NORMAL)
            line_numbers.delete('1.0', tk.END)
            
            line_numbers_string = '\n'.join(str(i) for i in range(1, lines + 1))
            line_numbers.insert('1.0', line_numbers_string)
            line_numbers.config(state=tk.DISABLED)
            
            # Nu sincroniza scroll-ul editorului, doar păstrează poziția line_numbers sincronizată cu editorul
            line_numbers.yview_moveto(editor.yview()[0])
            
        def on_scroll(self, *args):
            # Sincronizează scroll-ul între editor și line numbers
            current_editor = self.get_current_editor()
            line_numbers = self.get_current_line_numbers()
            
            if current_editor and line_numbers:
                # Aplică scroll-ul la ambele widget-uri
                current_editor.yview(*args)
                line_numbers.yview(*args)
                
                # Forțează sincronizarea cu un mic delay pentru a asigura că poziția de scroll este aceeași
                self.rootVSCODE.after(10, lambda: line_numbers.yview_moveto(current_editor.yview()[0]))
        
        def close_tab_by_index(self, index):
            # Asigură-te că indexul este valid
            if index >= len(self.files_opened):
                # Poate indexul s-a schimbat din cauza închiderii altor tab-uri
                # Găsim tab-ul curent selectat
                index = self.notebook.index(self.notebook.select())
            
            # Salvăm indexul curent
            current_tab_index = self.current_tab_index
            
            # Selectăm tab-ul pe care vrem să-l închidem
            self.notebook.select(index)
            self.current_tab_index = index
            
            # Închidem tab-ul folosind metoda existentă
            self.close_current_file()
            
            # Dacă tab-ul curent era diferit și încă există, revenim la el
            if current_tab_index != index and current_tab_index < len(self.notebook.tabs()):
                self.notebook.select(current_tab_index)
        
        def on_tab_middle_click(self, event):
            # Obține tab-ul pe care s-a făcut click
            clicked_tab = self.notebook.tk.call(self.notebook._w, "identify", "tab", event.x, event.y)
            if clicked_tab != "":
                # Închide tab-ul
                self.close_tab_by_index(int(clicked_tab))
        
        def setup_syntax_highlighting(self):
            # Python keywords
            self.keywords = [
                'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else',
                'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',
                'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield',
                'True', 'False', 'None', 'self', 'cls', 'print', 'len', 'str', 'int', 'float', 'list',
                'dict', 'tuple', 'set', 'open', 'range', 'enumerate', 'zip', 'map', 'filter'
            ]
            
            # Builtin functions pentru autocompletare
            for func in dir(__builtins__):
                if not func.startswith('_'):
                    self.autocomplete_words.add(func)
            
        def highlight_syntax(self, editor):
            # Elimină highlighting-ul anterior
            for tag in ['keyword', 'string', 'comment', 'number', 'function']:
                editor.tag_remove(tag, '1.0', tk.END)
            
            content = editor.get('1.0', tk.END)
            lines = content.split('\n')
            
            for line_num, line in enumerate(lines, 1):
                # Highlight keywords
                for keyword in self.keywords:
                    pattern = r'\b' + re.escape(keyword) + r'\b'
                    for match in re.finditer(pattern, line):
                        start = f"{line_num}.{match.start()}"
                        end = f"{line_num}.{match.end()}"
                        editor.tag_add('keyword', start, end)
                
                # Highlight strings
                string_patterns = [r'"[^"\\\n]*(?:\\.[^"\\\n]*)*"', r"'[^'\\\n]*(?:\\.[^'\\\n]*)*'", 
                                 r'"""[\s\S]*?"""', r"'''[\s\S]*?'''"]
                for pattern in string_patterns:
                    for match in re.finditer(pattern, line):
                        start = f"{line_num}.{match.start()}"
                        end = f"{line_num}.{match.end()}"
                        editor.tag_add('string', start, end)
                
                # Highlight comments
                comment_match = re.search(r'#.*$', line)
                if comment_match:
                    start = f"{line_num}.{comment_match.start()}"
                    end = f"{line_num}.{comment_match.end()}"
                    editor.tag_add('comment', start, end)
                
                # Highlight numbers
                for match in re.finditer(r'\b\d+\.?\d*\b', line):
                    start = f"{line_num}.{match.start()}"
                    end = f"{line_num}.{match.end()}"
                    editor.tag_add('number', start, end)
                
                # Highlight function definitions and calls
                func_def_match = re.search(r'def\s+(\w+)', line)
                if func_def_match:
                    start = f"{line_num}.{func_def_match.start(1)}"
                    end = f"{line_num}.{func_def_match.end(1)}"
                    editor.tag_add('function', start, end)
                    
                    # Adaugă la lista de cuvinte pentru autocompletare
                    self.autocomplete_words.add(func_def_match.group(1))
                
                # Highlight function calls
                for match in re.finditer(r'(\w+)\(', line):
                    start = f"{line_num}.{match.start(1)}"
                    end = f"{line_num}.{match.end(1)}"
                    editor.tag_add('function', start, end)
                    
                    # Adaugă la lista de cuvinte pentru autocompletare
                    self.autocomplete_words.add(match.group(1))
        
        def highlight_current_line(self, editor):
            editor.tag_remove("current_line", "1.0", tk.END)
            editor.tag_add("current_line", "insert linestart", "insert lineend+1c")
        
        def update_line_numbers(self, editor, line_numbers):
            # Salvează poziția de scroll curentă
            current_scroll = editor.yview()[0]
            
            content = editor.get('1.0', tk.END)
            lines = content.count('\n')
            if lines == 0:
                lines = 1
                
            line_numbers.config(state=tk.NORMAL)
            line_numbers.delete('1.0', tk.END)
            
            line_numbers_string = '\n'.join(str(i) for i in range(1, lines + 1))
            line_numbers.insert('1.0', line_numbers_string)
            line_numbers.config(state=tk.DISABLED)
            
            # Sincronizează line_numbers cu editorul fără a modifica poziția editorului
            line_numbers.yview_moveto(current_scroll)
            
            # Nu modificăm poziția de scroll a editorului
            # editor.yview_moveto(line_numbers.yview()[0]) - eliminat
        
        def on_text_change(self, event=None, editor=None, line_numbers=None):
            if not editor:
                editor = self.get_current_editor()
            if not line_numbers:
                line_numbers = self.get_current_line_numbers()
                
            self.update_line_numbers(editor, line_numbers)
            self.highlight_syntax(editor)
            self.highlight_current_line(editor)
            
            # Update cursor position in status bar
            cursor_pos = editor.index(tk.INSERT)
            line, col = cursor_pos.split('.')
            self.line_col_indicator.config(text=f"Ln {line}, Col {int(col)+1}")
        
        def on_content_modified(self, event, index):
            if index >= len(self.files_opened):
                # Poate a fost închis deja tab-ul
                return
                
            editor = self.files_opened[index]['editor']
            editor.edit_modified(False)  # Reset flag
            
            if not self.files_opened[index]['modified']:
                self.files_opened[index]['modified'] = True
                # Update tab name to show modified indicator
                title = self.files_opened[index]['title']
                if not title.endswith('*'):
                    self.notebook.tab(index, text=title + '*')
        
        def on_tab_changed(self, event):
            # Update the current tab index
            self.current_tab_index = self.notebook.index("current")
            
            # Actualizează titlul ferestrei cu numele fișierului curent
            if len(self.files_opened) > 0 and self.current_tab_index < len(self.files_opened):
                current_file = self.files_opened[self.current_tab_index]
                if current_file['path']:
                    self.rootVSCODE.title(f"{os.path.basename(current_file['path'])} - VS Code - Python Editor")
                else:
                    self.rootVSCODE.title(f"{current_file['title']} - VS Code - Python Editor")
                
                # Actualizează statusbar
                self.status_bar_left.config(text="Ready")
                if current_file['path']:
                    self.status_bar_right.config(text=f"Python {os.path.splitext(current_file['path'])[1]}")
                else:
                    self.status_bar_right.config(text="Python")
                
                # Aplică highlight și update line numbers
                editor = current_file['editor']
                line_numbers = current_file['line_numbers']
                self.highlight_syntax(editor)
                self.update_line_numbers(editor, line_numbers)
                self.highlight_current_line(editor)
                
                # Update cursor position
                cursor_pos = editor.index(tk.INSERT)
                line, col = cursor_pos.split('.')
                self.line_col_indicator.config(text=f"Ln {line}, Col {int(col)+1}")
        
        def bind_keystrokes(self):
            # Key bindings pentru rootVSCODE
            self.rootVSCODE.bind('<Control-n>', lambda e: self.new_file())
            self.rootVSCODE.bind('<Control-o>', lambda e: self.open_file())
            self.rootVSCODE.bind('<Control-s>', lambda e: self.save_file())
            self.rootVSCODE.bind('<Control-S>', lambda e: self.save_as_file())  # Ctrl+Shift+S
            self.rootVSCODE.bind('<Control-w>', lambda e: self.close_current_file())
            self.rootVSCODE.bind('<Control-f>', lambda e: self.find_text())
            self.rootVSCODE.bind('<Control-h>', lambda e: self.replace_text())
            self.rootVSCODE.bind('<Control-b>', lambda e: self.toggle_explorer())
            self.rootVSCODE.bind('<Control-grave>', lambda e: self.toggle_terminal())  # Ctrl+`
            self.rootVSCODE.bind('<F5>', lambda e: self.run_python_file())
            self.rootVSCODE.bind('<Control-F5>', lambda e: self.debug_python_file())
            self.rootVSCODE.bind('<Control-plus>', lambda e: self.zoom_in())  # Ctrl++
            self.rootVSCODE.bind('<Control-minus>', lambda e: self.zoom_out())  # Ctrl+-
        
        def new_file(self):
            # Creează un nou tab gol
            self.create_editor_tab("untitled")
        
        def open_file(self):
            file_path = filedialog.askopenfilename(
                filetypes=[("Python files", "*.py"), ("Text files", "*.txt"), ("All files", "*.*")]
            )
            if file_path:
                # Verifică dacă fișierul este deja deschis
                for i, file_info in enumerate(self.files_opened):
                    if file_info['path'] == file_path:
                        self.notebook.select(i)  # Selectează tab-ul existent
                        return
                
                try:
                    with open(file_path, 'r', encoding='utf-8') as file:
                        content = file.read()
                        
                        # Creează un nou tab cu conținutul fișierului
                        file_name = os.path.basename(file_path)
                        editor = self.create_editor_tab(file_name, content)
                        
                        # Actualizează calea pentru fișierul curent
                        current_index = len(self.files_opened) - 1
                        self.files_opened[current_index]['path'] = file_path
                        self.files_opened[current_index]['modified'] = False
                        
                        # Actualizează titlul ferestrei
                        self.rootVSCODE.title(f"{file_name} - VS Code - Python Editor")
                        
                        # Colectează cuvinte pentru autocompletare din fișier
                        self.collect_words_from_file(content)
                        
                        # Actualizează status bar
                        self.status_bar_left.config(text=f"Opened: {file_name}")
                        
                        # Adaugă la file tree dacă este în folder-ul deschis
                        self.refresh_file_explorer()
                except Exception as e:
                    messagebox.showerror("Error", f"Could not open file: {str(e)}")
        
        def open_folder(self):
            folder_path = filedialog.askdirectory()
            if folder_path:
                # Schimbă directorul curent
                os.chdir(folder_path)
                
                # Actualizează title bar
                self.rootVSCODE.title(f"{os.path.basename(folder_path)} - VS Code - Python Editor")
                
                # Schimbă status bar
                self.status_bar_left.config(text=f"Folder: {os.path.basename(folder_path)}")
                
                # Ascunde label-ul și arată treeview
                self.folder_label.pack_forget()
                self.file_tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                # Populează file explorer
                self.populate_file_explorer(folder_path)
        
        def populate_file_explorer(self, folder_path):
            # Șterge conținut anterior
            for item in self.file_tree.get_children():
                self.file_tree.delete(item)
            
            # Adaugă rootVSCODE folder
            rootVSCODE_name = os.path.basename(folder_path)
            rootVSCODE_id = self.file_tree.insert('', 'end', text=rootVSCODE_name, open=True, 
                                          values=(folder_path, "folder"))
            
            # Funcție recursivă pentru a adăuga fișiere și subfoldere
            def add_directory_contents(parent_id, parent_path):
                try:
                    # Sortează: întâi foldere, apoi fișiere, ambele alfabetic
                    items = os.listdir(parent_path)
                    folders = [i for i in items if os.path.isdir(os.path.join(parent_path, i)) and not i.startswith('.')]
                    files = [i for i in items if os.path.isfile(os.path.join(parent_path, i)) and not i.startswith('.')]
                    
                    folders.sort()
                    files.sort()
                    
                    # Adaugă foldere
                    for folder in folders:
                        folder_path = os.path.join(parent_path, folder)
                        folder_id = self.file_tree.insert(parent_id, 'end', text=folder, 
                                                       values=(folder_path, "folder"))
                        add_directory_contents(folder_id, folder_path)
                    
                    # Adaugă fișiere
                    for file in files:
                        file_path = os.path.join(parent_path, file)
                        # Alege icon bazat pe extensie
                        file_icon = ""
                        if file.endswith('.py'):
                            file_icon = "🐍 "
                        elif file.endswith(('.txt', '.md')):
                            file_icon = "📄 "
                        elif file.endswith(('.jpg', '.png', '.gif')):
                            file_icon = "🖼️ "
                        elif file.endswith(('.html', '.css', '.js')):
                            file_icon = "🌐 "
                        elif file.endswith('.json'):
                            file_icon = "📋 "
                        
                        self.file_tree.insert(parent_id, 'end', text=f"{file_icon}{file}", 
                                            values=(file_path, "file"))
                except Exception as e:
                    print(f"Error accessing {parent_path}: {e}")
            
            # Populează tree-ul
            add_directory_contents(rootVSCODE_id, folder_path)
        
        def refresh_file_explorer(self):
            # Reîmprospătează file explorer dacă există un folder deschis
            rootVSCODE_items = self.file_tree.get_children()
            if rootVSCODE_items:
                rootVSCODE_id = rootVSCODE_items[0]
                folder_path = self.file_tree.item(rootVSCODE_id, "values")[0]
                self.populate_file_explorer(folder_path)
        
        def on_tree_double_click(self, event):
            # Deschide fișier la dublu click
            selection = self.file_tree.selection()
            if not selection:
                return
                
            item_id = selection[0]
            item_values = self.file_tree.item(item_id, "values")
            if item_values and item_values[1] == "file":
                file_path = item_values[0]
                # Verifică dacă fișierul este deja deschis
                for i, file_info in enumerate(self.files_opened):
                    if file_info['path'] == file_path:
                        self.notebook.select(i)  # Selectează tab-ul existent
                        return
                
                # Deschide fișierul
                try:
                    with open(file_path, 'r', encoding='utf-8') as file:
                        content = file.read()
                        
                        # Creează un nou tab cu conținutul fișierului
                        file_name = os.path.basename(file_path)
                        editor = self.create_editor_tab(file_name, content)
                        
                        # Actualizează calea pentru fișierul curent
                        current_index = len(self.files_opened) - 1
                        self.files_opened[current_index]['path'] = file_path
                        self.files_opened[current_index]['modified'] = False
                        
                        # Actualizează titlul ferestrei
                        self.rootVSCODE.title(f"{file_name} - VS Code - Python Editor")
                        
                        # Colectează cuvinte pentru autocompletare din fișier
                        self.collect_words_from_file(content)
                except Exception as e:
                    messagebox.showerror("Error", f"Could not open file: {str(e)}")
        
        def save_file(self):
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return
                
            current_file = self.files_opened[self.current_tab_index]
            
            if current_file['path']:
                self.save_to_file(current_file['path'])
            else:
                self.save_as_file()
        
        def save_as_file(self):
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return
                
            file_path = filedialog.asksaveasfilename(
                defaultextension=".py",
                filetypes=[("Python files", "*.py"), ("Text files", "*.txt"), ("All files", "*.*")]
            )
            if file_path:
                self.save_to_file(file_path)
                
                # Actualizează informațiile despre fișier
                current_file = self.files_opened[self.current_tab_index]
                current_file['path'] = file_path
                current_file['title'] = os.path.basename(file_path)
                current_file['modified'] = False
                
                # Actualizează tab
                self.notebook.tab(self.current_tab_index, text=current_file['title'])
                
                # Actualizează title bar
                self.rootVSCODE.title(f"{current_file['title']} - VS Code - Python Editor")
                
                # Reîmprospătează file explorer
                self.refresh_file_explorer()
        
        def save_all_files(self):
            for i, file_info in enumerate(self.files_opened):
                if file_info['modified']:
                    if file_info['path']:
                        self.save_to_file(file_info['path'], i)
                    else:
                        # Salvează cu dialog doar prima dată
                        current_tab = self.current_tab_index
                        self.notebook.select(i)
                        self.save_as_file()
                        self.notebook.select(current_tab)
        
        def save_to_file(self, file_path, index=None):
            if index is None:
                index = self.current_tab_index
                
            if index >= len(self.files_opened):
                return False
                
            try:
                current_file = self.files_opened[index]
                content = current_file['editor'].get('1.0', tk.END + '-1c')
                
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(content)
                    
                # Actualizează starea modificată
                current_file['modified'] = False
                title = current_file['title'].rstrip('*')
                self.notebook.tab(index, text=title)
                
                # Actualizează status bar
                self.status_bar_left.config(text=f"Saved: {os.path.basename(file_path)}")
                
                # Actualizează timestamp in status bar
                now = datetime.now().strftime("%H:%M:%S")
                self.status_bar_right.config(text=f"Python {os.path.splitext(file_path)[1]} | {now}")
                
                return True
            except Exception as e:
                messagebox.showerror("Error", f"Could not save file: {str(e)}")
                return False
        
        def close_current_file(self):
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return
                
            current_file = self.files_opened[self.current_tab_index]
            
            # Verifică dacă fișierul a fost modificat
            if current_file['modified']:
                title = current_file['title'].rstrip('*')
                response = messagebox.askyesnocancel("Save Changes", 
                                                    f"Do you want to save changes to {title}?")
                if response is None:  # Cancel
                    return
                elif response:  # Yes
                    if not current_file['path']:
                        file_path = filedialog.asksaveasfilename(
                            defaultextension=".py",
                            filetypes=[("Python files", "*.py"), ("Text files", "*.txt"), ("All files", "*.*")]
                        )
                        if not file_path:
                            return  # Cancel save
                        saved = self.save_to_file(file_path)
                        if not saved:
                            return  # Save failed
                    else:
                        saved = self.save_to_file(current_file['path'])
                        if not saved:
                            return  # Save failed
            
            # Închide tab-ul
            self.notebook.forget(self.current_tab_index)
            
            # Elimină din lista de fișiere deschise
            self.files_opened.pop(self.current_tab_index)
            
            # Actualizăm indexul pentru restul tab-urilor
            for i in range(self.current_tab_index, len(self.files_opened)):
                # Actualizează referința la butonul de închidere
                self.files_opened[i]['close_btn'].bind("<Button-1>", lambda e, idx=i: self.close_tab_by_index(idx))
            
            # Deschide un nou tab dacă nu mai există altele
            if len(self.notebook.tabs()) == 0:
                self.create_editor_tab("untitled")
                
            # Actualizează UI
            self.on_tab_changed(None)
        
        def exit_application(self):
            # Verifică fișiere modificate și oferă salvare
            unsaved_files = [f for f in self.files_opened if f['modified']]
            
            if unsaved_files:
                response = messagebox.askyesnocancel("Save Changes", 
                                                   f"Save changes to {len(unsaved_files)} files before closing?")
                if response is None:  # Cancel
                    return
                elif response:  # Yes
                    self.save_all_files()
            
            # Curăță procesele terminalului
            self.cleanup_terminal_process()
            
            # Închide aplicația
            self.rootVSCODE.quit()
        
        def cut_text(self):
            editor = self.get_current_editor()
            if editor:
                if editor.tag_ranges(tk.SEL):
                    editor.event_generate("<<Cut>>")
        
        def copy_text(self):
            editor = self.get_current_editor()
            if editor:
                if editor.tag_ranges(tk.SEL):
                    editor.event_generate("<<Copy>>")
        
        def paste_text(self):
            editor = self.get_current_editor()
            if editor:
                editor.event_generate("<<Paste>>")
        
        def undo(self):
            editor = self.get_current_editor()
            if editor:
                try:
                    editor.edit_undo()
                    self.on_text_change(None, editor, self.get_current_line_numbers())
                except tk.TclError:
                    pass  # Nu există nimic de undo
        
        def redo(self):
            editor = self.get_current_editor()
            if editor:
                try:
                    editor.edit_redo()
                    self.on_text_change(None, editor, self.get_current_line_numbers())
                except tk.TclError:
                    pass  # Nu există nimic de redo
        
        def find_text(self):
            editor = self.get_current_editor()
            if not editor:
                return
                
            # Verifică dacă există text selectat
            try:
                selected_text = editor.get(tk.SEL_FIRST, tk.SEL_LAST)
            except tk.TclError:
                selected_text = ""
            
            # Creează dialog de căutare
            find_dialog = tk.Toplevel(self.rootVSCODE)
            find_dialog.title("Find")
            find_dialog.geometry("400x150")
            find_dialog.transient(self.rootVSCODE)
            find_dialog.configure(bg=self.colors['bg'])
            find_dialog.resizable(False, False)
            
            # Variabile pentru căutare
            search_var = tk.StringVar(value=selected_text)
            case_sensitive = tk.BooleanVar(value=False)
            match_whole_word = tk.BooleanVar(value=False)
            use_regex = tk.BooleanVar(value=False)
            
            # Layout
            search_frame = tk.Frame(find_dialog, bg=self.colors['bg'])
            search_frame.pack(fill=tk.X, padx=10, pady=10)
            
            tk.Label(search_frame, text="Find:", bg=self.colors['bg'], fg=self.colors['text']).pack(side=tk.LEFT, padx=(0, 5))
            search_entry = tk.Entry(search_frame, textvariable=search_var, bg=self.colors['editor_bg'],
                                   fg=self.colors['text'], insertbackground=self.colors['text'], width=30)
            search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
            search_entry.focus_set()
            
            # Opțiuni de căutare
            options_frame = tk.Frame(find_dialog, bg=self.colors['bg'])
            options_frame.pack(fill=tk.X, padx=10, pady=5)
            
            tk.Checkbutton(options_frame, text="Case sensitive", variable=case_sensitive,
                          bg=self.colors['bg'], fg=self.colors['text'], selectcolor=self.colors['editor_bg'],
                          activebackground=self.colors['bg'], activeforeground=self.colors['text']).pack(side=tk.LEFT, padx=5)
            
            tk.Checkbutton(options_frame, text="Match whole word", variable=match_whole_word,
                          bg=self.colors['bg'], fg=self.colors['text'], selectcolor=self.colors['editor_bg'],
                          activebackground=self.colors['bg'], activeforeground=self.colors['text']).pack(side=tk.LEFT, padx=5)
            
            tk.Checkbutton(options_frame, text="Use regex", variable=use_regex,
                          bg=self.colors['bg'], fg=self.colors['text'], selectcolor=self.colors['editor_bg'],
                          activebackground=self.colors['bg'], activeforeground=self.colors['text']).pack(side=tk.LEFT, padx=5)
            
            # Status
            status_var = tk.StringVar()
            status_label = tk.Label(find_dialog, textvariable=status_var, bg=self.colors['bg'], fg=self.colors['text'])
            status_label.pack(fill=tk.X, padx=10, pady=5)
            
            # Butoane
            buttons_frame = tk.Frame(find_dialog, bg=self.colors['bg'])
            buttons_frame.pack(fill=tk.X, padx=10, pady=10)
            
            def find_next():
                search_term = search_var.get()
                if not search_term:
                    status_var.set("Nothing to search for")
                    return
                    
                # Șterge highlight-uri anterioare
                editor.tag_remove('search', '1.0', tk.END)
                
                # Obține poziția curentă a cursorului
                current_pos = editor.index(tk.INSERT)
                
                # Caută după poziția curentă
                if use_regex.get():
                    try:
                        pattern = re.compile(search_term, 0 if case_sensitive.get() else re.IGNORECASE)
                    except re.error:
                        status_var.set("Invalid regex pattern")
                        return
                        
                    content = editor.get(current_pos, tk.END)
                    match = pattern.search(content)
                    
                    if match:
                        start_idx = editor.index(f"{current_pos}+{match.start()}c")
                        end_idx = editor.index(f"{current_pos}+{match.end()}c")
                        
                        # Verifică whole word dacă este necesar
                        if match_whole_word.get():
                            if (start_idx == "1.0" or not editor.get(f"{start_idx}-1c").isalnum()) and \
                               (end_idx == editor.index(tk.END) or not editor.get(f"{end_idx}").isalnum()):
                                found = True
                            else:
                                found = False
                                start_idx = editor.index(f"{end_idx}")
                        else:
                            found = True
                            
                        if found:
                            editor.tag_add('search', start_idx, end_idx)
                            editor.tag_configure('search', background='#555500', foreground='white')
                            editor.mark_set(tk.INSERT, end_idx)
                            editor.see(start_idx)
                            status_var.set(f"Found match at position {start_idx}")
                            return
                            
                    # Nu s-a găsit nimic, începe de la început
                    content = editor.get("1.0", current_pos)
                    match = pattern.search(content)
                    
                    if match:
                        start_idx = editor.index(f"1.0+{match.start()}c")
                        end_idx = editor.index(f"1.0+{match.end()}c")
                        
                        # Verifică whole word dacă este necesar
                        if match_whole_word.get():
                            if (start_idx == "1.0" or not editor.get(f"{start_idx}-1c").isalnum()) and \
                               (end_idx == editor.index(tk.END) or not editor.get(f"{end_idx}").isalnum()):
                                found = True
                            else:
                                found = False
                        else:
                            found = True
                            
                        if found:
                            editor.tag_add('search', start_idx, end_idx)
                            editor.tag_configure('search', background='#555500', foreground='white')
                            editor.mark_set(tk.INSERT, end_idx)
                            editor.see(start_idx)
                            status_var.set(f"Found match at position {start_idx} (wrapped search)")
                            return
                            
                    status_var.set("No matches found")
                else:
                    # Căutare normală
                    search_flags = "nocase" if not case_sensitive.get() else ""
                    
                    if match_whole_word.get():
                        # Adaugă \y pentru a potrivi doar cuvinte întregi
                        search_term = f"\\y{search_term}\\y"
                        
                    found_pos = editor.search(search_term, current_pos, tk.END, regexp=match_whole_word.get(), nocase=not case_sensitive.get())
                    
                    if found_pos:
                        # Calculează poziția de sfârșit
                        if match_whole_word.get() or use_regex.get():
                            # Pentru regex trebuie să determinăm lungimea potrivirii
                            match_length = len(re.search(search_term, editor.get(found_pos, tk.END)).group(0))
                        else:
                            match_length = len(search_term)
                            
                        end_pos = f"{found_pos}+{match_length}c"
                        
                        # Highlight și setează cursor
                        editor.tag_add('search', found_pos, end_pos)
                        editor.tag_configure('search', background='#555500', foreground='white')
                        editor.mark_set(tk.INSERT, end_pos)
                        editor.see(found_pos)
                        status_var.set(f"Found match at position {found_pos}")
                    else:
                        # Încearcă de la început
                        found_pos = editor.search(search_term, "1.0", current_pos, regexp=match_whole_word.get(), nocase=not case_sensitive.get())
                        
                        if found_pos:
                            # Calculează poziția de sfârșit
                            if match_whole_word.get() or use_regex.get():
                                # Pentru regex trebuie să determinăm lungimea potrivirii
                                match_length = len(re.search(search_term, editor.get(found_pos, tk.END)).group(0))
                            else:
                                match_length = len(search_term)
                                
                            end_pos = f"{found_pos}+{match_length}c"
                            
                            # Highlight și setează cursor
                            editor.tag_add('search', found_pos, end_pos)
                            editor.tag_configure('search', background='#555500', foreground='white')
                            editor.mark_set(tk.INSERT, end_pos)
                            editor.see(found_pos)
                            status_var.set(f"Found match at position {found_pos} (wrapped search)")
                        else:
                            status_var.set("No matches found")
            
            def find_all():
                search_term = search_var.get()
                if not search_term:
                    status_var.set("Nothing to search for")
                    return
                    
                # Șterge highlight-uri anterioare
                editor.tag_remove('search', '1.0', tk.END)
                
                # Contorizare
                count = 0
                
                if use_regex.get():
                    try:
                        pattern = re.compile(search_term, 0 if case_sensitive.get() else re.IGNORECASE)
                    except re.error:
                        status_var.set("Invalid regex pattern")
                        return
                        
                    content = editor.get("1.0", tk.END)
                    
                    for match in pattern.finditer(content):
                        start_idx = editor.index(f"1.0+{match.start()}c")
                        end_idx = editor.index(f"1.0+{match.end()}c")
                        
                        # Verifică whole word dacă este necesar
                        if match_whole_word.get():
                            if (start_idx == "1.0" or not editor.get(f"{start_idx}-1c").isalnum()) and \
                               (end_idx == editor.index(tk.END) or not editor.get(f"{end_idx}").isalnum()):
                                editor.tag_add('search', start_idx, end_idx)
                                count += 1
                        else:
                            editor.tag_add('search', start_idx, end_idx)
                            count += 1
                else:
                    # Căutare normală
                    start_pos = "1.0"
                    
                    while True:
                        search_flags = "nocase" if not case_sensitive.get() else ""
                        
                        if match_whole_word.get():
                            # Adaugă \y pentru a potrivi doar cuvinte întregi
                            pattern = f"\\y{search_term}\\y"
                            found_pos = editor.search(pattern, start_pos, tk.END, regexp=True, nocase=not case_sensitive.get())
                        else:
                            found_pos = editor.search(search_term, start_pos, tk.END, nocase=not case_sensitive.get())
                        
                        if not found_pos:
                            break
                            
                        # Calculează poziția de sfârșit
                        if match_whole_word.get():
                            # Pentru regex trebuie să determinăm lungimea potrivirii
                            match_length = len(re.search(pattern, editor.get(found_pos, tk.END)).group(0))
                        else:
                            match_length = len(search_term)
                            
                        end_pos = f"{found_pos}+{match_length}c"
                        
                        # Highlight
                        editor.tag_add('search', found_pos, end_pos)
                        count += 1
                        
                        # Actualizează poziția de început pentru următoarea căutare
                        start_pos = end_pos
                
                # Configurare highlight
                editor.tag_configure('search', background='#555500', foreground='white')
                
                # Actualizează status
                if count == 0:
                    status_var.set("No matches found")
                else:
                    status_var.set(f"Found {count} matches")
            
            # Butoane pentru acțiuni
            find_next_btn = tk.Button(buttons_frame, text="Find Next", command=find_next,
                                     bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                     activebackground=self.colors['selection'])
            find_next_btn.pack(side=tk.LEFT, padx=5)
            
            find_all_btn = tk.Button(buttons_frame, text="Find All", command=find_all,
                                   bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                   activebackground=self.colors['selection'])
            find_all_btn.pack(side=tk.LEFT, padx=5)
            
            close_btn = tk.Button(buttons_frame, text="Close", command=find_dialog.destroy,
                                bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                activebackground=self.colors['selection'])
            close_btn.pack(side=tk.RIGHT, padx=5)
            
            # Key bindings pentru dialog
            find_dialog.bind('<Return>', lambda e: find_next())
            find_dialog.bind('<Escape>', lambda e: find_dialog.destroy())
            
            # Centrare dialog
            find_dialog.update_idletasks()
            width = find_dialog.winfo_width()
            height = find_dialog.winfo_height()
            x = (self.rootVSCODE.winfo_width() // 2) - (width // 2) + self.rootVSCODE.winfo_x()
            y = (self.rootVSCODE.winfo_height() // 2) - (height // 2) + self.rootVSCODE.winfo_y()
            find_dialog.geometry(f"{width}x{height}+{x}+{y}")
        
        def replace_text(self):
            editor = self.get_current_editor()
            if not editor:
                return
                
            # Verifică dacă există text selectat
            try:
                selected_text = editor.get(tk.SEL_FIRST, tk.SEL_LAST)
            except tk.TclError:
                selected_text = ""
            
            # Creează dialog de căutare și înlocuire
            replace_dialog = tk.Toplevel(self.rootVSCODE)
            replace_dialog.title("Replace")
            replace_dialog.geometry("400x200")
            replace_dialog.transient(self.rootVSCODE)
            replace_dialog.configure(bg=self.colors['bg'])
            replace_dialog.resizable(False, False)
            
            # Variabile pentru căutare
            search_var = tk.StringVar(value=selected_text)
            replace_var = tk.StringVar()
            case_sensitive = tk.BooleanVar(value=False)
            match_whole_word = tk.BooleanVar(value=False)
            use_regex = tk.BooleanVar(value=False)
            
            # Layout
            search_frame = tk.Frame(replace_dialog, bg=self.colors['bg'])
            search_frame.pack(fill=tk.X, padx=10, pady=(10, 5))
            
            tk.Label(search_frame, text="Find:", bg=self.colors['bg'], fg=self.colors['text']).pack(side=tk.LEFT, padx=(0, 5))
            search_entry = tk.Entry(search_frame, textvariable=search_var, bg=self.colors['editor_bg'],
                                   fg=self.colors['text'], insertbackground=self.colors['text'], width=30)
            search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
            search_entry.focus_set()
            
            replace_frame = tk.Frame(replace_dialog, bg=self.colors['bg'])
            replace_frame.pack(fill=tk.X, padx=10, pady=5)
            
            tk.Label(replace_frame, text="Replace:", bg=self.colors['bg'], fg=self.colors['text']).pack(side=tk.LEFT, padx=(0, 5))
            replace_entry = tk.Entry(replace_frame, textvariable=replace_var, bg=self.colors['editor_bg'],
                                    fg=self.colors['text'], insertbackground=self.colors['text'], width=30)
            replace_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            # Opțiuni de căutare
            options_frame = tk.Frame(replace_dialog, bg=self.colors['bg'])
            options_frame.pack(fill=tk.X, padx=10, pady=5)
            
            tk.Checkbutton(options_frame, text="Case sensitive", variable=case_sensitive,
                          bg=self.colors['bg'], fg=self.colors['text'], selectcolor=self.colors['editor_bg'],
                          activebackground=self.colors['bg'], activeforeground=self.colors['text']).pack(side=tk.LEFT, padx=5)
            
            tk.Checkbutton(options_frame, text="Match whole word", variable=match_whole_word,
                          bg=self.colors['bg'], fg=self.colors['text'], selectcolor=self.colors['editor_bg'],
                          activebackground=self.colors['bg'], activeforeground=self.colors['text']).pack(side=tk.LEFT, padx=5)
            
            tk.Checkbutton(options_frame, text="Use regex", variable=use_regex,
                          bg=self.colors['bg'], fg=self.colors['text'], selectcolor=self.colors['editor_bg'],
                          activebackground=self.colors['bg'], activeforeground=self.colors['text']).pack(side=tk.LEFT, padx=5)
            
            # Status
            status_var = tk.StringVar()
            status_label = tk.Label(replace_dialog, textvariable=status_var, bg=self.colors['bg'], fg=self.colors['text'])
            status_label.pack(fill=tk.X, padx=10, pady=5)
            
            # Butoane
            buttons_frame = tk.Frame(replace_dialog, bg=self.colors['bg'])
            buttons_frame.pack(fill=tk.X, padx=10, pady=10)
            
            def find_next():
                search_term = search_var.get()
                if not search_term:
                    status_var.set("Nothing to search for")
                    return False
                    
                # Șterge highlight-uri anterioare
                editor.tag_remove('search', '1.0', tk.END)
                
                # Obține poziția curentă a cursorului
                current_pos = editor.index(tk.INSERT)
                
                # Caută după poziția curentă
                if use_regex.get():
                    try:
                        pattern = re.compile(search_term, 0 if case_sensitive.get() else re.IGNORECASE)
                    except re.error:
                        status_var.set("Invalid regex pattern")
                        return False
                        
                    content = editor.get(current_pos, tk.END)
                    match = pattern.search(content)
                    
                    if match:
                        start_idx = editor.index(f"{current_pos}+{match.start()}c")
                        end_idx = editor.index(f"{current_pos}+{match.end()}c")
                        
                        # Verifică whole word dacă este necesar
                        if match_whole_word.get():
                            if (start_idx == "1.0" or not editor.get(f"{start_idx}-1c").isalnum()) and \
                               (end_idx == editor.index(tk.END) or not editor.get(f"{end_idx}").isalnum()):
                                found = True
                            else:
                                found = False
                                start_idx = editor.index(f"{end_idx}")
                        else:
                            found = True
                            
                        if found:
                            editor.tag_add('search', start_idx, end_idx)
                            editor.tag_configure('search', background='#555500', foreground='white')
                            editor.mark_set(tk.INSERT, end_idx)
                            editor.see(start_idx)
                            status_var.set(f"Found match at position {start_idx}")
                            return True
                            
                    # Nu s-a găsit nimic, începe de la început
                    content = editor.get("1.0", current_pos)
                    match = pattern.search(content)
                    
                    if match:
                        start_idx = editor.index(f"1.0+{match.start()}c")
                        end_idx = editor.index(f"1.0+{match.end()}c")
                        
                        # Verifică whole word dacă este necesar
                        if match_whole_word.get():
                            if (start_idx == "1.0" or not editor.get(f"{start_idx}-1c").isalnum()) and \
                               (end_idx == editor.index(tk.END) or not editor.get(f"{end_idx}").isalnum()):
                                found = True
                            else:
                                found = False
                        else:
                            found = True
                            
                        if found:
                            editor.tag_add('search', start_idx, end_idx)
                            editor.tag_configure('search', background='#555500', foreground='white')
                            editor.mark_set(tk.INSERT, end_idx)
                            editor.see(start_idx)
                            status_var.set(f"Found match at position {start_idx} (wrapped search)")
                            return True
                            
                    status_var.set("No matches found")
                    return False
                else:
                    # Căutare normală
                    search_flags = "nocase" if not case_sensitive.get() else ""
                    
                    if match_whole_word.get():
                        # Adaugă \y pentru a potrivi doar cuvinte întregi
                        search_term = f"\\y{search_term}\\y"
                        
                    found_pos = editor.search(search_term, current_pos, tk.END, regexp=match_whole_word.get(), nocase=not case_sensitive.get())
                    
                    if found_pos:
                        # Calculează poziția de sfârșit
                        if match_whole_word.get() or use_regex.get():
                            # Pentru regex trebuie să determinăm lungimea potrivirii
                            match_length = len(re.search(search_term, editor.get(found_pos, tk.END)).group(0))
                        else:
                            match_length = len(search_term)
                            
                        end_pos = f"{found_pos}+{match_length}c"
                        
                        # Highlight și setează cursor
                        editor.tag_add('search', found_pos, end_pos)
                        editor.tag_configure('search', background='#555500', foreground='white')
                        editor.mark_set(tk.INSERT, end_pos)
                        editor.see(found_pos)
                        status_var.set(f"Found match at position {found_pos}")
                        return True
                    else:
                        # Încearcă de la început
                        found_pos = editor.search(search_term, "1.0", current_pos, regexp=match_whole_word.get(), nocase=not case_sensitive.get())
                        
                        if found_pos:
                            # Calculează poziția de sfârșit
                            if match_whole_word.get() or use_regex.get():
                                # Pentru regex trebuie să determinăm lungimea potrivirii
                                match_length = len(re.search(search_term, editor.get(found_pos, tk.END)).group(0))
                            else:
                                match_length = len(search_term)
                                
                            end_pos = f"{found_pos}+{match_length}c"
                            
                            # Highlight și setează cursor
                            editor.tag_add('search', found_pos, end_pos)
                            editor.tag_configure('search', background='#555500', foreground='white')
                            editor.mark_set(tk.INSERT, end_pos)
                            editor.see(found_pos)
                            status_var.set(f"Found match at position {found_pos} (wrapped search)")
                            return True
                        else:
                            status_var.set("No matches found")
                            return False
            
            def replace():
                # Înlocuiește textul selectat curent
                try:
                    # Verifică dacă există o selecție activă (de la căutarea anterioară)
                    if editor.tag_ranges('search'):
                        start = editor.tag_ranges('search')[0]
                        end = editor.tag_ranges('search')[1]
                        
                        # Înlocuiește textul
                        editor.delete(start, end)
                        editor.insert(start, replace_var.get())
                        
                        # Șterge highlight
                        editor.tag_remove('search', '1.0', tk.END)
                        
                        # Găsește următoarea potrivire
                        find_next()
                        
                        status_var.set(f"Replaced text at {start}")
                    else:
                        # Dacă nu există o selecție activă, caută prima potrivire
                        if find_next():
                            # Apelează din nou replace pentru a înlocui ce tocmai a fost găsit
                            replace()
                except tk.TclError:
                    status_var.set("No text is currently selected")
            
            def replace_all():
                search_term = search_var.get()
                replace_text = replace_var.get()
                
                if not search_term:
                    status_var.set("Nothing to search for")
                    return
                    
                # Șterge highlight-uri anterioare
                editor.tag_remove('search', '1.0', tk.END)
                
                # Contorizare
                count = 0
                
                # Dezactivează undo temporar pentru a grupa toate înlocuirile ca o singură acțiune
                editor.config(autoseparators=False)
                editor.edit_separator()
                
                if use_regex.get():
                    try:
                        pattern = re.compile(search_term, 0 if case_sensitive.get() else re.IGNORECASE)
                    except re.error:
                        status_var.set("Invalid regex pattern")
                        return
                        
                    content = editor.get("1.0", tk.END)
                    
                    # Dacă este regex, folosește o abordare diferită pentru înlocuire
                    if match_whole_word.get():
                        # Cod pentru regex cu match whole word
                        new_content = ""
                        last_end = 0
                        
                        for match in pattern.finditer(content):
                            start, end = match.span()
                            
                            # Verifică dacă e un cuvânt întreg
                            is_word_boundary_start = start == 0 or not content[start-1].isalnum()
                            is_word_boundary_end = end == len(content) or not content[end].isalnum()
                            
                            if is_word_boundary_start and is_word_boundary_end:
                                new_content += content[last_end:start] + replace_text
                                last_end = end
                                count += 1
                        
                        new_content += content[last_end:]
                        
                        # Actualizează conținut
                        editor.delete("1.0", tk.END)
                        editor.insert("1.0", new_content)
                    else:
                        # Regex normal fără constrângere de cuvânt întreg
                        new_content = pattern.sub(replace_text, content)
                        
                        # Calculează numărul de înlocuiri
                        count = len(re.findall(pattern, content))
                        
                        # Actualizează conținut
                        editor.delete("1.0", tk.END)
                        editor.insert("1.0", new_content)
                else:
                    # Înlocuire normală
                    start_pos = "1.0"
                    
                    while True:
                        if match_whole_word.get():
                            # Adaugă \y pentru a potrivi doar cuvinte întregi
                            pattern = f"\\y{search_term}\\y"
                            found_pos = editor.search(pattern, start_pos, tk.END, regexp=True, nocase=not case_sensitive.get())
                        else:
                            found_pos = editor.search(search_term, start_pos, tk.END, nocase=not case_sensitive.get())
                        
                        if not found_pos:
                            break
                            
                        # Calculează poziția de sfârșit
                        if match_whole_word.get():
                            # Pentru regex trebuie să determinăm lungimea potrivirii
                            match_length = len(re.search(pattern, editor.get(found_pos, tk.END)).group(0))
                        else:
                            match_length = len(search_term)
                            
                        end_pos = f"{found_pos}+{match_length}c"
                        
                        # Înlocuiește text
                        editor.delete(found_pos, end_pos)
                        editor.insert(found_pos, replace_text)
                        count += 1
                        
                        # Actualizează poziția de început pentru următoarea căutare
                        start_pos = f"{found_pos}+{len(replace_text)}c"
                
                # Reactivează undo
                editor.edit_separator()
                editor.config(autoseparators=True)
                
                # Actualizează status
                if count == 0:
                    status_var.set("No matches found")
                else:
                    status_var.set(f"Replaced {count} occurrences")
                    
                # Revalidează highlight syntax după înlocuiri
                self.highlight_syntax(editor)
            
            # Butoane pentru acțiuni
            find_next_btn = tk.Button(buttons_frame, text="Find Next", command=find_next,
                                     bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                     activebackground=self.colors['selection'])
            find_next_btn.pack(side=tk.LEFT, padx=5)
            
            replace_btn = tk.Button(buttons_frame, text="Replace", command=replace,
                                  bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                  activebackground=self.colors['selection'])
            replace_btn.pack(side=tk.LEFT, padx=5)
            
            replace_all_btn = tk.Button(buttons_frame, text="Replace All", command=replace_all,
                                       bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                       activebackground=self.colors['selection'])
            replace_all_btn.pack(side=tk.LEFT, padx=5)
            
            close_btn = tk.Button(buttons_frame, text="Close", command=replace_dialog.destroy,
                                bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                                activebackground=self.colors['selection'])
            close_btn.pack(side=tk.RIGHT, padx=5)
            
            # Key bindings pentru dialog
            replace_dialog.bind('<Return>', lambda e: find_next())
            replace_dialog.bind('<Escape>', lambda e: replace_dialog.destroy())
            
            # Centrare dialog
            replace_dialog.update_idletasks()
            width = replace_dialog.winfo_width()
            height = replace_dialog.winfo_height()
            x = (self.rootVSCODE.winfo_width() // 2) - (width // 2) + self.rootVSCODE.winfo_x()
            y = (self.rootVSCODE.winfo_height() // 2) - (height // 2) + self.rootVSCODE.winfo_y()
            replace_dialog.geometry(f"{width}x{height}+{x}+{y}")
        
        def toggle_explorer(self):
            if self.explorer_visible:
                self.sidebar_container.pack_forget()
                self.explorer_visible = False
            else:
                self.sidebar_container.pack(side=tk.LEFT, fill=tk.Y)
                self.explorer_visible = True
        
        def toggle_terminal(self):
            if self.terminal_visible:
                # Dacă închidem terminalul și există un proces rulând, oferă opțiunea de a-l opri
                if self.process is not None and self.process.poll() is None:
                    response = messagebox.askyesno("Process Running", 
                                                 "There is a process running in the terminal. Stop it?")
                    if response:
                        self.cleanup_terminal_process()
                
                self.editor_terminal_paned.forget(self.terminal_frame)
                self.terminal_visible = False
            else:
                self.editor_terminal_paned.add(self.terminal_frame, weight=1)
                self.terminal_visible = True
                
                # Actualizează separatorul
                self.editor_terminal_paned.update_idletasks()
                total_height = self.editor_terminal_paned.winfo_height()
                self.editor_terminal_paned.sashpos(0, int(total_height * 0.7))
                
        def get_current_editor(self):
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return None
            return self.files_opened[self.current_tab_index]['editor']
        
        def get_current_line_numbers(self):
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return None
            return self.files_opened[self.current_tab_index]['line_numbers']
        
        def collect_words_from_file(self, content):
            # Colectează toate cuvintele unice pentru autocompletare
            words = re.findall(r'\b\w+\b', content)
            self.autocomplete_words.update(words)
            
            # Adaugă funcții și clase
            for match in re.finditer(r'def\s+(\w+)', content):
                self.autocomplete_words.add(match.group(1))
            
            for match in re.finditer(r'class\s+(\w+)', content):
                self.autocomplete_words.add(match.group(1))
        
        def show_autocomplete(self, event, editor):
            # Verifică dacă s-a tastat "."
            cursor_pos = editor.index(tk.INSERT)
            line, column = map(int, cursor_pos.split('.'))
            
            # Obține cuvântul înainte de "."
            line_content = editor.get(f"{line}.0", f"{line}.{column}")
            match = re.search(r'(\w+)\.', line_content)
            
            if match:
                obj_name = match.group(1)
                # Aici ar trebui să determinăm membrii obiectului, pentru simplitate
                # vom oferi câteva metode comune pentru tipurile de bază Python
                
                if obj_name in ['str', 'list', 'dict', 'set', 'int', 'float']:
                    methods = self.get_type_methods(obj_name)
                else:
                    # Pentru alte obiecte, oferă sugestii generale
                    methods = ['__init__', '__str__', '__repr__', 'append', 'extend', 'insert', 'remove',
                             'pop', 'clear', 'index', 'count', 'sort', 'reverse', 'copy', 'keys', 
                             'values', 'items', 'get', 'update', 'add', 'lower', 'upper', 'strip', 
                             'split', 'join', 'replace', 'find', 'format']
                
                # Creează lista de sugestii
                self.show_completion_window(editor, methods)
        
        def get_type_methods(self, obj_type):
            # Dicționar cu metode comune pentru tipurile de bază Python
            type_methods = {
                'str': ['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs',
                       'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii',
                       'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable',
                       'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans',
                       'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit',
                       'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title',
                       'translate', 'upper', 'zfill'],
                'list': ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',
                        'reverse', 'sort'],
                'dict': ['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem',
                        'setdefault', 'update', 'values'],
                'set': ['add', 'clear', 'copy', 'difference', 'difference_update', 'discard',
                       'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset',
                       'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union',
                       'update'],
                'int': ['as_integer_ratio', 'bit_length', 'conjugate', 'from_bytes', 'to_bytes'],
                'float': ['as_integer_ratio', 'conjugate', 'fromhex', 'hex', 'is_integer']
            }
            
            return type_methods.get(obj_type, [])
        
        def show_completion_window(self, editor, suggestions):
            # Obține poziția cursor
            cursor_pos = editor.index(tk.INSERT)
            x, y, width, height = editor.bbox(cursor_pos)
            
            # Coordonate absolute
            x += editor.winfo_rootVSCODEx()
            y += editor.winfo_rootVSCODEy() + height
            
            # Creează fereastra de completare
            completion_window = tk.Toplevel(self.rootVSCODE)
            completion_window.wm_overrideredirect(True)
            completion_window.wm_geometry(f"+{x}+{y}")
            completion_window.configure(bg=self.colors['bg'])
            
            # Creează un frame pentru conținut
            frame = tk.Frame(completion_window, bg=self.colors['bg'], bd=1, relief=tk.SOLID)
            frame.pack(fill=tk.BOTH, expand=True)
            
            # Listbox pentru sugestii
            listbox = tk.Listbox(frame, bg=self.colors['editor_bg'], fg=self.colors['text'],
                                font=('Consolas', 10), height=min(10, len(suggestions)),
                                selectbackground=self.colors['selection'], bd=0)
            listbox.pack(fill=tk.BOTH, expand=True)
            
            # Adaugă sugestiile sortate alfabetic
            for item in sorted(suggestions):
                listbox.insert(tk.END, item)
            
            # Selectează primul item
            if listbox.size() > 0:
                listbox.selection_set(0)
                listbox.activate(0)
            
            # Funcție pentru a insera textul selectat
            def insert_selection(event=None):
                if listbox.curselection():
                    selected_item = listbox.get(listbox.curselection())
                    editor.insert(tk.INSERT, selected_item)
                    completion_window.destroy()
                    return "break"  # Previne procesarea ulterioară a evenimentului
            
            # Funcție pentru a naviga prin listă
            def navigate(event):
                selection = listbox.curselection()
                if selection:
                    index = selection[0]
                    if event.keysym == 'Up' and index > 0:
                        listbox.selection_clear(0, tk.END)
                        listbox.selection_set(index - 1)
                        listbox.activate(index - 1)
                        listbox.see(index - 1)
                    elif event.keysym == 'Down' and index < listbox.size() - 1:
                        listbox.selection_clear(0, tk.END)
                        listbox.selection_set(index + 1)
                        listbox.activate(index + 1)
                        listbox.see(index + 1)
                return "break"  # Previne procesarea ulterioară a evenimentului
            
            # Binding-uri pentru taste
            listbox.bind('<Return>', insert_selection)
            listbox.bind('<Double-Button-1>', insert_selection)
            listbox.bind('<Escape>', lambda e: completion_window.destroy())
            listbox.bind('<Up>', navigate)
            listbox.bind('<Down>', navigate)
            
            # Binding pentru a închide fereastra când se pierde focus-ul
            def on_focus_out(event):
                completion_window.destroy()
            
            completion_window.bind('<FocusOut>', on_focus_out)
            
            # Focus pe listbox
            listbox.focus_set()
        
        def comment_line(self):
            editor = self.get_current_editor()
            if not editor:
                return
                
            # Verifică dacă există selecție
            try:
                start_line = int(editor.index(tk.SEL_FIRST).split('.')[0])
                end_line = int(editor.index(tk.SEL_LAST).split('.')[0])
                has_selection = True
            except tk.TclError:
                # Nu există selecție, folosește linia curentă
                cursor_pos = editor.index(tk.INSERT)
                start_line = end_line = int(cursor_pos.split('.')[0])
                has_selection = False
            
            # Verifică dacă liniile sunt deja comentate
            all_commented = True
            for line in range(start_line, end_line + 1):
                line_content = editor.get(f"{line}.0", f"{line}.end")
                if line_content.strip() and not line_content.lstrip().startswith('#'):
                    all_commented = False
                    break
            
            # Comentează sau decomentează liniile
            for line in range(start_line, end_line + 1):
                line_content = editor.get(f"{line}.0", f"{line}.end")
                if not line_content.strip():
                    continue  # Sari liniile goale
                    
                if all_commented:
                    # Decomentează
                    if line_content.lstrip().startswith('#'):
                        # Găsește poziția primului #
                        hash_pos = line_content.find('#')
                        # Verifică dacă este urmat de un spațiu
                        if hash_pos + 1 < len(line_content) and line_content[hash_pos + 1] == ' ':
                            editor.delete(f"{line}.{hash_pos}", f"{line}.{hash_pos + 2}")
                        else:
                            editor.delete(f"{line}.{hash_pos}", f"{line}.{hash_pos + 1}")
                else:
                    # Comentează
                    indent = len(line_content) - len(line_content.lstrip())
                    editor.insert(f"{line}.{indent}", "# ")
            
            # Actualizează highlight
            self.highlight_syntax(editor)
        
        def indent(self):
            editor = self.get_current_editor()
            if not editor:
                return
                
            # Verifică dacă există selecție
            try:
                start_line = int(editor.index(tk.SEL_FIRST).split('.')[0])
                end_line = int(editor.index(tk.SEL_LAST).split('.')[0])
                has_selection = True
            except tk.TclError:
                # Nu există selecție, folosește linia curentă
                cursor_pos = editor.index(tk.INSERT)
                start_line = end_line = int(cursor_pos.split('.')[0])
                has_selection = False
            
            # Adaugă indentare la fiecare linie
            editor.config(autoseparators=False)
            editor.edit_separator()
            
            for line in range(start_line, end_line + 1):
                editor.insert(f"{line}.0", "    ")
            
            editor.edit_separator()
            editor.config(autoseparators=True)
            
            # Actualizează highlight
            self.highlight_syntax(editor)
        
        def dedent(self):
            editor = self.get_current_editor()
            if not editor:
                return
                
            # Verifică dacă există selecție
            try:
                start_line = int(editor.index(tk.SEL_FIRST).split('.')[0])
                end_line = int(editor.index(tk.SEL_LAST).split('.')[0])
                has_selection = True
            except tk.TclError:
                # Nu există selecție, folosește linia curentă
                cursor_pos = editor.index(tk.INSERT)
                start_line = end_line = int(cursor_pos.split('.')[0])
                has_selection = False
            
            # Dedentează fiecare linie
            editor.config(autoseparators=False)
            editor.edit_separator()
            
            for line in range(start_line, end_line + 1):
                line_content = editor.get(f"{line}.0", f"{line}.end")
                
                # Verifică dacă există cel puțin 4 spații (sau 1 tab) la începutul liniei
                if line_content.startswith('    '):
                    editor.delete(f"{line}.0", f"{line}.4")
                elif line_content.startswith('\t'):
                    editor.delete(f"{line}.0", f"{line}.1")
                elif line_content.startswith(' '):
                    # Dedentează cu numărul de spații disponibile (maxim 4)
                    spaces = len(line_content) - len(line_content.lstrip(' '))
                    if spaces > 0:
                        editor.delete(f"{line}.0", f"{line}.{min(spaces, 4)}")
            
            editor.edit_separator()
            editor.config(autoseparators=True)
            
            # Actualizează highlight
            self.highlight_syntax(editor)
        
        def handle_tab(self, event, editor):
            try:
                # Verifică dacă există o selecție
                sel_start = editor.index(tk.SEL_FIRST)
                sel_end = editor.index(tk.SEL_LAST)
                
                # Există selecție, aplică indentare pe mai multe linii
                start_line = int(sel_start.split('.')[0])
                end_line = int(sel_end.split('.')[0])
                
                # Verifică dacă selecția se întinde pe mai multe linii
                if start_line != end_line:
                    self.indent()
                    return "break"
            except tk.TclError:
                # Nu există selecție, folosește comportamentul normal (inserează un tab/spații)
                editor.insert(tk.INSERT, "    ")
                return "break"
        
        def auto_close_bracket(self, event, editor, opening, closing):
            # Adaugă automat închiderea parantezei, ghilimelei etc.
            editor.insert(tk.INSERT, closing)
            editor.mark_set(tk.INSERT, "insert-1c")  # Mută cursorul înapoi cu o poziție
            return "break"
        
        def auto_indent_after_colon(self, event, editor):
            # Auto-indentare după ":" în Python
            cursor_pos = editor.index(tk.INSERT)
            line, col = cursor_pos.split('.')
            
            # Verifică dacă ":" este la sfârșitul unei linii care conține cuvinte cheie Python
            line_content = editor.get(f"{line}.0", f"{line}.{col}")
            
            # Verifică dacă linia conține un keyword care ar trebui să ducă la indentare
            contains_indent_keyword = any(kw in line_content for kw in 
                                         ['if ', 'else:', 'elif ', 'for ', 'while ', 'def ', 'class ', 'try:', 'except ', 'finally:'])
            
            if contains_indent_keyword and line_content.rstrip().endswith(':'):
                # Verifică dacă cursorul este la sfârșitul liniei
                is_end_of_line = editor.get(cursor_pos, f"{line}.end").strip() == ""
                
                if is_end_of_line:
                    # Adaugă o nouă linie indentată automat
                    current_indent = len(line_content) - len(line_content.lstrip())
                    new_indent = current_indent + 4
                    editor.insert(cursor_pos, f"\n{' ' * new_indent}")
                    return "break"
        
        def auto_indent(self, event, editor):
            # Auto-indentare după Enter
            cursor_pos = editor.index(tk.INSERT)
            line, col = cursor_pos.split('.')
            prev_line = int(line) - 1
            
            if prev_line > 0:
                # Obține indentarea liniei anterioare
                prev_line_content = editor.get(f"{prev_line}.0", f"{prev_line}.end")
                indent = len(prev_line_content) - len(prev_line_content.lstrip())
                
                # Verifică dacă linia anterioară se termină cu ":"
                if prev_line_content.rstrip().endswith(':'):
                    # Adaugă indentare suplimentară pentru blocuri noi
                    indent += 4
                
                # Adaugă indentarea
                editor.insert(cursor_pos, ' ' * indent)
        
        def zoom_in(self):
            # Mărire font
            editor = self.get_current_editor()
            if not editor:
                return
                
            font_obj = font.Font(font=editor['font'])
            current_size = font_obj.actual('size')
            
            if current_size < 36:  # Limită superioară pentru font
                new_size = current_size + 1
                new_font = (font_obj.actual('family'), new_size)
                
                # Actualizează font pentru toți editorii
                for file_info in self.files_opened:
                    file_info['editor'].configure(font=new_font)
                    file_info['line_numbers'].configure(font=new_font)
        
        def zoom_out(self):
            # Micșorare font
            editor = self.get_current_editor()
            if not editor:
                return
                
            font_obj = font.Font(font=editor['font'])
            current_size = font_obj.actual('size')
            
            if current_size > 6:  # Limită inferioară pentru font
                new_size = current_size - 1
                new_font = (font_obj.actual('family'), new_size)
                
                # Actualizează font pentru toți editorii
                for file_info in self.files_opened:
                    file_info['editor'].configure(font=new_font)
                    file_info['line_numbers'].configure(font=new_font)
        
        '''
        def run_python_file(self):
            # Rulează fișierul Python curent
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return
                
            current_file = self.files_opened[self.current_tab_index]
            
            # Dacă fișierul nu a fost salvat, încearcă să-l salvezi mai întâi
            if current_file['modified'] or not current_file['path']:
                if not current_file['path']:
                    # Solicită salvarea fișierului
                    file_path = filedialog.asksaveasfilename(
                        defaultextension=".py",
                        filetypes=[("Python files", "*.py"), ("All files", "*.*")]
                    )
                    if not file_path:
                        messagebox.showwarning("Run Error", "Cannot run unsaved file. Please save the file first.")
                        return
                    
                    self.save_to_file(file_path)
                    current_file['path'] = file_path
                    current_file['title'] = os.path.basename(file_path)
                    current_file['modified'] = False
                    self.notebook.tab(self.current_tab_index, text=current_file['title'])
                else:
                    # Salvează fișierul existent
                    self.save_file()
            
            # Asigură-te că terminalul este vizibil
            if not self.terminal_visible:
                self.toggle_terminal()
            
            # Oprește orice proces anterior
            self.cleanup_terminal_process()
            
            # Curăță terminalul
            self.terminal_output.config(state=tk.NORMAL)
            self.terminal_output.delete('1.0', tk.END)
            self.terminal_output.insert(tk.END, f"Running {os.path.basename(current_file['path'])}...\n")
            self.terminal_output.insert(tk.END, "=" * 50 + "\n\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.config(state=tk.DISABLED)
            
            # Activează input field-ul
            self.terminal_input.config(state=tk.NORMAL)
            
            # Determină comanda Python
            python_cmd = "python" if platform.system() == "Windows" else "python3"
            
            try:
                # Creează procesul ca un cmd pe Windows sau un terminal pe Unix
                if platform.system() == "Windows":
                    # Folosește cmd.exe pentru a rula Python interactiv
                    cmd = f'cmd.exe /c {python_cmd} "{current_file["path"]}"'
                    
                    # Folosește STARTUPINFO pentru a ascunde fereastra cmd
                    startupinfo = subprocess.STARTUPINFO()
                    startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                    
                    # Creează procesul cu toate fluxurile conectate și fără buffering
                    self.process = subprocess.Popen(
                        cmd,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE, 
                        stderr=subprocess.PIPE,
                        shell=True,
                        universal_newlines=True,
                        startupinfo=startupinfo,
                        bufsize=0,
                        encoding='utf-8',
                        errors='replace',
                        env=dict(os.environ, PYTHONIOENCODING='utf-8', PYTHONUNBUFFERED='1')
                    )
                else:
                    # Pe Unix, folosim direct comanda Python
                    self.process = subprocess.Popen(
                        [python_cmd, current_file['path']],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        universal_newlines=True,
                        bufsize=0,
                        encoding='utf-8',
                        errors='replace',
                        env=dict(os.environ, PYTHONIOENCODING='utf-8', PYTHONUNBUFFERED='1')
                    )
                
                # Thread pentru a citi stdout
                def read_stdout():
                    while self.process and self.process.poll() is None:
                        try:
                            # Citim un singur caracter pentru a evita blocarea
                            char = self.process.stdout.read(1)
                            if char:
                                self.terminal_output.config(state=tk.NORMAL)
                                self.terminal_output.insert(tk.END, char)
                                self.terminal_output.see(tk.END)
                                self.terminal_output.config(state=tk.DISABLED)
                                self.rootVSCODE.update_idletasks()
                        except (IOError, OSError):
                            break
                        except Exception as e:
                            print(f"Stdout error: {e}")
                            break
                
                # Thread pentru a citi stderr
                def read_stderr():
                    while self.process and self.process.poll() is None:
                        try:
                            # Citim un singur caracter pentru a evita blocarea
                            char = self.process.stderr.read(1)
                            if char:
                                self.terminal_output.config(state=tk.NORMAL)
                                self.terminal_output.insert(tk.END, char, "error")
                                self.terminal_output.see(tk.END)
                                self.terminal_output.config(state=tk.DISABLED)
                                self.rootVSCODE.update_idletasks()
                        except (IOError, OSError):
                            break
                        except Exception as e:
                            print(f"Stderr error: {e}")
                            break
                
                # Thread pentru a monitoriza terminarea procesului
                def monitor_process():
                    if self.process:
                        return_code = self.process.wait()
                        
                        # Dacă thread-urile au fost oprite, nu mai continua
                        if self.stop_threads.is_set():
                            return
                        
                        self.terminal_output.config(state=tk.NORMAL)
                        self.terminal_output.insert(tk.END, f"\n\n{'='*50}\n")
                        self.terminal_output.insert(tk.END, f"[Process completed with exit code {return_code}]")
                        if return_code == 0:
                            self.terminal_output.insert(tk.END, "\n[Program finished successfully]")
                        else:
                            self.terminal_output.insert(tk.END, f"\n[Program finished with errors]", "error")
                            
                        self.terminal_output.insert(tk.END, "\n[Terminal input disabled. Run another program to continue.]\n")
                        self.terminal_output.see(tk.END)
                        self.terminal_output.config(state=tk.DISABLED)
                        
                        # Dezactivează input field-ul
                        self.terminal_input.config(state=tk.DISABLED)
                        
                        # Actualizează statusbar
                        self.status_bar_left.config(text="Ready")
                
                # Pornește thread-urile
                stdout_thread = threading.Thread(target=read_stdout, daemon=True)
                stderr_thread = threading.Thread(target=read_stderr, daemon=True)
                monitor_thread = threading.Thread(target=monitor_process, daemon=True)
                
                stdout_thread.start()
                stderr_thread.start()
                monitor_thread.start()
                
                self.terminal_threads = [stdout_thread, stderr_thread, monitor_thread]
                
                # Focalizează pe input
                self.terminal_input.focus_set()
                
            except Exception as e:
                self.terminal_output.config(state=tk.NORMAL)
                self.terminal_output.insert(tk.END, f"Error running program: {str(e)}\n", "error")
                self.terminal_output.see(tk.END)
                self.terminal_output.config(state=tk.DISABLED)
            
            # Actualizează statusbar
            self.status_bar_left.config(text=f"Running: {os.path.basename(current_file['path'])}")
        '''
        
        def run_python_file(self):
            # Rulează fișierul Python curent
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return
                
            current_file = self.files_opened[self.current_tab_index]
            
            # Dacă fișierul nu a fost salvat, încearcă să-l salvezi mai întâi
            if current_file['modified'] or not current_file['path']:
                if not current_file['path']:
                    # Solicită salvarea fișierului
                    file_path = filedialog.asksaveasfilename(
                        defaultextension=".py",
                        filetypes=[("Python files", "*.py"), ("All files", "*.*")]
                    )
                    if not file_path:
                        messagebox.showwarning("Run Error", "Cannot run unsaved file. Please save the file first.")
                        return
                    
                    self.save_to_file(file_path)
                    current_file['path'] = file_path
                    current_file['title'] = os.path.basename(file_path)
                    current_file['modified'] = False
                    self.notebook.tab(self.current_tab_index, text=current_file['title'])
                else:
                    # Salvează fișierul existent
                    self.save_file()
            
            # Asigură-te că terminalul este vizibil
            if not self.terminal_visible:
                self.toggle_terminal()
            
            # Oprește orice proces anterior
            self.cleanup_terminal_process()
            
            # Curăță terminalul
            self.terminal_output.config(state=tk.NORMAL)
            self.terminal_output.delete('1.0', tk.END)
            self.terminal_output.insert(tk.END, f"Running {os.path.basename(current_file['path'])}...\n")
            self.terminal_output.insert(tk.END, f"Type input in the field below whenever the program waits for input.\n")
            self.terminal_output.insert(tk.END, "=" * 50 + "\n\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.config(state=tk.DISABLED)
            
            # Activează input field-ul
            self.terminal_input.config(state=tk.NORMAL)
            self.terminal_input.focus_set()
            
            # Resetează starea
            self.awaiting_input = False
            
            try:
                # Determină comanda Python corectă utilizând executabilul Python actual
                python_cmd = sys.executable
                
                # Setăm variabile de mediu pentru a asigura comportamentul corect Python
                env_vars = dict(os.environ)
                env_vars['PYTHONIOENCODING'] = 'utf-8'
                env_vars['PYTHONUNBUFFERED'] = '1'
                env_vars['PYTHONLEGACYWINDOWSSTDIO'] = '1'  # Important pentru Windows
                
                # Creează procesul cu configurare optimizată
                if platform.system() == "Windows":
                    # Pe Windows, folosim CREATE_NEW_PROCESS_GROUP pentru control mai bun
                    self.process = subprocess.Popen(
                        [python_cmd, current_file['path']],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        universal_newlines=True,
                        bufsize=0,  # Fără buffering
                        encoding='utf-8',
                        errors='replace',
                        env=env_vars,
                        creationflags=subprocess.CREATE_NEW_PROCESS_GROUP
                    )
                else:
                    # Pe Unix/Linux/Mac
                    self.process = subprocess.Popen(
                        [python_cmd, current_file['path']],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        universal_newlines=True,
                        bufsize=0,  # Fără buffering
                        encoding='utf-8',
                        errors='replace',
                        env=env_vars
                    )
                
                # Thread pentru a citi stdout - versiune îmbunătățită
                def read_stdout():
                    buffer = ""
                    while self.process and self.process.poll() is None and not self.stop_threads.is_set():
                        try:
                            # Citim în bucăți mai mari pentru eficiență
                            chunk = self.process.stdout.read(256)
                            if chunk:
                                # Actualizăm terminalul imediat
                                self.rootVSCODE.after_idle(lambda text=chunk: self.update_terminal_text(text, "normal"))
                                
                                # Verificăm pentru prompt-uri de input
                                buffer += chunk
                                # Păstrăm doar ultimele 200 de caractere în buffer
                                if len(buffer) > 200:
                                    buffer = buffer[-200:]
                                
                                # Detectează prompt-uri de input mai eficient
                                lines = buffer.split('\n')
                                last_line = lines[-1].strip() if lines else ""
                                
                                # Verifică pentru indicatori comuni de input
                                input_indicators = [':', '?', '>>>', 'Enter', 'input', 'Input', 'Press']
                                if any(indicator in last_line for indicator in input_indicators):
                                    self.rootVSCODE.after_idle(self.enable_input)
                            else:
                                # Mică pauză dacă nu avem date
                                time.sleep(0.01)
                        except (IOError, OSError, ValueError):
                            break
                        except Exception as e:
                            print(f"Stdout error: {e}")
                            break
                
                # Thread pentru a citi stderr - versiune îmbunătățită
                def read_stderr():
                    while self.process and self.process.poll() is None and not self.stop_threads.is_set():
                        try:
                            # Citim în bucăți mai mari pentru eficiență
                            chunk = self.process.stderr.read(256)
                            if chunk:
                                # Actualizăm terminalul imediat cu tag de eroare
                                self.rootVSCODE.after_idle(lambda text=chunk: self.update_terminal_text(text, "error"))
                            else:
                                # Mică pauză dacă nu avem date
                                time.sleep(0.01)
                        except (IOError, OSError, ValueError):
                            break
                        except Exception as e:
                            print(f"Stderr error: {e}")
                            break
                
                # Thread pentru a monitoriza terminarea procesului
                def monitor_process():
                    if self.process:
                        return_code = self.process.wait()
                        
                        # Dacă thread-urile au fost oprite, nu mai continua
                        if self.stop_threads.is_set():
                            return
                        
                        # Așteaptă puțin pentru a se asigura că tot output-ul a fost procesat
                        time.sleep(0.1)
                        
                        # Citește orice output rămas
                        try:
                            remaining_stdout, remaining_stderr = self.process.communicate(timeout=0.5)
                            if remaining_stdout:
                                self.rootVSCODE.after_idle(lambda text=remaining_stdout: self.update_terminal_text(text, "normal"))
                            if remaining_stderr:
                                self.rootVSCODE.after_idle(lambda text=remaining_stderr: self.update_terminal_text(text, "error"))
                        except:
                            pass
                        
                        # Afișează mesajul de finalizare folosind after_idle
                        def show_completion():
                            self.terminal_output.config(state=tk.NORMAL)
                            self.terminal_output.insert(tk.END, f"\n\n{'='*50}\n")
                            self.terminal_output.insert(tk.END, f"[Process completed with exit code {return_code}]")
                            if return_code == 0:
                                self.terminal_output.insert(tk.END, "\n[Program finished successfully]")
                            else:
                                self.terminal_output.insert(tk.END, f"\n[Program finished with errors]", "error")
                                
                            self.terminal_output.insert(tk.END, "\n[Terminal input disabled. Run another program to continue.]\n")
                            self.terminal_output.see(tk.END)
                            self.terminal_output.config(state=tk.DISABLED)
                            
                            # Dezactivează input field-ul
                            self.terminal_input.config(state=tk.DISABLED)
                            
                            # Actualizează statusbar
                            self.status_bar_left.config(text="Ready")
                            
                            # Resetează starea procesului
                            self.process = None
                            self.awaiting_input = False
                        
                        self.rootVSCODE.after_idle(show_completion)
                
                # Pornește thread-urile
                stdout_thread = threading.Thread(target=read_stdout, daemon=True)
                stderr_thread = threading.Thread(target=read_stderr, daemon=True)
                monitor_thread = threading.Thread(target=monitor_process, daemon=True)
                
                stdout_thread.start()
                stderr_thread.start()
                monitor_thread.start()
                
                self.terminal_threads = [stdout_thread, stderr_thread, monitor_thread]
                
            except Exception as e:
                self.terminal_output.config(state=tk.NORMAL)
                self.terminal_output.insert(tk.END, f"Error running program: {str(e)}\n", "error")
                self.terminal_output.see(tk.END)
                self.terminal_output.config(state=tk.DISABLED)
            
            # Actualizează statusbar
            self.status_bar_left.config(text=f"Running: {os.path.basename(current_file['path'])}")

        
        def update_terminal_text(self, text, tag_type="normal"):
            """Actualizează terminalul cu text nou într-un mod thread-safe"""
            try:
                self.terminal_output.config(state=tk.NORMAL)
                if tag_type == "error":
                    self.terminal_output.insert(tk.END, text, "error")
                else:
                    self.terminal_output.insert(tk.END, text)
                self.terminal_output.see(tk.END)
                self.terminal_output.config(state=tk.DISABLED)
                self.rootVSCODE.update_idletasks()
            except Exception as e:
                print(f"Error updating terminal: {e}")

        def enable_input(self):
            """Activează input-ul în terminal într-un mod thread-safe"""
            try:
                if not self.awaiting_input:
                    self.awaiting_input = True
                    self.terminal_input.focus_set()
            except Exception as e:
                print(f"Error enabling input: {e}")

        def cleanup_terminal_process(self):
            """Oprește procesul curent și thread-urile asociate"""
            # Semnalează thread-urilor să se oprească
            self.stop_threads.set()
            
            # Oprește procesul
            if self.process is not None:
                try:
                    # Închide stdin înainte de a termina procesul pentru a evita erori EOF
                    if hasattr(self.process, 'stdin') and self.process.stdin:
                        try:
                            self.process.stdin.close()
                        except:
                            pass
                        
                    # Încearcă să termine procesul normal
                    self.process.terminate()
                    
                    # Așteaptă puțin pentru terminare normală
                    for _ in range(10):  # Încearcă de 10 ori cu un mic delay
                        if self.process.poll() is not None:
                            break  # Procesul s-a terminat
                        time.sleep(0.1)
                        
                    # Dacă procesul încă rulează, forțează închiderea
                    if self.process.poll() is None:
                        self.process.kill()
                        time.sleep(0.1)  # Mică pauză după kill
                except:
                    pass
                finally:
                    self.process = None
            
            # Așteaptă oprirea thread-urilor cu timeout mai mare
            for thread in self.terminal_threads:
                if thread.is_alive():
                    thread.join(timeout=1.0)
            
            # Curăță lista de thread-uri
            self.terminal_threads.clear()
            
            # Resetează flag-ul pentru thread-uri
            self.stop_threads.clear()
            
            # Resetează starea
            self.awaiting_input = False
            
            # Dezactivează input field-ul
            self.terminal_input.config(state=tk.DISABLED)
            self.terminal_input.delete(0, tk.END)
        
        def read_output_to_queue(self, pipe, output_queue):
            """Citește output-ul din pipe și îl pune într-o coadă"""
            for line in iter(pipe.readline, ''):
                if self.stop_threads.is_set():
                    break
                output_queue.put(line)
            
            try:
                pipe.close()
            except:
                pass

        def update_terminal_from_queue(self):
            """Actualizează terminalul din cozile de output - versiune simplificată"""
            while not self.stop_threads.is_set():
                output_processed = False
                
                # Procesează output-ul standard
                try:
                    while not self.output_queue.empty():
                        line = self.output_queue.get_nowait()
                        self.terminal_output.config(state=tk.NORMAL)
                        self.terminal_output.insert(tk.END, line)
                        self.terminal_output.see(tk.END)
                        self.terminal_output.config(state=tk.DISABLED)
                        self.rootVSCODE.update_idletasks()
                        output_processed = True
                except queue.Empty:
                    pass
                
                # Procesează erorile
                try:
                    while not self.error_queue.empty():
                        line = self.error_queue.get_nowait()
                        self.terminal_output.config(state=tk.NORMAL)
                        self.terminal_output.insert(tk.END, line, "error")
                        self.terminal_output.see(tk.END)
                        self.terminal_output.config(state=tk.DISABLED)
                        self.rootVSCODE.update_idletasks()
                        output_processed = True
                except queue.Empty:
                    pass
                
                # Scurtă pauză pentru a nu supraîncărca CPU
                time.sleep(0.05)
                
        def check_for_input_state(self):
            """Verifică dacă procesul așteaptă input de la utilizator"""
            if not self.process or self.process.poll() is not None:
                return
                
            # Verifică dacă avem output nou
            if not self.output_queue.empty() or not self.error_queue.empty():
                return
                
            # Verifică dacă procesul este blocat așteptând input
            # (Nu avem output nou și procesul încă rulează)
            current_time = time.time()
            if hasattr(self, 'last_output_time') and (current_time - self.last_output_time) > 0.5:
                # Procesul probabil așteaptă input
                if not self.awaiting_input:
                    self.awaiting_input = True
                    self.terminal_input.config(state=tk.NORMAL)
                    self.terminal_input.focus_set()
                
        def monitor_process_completion(self):
            """Monitorizează finalizarea procesului"""
            if not self.process:
                return
                
            # Așteaptă finalizarea procesului
            return_code = self.process.wait()
            
            # Dacă thread-urile au fost oprite, nu mai continua
            if self.stop_threads.is_set():
                return
            
            # Așteaptă puțin să se proceseze toate output-urile
            time.sleep(0.2)
            
            # Afișează un mesaj despre terminarea procesului
            self.terminal_output.config(state=tk.NORMAL)
            self.terminal_output.insert(tk.END, f"\n{'='*50}\n")
            self.terminal_output.insert(tk.END, f"[Process completed with exit code {return_code}]")
            if return_code == 0:
                self.terminal_output.insert(tk.END, "\n[Program finished successfully]")
            else:
                self.terminal_output.insert(tk.END, f"\n[Program finished with errors]", "error")
                
            self.terminal_output.insert(tk.END, "\n[Terminal input disabled. Run another program to continue.]\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.config(state=tk.DISABLED)
            
            # Dezactivează input field-ul
            self.terminal_input.config(state=tk.DISABLED)
            self.terminal_input.delete(0, tk.END)
            
            self.rootVSCODE.update_idletasks()
            
            # Actualizează statusbar
            self.status_bar_left.config(text="Ready")
            
            # Curăță starea complet
            self.process = None
            self.awaiting_input = False
            self.last_output_incomplete = False

            # Asigură-te că terminalul este vizibil
            if not self.terminal_visible:
                self.toggle_terminal()
            
            # Oprește orice proces anterior
            self.cleanup_terminal_process()
            
            # Curăță terminalul
            self.terminal_output.config(state=tk.NORMAL)
            self.terminal_output.delete('1.0', tk.END)
            self.terminal_output.insert(tk.END, f"Running {os.path.basename(current_file['path'])}...\n")
            self.terminal_output.insert(tk.END, "=" * 50 + "\n\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.config(state=tk.DISABLED)
            
            # Activează input field-ul
            self.terminal_input.config(state=tk.NORMAL)
            
            # Determină comanda Python
            python_cmd = "python" if platform.system() == "Windows" else "python3"
            
            try:
                # Folosește PIPE pentru stdin, stdout și stderr
                self.process = subprocess.Popen(
                    [python_cmd, current_file['path']],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    universal_newlines=True,
                    bufsize=0,
                    encoding='utf-8',
                    errors='replace',
                    env=dict(os.environ, PYTHONIOENCODING='utf-8', PYTHONUNBUFFERED='1')
                )
                
                # Setează flag-ul pentru a indica că procesul rulează
                self.process_running = True
                
                # Thread pentru a citi output-ul
                def read_output():
                    # Folosim un buffer pentru a colecta caractere până la o linie completă
                    stdout_buffer = ""
                    stderr_buffer = ""
                    
                    while self.process_running and self.process and self.process.poll() is None:
                        # Verifică dacă există date disponibile pentru citire
                        r_list = []
                        if self.process.stdout:
                            r_list.append(self.process.stdout)
                        if self.process.stderr:
                            r_list.append(self.process.stderr)
                        
                        if not r_list:
                            time.sleep(0.05)
                            continue
                        
                        # Folosim select pentru a verifica care stream are date disponibile
                        # Timeout de 0.1 secunde pentru a nu bloca thread-ul
                        try:
                            ready, _, _ = select.select(r_list, [], [], 0.1)
                            
                            for stream in ready:
                                if stream == self.process.stdout:
                                    # Citim o linie sau bucăți din stdout
                                    char = stream.read(1)
                                    if char:
                                        # Afișează caracterul imediat
                                        self.terminal_output.config(state=tk.NORMAL)
                                        self.terminal_output.insert(tk.END, char)
                                        self.terminal_output.see(tk.END)
                                        self.terminal_output.config(state=tk.DISABLED)
                                        self.rootVSCODE.update_idletasks()
                                
                                elif stream == self.process.stderr:
                                    # Citim o linie sau bucăți din stderr
                                    char = stream.read(1)
                                    if char:
                                        # Afișează caracterul imediat ca eroare
                                        self.terminal_output.config(state=tk.NORMAL)
                                        self.terminal_output.insert(tk.END, char, "error")
                                        self.terminal_output.see(tk.END)
                                        self.terminal_output.config(state=tk.DISABLED)
                                        self.rootVSCODE.update_idletasks()
                        except (OSError, IOError, ValueError) as e:
                            # Eroare la select sau stream închis
                            break
                        except Exception as e:
                            # Afișăm eroarea și continuăm
                            print(f"Error reading output: {e}")
                            time.sleep(0.1)
                    
                    # Procesul s-a terminat sau a fost oprit
                    if self.process:
                        # Încercăm să citim orice output rămas
                        try:
                            # Dăm un timeout scurt pentru communicate pentru a evita blocarea
                            stdout, stderr = self.process.communicate(timeout=0.5)
                            
                            if stdout:
                                self.terminal_output.config(state=tk.NORMAL)
                                self.terminal_output.insert(tk.END, stdout)
                                self.terminal_output.config(state=tk.DISABLED)
                            
                            if stderr:
                                self.terminal_output.config(state=tk.NORMAL)
                                self.terminal_output.insert(tk.END, stderr, "error")
                                self.terminal_output.config(state=tk.DISABLED)
                        except subprocess.TimeoutExpired:
                            # Dacă timeout expiră, continuăm oricum
                            pass
                        except Exception as e:
                            print(f"Error collecting remaining output: {e}")
                
                # Thread pentru a monitoriza terminarea procesului
                def monitor_process():
                    if self.process:
                        return_code = self.process.wait()
                        
                        # Setează flag-ul pentru a opri citirea output-ului
                        self.process_running = False
                        
                        # Dacă thread-urile au fost oprite, nu mai continua
                        if self.stop_threads.is_set():
                            return
                        
                        # Așteaptă puțin să se proceseze tot output-ul rămas
                        time.sleep(0.2)
                        
                        # Afișează mesajul de finalizare
                        self.terminal_output.config(state=tk.NORMAL)
                        self.terminal_output.insert(tk.END, f"\n\n{'='*50}\n")
                        self.terminal_output.insert(tk.END, f"[Process completed with exit code {return_code}]")
                        if return_code == 0:
                            self.terminal_output.insert(tk.END, "\n[Program finished successfully]")
                        else:
                            self.terminal_output.insert(tk.END, f"\n[Program finished with errors]", "error")
                            
                        self.terminal_output.insert(tk.END, "\n[Terminal input disabled. Run another program to continue.]\n")
                        self.terminal_output.see(tk.END)
                        self.terminal_output.config(state=tk.DISABLED)
                        
                        # Dezactivează input field-ul
                        self.terminal_input.config(state=tk.DISABLED)
                        
                        # Actualizează statusbar
                        self.status_bar_left.config(text="Ready")
                
                # Import necesar pentru select
                import select
                
                # Inițializează flag-ul pentru procesul care rulează
                self.process_running = True
                
                # Pornește thread-urile
                output_thread = threading.Thread(target=read_output, daemon=True)
                monitor_thread = threading.Thread(target=monitor_process, daemon=True)
                
                output_thread.start()
                monitor_thread.start()
                
                self.terminal_threads = [output_thread, monitor_thread]
                
                # Focalizează pe input
                self.terminal_input.focus_set()
                
            except Exception as e:
                self.terminal_output.config(state=tk.NORMAL)
                self.terminal_output.insert(tk.END, f"Error running program: {str(e)}\n", "error")
                self.terminal_output.see(tk.END)
                self.terminal_output.config(state=tk.DISABLED)
            
            # Actualizează statusbar
            self.status_bar_left.config(text=f"Running: {os.path.basename(current_file['path'])}")
        
        def debug_python_file(self):
            # Simulare debug pentru fișierul Python curent
            if len(self.files_opened) == 0 or self.current_tab_index >= len(self.files_opened):
                return
                
            current_file = self.files_opened[self.current_tab_index]
            
            # Dacă fișierul nu a fost salvat, încearcă să-l salvezi mai întâi
            if current_file['modified'] or not current_file['path']:
                if not current_file['path']:
                    messagebox.showwarning("Debug Error", "Cannot debug unsaved file. Please save the file first.")
                    return
                else:
                    self.save_file()
            
            # Afișează un dialog pentru simularea debugging
            debug_dialog = tk.Toplevel(self.rootVSCODE)
            debug_dialog.title("Debug Mode")
            debug_dialog.geometry("400x300")
            debug_dialog.transient(self.rootVSCODE)
            debug_dialog.configure(bg=self.colors['bg'])
            
            # Mesaj informativ
            tk.Label(debug_dialog, text=f"Debugging {os.path.basename(current_file['path'])}", 
                   bg=self.colors['bg'], fg=self.colors['text'], font=('Consolas', 12, 'bold')).pack(pady=10)
            
            tk.Label(debug_dialog, text="Debug features:\n\n• Breakpoints\n• Variable inspection\n• Step-by-step execution\n• Call stack viewing", 
                   bg=self.colors['bg'], fg=self.colors['text'], justify=tk.LEFT).pack(pady=10, padx=20, anchor='w')
            
            tk.Label(debug_dialog, text="This is a simulated debug interface.\nIn a full implementation, this would launch pdb or a visual debugger.", 
                   bg=self.colors['bg'], fg=self.colors['text']).pack(pady=10)
            
            # Buton pentru închidere
            tk.Button(debug_dialog, text="Close", command=debug_dialog.destroy,
                    bg=self.colors['sidebar_bg'], fg=self.colors['text'],
                    activebackground=self.colors['selection']).pack(pady=20)
        
        def run(self):
            # Adaugă conținut de demonstrație în primul editor
            demo_content = '''# VS Code Python Editor
    # Tema Dark activată!

    def hello_world():
        """Funcție de demonstrație cu highlight de sintaxă"""
        name = "Python Developer"
        age = 25
        print(f"Hello, {name}! You are {age} years old.")
        
        # Aceasta este o listă
        languages = ["Python", "JavaScript", "C++", "Java"]
        
        for lang in languages:
            print(f"I love {lang}!")
        
        return True

    class ExampleClass:
        """O clasă de exemplu pentru demonstrație"""
        
        def __init__(self, name):
            self.name = name
        
        def greet(self):
            """Metoda de salut"""
            return f"Hello from {self.name}!"

    if __name__ == "__main__":
        # Punct de intrare pentru program
        result = hello_world()
        print(f"Function returned: {result}")
        
        # Creăm o instanță a clasei
        example = ExampleClass("VS Code Editor")
        print(example.greet())
    '''
            # Actualizează conținutul primului editor
            current_editor = self.get_current_editor()
            if current_editor:
                current_editor.delete('1.0', tk.END)
                current_editor.insert('1.0', demo_content)
                self.on_text_change(None, current_editor, self.get_current_line_numbers())
                
                # Colectează cuvinte pentru autocompletare din conținutul demo
                self.collect_words_from_file(demo_content)
            
            # Actualizează statusbar
            self.status_bar_left.config(text="Ready")
            
            # Afișează terminalul inițial și apoi îl ascunde pentru mai mult spațiu
            self.toggle_terminal()
            self.terminal_output.config(state=tk.NORMAL)
            self.terminal_output.delete('1.0', tk.END)
            self.terminal_output.insert(tk.END, "Terminal ready. Run your Python script using F5 or the Run menu.\n")
            self.terminal_output.insert(tk.END, "Input is disabled until you run a program.\n")
            self.terminal_output.config(state=tk.DISABLED)
            # Dezactivează input field-ul inițial
            self.terminal_input.config(state=tk.DISABLED)
            # Ascunde terminalul inițial pentru a avea mai mult spațiu pentru editor
            self.toggle_terminal()
            
            # Configurare pentru a reține dimensiunea ferestrei
            self.rootVSCODE.update_idletasks()
            width = self.rootVSCODE.winfo_width()
            height = self.rootVSCODE.winfo_height()
            self.rootVSCODE.minsize(800, 600)
            
            # Centrează fereastra pe ecran
            screen_width = self.rootVSCODE.winfo_screenwidth()
            screen_height = self.rootVSCODE.winfo_screenheight()
            x = (screen_width - width) // 2
            y = (screen_height - height) // 2
            self.rootVSCODE.geometry(f"{width}x{height}+{x}+{y}")
            
            # Pornește mainloop
            self.rootVSCODE.mainloop()

    if __name__ == "__main__":
        editor = VSCodeEditor()
        editor.run()
        
if pdfviewervar == 3333444400997676:
    from tkinter import filedialog as fd
    import fitz  # PyMuPDF
    from PIL import Image, ImageTk
    import io
    
    # Definirea numele fișierului pentru salvarea cheii
    FOLDER_NAME = "Serial"
    FILE_NAME = "product_key.lic95"
    cale_fis = "file_paths.txt"
    cale_fldr = "folder_paths.txt"

    # Definirea cheii de validare
    KEY = "R46BX-JHR2J-PG7ER-24QFG-MWKVR"
    
    key_is_valid = False
    file_path = os.path.join(FOLDER_NAME, FILE_NAME)

    if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
        try:
            with open(file_path, "r") as file:
                saved_key = file.read().strip()
                if saved_key == KEY:
                    key_is_valid = True
        except Exception as e:
            print(f"Error checking key: {e}")
    if not key_is_valid:
        # Verifică și creează folderul Serial dacă nu există
        if not os.path.exists(FOLDER_NAME):
            try:
                os.makedirs(FOLDER_NAME)
                print(f"Folder '{FOLDER_NAME}' created successfully.")
            except Exception as e:
                print(f"Error creating folder '{FOLDER_NAME}': {e}")

        def validate_key(event=None):
            # Funcția pentru validarea cheii
            global xx
            if text_box.get("1.0", "end-1c").strip() == KEY:
                xx = 2
                validate_button.config(state=tk.NORMAL)
                no_key_button.config(state=tk.DISABLED)
                
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Salvarea cheii în fișier text
                with open(file_path, "w") as file:
                    file.write(KEY)
                try:
                    if not os.path.exists("file_paths.txt"):
                        with open("file_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file file_paths.txt: {e}")

                try:
                    if not os.path.exists("folder_paths.txt"):
                        with open("folder_paths.txt", "w") as file:
                            file.write("")
                except Exception as e:
                    print(f"An error occurred while creating the file folder_paths.txt: {e}")
            else:
                xx = 0
                validate_button.config(state=tk.DISABLED)
                no_key_button.config(state=tk.NORMAL)

        def load_key():
            try:
                # Calea completă către fișier în folderul Serial
                file_path = os.path.join(FOLDER_NAME, FILE_NAME)
                
                # Încărcarea cheii din fișier text
                with open(file_path, "r") as file:
                    key = file.read().strip()
                    text_box.delete("1.0", "end")
                    text_box.insert("1.0", key)
                    validate_key()  # Validarea automată a cheii încărcate
            except FileNotFoundError:
                pass

        def nokey():
            messagebox.showinfo(title="Unlicensed Product", message="Secure connection.\nWelcome to the muap.ro domain!\nFor full access, please contact the administrator (Tudor Marmureanu).")
            sys.exit()

        def valkey():
            messagebox.showinfo(title="Product Activated (professional version)", message="Secure connection.\nWelcome to the muap.ro domain!")
            validation.destroy()

        def on_closing():
            #pass
            messagebox.showwarning("Warning", "Close the program from the Command Prompt to stop all processes!")

        # Crearea ferestrei principale pentru validare
        validation = tk.Tk()
        validation.protocol("WM_DELETE_WINDOW", on_closing)
        validation.title("Product key validation")
        validation.geometry("260x260")  # Setarea dimensiunilor ferestrei principale
        validation.config(bg="gray20")
        #image_icon52 = PhotoImage(file = "img/keylogo.png")
        #validation.iconphoto(False, image_icon52)

        # Crearea obiectului Text editabil
        text_box = tk.Text(validation, height=1, width=30)  # Setarea wrap="none" pentru a face obiectul Text dreptunghiular
        text_box.config(bd=4)
        text_box.pack(pady=10)
        text_box.bind("<KeyRelease>", validate_key)  # Legarea funcției validate_key() de evenimentul de eliberare a tastelor

        # Crearea butonului "I don't have a product key"
        no_key_button = tk.Button(validation, text="I don't have a product key", bg="black", fg="lime green", bd=5, command=nokey)
        no_key_button.pack(pady=5)

        # Crearea butonului "Validate key"
        validate_button = tk.Button(validation, text="Validate key" ,bg="black", fg="lime green", bd=5, command=valkey, state=tk.DISABLED)
        validate_button.pack(pady=5)

        # Încărcarea cheii la deschiderea programului (dacă există)
        load_key()

        # Rularea buclei principale
        validation.mainloop()

    class Win95Theme:
        BG_COLOR = "#c0c0c0"  # Light gray background
        BUTTON_COLOR = "#c0c0c0"  # Button background
        BUTTON_ACTIVE = "#dfdfdf"  # Button when pressed
        TEXT_COLOR = "#000000"  # Black text
        DISABLED_TEXT = "#808080"  # Gray disabled text
        HIGHLIGHT_COLOR = "#000080"  # Navy blue for selection
        HIGHLIGHT_TEXT = "#ffffff"  # White text on selection
        WINDOW_BG = "#c0c0c0"  # Window background
        CANVAS_BG = "#ffffff"  # Canvas background (white for PDF)
        MENU_BG = "#c0c0c0"  # Menu background
        
        @staticmethod
        def configure_widget(widget, widget_type="default"):
            """Apply Windows 95 styling to widgets"""
            if widget_type == "button":
                widget.configure(
                    relief="raised",
                    borderwidth=2,
                    background=Win95Theme.BUTTON_COLOR,
                    foreground=Win95Theme.TEXT_COLOR,
                    font=("MS Sans Serif", 8)
                )
            elif widget_type == "label":
                widget.configure(
                    background=Win95Theme.BG_COLOR,
                    foreground=Win95Theme.TEXT_COLOR,
                    font=("MS Sans Serif", 8)
                )
            elif widget_type == "frame":
                widget.configure(
                    background=Win95Theme.BG_COLOR,
                    relief="sunken",
                    borderwidth=2
                )
            elif widget_type == "canvas":
                widget.configure(
                    background=Win95Theme.CANVAS_BG,
                    relief="sunken",
                    borderwidth=2,
                    highlightthickness=0
                )


    class PDFMiner:
        def __init__(self, filepath):
            """
            Initialize PDFMiner with a PDF file path
            """
            self.filepath = filepath
            self.pdf_document = None
            self.load_document()
        
        def load_document(self):
            """
            Load the PDF document using PyMuPDF
            """
            try:
                self.pdf_document = fitz.open(self.filepath)
            except Exception as e:
                print(f"Error loading PDF: {e}")
                messagebox.showerror("Error", f"Failed to load PDF: {e}")
                self.pdf_document = None
        
        def get_metadata(self):
            """
            Extract metadata and number of pages from the PDF
            Returns: (metadata_dict, number_of_pages)
            """
            if not self.pdf_document:
                return {}, 0
            
            try:
                # Get metadata
                metadata = self.pdf_document.metadata
                
                # Get number of pages
                num_pages = len(self.pdf_document)
                
                return metadata, num_pages
            except Exception as e:
                print(f"Error getting metadata: {e}")
                return {}, 0
        
        def get_page(self, page_number, zoom_level=1.0, rotation=0):
            """
            Convert a PDF page to a PhotoImage for tkinter display
            Args:
                page_number: Page index (0-based)
                zoom_level: Zoom factor for the page
                rotation: Rotation angle in degrees (0, 90, 180, 270)
            Returns:
                PhotoImage object for tkinter
            """
            if not self.pdf_document:
                return None
            
            try:
                # Get the page
                page = self.pdf_document[page_number]
                
                # Create a transformation matrix with zoom and rotation
                base_scale = 1.5
                mat = fitz.Matrix(base_scale * zoom_level, base_scale * zoom_level)
                
                # Apply rotation
                if rotation != 0:
                    mat = mat * fitz.Matrix(rotation)
                
                # Render page to pixmap
                pix = page.get_pixmap(matrix=mat)
                
                # Convert pixmap to PIL Image
                img_data = pix.tobytes("ppm")
                img = Image.open(io.BytesIO(img_data))
                
                # Convert PIL Image to PhotoImage
                photo = ImageTk.PhotoImage(img)
                
                return photo
                
            except Exception as e:
                print(f"Error rendering page {page_number}: {e}")
                return None
        
        def close(self):
            """
            Close the PDF document
            """
            if self.pdf_document:
                self.pdf_document.close()
        
        def __del__(self):
            """
            Cleanup when object is destroyed
            """
            self.close()


    class PDFViewer:
        def __init__(self, master):
            # path for the pdf doc
            self.path = None
            # state of the pdf doc, open or closed
            self.fileisopen = None
            # author of the pdf doc
            self.author = None
            # name for the pdf doc
            self.name = None
            # the current page for the pdf
            self.current_page = 0
            # total number of pages for the pdf doc
            self.numPages = None    
            # creating the window
            self.master = master
            # Apply Windows 95 theme to main window
            self.master.configure(bg=Win95Theme.WINDOW_BG)
            # gives title to the main window
            self.master.title('PDF Viewer')
            # gives dimensions to main window
            self.master.geometry('800x700+150+40')
            # enable window resizing
            self.master.resizable(width = 1, height = 1)
            # set minimum window size
            self.master.minsize(600, 500)
            
            # Try to load icon, but continue if file not found
            try:
                self.master.iconbitmap('pdf_file_icon.ico')
            except:
                pass  # Icon file not found, continue without it
            
            # creating the menu
            self.menu = Menu(self.master)
            # adding it to the main window
            self.master.config(menu=self.menu)
            # creating a sub menu
            self.filemenu = Menu(self.menu)
            # giving the sub menu a label
            self.menu.add_cascade(label="File", menu=self.filemenu)
            # adding a two buttons to the sub menus
            self.filemenu.add_command(label="Open File", command=self.open_file)
            self.filemenu.add_command(label="Exit", command=self.master.destroy)
            
            # Configure grid weights for resizing
            self.master.grid_rowconfigure(0, weight=1)
            self.master.grid_columnconfigure(0, weight=1)
            
            # creating the top frame
            self.top_frame = ttk.Frame(self.master)
            # placing the frame using inside main window using grid()
            self.top_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
            # Configure grid weights for top frame
            self.top_frame.grid_rowconfigure(0, weight=1)
            self.top_frame.grid_columnconfigure(0, weight=1)
            
            # creating the bottom frame
            self.bottom_frame = ttk.Frame(self.master, height=60)
            # placing the frame using inside main window using grid()
            self.bottom_frame.grid(row=1, column=0, sticky="ew", padx=5, pady=5)
            # Configure grid weights for bottom frame
            self.bottom_frame.grid_columnconfigure(0, weight=1)
            self.bottom_frame.grid_columnconfigure(8, weight=1)
            
            # creating a vertical scrollbar
            self.scrolly = Scrollbar(self.top_frame, orient=VERTICAL)
            # adding the scrollbar
            self.scrolly.grid(row=0, column=1, sticky="ns")
            
            # creating a horizontal scrollbar
            self.scrollx = Scrollbar(self.top_frame, orient=HORIZONTAL)
            # adding the scrollbar
            self.scrollx.grid(row=1, column=0, sticky="ew")
            
            # creating the canvas for display the PDF pages
            self.output = Canvas(self.top_frame, bg='#ECE8F3')
            # inserting both vertical and horizontal scrollbars to the canvas
            self.output.configure(yscrollcommand=self.scrolly.set, xscrollcommand=self.scrollx.set)
            # adding the canvas
            self.output.grid(row=0, column=0, sticky="nsew")
            # configuring the scrollbars to the canvas
            self.scrolly.configure(command=self.output.yview)
            self.scrollx.configure(command=self.output.xview)
            
            # Bind mouse wheel to canvas for scrolling
            self.output.bind("<MouseWheel>", self.on_mousewheel)
            self.output.bind("<Button-4>", self.on_mousewheel)  # Linux
            self.output.bind("<Button-5>", self.on_mousewheel)  # Linux
            self.output.bind("<Shift-MouseWheel>", self.on_horizontal_mousewheel)
            
            # Bind canvas resize event
            self.output.bind("<Configure>", self.on_canvas_configure)
            
            # Try to load button icons, create text buttons if images not found
            try:
                self.uparrow_icon = PhotoImage(file='uparrow.png')
                self.downarrow_icon = PhotoImage(file='downarrow.png')
                # resizing the icons to fit on buttons
                self.uparrow = self.uparrow_icon.subsample(3, 3)
                self.downarrow = self.downarrow_icon.subsample(3, 3)
                # creating buttons with icons
                self.upbutton = ttk.Button(self.bottom_frame, image=self.uparrow, command=self.previous_page)
                self.downbutton = ttk.Button(self.bottom_frame, image=self.downarrow, command=self.next_page)
            except:
                # If image files not found, create text buttons
                self.upbutton = ttk.Button(self.bottom_frame, text="↑ Prev", command=self.previous_page)
                self.downbutton = ttk.Button(self.bottom_frame, text="Next ↓", command=self.next_page)
            
            # adding the buttons with better positioning
            self.upbutton.grid(row=0, column=1, padx=5, pady=8)
            self.downbutton.grid(row=0, column=2, padx=5, pady=8)
            
            # label for displaying page numbers
            self.page_label = ttk.Label(self.bottom_frame, text='No PDF loaded')
            # adding the label
            self.page_label.grid(row=0, column=3, padx=10, pady=8)
            
            # Add zoom controls
            self.zoom_in_button = ttk.Button(self.bottom_frame, text="Zoom +", command=self.zoom_in)
            self.zoom_in_button.grid(row=0, column=4, padx=2, pady=8)
            
            self.zoom_out_button = ttk.Button(self.bottom_frame, text="Zoom -", command=self.zoom_out)
            self.zoom_out_button.grid(row=0, column=5, padx=2, pady=8)
            
            # Zoom level
            self.zoom_level = 1.0
            self.zoom_label = ttk.Label(self.bottom_frame, text="100%")
            self.zoom_label.grid(row=0, column=6, padx=5, pady=8)
            
            # Add rotation controls
            self.rotate_left_button = ttk.Button(self.bottom_frame, text="↻ Rotate L", command=self.rotate_left)
            self.rotate_left_button.grid(row=0, column=8, padx=2, pady=8)
            
            self.rotate_right_button = ttk.Button(self.bottom_frame, text="Rotate R ↺", command=self.rotate_right)
            self.rotate_right_button.grid(row=0, column=9, padx=2, pady=8)
            
            # Rotation angle (0, 90, 180, 270 degrees)
            self.rotation = 0
            
            # Add welcome message to canvas
            self.output.create_text(400, 300, text="PDF Viewer\n\nClick File > Open File to load a PDF", 
                                   font=("Arial", 16), fill="gray", justify=CENTER)
        
        def on_mousewheel(self, event):
            """Handle mouse wheel scrolling"""
            if self.fileisopen:
                # Windows and MacOS
                if event.delta:
                    delta = -1 * (event.delta / 120)
                # Linux
                else:
                    if event.num == 4:
                        delta = -1
                    else:
                        delta = 1
                
                self.output.yview_scroll(int(delta), "units")
        
        def on_horizontal_mousewheel(self, event):
            """Handle horizontal mouse wheel scrolling"""
            if self.fileisopen:
                if event.delta:
                    delta = -1 * (event.delta / 120)
                else:
                    if event.num == 4:
                        delta = -1
                    else:
                        delta = 1
                
                self.output.xview_scroll(int(delta), "units")
        
        def on_canvas_configure(self, event):
            """Handle canvas resize"""
            if self.fileisopen:
                # Update scroll region when canvas is resized
                self.output.configure(scrollregion=self.output.bbox("all"))
        
        def zoom_in(self):
            """Increase zoom level"""
            if self.fileisopen:
                self.zoom_level *= 1.2
                self.update_zoom()
        
        def zoom_out(self):
            """Decrease zoom level"""
            if self.fileisopen:
                self.zoom_level /= 1.2
                if self.zoom_level < 0.1:
                    self.zoom_level = 0.1
                self.update_zoom()
        
        def update_zoom(self):
            """Update the display with new zoom level"""
            if self.fileisopen:
                self.display_page()
                self.zoom_label.config(text=f"{int(self.zoom_level * 100)}%")
        
        def rotate_left(self):
            """Rotate page 90 degrees counter-clockwise"""
            if self.fileisopen:
                self.rotation = (self.rotation - 90) % 360
                self.display_page()
        
        def rotate_right(self):
            """Rotate page 90 degrees clockwise"""
            if self.fileisopen:
                self.rotation = (self.rotation + 90) % 360
                self.display_page()
            
        # function for opening pdf files
        def open_file(self):
            # open the file dialog
            filepath = fd.askopenfilename(
                title='Select a PDF file', 
                initialdir=os.getcwd(), 
                filetypes=(('PDF', '*.pdf'), ('All files', '*.*'))
            )
            # checking if the file exists
            if filepath:
                try:
                    # declaring the path
                    self.path = filepath
                    # extracting the pdf file from the path
                    filename = os.path.basename(self.path)
                    # passing the path to PDFMiner 
                    self.miner = PDFMiner(self.path)
                    # getting data and numPages
                    data, numPages = self.miner.get_metadata()
                    # setting the current page to 0
                    self.current_page = 0
                    # reset rotation when opening new file
                    self.rotation = 0
                    # checking if numPages exists
                    if numPages:
                        # getting the title
                        self.name = data.get('title', filename[:-4])
                        # getting the author
                        self.author = data.get('author', None)
                        self.numPages = numPages
                        # setting fileopen to True
                        self.fileisopen = True
                        # calling the display_page() function
                        self.display_page()
                        # replacing the window title with the PDF document name
                        self.master.title(f"PDF Viewer - {self.name}")
                    else:
                        messagebox.showerror("Error", "Could not load PDF file. Please check if the file is valid.")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to open PDF file:\n{str(e)}")
        
        # the function to display the page  
        def display_page(self):
            # checking if numPages is less than current_page and if current_page is less than
            # or equal to 0
            if 0 <= self.current_page < self.numPages:
                try:
                    # Clear the canvas
                    self.output.delete("all")
                    # getting the page using get_page() function from miner with zoom and rotation
                    self.img_file = self.miner.get_page(self.current_page, self.zoom_level, self.rotation)
                    if self.img_file:
                        # inserting the page image inside the Canvas
                        self.output.create_image(0, 0, anchor='nw', image=self.img_file)
                        # the variable to be stringified
                        self.stringified_current_page = self.current_page + 1
                        # updating the page label with number of pages 
                        self.page_label['text'] = str(self.stringified_current_page) + ' of ' + str(self.numPages)
                        # creating a region for inserting the page inside the Canvas
                        self.output.configure(scrollregion=self.output.bbox("all"))
                    else:
                        self.output.create_text(400, 300, text="Error loading page", 
                                              font=("Arial", 16), fill="red", justify=CENTER)
                except Exception as e:
                    print(f"Error displaying page: {e}")
                    self.output.create_text(400, 300, text="Error displaying page", 
                                          font=("Arial", 16), fill="red", justify=CENTER)

        # function for displaying next page
        def next_page(self):
            # checking if file is open
            if self.fileisopen:
                # checking if current_page is less than numPages-1
                if self.current_page < self.numPages - 1:
                    # updating the page with value 1
                    self.current_page += 1
                    # displaying the new page
                    self.display_page()
                                
        # function for displaying the previous page        
        def previous_page(self):
            # checking if fileisopen
            if self.fileisopen:
                # checking if current_page is greater than 0
                if self.current_page > 0:
                    # decrementing the current_page by 1
                    self.current_page -= 1
                    # displaying the previous page
                    self.display_page()

        def __del__(self):
            """
            Cleanup when the viewer is destroyed
            """
            if hasattr(self, 'miner') and self.miner:
                self.miner.close()


    if __name__ == "__main__":
        try:
            import fitz
            from PIL import Image, ImageTk
        except ImportError as e:
            messagebox.showerror("Missing Dependencies", 
                               "Please install required packages:\n\n"
                               "pip install PyMuPDF Pillow\n\n"
                               f"Error: {e}")
            exit(1)
        
        # creating the rootpdfreaderroot window using Tk() class
        rootpdfreaderroot = Tk()
        # instantiating/creating object app for class PDFViewer
        app = PDFViewer(rootpdfreaderroot)
        # calling the mainloop to run the app infinitely until user closes it
        rootpdfreaderroot.mainloop()
